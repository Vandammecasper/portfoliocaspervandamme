/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/contactme/page"],{

/***/ "(app-pages-browser)/./node_modules/lottie-react/build/index.umd.js":
/*!******************************************************!*\
  !*** ./node_modules/lottie-react/build/index.umd.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! lottie-web */ \"(app-pages-browser)/./node_modules/lottie-web/build/player/lottie.js\"), __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\")) :\n  0;\n})(this, (function (exports, lottie, React) { 'use strict';\n\n  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n  var lottie__default = /*#__PURE__*/_interopDefaultLegacy(lottie);\n  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);\n\n  function _iterableToArrayLimit(arr, i) {\n    var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (null != _i) {\n      var _s,\n        _e,\n        _x,\n        _r,\n        _arr = [],\n        _n = !0,\n        _d = !1;\n      try {\n        if (_x = (_i = _i.call(arr)).next, 0 === i) {\n          if (Object(_i) !== _i) return;\n          _n = !1;\n        } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n      } catch (err) {\n        _d = !0, _e = err;\n      } finally {\n        try {\n          if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n        } finally {\n          if (_d) throw _e;\n        }\n      }\n      return _arr;\n    }\n  }\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      enumerableOnly && (symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n  }\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = null != arguments[i] ? arguments[i] : {};\n      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n    return target;\n  }\n  function _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  }\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n    return target;\n  }\n  function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n    return target;\n  }\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n  }\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n    return arr2;\n  }\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  function _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || \"default\");\n      if (typeof res !== \"object\") return res;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n  }\n  function _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n  }\n\n  var _excluded$1 = [\"animationData\", \"loop\", \"autoplay\", \"initialSegment\", \"onComplete\", \"onLoopComplete\", \"onEnterFrame\", \"onSegmentStart\", \"onConfigReady\", \"onDataReady\", \"onDataFailed\", \"onLoadedImages\", \"onDOMLoaded\", \"onDestroy\", \"lottieRef\", \"renderer\", \"name\", \"assetsPath\", \"rendererSettings\"];\n  var useLottie = function useLottie(props, style) {\n    var animationData = props.animationData,\n      loop = props.loop,\n      autoplay = props.autoplay,\n      initialSegment = props.initialSegment,\n      onComplete = props.onComplete,\n      onLoopComplete = props.onLoopComplete,\n      onEnterFrame = props.onEnterFrame,\n      onSegmentStart = props.onSegmentStart,\n      onConfigReady = props.onConfigReady,\n      onDataReady = props.onDataReady,\n      onDataFailed = props.onDataFailed,\n      onLoadedImages = props.onLoadedImages,\n      onDOMLoaded = props.onDOMLoaded,\n      onDestroy = props.onDestroy;\n      props.lottieRef;\n      props.renderer;\n      props.name;\n      props.assetsPath;\n      props.rendererSettings;\n      var rest = _objectWithoutProperties(props, _excluded$1);\n    var _useState = React.useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      animationLoaded = _useState2[0],\n      setAnimationLoaded = _useState2[1];\n    var animationInstanceRef = React.useRef();\n    var animationContainer = React.useRef(null);\n    /*\n          ======================================\n              INTERACTION METHODS\n          ======================================\n       */\n    /**\n     * Play\n     */\n    var play = function play() {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.play();\n    };\n    /**\n     * Stop\n     */\n    var stop = function stop() {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.stop();\n    };\n    /**\n     * Pause\n     */\n    var pause = function pause() {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.pause();\n    };\n    /**\n     * Set animation speed\n     * @param speed\n     */\n    var setSpeed = function setSpeed(speed) {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.setSpeed(speed);\n    };\n    /**\n     * Got to frame and play\n     * @param value\n     * @param isFrame\n     */\n    var goToAndPlay = function goToAndPlay(value, isFrame) {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.goToAndPlay(value, isFrame);\n    };\n    /**\n     * Got to frame and stop\n     * @param value\n     * @param isFrame\n     */\n    var goToAndStop = function goToAndStop(value, isFrame) {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.goToAndStop(value, isFrame);\n    };\n    /**\n     * Set animation direction\n     * @param direction\n     */\n    var setDirection = function setDirection(direction) {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.setDirection(direction);\n    };\n    /**\n     * Play animation segments\n     * @param segments\n     * @param forceFlag\n     */\n    var playSegments = function playSegments(segments, forceFlag) {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.playSegments(segments, forceFlag);\n    };\n    /**\n     * Set sub frames\n     * @param useSubFrames\n     */\n    var setSubframe = function setSubframe(useSubFrames) {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.setSubframe(useSubFrames);\n    };\n    /**\n     * Get animation duration\n     * @param inFrames\n     */\n    var getDuration = function getDuration(inFrames) {\n      var _a;\n      return (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.getDuration(inFrames);\n    };\n    /**\n     * Destroy animation\n     */\n    var destroy = function destroy() {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.destroy();\n      // Removing the reference to the animation so separate cleanups are skipped.\n      // Without it the internal `lottie-react` instance throws exceptions as it already cleared itself on destroy.\n      animationInstanceRef.current = undefined;\n    };\n    /*\n          ======================================\n              LOTTIE\n          ======================================\n       */\n    /**\n     * Load a new animation, and if it's the case, destroy the previous one\n     * @param {Object} forcedConfigs\n     */\n    var loadAnimation = function loadAnimation() {\n      var forcedConfigs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _a;\n      // Return if the container ref is null\n      if (!animationContainer.current) {\n        return;\n      }\n      // Destroy any previous instance\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.destroy();\n      // Build the animation configuration\n      var config = _objectSpread2(_objectSpread2(_objectSpread2({}, props), forcedConfigs), {}, {\n        container: animationContainer.current\n      });\n      // Save the animation instance\n      animationInstanceRef.current = lottie__default[\"default\"].loadAnimation(config);\n      setAnimationLoaded(!!animationInstanceRef.current);\n      // Return a function that will clean up\n      return function () {\n        var _a;\n        (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.destroy();\n        animationInstanceRef.current = undefined;\n      };\n    };\n    /**\n     * (Re)Initialize when animation data changed\n     */\n    React.useEffect(function () {\n      var onUnmount = loadAnimation();\n      // Clean up on unmount\n      return function () {\n        return onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount();\n      };\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [animationData, loop]);\n    // Update the autoplay state\n    React.useEffect(function () {\n      if (!animationInstanceRef.current) {\n        return;\n      }\n      animationInstanceRef.current.autoplay = !!autoplay;\n    }, [autoplay]);\n    // Update the initial segment state\n    React.useEffect(function () {\n      if (!animationInstanceRef.current) {\n        return;\n      }\n      // When null should reset to default animation length\n      if (!initialSegment) {\n        animationInstanceRef.current.resetSegments(true);\n        return;\n      }\n      // If it's not a valid segment, do nothing\n      if (!Array.isArray(initialSegment) || !initialSegment.length) {\n        return;\n      }\n      // If the current position it's not in the new segment\n      // set the current position to start\n      if (animationInstanceRef.current.currentRawFrame < initialSegment[0] || animationInstanceRef.current.currentRawFrame > initialSegment[1]) {\n        animationInstanceRef.current.currentRawFrame = initialSegment[0];\n      }\n      // Update the segment\n      animationInstanceRef.current.setSegment(initialSegment[0], initialSegment[1]);\n    }, [initialSegment]);\n    /*\n          ======================================\n              EVENTS\n          ======================================\n       */\n    /**\n     * Reinitialize listener on change\n     */\n    React.useEffect(function () {\n      var partialListeners = [{\n        name: \"complete\",\n        handler: onComplete\n      }, {\n        name: \"loopComplete\",\n        handler: onLoopComplete\n      }, {\n        name: \"enterFrame\",\n        handler: onEnterFrame\n      }, {\n        name: \"segmentStart\",\n        handler: onSegmentStart\n      }, {\n        name: \"config_ready\",\n        handler: onConfigReady\n      }, {\n        name: \"data_ready\",\n        handler: onDataReady\n      }, {\n        name: \"data_failed\",\n        handler: onDataFailed\n      }, {\n        name: \"loaded_images\",\n        handler: onLoadedImages\n      }, {\n        name: \"DOMLoaded\",\n        handler: onDOMLoaded\n      }, {\n        name: \"destroy\",\n        handler: onDestroy\n      }];\n      var listeners = partialListeners.filter(function (listener) {\n        return listener.handler != null;\n      });\n      if (!listeners.length) {\n        return;\n      }\n      var deregisterList = listeners.map(\n      /**\n       * Handle the process of adding an event listener\n       * @param {Listener} listener\n       * @return {Function} Function that deregister the listener\n       */\n      function (listener) {\n        var _a;\n        (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener(listener.name, listener.handler);\n        // Return a function to deregister this listener\n        return function () {\n          var _a;\n          (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(listener.name, listener.handler);\n        };\n      });\n      // Deregister listeners on unmount\n      return function () {\n        deregisterList.forEach(function (deregister) {\n          return deregister();\n        });\n      };\n    }, [onComplete, onLoopComplete, onEnterFrame, onSegmentStart, onConfigReady, onDataReady, onDataFailed, onLoadedImages, onDOMLoaded, onDestroy]);\n    /**\n     * Build the animation view\n     */\n    var View = /*#__PURE__*/React__default[\"default\"].createElement(\"div\", _objectSpread2({\n      style: style,\n      ref: animationContainer\n    }, rest));\n    return {\n      View: View,\n      play: play,\n      stop: stop,\n      pause: pause,\n      setSpeed: setSpeed,\n      goToAndStop: goToAndStop,\n      goToAndPlay: goToAndPlay,\n      setDirection: setDirection,\n      playSegments: playSegments,\n      setSubframe: setSubframe,\n      getDuration: getDuration,\n      destroy: destroy,\n      animationContainerRef: animationContainer,\n      animationLoaded: animationLoaded,\n      animationItem: animationInstanceRef.current\n    };\n  };\n\n  // helpers\n  function getContainerVisibility(container) {\n    var _container$getBoundin = container.getBoundingClientRect(),\n      top = _container$getBoundin.top,\n      height = _container$getBoundin.height;\n    var current = window.innerHeight - top;\n    var max = window.innerHeight + height;\n    return current / max;\n  }\n  function getContainerCursorPosition(container, cursorX, cursorY) {\n    var _container$getBoundin2 = container.getBoundingClientRect(),\n      top = _container$getBoundin2.top,\n      left = _container$getBoundin2.left,\n      width = _container$getBoundin2.width,\n      height = _container$getBoundin2.height;\n    var x = (cursorX - left) / width;\n    var y = (cursorY - top) / height;\n    return {\n      x: x,\n      y: y\n    };\n  }\n  var useInitInteractivity = function useInitInteractivity(_ref) {\n    var wrapperRef = _ref.wrapperRef,\n      animationItem = _ref.animationItem,\n      mode = _ref.mode,\n      actions = _ref.actions;\n    React.useEffect(function () {\n      var wrapper = wrapperRef.current;\n      if (!wrapper || !animationItem || !actions.length) {\n        return;\n      }\n      animationItem.stop();\n      var scrollModeHandler = function scrollModeHandler() {\n        var assignedSegment = null;\n        var scrollHandler = function scrollHandler() {\n          var currentPercent = getContainerVisibility(wrapper);\n          // Find the first action that satisfies the current position conditions\n          var action = actions.find(function (_ref2) {\n            var visibility = _ref2.visibility;\n            return visibility && currentPercent >= visibility[0] && currentPercent <= visibility[1];\n          });\n          // Skip if no matching action was found!\n          if (!action) {\n            return;\n          }\n          if (action.type === \"seek\" && action.visibility && action.frames.length === 2) {\n            // Seek: Go to a frame based on player scroll position action\n            var frameToGo = action.frames[0] + Math.ceil((currentPercent - action.visibility[0]) / (action.visibility[1] - action.visibility[0]) * action.frames[1]);\n            //! goToAndStop must be relative to the start of the current segment\n            animationItem.goToAndStop(frameToGo - animationItem.firstFrame - 1, true);\n          }\n          if (action.type === \"loop\") {\n            // Loop: Loop a given frames\n            if (assignedSegment === null) {\n              // if not playing any segments currently. play those segments and save to state\n              animationItem.playSegments(action.frames, true);\n              assignedSegment = action.frames;\n            } else {\n              // if playing any segments currently.\n              //check if segments in state are equal to the frames selected by action\n              if (assignedSegment !== action.frames) {\n                // if they are not equal. new segments are to be loaded\n                animationItem.playSegments(action.frames, true);\n                assignedSegment = action.frames;\n              } else if (animationItem.isPaused) {\n                // if they are equal the play method must be called only if lottie is paused\n                animationItem.playSegments(action.frames, true);\n                assignedSegment = action.frames;\n              }\n            }\n          }\n          if (action.type === \"play\" && animationItem.isPaused) {\n            // Play: Reset segments and continue playing full animation from current position\n            animationItem.resetSegments(true);\n            animationItem.play();\n          }\n          if (action.type === \"stop\") {\n            // Stop: Stop playback\n            animationItem.goToAndStop(action.frames[0] - animationItem.firstFrame - 1, true);\n          }\n        };\n        document.addEventListener(\"scroll\", scrollHandler);\n        return function () {\n          document.removeEventListener(\"scroll\", scrollHandler);\n        };\n      };\n      var cursorModeHandler = function cursorModeHandler() {\n        var handleCursor = function handleCursor(_x, _y) {\n          var x = _x;\n          var y = _y;\n          // Resolve cursor position if cursor is inside container\n          if (x !== -1 && y !== -1) {\n            // Get container cursor position\n            var pos = getContainerCursorPosition(wrapper, x, y);\n            // Use the resolved position\n            x = pos.x;\n            y = pos.y;\n          }\n          // Find the first action that satisfies the current position conditions\n          var action = actions.find(function (_ref3) {\n            var position = _ref3.position;\n            if (position && Array.isArray(position.x) && Array.isArray(position.y)) {\n              return x >= position.x[0] && x <= position.x[1] && y >= position.y[0] && y <= position.y[1];\n            }\n            if (position && !Number.isNaN(position.x) && !Number.isNaN(position.y)) {\n              return x === position.x && y === position.y;\n            }\n            return false;\n          });\n          // Skip if no matching action was found!\n          if (!action) {\n            return;\n          }\n          // Process action types:\n          if (action.type === \"seek\" && action.position && Array.isArray(action.position.x) && Array.isArray(action.position.y) && action.frames.length === 2) {\n            // Seek: Go to a frame based on player scroll position action\n            var xPercent = (x - action.position.x[0]) / (action.position.x[1] - action.position.x[0]);\n            var yPercent = (y - action.position.y[0]) / (action.position.y[1] - action.position.y[0]);\n            animationItem.playSegments(action.frames, true);\n            animationItem.goToAndStop(Math.ceil((xPercent + yPercent) / 2 * (action.frames[1] - action.frames[0])), true);\n          }\n          if (action.type === \"loop\") {\n            animationItem.playSegments(action.frames, true);\n          }\n          if (action.type === \"play\") {\n            // Play: Reset segments and continue playing full animation from current position\n            if (animationItem.isPaused) {\n              animationItem.resetSegments(false);\n            }\n            animationItem.playSegments(action.frames);\n          }\n          if (action.type === \"stop\") {\n            animationItem.goToAndStop(action.frames[0], true);\n          }\n        };\n        var mouseMoveHandler = function mouseMoveHandler(ev) {\n          handleCursor(ev.clientX, ev.clientY);\n        };\n        var mouseOutHandler = function mouseOutHandler() {\n          handleCursor(-1, -1);\n        };\n        wrapper.addEventListener(\"mousemove\", mouseMoveHandler);\n        wrapper.addEventListener(\"mouseout\", mouseOutHandler);\n        return function () {\n          wrapper.removeEventListener(\"mousemove\", mouseMoveHandler);\n          wrapper.removeEventListener(\"mouseout\", mouseOutHandler);\n        };\n      };\n      switch (mode) {\n        case \"scroll\":\n          return scrollModeHandler();\n        case \"cursor\":\n          return cursorModeHandler();\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [mode, animationItem]);\n  };\n  var useLottieInteractivity = function useLottieInteractivity(_ref4) {\n    var actions = _ref4.actions,\n      mode = _ref4.mode,\n      lottieObj = _ref4.lottieObj;\n    var animationItem = lottieObj.animationItem,\n      View = lottieObj.View,\n      animationContainerRef = lottieObj.animationContainerRef;\n    useInitInteractivity({\n      actions: actions,\n      animationItem: animationItem,\n      mode: mode,\n      wrapperRef: animationContainerRef\n    });\n    return View;\n  };\n\n  var _excluded = [\"style\", \"interactivity\"];\n  var Lottie = function Lottie(props) {\n    var _a, _b, _c;\n    var style = props.style,\n      interactivity = props.interactivity,\n      lottieProps = _objectWithoutProperties(props, _excluded);\n    /**\n     * Initialize the 'useLottie' hook\n     */\n    var _useLottie = useLottie(lottieProps, style),\n      View = _useLottie.View,\n      play = _useLottie.play,\n      stop = _useLottie.stop,\n      pause = _useLottie.pause,\n      setSpeed = _useLottie.setSpeed,\n      goToAndStop = _useLottie.goToAndStop,\n      goToAndPlay = _useLottie.goToAndPlay,\n      setDirection = _useLottie.setDirection,\n      playSegments = _useLottie.playSegments,\n      setSubframe = _useLottie.setSubframe,\n      getDuration = _useLottie.getDuration,\n      destroy = _useLottie.destroy,\n      animationContainerRef = _useLottie.animationContainerRef,\n      animationLoaded = _useLottie.animationLoaded,\n      animationItem = _useLottie.animationItem;\n    /**\n     * Make the hook variables/methods available through the provided 'lottieRef'\n     */\n    React.useEffect(function () {\n      if (props.lottieRef) {\n        props.lottieRef.current = {\n          play: play,\n          stop: stop,\n          pause: pause,\n          setSpeed: setSpeed,\n          goToAndPlay: goToAndPlay,\n          goToAndStop: goToAndStop,\n          setDirection: setDirection,\n          playSegments: playSegments,\n          setSubframe: setSubframe,\n          getDuration: getDuration,\n          destroy: destroy,\n          animationContainerRef: animationContainerRef,\n          animationLoaded: animationLoaded,\n          animationItem: animationItem\n        };\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [(_a = props.lottieRef) === null || _a === void 0 ? void 0 : _a.current]);\n    return useLottieInteractivity({\n      lottieObj: {\n        View: View,\n        play: play,\n        stop: stop,\n        pause: pause,\n        setSpeed: setSpeed,\n        goToAndStop: goToAndStop,\n        goToAndPlay: goToAndPlay,\n        setDirection: setDirection,\n        playSegments: playSegments,\n        setSubframe: setSubframe,\n        getDuration: getDuration,\n        destroy: destroy,\n        animationContainerRef: animationContainerRef,\n        animationLoaded: animationLoaded,\n        animationItem: animationItem\n      },\n      actions: (_b = interactivity === null || interactivity === void 0 ? void 0 : interactivity.actions) !== null && _b !== void 0 ? _b : [],\n      mode: (_c = interactivity === null || interactivity === void 0 ? void 0 : interactivity.mode) !== null && _c !== void 0 ? _c : \"scroll\"\n    });\n  };\n\n  Object.defineProperty(exports, 'LottiePlayer', {\n    enumerable: true,\n    get: function () { return lottie__default[\"default\"]; }\n  });\n  exports[\"default\"] = Lottie;\n  exports.useLottie = useLottie;\n  exports.useLottieInteractivity = useLottieInteractivity;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=index.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3R0aWUtcmVhY3QvYnVpbGQvaW5kZXgudW1kLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsRUFBRSxLQUE0RCxvQkFBb0IsbUJBQU8sQ0FBQyx3RkFBWSxHQUFHLG1CQUFPLENBQUMsbUZBQU87QUFDeEgsRUFBRSxDQUM2STtBQUMvSSxDQUFDLDZDQUE2Qzs7QUFFOUMsdUNBQXVDLDREQUE0RDs7QUFFbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZLDZFQUE2RTtBQUNuRyxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSw0QkFBNEI7QUFDOUY7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELGFBQWE7O0FBRTlELENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG90dGllLXJlYWN0L2J1aWxkL2luZGV4LnVtZC5qcz82NjNjIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnbG90dGllLXdlYicpLCByZXF1aXJlKCdyZWFjdCcpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnbG90dGllLXdlYicsICdyZWFjdCddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsW1wibG90dGllLXJlYWN0XCJdID0ge30sIGdsb2JhbC5Mb3R0aWUsIGdsb2JhbC5SZWFjdCkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCBsb3R0aWUsIFJlYWN0KSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxuICB2YXIgbG90dGllX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShsb3R0aWUpO1xuICB2YXIgUmVhY3RfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KFJlYWN0KTtcblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gICAgdmFyIF9pID0gbnVsbCA9PSBhcnIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG4gICAgaWYgKG51bGwgIT0gX2kpIHtcbiAgICAgIHZhciBfcyxcbiAgICAgICAgX2UsXG4gICAgICAgIF94LFxuICAgICAgICBfcixcbiAgICAgICAgX2FyciA9IFtdLFxuICAgICAgICBfbiA9ICEwLFxuICAgICAgICBfZCA9ICExO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKF94ID0gKF9pID0gX2kuY2FsbChhcnIpKS5uZXh0LCAwID09PSBpKSB7XG4gICAgICAgICAgaWYgKE9iamVjdChfaSkgIT09IF9pKSByZXR1cm47XG4gICAgICAgICAgX24gPSAhMTtcbiAgICAgICAgfSBlbHNlIGZvciAoOyAhKF9uID0gKF9zID0gX3guY2FsbChfaSkpLmRvbmUpICYmIChfYXJyLnB1c2goX3MudmFsdWUpLCBfYXJyLmxlbmd0aCAhPT0gaSk7IF9uID0gITApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kID0gITAsIF9lID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9uICYmIG51bGwgIT0gX2kucmV0dXJuICYmIChfciA9IF9pLnJldHVybigpLCBPYmplY3QoX3IpICE9PSBfcikpIHJldHVybjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX2FycjtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICAgIGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbiAgfVxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgICBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpO1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICB2YXIga2V5LCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gICAgdmFyIGtleSwgaTtcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICAgIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG4gIH1cbiAgZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG4gIH1cbiAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB9XG4gIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuICAgIHJldHVybiBhcnIyO1xuICB9XG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuICBmdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gICAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICAgIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgICAgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gICAgfVxuICAgIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xuICB9XG4gIGZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICAgIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xuICB9XG5cbiAgdmFyIF9leGNsdWRlZCQxID0gW1wiYW5pbWF0aW9uRGF0YVwiLCBcImxvb3BcIiwgXCJhdXRvcGxheVwiLCBcImluaXRpYWxTZWdtZW50XCIsIFwib25Db21wbGV0ZVwiLCBcIm9uTG9vcENvbXBsZXRlXCIsIFwib25FbnRlckZyYW1lXCIsIFwib25TZWdtZW50U3RhcnRcIiwgXCJvbkNvbmZpZ1JlYWR5XCIsIFwib25EYXRhUmVhZHlcIiwgXCJvbkRhdGFGYWlsZWRcIiwgXCJvbkxvYWRlZEltYWdlc1wiLCBcIm9uRE9NTG9hZGVkXCIsIFwib25EZXN0cm95XCIsIFwibG90dGllUmVmXCIsIFwicmVuZGVyZXJcIiwgXCJuYW1lXCIsIFwiYXNzZXRzUGF0aFwiLCBcInJlbmRlcmVyU2V0dGluZ3NcIl07XG4gIHZhciB1c2VMb3R0aWUgPSBmdW5jdGlvbiB1c2VMb3R0aWUocHJvcHMsIHN0eWxlKSB7XG4gICAgdmFyIGFuaW1hdGlvbkRhdGEgPSBwcm9wcy5hbmltYXRpb25EYXRhLFxuICAgICAgbG9vcCA9IHByb3BzLmxvb3AsXG4gICAgICBhdXRvcGxheSA9IHByb3BzLmF1dG9wbGF5LFxuICAgICAgaW5pdGlhbFNlZ21lbnQgPSBwcm9wcy5pbml0aWFsU2VnbWVudCxcbiAgICAgIG9uQ29tcGxldGUgPSBwcm9wcy5vbkNvbXBsZXRlLFxuICAgICAgb25Mb29wQ29tcGxldGUgPSBwcm9wcy5vbkxvb3BDb21wbGV0ZSxcbiAgICAgIG9uRW50ZXJGcmFtZSA9IHByb3BzLm9uRW50ZXJGcmFtZSxcbiAgICAgIG9uU2VnbWVudFN0YXJ0ID0gcHJvcHMub25TZWdtZW50U3RhcnQsXG4gICAgICBvbkNvbmZpZ1JlYWR5ID0gcHJvcHMub25Db25maWdSZWFkeSxcbiAgICAgIG9uRGF0YVJlYWR5ID0gcHJvcHMub25EYXRhUmVhZHksXG4gICAgICBvbkRhdGFGYWlsZWQgPSBwcm9wcy5vbkRhdGFGYWlsZWQsXG4gICAgICBvbkxvYWRlZEltYWdlcyA9IHByb3BzLm9uTG9hZGVkSW1hZ2VzLFxuICAgICAgb25ET01Mb2FkZWQgPSBwcm9wcy5vbkRPTUxvYWRlZCxcbiAgICAgIG9uRGVzdHJveSA9IHByb3BzLm9uRGVzdHJveTtcbiAgICAgIHByb3BzLmxvdHRpZVJlZjtcbiAgICAgIHByb3BzLnJlbmRlcmVyO1xuICAgICAgcHJvcHMubmFtZTtcbiAgICAgIHByb3BzLmFzc2V0c1BhdGg7XG4gICAgICBwcm9wcy5yZW5kZXJlclNldHRpbmdzO1xuICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCQxKTtcbiAgICB2YXIgX3VzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgICBhbmltYXRpb25Mb2FkZWQgPSBfdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0QW5pbWF0aW9uTG9hZGVkID0gX3VzZVN0YXRlMlsxXTtcbiAgICB2YXIgYW5pbWF0aW9uSW5zdGFuY2VSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgICB2YXIgYW5pbWF0aW9uQ29udGFpbmVyID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIC8qXG4gICAgICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgICAgSU5URVJBQ1RJT04gTUVUSE9EU1xuICAgICAgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgKi9cbiAgICAvKipcbiAgICAgKiBQbGF5XG4gICAgICovXG4gICAgdmFyIHBsYXkgPSBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gYW5pbWF0aW9uSW5zdGFuY2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBsYXkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3BcbiAgICAgKi9cbiAgICB2YXIgc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RvcCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGF1c2VcbiAgICAgKi9cbiAgICB2YXIgcGF1c2UgPSBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IGFuaW1hdGlvbkluc3RhbmNlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXVzZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGFuaW1hdGlvbiBzcGVlZFxuICAgICAqIEBwYXJhbSBzcGVlZFxuICAgICAqL1xuICAgIHZhciBzZXRTcGVlZCA9IGZ1bmN0aW9uIHNldFNwZWVkKHNwZWVkKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0U3BlZWQoc3BlZWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR290IHRvIGZyYW1lIGFuZCBwbGF5XG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIGlzRnJhbWVcbiAgICAgKi9cbiAgICB2YXIgZ29Ub0FuZFBsYXkgPSBmdW5jdGlvbiBnb1RvQW5kUGxheSh2YWx1ZSwgaXNGcmFtZSkge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gYW5pbWF0aW9uSW5zdGFuY2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdvVG9BbmRQbGF5KHZhbHVlLCBpc0ZyYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdvdCB0byBmcmFtZSBhbmQgc3RvcFxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBpc0ZyYW1lXG4gICAgICovXG4gICAgdmFyIGdvVG9BbmRTdG9wID0gZnVuY3Rpb24gZ29Ub0FuZFN0b3AodmFsdWUsIGlzRnJhbWUpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IGFuaW1hdGlvbkluc3RhbmNlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nb1RvQW5kU3RvcCh2YWx1ZSwgaXNGcmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgYW5pbWF0aW9uIGRpcmVjdGlvblxuICAgICAqIEBwYXJhbSBkaXJlY3Rpb25cbiAgICAgKi9cbiAgICB2YXIgc2V0RGlyZWN0aW9uID0gZnVuY3Rpb24gc2V0RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gYW5pbWF0aW9uSW5zdGFuY2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGxheSBhbmltYXRpb24gc2VnbWVudHNcbiAgICAgKiBAcGFyYW0gc2VnbWVudHNcbiAgICAgKiBAcGFyYW0gZm9yY2VGbGFnXG4gICAgICovXG4gICAgdmFyIHBsYXlTZWdtZW50cyA9IGZ1bmN0aW9uIHBsYXlTZWdtZW50cyhzZWdtZW50cywgZm9yY2VGbGFnKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGxheVNlZ21lbnRzKHNlZ21lbnRzLCBmb3JjZUZsYWcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHN1YiBmcmFtZXNcbiAgICAgKiBAcGFyYW0gdXNlU3ViRnJhbWVzXG4gICAgICovXG4gICAgdmFyIHNldFN1YmZyYW1lID0gZnVuY3Rpb24gc2V0U3ViZnJhbWUodXNlU3ViRnJhbWVzKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0U3ViZnJhbWUodXNlU3ViRnJhbWVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBhbmltYXRpb24gZHVyYXRpb25cbiAgICAgKiBAcGFyYW0gaW5GcmFtZXNcbiAgICAgKi9cbiAgICB2YXIgZ2V0RHVyYXRpb24gPSBmdW5jdGlvbiBnZXREdXJhdGlvbihpbkZyYW1lcykge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IGFuaW1hdGlvbkluc3RhbmNlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXREdXJhdGlvbihpbkZyYW1lcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95IGFuaW1hdGlvblxuICAgICAqL1xuICAgIHZhciBkZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IGFuaW1hdGlvbkluc3RhbmNlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgICAvLyBSZW1vdmluZyB0aGUgcmVmZXJlbmNlIHRvIHRoZSBhbmltYXRpb24gc28gc2VwYXJhdGUgY2xlYW51cHMgYXJlIHNraXBwZWQuXG4gICAgICAvLyBXaXRob3V0IGl0IHRoZSBpbnRlcm5hbCBgbG90dGllLXJlYWN0YCBpbnN0YW5jZSB0aHJvd3MgZXhjZXB0aW9ucyBhcyBpdCBhbHJlYWR5IGNsZWFyZWQgaXRzZWxmIG9uIGRlc3Ryb3kuXG4gICAgICBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLypcbiAgICAgICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgICBMT1RUSUVcbiAgICAgICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICovXG4gICAgLyoqXG4gICAgICogTG9hZCBhIG5ldyBhbmltYXRpb24sIGFuZCBpZiBpdCdzIHRoZSBjYXNlLCBkZXN0cm95IHRoZSBwcmV2aW91cyBvbmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZm9yY2VkQ29uZmlnc1xuICAgICAqL1xuICAgIHZhciBsb2FkQW5pbWF0aW9uID0gZnVuY3Rpb24gbG9hZEFuaW1hdGlvbigpIHtcbiAgICAgIHZhciBmb3JjZWRDb25maWdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHZhciBfYTtcbiAgICAgIC8vIFJldHVybiBpZiB0aGUgY29udGFpbmVyIHJlZiBpcyBudWxsXG4gICAgICBpZiAoIWFuaW1hdGlvbkNvbnRhaW5lci5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIERlc3Ryb3kgYW55IHByZXZpb3VzIGluc3RhbmNlXG4gICAgICAoX2EgPSBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgLy8gQnVpbGQgdGhlIGFuaW1hdGlvbiBjb25maWd1cmF0aW9uXG4gICAgICB2YXIgY29uZmlnID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHByb3BzKSwgZm9yY2VkQ29uZmlncyksIHt9LCB7XG4gICAgICAgIGNvbnRhaW5lcjogYW5pbWF0aW9uQ29udGFpbmVyLmN1cnJlbnRcbiAgICAgIH0pO1xuICAgICAgLy8gU2F2ZSB0aGUgYW5pbWF0aW9uIGluc3RhbmNlXG4gICAgICBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50ID0gbG90dGllX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5sb2FkQW5pbWF0aW9uKGNvbmZpZyk7XG4gICAgICBzZXRBbmltYXRpb25Mb2FkZWQoISFhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50KTtcbiAgICAgIC8vIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBjbGVhbiB1cFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgICBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIChSZSlJbml0aWFsaXplIHdoZW4gYW5pbWF0aW9uIGRhdGEgY2hhbmdlZFxuICAgICAqL1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb25Vbm1vdW50ID0gbG9hZEFuaW1hdGlvbigpO1xuICAgICAgLy8gQ2xlYW4gdXAgb24gdW5tb3VudFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9uVW5tb3VudCA9PT0gbnVsbCB8fCBvblVubW91bnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uVW5tb3VudCgpO1xuICAgICAgfTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbYW5pbWF0aW9uRGF0YSwgbG9vcF0pO1xuICAgIC8vIFVwZGF0ZSB0aGUgYXV0b3BsYXkgc3RhdGVcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFuaW1hdGlvbkluc3RhbmNlUmVmLmN1cnJlbnQuYXV0b3BsYXkgPSAhIWF1dG9wbGF5O1xuICAgIH0sIFthdXRvcGxheV0pO1xuICAgIC8vIFVwZGF0ZSB0aGUgaW5pdGlhbCBzZWdtZW50IHN0YXRlXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghYW5pbWF0aW9uSW5zdGFuY2VSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBXaGVuIG51bGwgc2hvdWxkIHJlc2V0IHRvIGRlZmF1bHQgYW5pbWF0aW9uIGxlbmd0aFxuICAgICAgaWYgKCFpbml0aWFsU2VnbWVudCkge1xuICAgICAgICBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50LnJlc2V0U2VnbWVudHModHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIElmIGl0J3Mgbm90IGEgdmFsaWQgc2VnbWVudCwgZG8gbm90aGluZ1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGluaXRpYWxTZWdtZW50KSB8fCAhaW5pdGlhbFNlZ21lbnQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBjdXJyZW50IHBvc2l0aW9uIGl0J3Mgbm90IGluIHRoZSBuZXcgc2VnbWVudFxuICAgICAgLy8gc2V0IHRoZSBjdXJyZW50IHBvc2l0aW9uIHRvIHN0YXJ0XG4gICAgICBpZiAoYW5pbWF0aW9uSW5zdGFuY2VSZWYuY3VycmVudC5jdXJyZW50UmF3RnJhbWUgPCBpbml0aWFsU2VnbWVudFswXSB8fCBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50LmN1cnJlbnRSYXdGcmFtZSA+IGluaXRpYWxTZWdtZW50WzFdKSB7XG4gICAgICAgIGFuaW1hdGlvbkluc3RhbmNlUmVmLmN1cnJlbnQuY3VycmVudFJhd0ZyYW1lID0gaW5pdGlhbFNlZ21lbnRbMF07XG4gICAgICB9XG4gICAgICAvLyBVcGRhdGUgdGhlIHNlZ21lbnRcbiAgICAgIGFuaW1hdGlvbkluc3RhbmNlUmVmLmN1cnJlbnQuc2V0U2VnbWVudChpbml0aWFsU2VnbWVudFswXSwgaW5pdGlhbFNlZ21lbnRbMV0pO1xuICAgIH0sIFtpbml0aWFsU2VnbWVudF0pO1xuICAgIC8qXG4gICAgICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgICAgRVZFTlRTXG4gICAgICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJlaW5pdGlhbGl6ZSBsaXN0ZW5lciBvbiBjaGFuZ2VcbiAgICAgKi9cbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcnRpYWxMaXN0ZW5lcnMgPSBbe1xuICAgICAgICBuYW1lOiBcImNvbXBsZXRlXCIsXG4gICAgICAgIGhhbmRsZXI6IG9uQ29tcGxldGVcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJsb29wQ29tcGxldGVcIixcbiAgICAgICAgaGFuZGxlcjogb25Mb29wQ29tcGxldGVcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJlbnRlckZyYW1lXCIsXG4gICAgICAgIGhhbmRsZXI6IG9uRW50ZXJGcmFtZVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcInNlZ21lbnRTdGFydFwiLFxuICAgICAgICBoYW5kbGVyOiBvblNlZ21lbnRTdGFydFxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcImNvbmZpZ19yZWFkeVwiLFxuICAgICAgICBoYW5kbGVyOiBvbkNvbmZpZ1JlYWR5XG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZGF0YV9yZWFkeVwiLFxuICAgICAgICBoYW5kbGVyOiBvbkRhdGFSZWFkeVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcImRhdGFfZmFpbGVkXCIsXG4gICAgICAgIGhhbmRsZXI6IG9uRGF0YUZhaWxlZFxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcImxvYWRlZF9pbWFnZXNcIixcbiAgICAgICAgaGFuZGxlcjogb25Mb2FkZWRJbWFnZXNcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJET01Mb2FkZWRcIixcbiAgICAgICAgaGFuZGxlcjogb25ET01Mb2FkZWRcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJkZXN0cm95XCIsXG4gICAgICAgIGhhbmRsZXI6IG9uRGVzdHJveVxuICAgICAgfV07XG4gICAgICB2YXIgbGlzdGVuZXJzID0gcGFydGlhbExpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lci5oYW5kbGVyICE9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIGlmICghbGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZGVyZWdpc3Rlckxpc3QgPSBsaXN0ZW5lcnMubWFwKFxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgdGhlIHByb2Nlc3Mgb2YgYWRkaW5nIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgKiBAcGFyYW0ge0xpc3RlbmVyfSBsaXN0ZW5lclxuICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgZGVyZWdpc3RlciB0aGUgbGlzdGVuZXJcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gYW5pbWF0aW9uSW5zdGFuY2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZEV2ZW50TGlzdGVuZXIobGlzdGVuZXIubmFtZSwgbGlzdGVuZXIuaGFuZGxlcik7XG4gICAgICAgIC8vIFJldHVybiBhIGZ1bmN0aW9uIHRvIGRlcmVnaXN0ZXIgdGhpcyBsaXN0ZW5lclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAoX2EgPSBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihsaXN0ZW5lci5uYW1lLCBsaXN0ZW5lci5oYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgLy8gRGVyZWdpc3RlciBsaXN0ZW5lcnMgb24gdW5tb3VudFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVyZWdpc3Rlckxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZGVyZWdpc3Rlcikge1xuICAgICAgICAgIHJldHVybiBkZXJlZ2lzdGVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9LCBbb25Db21wbGV0ZSwgb25Mb29wQ29tcGxldGUsIG9uRW50ZXJGcmFtZSwgb25TZWdtZW50U3RhcnQsIG9uQ29uZmlnUmVhZHksIG9uRGF0YVJlYWR5LCBvbkRhdGFGYWlsZWQsIG9uTG9hZGVkSW1hZ2VzLCBvbkRPTUxvYWRlZCwgb25EZXN0cm95XSk7XG4gICAgLyoqXG4gICAgICogQnVpbGQgdGhlIGFuaW1hdGlvbiB2aWV3XG4gICAgICovXG4gICAgdmFyIFZpZXcgPSAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX29iamVjdFNwcmVhZDIoe1xuICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgcmVmOiBhbmltYXRpb25Db250YWluZXJcbiAgICB9LCByZXN0KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIFZpZXc6IFZpZXcsXG4gICAgICBwbGF5OiBwbGF5LFxuICAgICAgc3RvcDogc3RvcCxcbiAgICAgIHBhdXNlOiBwYXVzZSxcbiAgICAgIHNldFNwZWVkOiBzZXRTcGVlZCxcbiAgICAgIGdvVG9BbmRTdG9wOiBnb1RvQW5kU3RvcCxcbiAgICAgIGdvVG9BbmRQbGF5OiBnb1RvQW5kUGxheSxcbiAgICAgIHNldERpcmVjdGlvbjogc2V0RGlyZWN0aW9uLFxuICAgICAgcGxheVNlZ21lbnRzOiBwbGF5U2VnbWVudHMsXG4gICAgICBzZXRTdWJmcmFtZTogc2V0U3ViZnJhbWUsXG4gICAgICBnZXREdXJhdGlvbjogZ2V0RHVyYXRpb24sXG4gICAgICBkZXN0cm95OiBkZXN0cm95LFxuICAgICAgYW5pbWF0aW9uQ29udGFpbmVyUmVmOiBhbmltYXRpb25Db250YWluZXIsXG4gICAgICBhbmltYXRpb25Mb2FkZWQ6IGFuaW1hdGlvbkxvYWRlZCxcbiAgICAgIGFuaW1hdGlvbkl0ZW06IGFuaW1hdGlvbkluc3RhbmNlUmVmLmN1cnJlbnRcbiAgICB9O1xuICB9O1xuXG4gIC8vIGhlbHBlcnNcbiAgZnVuY3Rpb24gZ2V0Q29udGFpbmVyVmlzaWJpbGl0eShjb250YWluZXIpIHtcbiAgICB2YXIgX2NvbnRhaW5lciRnZXRCb3VuZGluID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgdG9wID0gX2NvbnRhaW5lciRnZXRCb3VuZGluLnRvcCxcbiAgICAgIGhlaWdodCA9IF9jb250YWluZXIkZ2V0Qm91bmRpbi5oZWlnaHQ7XG4gICAgdmFyIGN1cnJlbnQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3A7XG4gICAgdmFyIG1heCA9IHdpbmRvdy5pbm5lckhlaWdodCArIGhlaWdodDtcbiAgICByZXR1cm4gY3VycmVudCAvIG1heDtcbiAgfVxuICBmdW5jdGlvbiBnZXRDb250YWluZXJDdXJzb3JQb3NpdGlvbihjb250YWluZXIsIGN1cnNvclgsIGN1cnNvclkpIHtcbiAgICB2YXIgX2NvbnRhaW5lciRnZXRCb3VuZGluMiA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHRvcCA9IF9jb250YWluZXIkZ2V0Qm91bmRpbjIudG9wLFxuICAgICAgbGVmdCA9IF9jb250YWluZXIkZ2V0Qm91bmRpbjIubGVmdCxcbiAgICAgIHdpZHRoID0gX2NvbnRhaW5lciRnZXRCb3VuZGluMi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9jb250YWluZXIkZ2V0Qm91bmRpbjIuaGVpZ2h0O1xuICAgIHZhciB4ID0gKGN1cnNvclggLSBsZWZ0KSAvIHdpZHRoO1xuICAgIHZhciB5ID0gKGN1cnNvclkgLSB0b3ApIC8gaGVpZ2h0O1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG4gIH1cbiAgdmFyIHVzZUluaXRJbnRlcmFjdGl2aXR5ID0gZnVuY3Rpb24gdXNlSW5pdEludGVyYWN0aXZpdHkoX3JlZikge1xuICAgIHZhciB3cmFwcGVyUmVmID0gX3JlZi53cmFwcGVyUmVmLFxuICAgICAgYW5pbWF0aW9uSXRlbSA9IF9yZWYuYW5pbWF0aW9uSXRlbSxcbiAgICAgIG1vZGUgPSBfcmVmLm1vZGUsXG4gICAgICBhY3Rpb25zID0gX3JlZi5hY3Rpb25zO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHdyYXBwZXJSZWYuY3VycmVudDtcbiAgICAgIGlmICghd3JhcHBlciB8fCAhYW5pbWF0aW9uSXRlbSB8fCAhYWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYW5pbWF0aW9uSXRlbS5zdG9wKCk7XG4gICAgICB2YXIgc2Nyb2xsTW9kZUhhbmRsZXIgPSBmdW5jdGlvbiBzY3JvbGxNb2RlSGFuZGxlcigpIHtcbiAgICAgICAgdmFyIGFzc2lnbmVkU2VnbWVudCA9IG51bGw7XG4gICAgICAgIHZhciBzY3JvbGxIYW5kbGVyID0gZnVuY3Rpb24gc2Nyb2xsSGFuZGxlcigpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFBlcmNlbnQgPSBnZXRDb250YWluZXJWaXNpYmlsaXR5KHdyYXBwZXIpO1xuICAgICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IGFjdGlvbiB0aGF0IHNhdGlzZmllcyB0aGUgY3VycmVudCBwb3NpdGlvbiBjb25kaXRpb25zXG4gICAgICAgICAgdmFyIGFjdGlvbiA9IGFjdGlvbnMuZmluZChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICAgIHZhciB2aXNpYmlsaXR5ID0gX3JlZjIudmlzaWJpbGl0eTtcbiAgICAgICAgICAgIHJldHVybiB2aXNpYmlsaXR5ICYmIGN1cnJlbnRQZXJjZW50ID49IHZpc2liaWxpdHlbMF0gJiYgY3VycmVudFBlcmNlbnQgPD0gdmlzaWJpbGl0eVsxXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBTa2lwIGlmIG5vIG1hdGNoaW5nIGFjdGlvbiB3YXMgZm91bmQhXG4gICAgICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSBcInNlZWtcIiAmJiBhY3Rpb24udmlzaWJpbGl0eSAmJiBhY3Rpb24uZnJhbWVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgLy8gU2VlazogR28gdG8gYSBmcmFtZSBiYXNlZCBvbiBwbGF5ZXIgc2Nyb2xsIHBvc2l0aW9uIGFjdGlvblxuICAgICAgICAgICAgdmFyIGZyYW1lVG9HbyA9IGFjdGlvbi5mcmFtZXNbMF0gKyBNYXRoLmNlaWwoKGN1cnJlbnRQZXJjZW50IC0gYWN0aW9uLnZpc2liaWxpdHlbMF0pIC8gKGFjdGlvbi52aXNpYmlsaXR5WzFdIC0gYWN0aW9uLnZpc2liaWxpdHlbMF0pICogYWN0aW9uLmZyYW1lc1sxXSk7XG4gICAgICAgICAgICAvLyEgZ29Ub0FuZFN0b3AgbXVzdCBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGN1cnJlbnQgc2VnbWVudFxuICAgICAgICAgICAgYW5pbWF0aW9uSXRlbS5nb1RvQW5kU3RvcChmcmFtZVRvR28gLSBhbmltYXRpb25JdGVtLmZpcnN0RnJhbWUgLSAxLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSBcImxvb3BcIikge1xuICAgICAgICAgICAgLy8gTG9vcDogTG9vcCBhIGdpdmVuIGZyYW1lc1xuICAgICAgICAgICAgaWYgKGFzc2lnbmVkU2VnbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBpZiBub3QgcGxheWluZyBhbnkgc2VnbWVudHMgY3VycmVudGx5LiBwbGF5IHRob3NlIHNlZ21lbnRzIGFuZCBzYXZlIHRvIHN0YXRlXG4gICAgICAgICAgICAgIGFuaW1hdGlvbkl0ZW0ucGxheVNlZ21lbnRzKGFjdGlvbi5mcmFtZXMsIHRydWUpO1xuICAgICAgICAgICAgICBhc3NpZ25lZFNlZ21lbnQgPSBhY3Rpb24uZnJhbWVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaWYgcGxheWluZyBhbnkgc2VnbWVudHMgY3VycmVudGx5LlxuICAgICAgICAgICAgICAvL2NoZWNrIGlmIHNlZ21lbnRzIGluIHN0YXRlIGFyZSBlcXVhbCB0byB0aGUgZnJhbWVzIHNlbGVjdGVkIGJ5IGFjdGlvblxuICAgICAgICAgICAgICBpZiAoYXNzaWduZWRTZWdtZW50ICE9PSBhY3Rpb24uZnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhleSBhcmUgbm90IGVxdWFsLiBuZXcgc2VnbWVudHMgYXJlIHRvIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkl0ZW0ucGxheVNlZ21lbnRzKGFjdGlvbi5mcmFtZXMsIHRydWUpO1xuICAgICAgICAgICAgICAgIGFzc2lnbmVkU2VnbWVudCA9IGFjdGlvbi5mcmFtZXM7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5pbWF0aW9uSXRlbS5pc1BhdXNlZCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXkgYXJlIGVxdWFsIHRoZSBwbGF5IG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBvbmx5IGlmIGxvdHRpZSBpcyBwYXVzZWRcbiAgICAgICAgICAgICAgICBhbmltYXRpb25JdGVtLnBsYXlTZWdtZW50cyhhY3Rpb24uZnJhbWVzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBhc3NpZ25lZFNlZ21lbnQgPSBhY3Rpb24uZnJhbWVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gXCJwbGF5XCIgJiYgYW5pbWF0aW9uSXRlbS5pc1BhdXNlZCkge1xuICAgICAgICAgICAgLy8gUGxheTogUmVzZXQgc2VnbWVudHMgYW5kIGNvbnRpbnVlIHBsYXlpbmcgZnVsbCBhbmltYXRpb24gZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgICAgICBhbmltYXRpb25JdGVtLnJlc2V0U2VnbWVudHModHJ1ZSk7XG4gICAgICAgICAgICBhbmltYXRpb25JdGVtLnBsYXkoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSBcInN0b3BcIikge1xuICAgICAgICAgICAgLy8gU3RvcDogU3RvcCBwbGF5YmFja1xuICAgICAgICAgICAgYW5pbWF0aW9uSXRlbS5nb1RvQW5kU3RvcChhY3Rpb24uZnJhbWVzWzBdIC0gYW5pbWF0aW9uSXRlbS5maXJzdEZyYW1lIC0gMSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHNjcm9sbEhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgc2Nyb2xsSGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgdmFyIGN1cnNvck1vZGVIYW5kbGVyID0gZnVuY3Rpb24gY3Vyc29yTW9kZUhhbmRsZXIoKSB7XG4gICAgICAgIHZhciBoYW5kbGVDdXJzb3IgPSBmdW5jdGlvbiBoYW5kbGVDdXJzb3IoX3gsIF95KSB7XG4gICAgICAgICAgdmFyIHggPSBfeDtcbiAgICAgICAgICB2YXIgeSA9IF95O1xuICAgICAgICAgIC8vIFJlc29sdmUgY3Vyc29yIHBvc2l0aW9uIGlmIGN1cnNvciBpcyBpbnNpZGUgY29udGFpbmVyXG4gICAgICAgICAgaWYgKHggIT09IC0xICYmIHkgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBHZXQgY29udGFpbmVyIGN1cnNvciBwb3NpdGlvblxuICAgICAgICAgICAgdmFyIHBvcyA9IGdldENvbnRhaW5lckN1cnNvclBvc2l0aW9uKHdyYXBwZXIsIHgsIHkpO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSByZXNvbHZlZCBwb3NpdGlvblxuICAgICAgICAgICAgeCA9IHBvcy54O1xuICAgICAgICAgICAgeSA9IHBvcy55O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBhY3Rpb24gdGhhdCBzYXRpc2ZpZXMgdGhlIGN1cnJlbnQgcG9zaXRpb24gY29uZGl0aW9uc1xuICAgICAgICAgIHZhciBhY3Rpb24gPSBhY3Rpb25zLmZpbmQoZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBfcmVmMy5wb3NpdGlvbjtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiAmJiBBcnJheS5pc0FycmF5KHBvc2l0aW9uLngpICYmIEFycmF5LmlzQXJyYXkocG9zaXRpb24ueSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHggPj0gcG9zaXRpb24ueFswXSAmJiB4IDw9IHBvc2l0aW9uLnhbMV0gJiYgeSA+PSBwb3NpdGlvbi55WzBdICYmIHkgPD0gcG9zaXRpb24ueVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiAmJiAhTnVtYmVyLmlzTmFOKHBvc2l0aW9uLngpICYmICFOdW1iZXIuaXNOYU4ocG9zaXRpb24ueSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHggPT09IHBvc2l0aW9uLnggJiYgeSA9PT0gcG9zaXRpb24ueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBTa2lwIGlmIG5vIG1hdGNoaW5nIGFjdGlvbiB3YXMgZm91bmQhXG4gICAgICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUHJvY2VzcyBhY3Rpb24gdHlwZXM6XG4gICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSBcInNlZWtcIiAmJiBhY3Rpb24ucG9zaXRpb24gJiYgQXJyYXkuaXNBcnJheShhY3Rpb24ucG9zaXRpb24ueCkgJiYgQXJyYXkuaXNBcnJheShhY3Rpb24ucG9zaXRpb24ueSkgJiYgYWN0aW9uLmZyYW1lcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIC8vIFNlZWs6IEdvIHRvIGEgZnJhbWUgYmFzZWQgb24gcGxheWVyIHNjcm9sbCBwb3NpdGlvbiBhY3Rpb25cbiAgICAgICAgICAgIHZhciB4UGVyY2VudCA9ICh4IC0gYWN0aW9uLnBvc2l0aW9uLnhbMF0pIC8gKGFjdGlvbi5wb3NpdGlvbi54WzFdIC0gYWN0aW9uLnBvc2l0aW9uLnhbMF0pO1xuICAgICAgICAgICAgdmFyIHlQZXJjZW50ID0gKHkgLSBhY3Rpb24ucG9zaXRpb24ueVswXSkgLyAoYWN0aW9uLnBvc2l0aW9uLnlbMV0gLSBhY3Rpb24ucG9zaXRpb24ueVswXSk7XG4gICAgICAgICAgICBhbmltYXRpb25JdGVtLnBsYXlTZWdtZW50cyhhY3Rpb24uZnJhbWVzLCB0cnVlKTtcbiAgICAgICAgICAgIGFuaW1hdGlvbkl0ZW0uZ29Ub0FuZFN0b3AoTWF0aC5jZWlsKCh4UGVyY2VudCArIHlQZXJjZW50KSAvIDIgKiAoYWN0aW9uLmZyYW1lc1sxXSAtIGFjdGlvbi5mcmFtZXNbMF0pKSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gXCJsb29wXCIpIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbkl0ZW0ucGxheVNlZ21lbnRzKGFjdGlvbi5mcmFtZXMsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09IFwicGxheVwiKSB7XG4gICAgICAgICAgICAvLyBQbGF5OiBSZXNldCBzZWdtZW50cyBhbmQgY29udGludWUgcGxheWluZyBmdWxsIGFuaW1hdGlvbiBmcm9tIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgICAgIGlmIChhbmltYXRpb25JdGVtLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvbkl0ZW0ucmVzZXRTZWdtZW50cyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmltYXRpb25JdGVtLnBsYXlTZWdtZW50cyhhY3Rpb24uZnJhbWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSBcInN0b3BcIikge1xuICAgICAgICAgICAgYW5pbWF0aW9uSXRlbS5nb1RvQW5kU3RvcChhY3Rpb24uZnJhbWVzWzBdLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtb3VzZU1vdmVIYW5kbGVyID0gZnVuY3Rpb24gbW91c2VNb3ZlSGFuZGxlcihldikge1xuICAgICAgICAgIGhhbmRsZUN1cnNvcihldi5jbGllbnRYLCBldi5jbGllbnRZKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1vdXNlT3V0SGFuZGxlciA9IGZ1bmN0aW9uIG1vdXNlT3V0SGFuZGxlcigpIHtcbiAgICAgICAgICBoYW5kbGVDdXJzb3IoLTEsIC0xKTtcbiAgICAgICAgfTtcbiAgICAgICAgd3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZUhhbmRsZXIpO1xuICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCBtb3VzZU91dEhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3VzZU1vdmVIYW5kbGVyKTtcbiAgICAgICAgICB3cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCBtb3VzZU91dEhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlIFwic2Nyb2xsXCI6XG4gICAgICAgICAgcmV0dXJuIHNjcm9sbE1vZGVIYW5kbGVyKCk7XG4gICAgICAgIGNhc2UgXCJjdXJzb3JcIjpcbiAgICAgICAgICByZXR1cm4gY3Vyc29yTW9kZUhhbmRsZXIoKTtcbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbbW9kZSwgYW5pbWF0aW9uSXRlbV0pO1xuICB9O1xuICB2YXIgdXNlTG90dGllSW50ZXJhY3Rpdml0eSA9IGZ1bmN0aW9uIHVzZUxvdHRpZUludGVyYWN0aXZpdHkoX3JlZjQpIHtcbiAgICB2YXIgYWN0aW9ucyA9IF9yZWY0LmFjdGlvbnMsXG4gICAgICBtb2RlID0gX3JlZjQubW9kZSxcbiAgICAgIGxvdHRpZU9iaiA9IF9yZWY0LmxvdHRpZU9iajtcbiAgICB2YXIgYW5pbWF0aW9uSXRlbSA9IGxvdHRpZU9iai5hbmltYXRpb25JdGVtLFxuICAgICAgVmlldyA9IGxvdHRpZU9iai5WaWV3LFxuICAgICAgYW5pbWF0aW9uQ29udGFpbmVyUmVmID0gbG90dGllT2JqLmFuaW1hdGlvbkNvbnRhaW5lclJlZjtcbiAgICB1c2VJbml0SW50ZXJhY3Rpdml0eSh7XG4gICAgICBhY3Rpb25zOiBhY3Rpb25zLFxuICAgICAgYW5pbWF0aW9uSXRlbTogYW5pbWF0aW9uSXRlbSxcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICB3cmFwcGVyUmVmOiBhbmltYXRpb25Db250YWluZXJSZWZcbiAgICB9KTtcbiAgICByZXR1cm4gVmlldztcbiAgfTtcblxuICB2YXIgX2V4Y2x1ZGVkID0gW1wic3R5bGVcIiwgXCJpbnRlcmFjdGl2aXR5XCJdO1xuICB2YXIgTG90dGllID0gZnVuY3Rpb24gTG90dGllKHByb3BzKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgdmFyIHN0eWxlID0gcHJvcHMuc3R5bGUsXG4gICAgICBpbnRlcmFjdGl2aXR5ID0gcHJvcHMuaW50ZXJhY3Rpdml0eSxcbiAgICAgIGxvdHRpZVByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQpO1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlICd1c2VMb3R0aWUnIGhvb2tcbiAgICAgKi9cbiAgICB2YXIgX3VzZUxvdHRpZSA9IHVzZUxvdHRpZShsb3R0aWVQcm9wcywgc3R5bGUpLFxuICAgICAgVmlldyA9IF91c2VMb3R0aWUuVmlldyxcbiAgICAgIHBsYXkgPSBfdXNlTG90dGllLnBsYXksXG4gICAgICBzdG9wID0gX3VzZUxvdHRpZS5zdG9wLFxuICAgICAgcGF1c2UgPSBfdXNlTG90dGllLnBhdXNlLFxuICAgICAgc2V0U3BlZWQgPSBfdXNlTG90dGllLnNldFNwZWVkLFxuICAgICAgZ29Ub0FuZFN0b3AgPSBfdXNlTG90dGllLmdvVG9BbmRTdG9wLFxuICAgICAgZ29Ub0FuZFBsYXkgPSBfdXNlTG90dGllLmdvVG9BbmRQbGF5LFxuICAgICAgc2V0RGlyZWN0aW9uID0gX3VzZUxvdHRpZS5zZXREaXJlY3Rpb24sXG4gICAgICBwbGF5U2VnbWVudHMgPSBfdXNlTG90dGllLnBsYXlTZWdtZW50cyxcbiAgICAgIHNldFN1YmZyYW1lID0gX3VzZUxvdHRpZS5zZXRTdWJmcmFtZSxcbiAgICAgIGdldER1cmF0aW9uID0gX3VzZUxvdHRpZS5nZXREdXJhdGlvbixcbiAgICAgIGRlc3Ryb3kgPSBfdXNlTG90dGllLmRlc3Ryb3ksXG4gICAgICBhbmltYXRpb25Db250YWluZXJSZWYgPSBfdXNlTG90dGllLmFuaW1hdGlvbkNvbnRhaW5lclJlZixcbiAgICAgIGFuaW1hdGlvbkxvYWRlZCA9IF91c2VMb3R0aWUuYW5pbWF0aW9uTG9hZGVkLFxuICAgICAgYW5pbWF0aW9uSXRlbSA9IF91c2VMb3R0aWUuYW5pbWF0aW9uSXRlbTtcbiAgICAvKipcbiAgICAgKiBNYWtlIHRoZSBob29rIHZhcmlhYmxlcy9tZXRob2RzIGF2YWlsYWJsZSB0aHJvdWdoIHRoZSBwcm92aWRlZCAnbG90dGllUmVmJ1xuICAgICAqL1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocHJvcHMubG90dGllUmVmKSB7XG4gICAgICAgIHByb3BzLmxvdHRpZVJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgIHBsYXk6IHBsYXksXG4gICAgICAgICAgc3RvcDogc3RvcCxcbiAgICAgICAgICBwYXVzZTogcGF1c2UsXG4gICAgICAgICAgc2V0U3BlZWQ6IHNldFNwZWVkLFxuICAgICAgICAgIGdvVG9BbmRQbGF5OiBnb1RvQW5kUGxheSxcbiAgICAgICAgICBnb1RvQW5kU3RvcDogZ29Ub0FuZFN0b3AsXG4gICAgICAgICAgc2V0RGlyZWN0aW9uOiBzZXREaXJlY3Rpb24sXG4gICAgICAgICAgcGxheVNlZ21lbnRzOiBwbGF5U2VnbWVudHMsXG4gICAgICAgICAgc2V0U3ViZnJhbWU6IHNldFN1YmZyYW1lLFxuICAgICAgICAgIGdldER1cmF0aW9uOiBnZXREdXJhdGlvbixcbiAgICAgICAgICBkZXN0cm95OiBkZXN0cm95LFxuICAgICAgICAgIGFuaW1hdGlvbkNvbnRhaW5lclJlZjogYW5pbWF0aW9uQ29udGFpbmVyUmVmLFxuICAgICAgICAgIGFuaW1hdGlvbkxvYWRlZDogYW5pbWF0aW9uTG9hZGVkLFxuICAgICAgICAgIGFuaW1hdGlvbkl0ZW06IGFuaW1hdGlvbkl0ZW1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbKF9hID0gcHJvcHMubG90dGllUmVmKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VycmVudF0pO1xuICAgIHJldHVybiB1c2VMb3R0aWVJbnRlcmFjdGl2aXR5KHtcbiAgICAgIGxvdHRpZU9iajoge1xuICAgICAgICBWaWV3OiBWaWV3LFxuICAgICAgICBwbGF5OiBwbGF5LFxuICAgICAgICBzdG9wOiBzdG9wLFxuICAgICAgICBwYXVzZTogcGF1c2UsXG4gICAgICAgIHNldFNwZWVkOiBzZXRTcGVlZCxcbiAgICAgICAgZ29Ub0FuZFN0b3A6IGdvVG9BbmRTdG9wLFxuICAgICAgICBnb1RvQW5kUGxheTogZ29Ub0FuZFBsYXksXG4gICAgICAgIHNldERpcmVjdGlvbjogc2V0RGlyZWN0aW9uLFxuICAgICAgICBwbGF5U2VnbWVudHM6IHBsYXlTZWdtZW50cyxcbiAgICAgICAgc2V0U3ViZnJhbWU6IHNldFN1YmZyYW1lLFxuICAgICAgICBnZXREdXJhdGlvbjogZ2V0RHVyYXRpb24sXG4gICAgICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgICAgIGFuaW1hdGlvbkNvbnRhaW5lclJlZjogYW5pbWF0aW9uQ29udGFpbmVyUmVmLFxuICAgICAgICBhbmltYXRpb25Mb2FkZWQ6IGFuaW1hdGlvbkxvYWRlZCxcbiAgICAgICAgYW5pbWF0aW9uSXRlbTogYW5pbWF0aW9uSXRlbVxuICAgICAgfSxcbiAgICAgIGFjdGlvbnM6IChfYiA9IGludGVyYWN0aXZpdHkgPT09IG51bGwgfHwgaW50ZXJhY3Rpdml0eSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJhY3Rpdml0eS5hY3Rpb25zKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSxcbiAgICAgIG1vZGU6IChfYyA9IGludGVyYWN0aXZpdHkgPT09IG51bGwgfHwgaW50ZXJhY3Rpdml0eSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJhY3Rpdml0eS5tb2RlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcInNjcm9sbFwiXG4gICAgfSk7XG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdMb3R0aWVQbGF5ZXInLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvdHRpZV9fZGVmYXVsdFtcImRlZmF1bHRcIl07IH1cbiAgfSk7XG4gIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gTG90dGllO1xuICBleHBvcnRzLnVzZUxvdHRpZSA9IHVzZUxvdHRpZTtcbiAgZXhwb3J0cy51c2VMb3R0aWVJbnRlcmFjdGl2aXR5ID0gdXNlTG90dGllSW50ZXJhY3Rpdml0eTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC51bWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lottie-react/build/index.umd.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lottie-web/build/player/lottie.js":
/*!********************************************************!*\
  !*** ./node_modules/lottie-web/build/player/lottie.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("(typeof navigator !== \"undefined\") && (function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n})(this, (function () { 'use strict';\n\n  var svgNS = 'http://www.w3.org/2000/svg';\n  var locationHref = '';\n  var _useWebWorker = false;\n  var initialDefaultFrame = -999999;\n\n  var setWebWorker = function setWebWorker(flag) {\n    _useWebWorker = !!flag;\n  };\n\n  var getWebWorker = function getWebWorker() {\n    return _useWebWorker;\n  };\n\n  var setLocationHref = function setLocationHref(value) {\n    locationHref = value;\n  };\n\n  var getLocationHref = function getLocationHref() {\n    return locationHref;\n  };\n\n  function createTag(type) {\n    // return {appendChild:function(){},setAttribute:function(){},style:{}}\n    return document.createElement(type);\n  }\n\n  function extendPrototype(sources, destination) {\n    var i;\n    var len = sources.length;\n    var sourcePrototype;\n\n    for (i = 0; i < len; i += 1) {\n      sourcePrototype = sources[i].prototype;\n\n      for (var attr in sourcePrototype) {\n        if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];\n      }\n    }\n  }\n\n  function getDescriptor(object, prop) {\n    return Object.getOwnPropertyDescriptor(object, prop);\n  }\n\n  function createProxyFunction(prototype) {\n    function ProxyFunction() {}\n\n    ProxyFunction.prototype = prototype;\n    return ProxyFunction;\n  }\n\n  // import Howl from '../../3rd_party/howler';\n  var audioControllerFactory = function () {\n    function AudioController(audioFactory) {\n      this.audios = [];\n      this.audioFactory = audioFactory;\n      this._volume = 1;\n      this._isMuted = false;\n    }\n\n    AudioController.prototype = {\n      addAudio: function addAudio(audio) {\n        this.audios.push(audio);\n      },\n      pause: function pause() {\n        var i;\n        var len = this.audios.length;\n\n        for (i = 0; i < len; i += 1) {\n          this.audios[i].pause();\n        }\n      },\n      resume: function resume() {\n        var i;\n        var len = this.audios.length;\n\n        for (i = 0; i < len; i += 1) {\n          this.audios[i].resume();\n        }\n      },\n      setRate: function setRate(rateValue) {\n        var i;\n        var len = this.audios.length;\n\n        for (i = 0; i < len; i += 1) {\n          this.audios[i].setRate(rateValue);\n        }\n      },\n      createAudio: function createAudio(assetPath) {\n        if (this.audioFactory) {\n          return this.audioFactory(assetPath);\n        }\n\n        if (window.Howl) {\n          return new window.Howl({\n            src: [assetPath]\n          });\n        }\n\n        return {\n          isPlaying: false,\n          play: function play() {\n            this.isPlaying = true;\n          },\n          seek: function seek() {\n            this.isPlaying = false;\n          },\n          playing: function playing() {},\n          rate: function rate() {},\n          setVolume: function setVolume() {}\n        };\n      },\n      setAudioFactory: function setAudioFactory(audioFactory) {\n        this.audioFactory = audioFactory;\n      },\n      setVolume: function setVolume(value) {\n        this._volume = value;\n\n        this._updateVolume();\n      },\n      mute: function mute() {\n        this._isMuted = true;\n\n        this._updateVolume();\n      },\n      unmute: function unmute() {\n        this._isMuted = false;\n\n        this._updateVolume();\n      },\n      getVolume: function getVolume() {\n        return this._volume;\n      },\n      _updateVolume: function _updateVolume() {\n        var i;\n        var len = this.audios.length;\n\n        for (i = 0; i < len; i += 1) {\n          this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1));\n        }\n      }\n    };\n    return function () {\n      return new AudioController();\n    };\n  }();\n\n  var createTypedArray = function () {\n    function createRegularArray(type, len) {\n      var i = 0;\n      var arr = [];\n      var value;\n\n      switch (type) {\n        case 'int16':\n        case 'uint8c':\n          value = 1;\n          break;\n\n        default:\n          value = 1.1;\n          break;\n      }\n\n      for (i = 0; i < len; i += 1) {\n        arr.push(value);\n      }\n\n      return arr;\n    }\n\n    function createTypedArrayFactory(type, len) {\n      if (type === 'float32') {\n        return new Float32Array(len);\n      }\n\n      if (type === 'int16') {\n        return new Int16Array(len);\n      }\n\n      if (type === 'uint8c') {\n        return new Uint8ClampedArray(len);\n      }\n\n      return createRegularArray(type, len);\n    }\n\n    if (typeof Uint8ClampedArray === 'function' && typeof Float32Array === 'function') {\n      return createTypedArrayFactory;\n    }\n\n    return createRegularArray;\n  }();\n\n  function createSizedArray(len) {\n    return Array.apply(null, {\n      length: len\n    });\n  }\n\n  function _typeof$6(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof$6 = function _typeof(obj) { return typeof obj; }; } else { _typeof$6 = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof$6(obj); }\n  var subframeEnabled = true;\n  var expressionsPlugin = null;\n  var expressionsInterfaces = null;\n  var idPrefix$1 = '';\n  var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n  var _shouldRoundValues = false;\n  var bmPow = Math.pow;\n  var bmSqrt = Math.sqrt;\n  var bmFloor = Math.floor;\n  var bmMax = Math.max;\n  var bmMin = Math.min;\n  var BMMath = {};\n\n  (function () {\n    var propertyNames = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'atan2', 'ceil', 'cbrt', 'expm1', 'clz32', 'cos', 'cosh', 'exp', 'floor', 'fround', 'hypot', 'imul', 'log', 'log1p', 'log2', 'log10', 'max', 'min', 'pow', 'random', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc', 'E', 'LN10', 'LN2', 'LOG10E', 'LOG2E', 'PI', 'SQRT1_2', 'SQRT2'];\n    var i;\n    var len = propertyNames.length;\n\n    for (i = 0; i < len; i += 1) {\n      BMMath[propertyNames[i]] = Math[propertyNames[i]];\n    }\n  })();\n\n  function ProjectInterface$1() {\n    return {};\n  }\n\n  BMMath.random = Math.random;\n\n  BMMath.abs = function (val) {\n    var tOfVal = _typeof$6(val);\n\n    if (tOfVal === 'object' && val.length) {\n      var absArr = createSizedArray(val.length);\n      var i;\n      var len = val.length;\n\n      for (i = 0; i < len; i += 1) {\n        absArr[i] = Math.abs(val[i]);\n      }\n\n      return absArr;\n    }\n\n    return Math.abs(val);\n  };\n\n  var defaultCurveSegments = 150;\n  var degToRads = Math.PI / 180;\n  var roundCorner = 0.5519;\n\n  function roundValues(flag) {\n    _shouldRoundValues = !!flag;\n  }\n\n  function bmRnd(value) {\n    if (_shouldRoundValues) {\n      return Math.round(value);\n    }\n\n    return value;\n  }\n\n  function styleDiv(element) {\n    element.style.position = 'absolute';\n    element.style.top = 0;\n    element.style.left = 0;\n    element.style.display = 'block';\n    element.style.transformOrigin = '0 0';\n    element.style.webkitTransformOrigin = '0 0';\n    element.style.backfaceVisibility = 'visible';\n    element.style.webkitBackfaceVisibility = 'visible';\n    element.style.transformStyle = 'preserve-3d';\n    element.style.webkitTransformStyle = 'preserve-3d';\n    element.style.mozTransformStyle = 'preserve-3d';\n  }\n\n  function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {\n    this.type = type;\n    this.currentTime = currentTime;\n    this.totalTime = totalTime;\n    this.direction = frameMultiplier < 0 ? -1 : 1;\n  }\n\n  function BMCompleteEvent(type, frameMultiplier) {\n    this.type = type;\n    this.direction = frameMultiplier < 0 ? -1 : 1;\n  }\n\n  function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {\n    this.type = type;\n    this.currentLoop = currentLoop;\n    this.totalLoops = totalLoops;\n    this.direction = frameMultiplier < 0 ? -1 : 1;\n  }\n\n  function BMSegmentStartEvent(type, firstFrame, totalFrames) {\n    this.type = type;\n    this.firstFrame = firstFrame;\n    this.totalFrames = totalFrames;\n  }\n\n  function BMDestroyEvent(type, target) {\n    this.type = type;\n    this.target = target;\n  }\n\n  function BMRenderFrameErrorEvent(nativeError, currentTime) {\n    this.type = 'renderFrameError';\n    this.nativeError = nativeError;\n    this.currentTime = currentTime;\n  }\n\n  function BMConfigErrorEvent(nativeError) {\n    this.type = 'configError';\n    this.nativeError = nativeError;\n  }\n\n  function BMAnimationConfigErrorEvent(type, nativeError) {\n    this.type = type;\n    this.nativeError = nativeError;\n  }\n\n  var createElementID = function () {\n    var _count = 0;\n    return function createID() {\n      _count += 1;\n      return idPrefix$1 + '__lottie_element_' + _count;\n    };\n  }();\n\n  function HSVtoRGB(h, s, v) {\n    var r;\n    var g;\n    var b;\n    var i;\n    var f;\n    var p;\n    var q;\n    var t;\n    i = Math.floor(h * 6);\n    f = h * 6 - i;\n    p = v * (1 - s);\n    q = v * (1 - f * s);\n    t = v * (1 - (1 - f) * s);\n\n    switch (i % 6) {\n      case 0:\n        r = v;\n        g = t;\n        b = p;\n        break;\n\n      case 1:\n        r = q;\n        g = v;\n        b = p;\n        break;\n\n      case 2:\n        r = p;\n        g = v;\n        b = t;\n        break;\n\n      case 3:\n        r = p;\n        g = q;\n        b = v;\n        break;\n\n      case 4:\n        r = t;\n        g = p;\n        b = v;\n        break;\n\n      case 5:\n        r = v;\n        g = p;\n        b = q;\n        break;\n\n      default:\n        break;\n    }\n\n    return [r, g, b];\n  }\n\n  function RGBtoHSV(r, g, b) {\n    var max = Math.max(r, g, b);\n    var min = Math.min(r, g, b);\n    var d = max - min;\n    var h;\n    var s = max === 0 ? 0 : d / max;\n    var v = max / 255;\n\n    switch (max) {\n      case min:\n        h = 0;\n        break;\n\n      case r:\n        h = g - b + d * (g < b ? 6 : 0);\n        h /= 6 * d;\n        break;\n\n      case g:\n        h = b - r + d * 2;\n        h /= 6 * d;\n        break;\n\n      case b:\n        h = r - g + d * 4;\n        h /= 6 * d;\n        break;\n\n      default:\n        break;\n    }\n\n    return [h, s, v];\n  }\n\n  function addSaturationToRGB(color, offset) {\n    var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);\n    hsv[1] += offset;\n\n    if (hsv[1] > 1) {\n      hsv[1] = 1;\n    } else if (hsv[1] <= 0) {\n      hsv[1] = 0;\n    }\n\n    return HSVtoRGB(hsv[0], hsv[1], hsv[2]);\n  }\n\n  function addBrightnessToRGB(color, offset) {\n    var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);\n    hsv[2] += offset;\n\n    if (hsv[2] > 1) {\n      hsv[2] = 1;\n    } else if (hsv[2] < 0) {\n      hsv[2] = 0;\n    }\n\n    return HSVtoRGB(hsv[0], hsv[1], hsv[2]);\n  }\n\n  function addHueToRGB(color, offset) {\n    var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);\n    hsv[0] += offset / 360;\n\n    if (hsv[0] > 1) {\n      hsv[0] -= 1;\n    } else if (hsv[0] < 0) {\n      hsv[0] += 1;\n    }\n\n    return HSVtoRGB(hsv[0], hsv[1], hsv[2]);\n  }\n\n  var rgbToHex = function () {\n    var colorMap = [];\n    var i;\n    var hex;\n\n    for (i = 0; i < 256; i += 1) {\n      hex = i.toString(16);\n      colorMap[i] = hex.length === 1 ? '0' + hex : hex;\n    }\n\n    return function (r, g, b) {\n      if (r < 0) {\n        r = 0;\n      }\n\n      if (g < 0) {\n        g = 0;\n      }\n\n      if (b < 0) {\n        b = 0;\n      }\n\n      return '#' + colorMap[r] + colorMap[g] + colorMap[b];\n    };\n  }();\n\n  var setSubframeEnabled = function setSubframeEnabled(flag) {\n    subframeEnabled = !!flag;\n  };\n\n  var getSubframeEnabled = function getSubframeEnabled() {\n    return subframeEnabled;\n  };\n\n  var setExpressionsPlugin = function setExpressionsPlugin(value) {\n    expressionsPlugin = value;\n  };\n\n  var getExpressionsPlugin = function getExpressionsPlugin() {\n    return expressionsPlugin;\n  };\n\n  var setExpressionInterfaces = function setExpressionInterfaces(value) {\n    expressionsInterfaces = value;\n  };\n\n  var getExpressionInterfaces = function getExpressionInterfaces() {\n    return expressionsInterfaces;\n  };\n\n  var setDefaultCurveSegments = function setDefaultCurveSegments(value) {\n    defaultCurveSegments = value;\n  };\n\n  var getDefaultCurveSegments = function getDefaultCurveSegments() {\n    return defaultCurveSegments;\n  };\n\n  var setIdPrefix = function setIdPrefix(value) {\n    idPrefix$1 = value;\n  };\n\n  var getIdPrefix = function getIdPrefix() {\n    return idPrefix$1;\n  };\n\n  function createNS(type) {\n    // return {appendChild:function(){},setAttribute:function(){},style:{}}\n    return document.createElementNS(svgNS, type);\n  }\n\n  function _typeof$5(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof$5 = function _typeof(obj) { return typeof obj; }; } else { _typeof$5 = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof$5(obj); }\n\n  var dataManager = function () {\n    var _counterId = 1;\n    var processes = [];\n    var workerFn;\n    var workerInstance;\n    var workerProxy = {\n      onmessage: function onmessage() {},\n      postMessage: function postMessage(path) {\n        workerFn({\n          data: path\n        });\n      }\n    };\n    var _workerSelf = {\n      postMessage: function postMessage(data) {\n        workerProxy.onmessage({\n          data: data\n        });\n      }\n    };\n\n    function createWorker(fn) {\n      if (window.Worker && window.Blob && getWebWorker()) {\n        var blob = new Blob(['var _workerSelf = self; self.onmessage = ', fn.toString()], {\n          type: 'text/javascript'\n        }); // var blob = new Blob(['self.onmessage = ', fn.toString()], { type: 'text/javascript' });\n\n        var url = URL.createObjectURL(blob);\n        return new Worker(url);\n      }\n\n      workerFn = fn;\n      return workerProxy;\n    }\n\n    function setupWorker() {\n      if (!workerInstance) {\n        workerInstance = createWorker(function workerStart(e) {\n          function dataFunctionManager() {\n            function completeLayers(layers, comps) {\n              var layerData;\n              var i;\n              var len = layers.length;\n              var j;\n              var jLen;\n              var k;\n              var kLen;\n\n              for (i = 0; i < len; i += 1) {\n                layerData = layers[i];\n\n                if ('ks' in layerData && !layerData.completed) {\n                  layerData.completed = true;\n\n                  if (layerData.hasMask) {\n                    var maskProps = layerData.masksProperties;\n                    jLen = maskProps.length;\n\n                    for (j = 0; j < jLen; j += 1) {\n                      if (maskProps[j].pt.k.i) {\n                        convertPathsToAbsoluteValues(maskProps[j].pt.k);\n                      } else {\n                        kLen = maskProps[j].pt.k.length;\n\n                        for (k = 0; k < kLen; k += 1) {\n                          if (maskProps[j].pt.k[k].s) {\n                            convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);\n                          }\n\n                          if (maskProps[j].pt.k[k].e) {\n                            convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);\n                          }\n                        }\n                      }\n                    }\n                  }\n\n                  if (layerData.ty === 0) {\n                    layerData.layers = findCompLayers(layerData.refId, comps);\n                    completeLayers(layerData.layers, comps);\n                  } else if (layerData.ty === 4) {\n                    completeShapes(layerData.shapes);\n                  } else if (layerData.ty === 5) {\n                    completeText(layerData);\n                  }\n                }\n              }\n            }\n\n            function completeChars(chars, assets) {\n              if (chars) {\n                var i = 0;\n                var len = chars.length;\n\n                for (i = 0; i < len; i += 1) {\n                  if (chars[i].t === 1) {\n                    // var compData = findComp(chars[i].data.refId, assets);\n                    chars[i].data.layers = findCompLayers(chars[i].data.refId, assets); // chars[i].data.ip = 0;\n                    // chars[i].data.op = 99999;\n                    // chars[i].data.st = 0;\n                    // chars[i].data.sr = 1;\n                    // chars[i].w = compData.w;\n                    // chars[i].data.ks = {\n                    //   a: { k: [0, 0, 0], a: 0 },\n                    //   p: { k: [0, -compData.h, 0], a: 0 },\n                    //   r: { k: 0, a: 0 },\n                    //   s: { k: [100, 100], a: 0 },\n                    //   o: { k: 100, a: 0 },\n                    // };\n\n                    completeLayers(chars[i].data.layers, assets);\n                  }\n                }\n              }\n            }\n\n            function findComp(id, comps) {\n              var i = 0;\n              var len = comps.length;\n\n              while (i < len) {\n                if (comps[i].id === id) {\n                  return comps[i];\n                }\n\n                i += 1;\n              }\n\n              return null;\n            }\n\n            function findCompLayers(id, comps) {\n              var comp = findComp(id, comps);\n\n              if (comp) {\n                if (!comp.layers.__used) {\n                  comp.layers.__used = true;\n                  return comp.layers;\n                }\n\n                return JSON.parse(JSON.stringify(comp.layers));\n              }\n\n              return null;\n            }\n\n            function completeShapes(arr) {\n              var i;\n              var len = arr.length;\n              var j;\n              var jLen;\n\n              for (i = len - 1; i >= 0; i -= 1) {\n                if (arr[i].ty === 'sh') {\n                  if (arr[i].ks.k.i) {\n                    convertPathsToAbsoluteValues(arr[i].ks.k);\n                  } else {\n                    jLen = arr[i].ks.k.length;\n\n                    for (j = 0; j < jLen; j += 1) {\n                      if (arr[i].ks.k[j].s) {\n                        convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);\n                      }\n\n                      if (arr[i].ks.k[j].e) {\n                        convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);\n                      }\n                    }\n                  }\n                } else if (arr[i].ty === 'gr') {\n                  completeShapes(arr[i].it);\n                }\n              }\n            }\n\n            function convertPathsToAbsoluteValues(path) {\n              var i;\n              var len = path.i.length;\n\n              for (i = 0; i < len; i += 1) {\n                path.i[i][0] += path.v[i][0];\n                path.i[i][1] += path.v[i][1];\n                path.o[i][0] += path.v[i][0];\n                path.o[i][1] += path.v[i][1];\n              }\n            }\n\n            function checkVersion(minimum, animVersionString) {\n              var animVersion = animVersionString ? animVersionString.split('.') : [100, 100, 100];\n\n              if (minimum[0] > animVersion[0]) {\n                return true;\n              }\n\n              if (animVersion[0] > minimum[0]) {\n                return false;\n              }\n\n              if (minimum[1] > animVersion[1]) {\n                return true;\n              }\n\n              if (animVersion[1] > minimum[1]) {\n                return false;\n              }\n\n              if (minimum[2] > animVersion[2]) {\n                return true;\n              }\n\n              if (animVersion[2] > minimum[2]) {\n                return false;\n              }\n\n              return null;\n            }\n\n            var checkText = function () {\n              var minimumVersion = [4, 4, 14];\n\n              function updateTextLayer(textLayer) {\n                var documentData = textLayer.t.d;\n                textLayer.t.d = {\n                  k: [{\n                    s: documentData,\n                    t: 0\n                  }]\n                };\n              }\n\n              function iterateLayers(layers) {\n                var i;\n                var len = layers.length;\n\n                for (i = 0; i < len; i += 1) {\n                  if (layers[i].ty === 5) {\n                    updateTextLayer(layers[i]);\n                  }\n                }\n              }\n\n              return function (animationData) {\n                if (checkVersion(minimumVersion, animationData.v)) {\n                  iterateLayers(animationData.layers);\n\n                  if (animationData.assets) {\n                    var i;\n                    var len = animationData.assets.length;\n\n                    for (i = 0; i < len; i += 1) {\n                      if (animationData.assets[i].layers) {\n                        iterateLayers(animationData.assets[i].layers);\n                      }\n                    }\n                  }\n                }\n              };\n            }();\n\n            var checkChars = function () {\n              var minimumVersion = [4, 7, 99];\n              return function (animationData) {\n                if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {\n                  var i;\n                  var len = animationData.chars.length;\n\n                  for (i = 0; i < len; i += 1) {\n                    var charData = animationData.chars[i];\n\n                    if (charData.data && charData.data.shapes) {\n                      completeShapes(charData.data.shapes);\n                      charData.data.ip = 0;\n                      charData.data.op = 99999;\n                      charData.data.st = 0;\n                      charData.data.sr = 1;\n                      charData.data.ks = {\n                        p: {\n                          k: [0, 0],\n                          a: 0\n                        },\n                        s: {\n                          k: [100, 100],\n                          a: 0\n                        },\n                        a: {\n                          k: [0, 0],\n                          a: 0\n                        },\n                        r: {\n                          k: 0,\n                          a: 0\n                        },\n                        o: {\n                          k: 100,\n                          a: 0\n                        }\n                      };\n\n                      if (!animationData.chars[i].t) {\n                        charData.data.shapes.push({\n                          ty: 'no'\n                        });\n                        charData.data.shapes[0].it.push({\n                          p: {\n                            k: [0, 0],\n                            a: 0\n                          },\n                          s: {\n                            k: [100, 100],\n                            a: 0\n                          },\n                          a: {\n                            k: [0, 0],\n                            a: 0\n                          },\n                          r: {\n                            k: 0,\n                            a: 0\n                          },\n                          o: {\n                            k: 100,\n                            a: 0\n                          },\n                          sk: {\n                            k: 0,\n                            a: 0\n                          },\n                          sa: {\n                            k: 0,\n                            a: 0\n                          },\n                          ty: 'tr'\n                        });\n                      }\n                    }\n                  }\n                }\n              };\n            }();\n\n            var checkPathProperties = function () {\n              var minimumVersion = [5, 7, 15];\n\n              function updateTextLayer(textLayer) {\n                var pathData = textLayer.t.p;\n\n                if (typeof pathData.a === 'number') {\n                  pathData.a = {\n                    a: 0,\n                    k: pathData.a\n                  };\n                }\n\n                if (typeof pathData.p === 'number') {\n                  pathData.p = {\n                    a: 0,\n                    k: pathData.p\n                  };\n                }\n\n                if (typeof pathData.r === 'number') {\n                  pathData.r = {\n                    a: 0,\n                    k: pathData.r\n                  };\n                }\n              }\n\n              function iterateLayers(layers) {\n                var i;\n                var len = layers.length;\n\n                for (i = 0; i < len; i += 1) {\n                  if (layers[i].ty === 5) {\n                    updateTextLayer(layers[i]);\n                  }\n                }\n              }\n\n              return function (animationData) {\n                if (checkVersion(minimumVersion, animationData.v)) {\n                  iterateLayers(animationData.layers);\n\n                  if (animationData.assets) {\n                    var i;\n                    var len = animationData.assets.length;\n\n                    for (i = 0; i < len; i += 1) {\n                      if (animationData.assets[i].layers) {\n                        iterateLayers(animationData.assets[i].layers);\n                      }\n                    }\n                  }\n                }\n              };\n            }();\n\n            var checkColors = function () {\n              var minimumVersion = [4, 1, 9];\n\n              function iterateShapes(shapes) {\n                var i;\n                var len = shapes.length;\n                var j;\n                var jLen;\n\n                for (i = 0; i < len; i += 1) {\n                  if (shapes[i].ty === 'gr') {\n                    iterateShapes(shapes[i].it);\n                  } else if (shapes[i].ty === 'fl' || shapes[i].ty === 'st') {\n                    if (shapes[i].c.k && shapes[i].c.k[0].i) {\n                      jLen = shapes[i].c.k.length;\n\n                      for (j = 0; j < jLen; j += 1) {\n                        if (shapes[i].c.k[j].s) {\n                          shapes[i].c.k[j].s[0] /= 255;\n                          shapes[i].c.k[j].s[1] /= 255;\n                          shapes[i].c.k[j].s[2] /= 255;\n                          shapes[i].c.k[j].s[3] /= 255;\n                        }\n\n                        if (shapes[i].c.k[j].e) {\n                          shapes[i].c.k[j].e[0] /= 255;\n                          shapes[i].c.k[j].e[1] /= 255;\n                          shapes[i].c.k[j].e[2] /= 255;\n                          shapes[i].c.k[j].e[3] /= 255;\n                        }\n                      }\n                    } else {\n                      shapes[i].c.k[0] /= 255;\n                      shapes[i].c.k[1] /= 255;\n                      shapes[i].c.k[2] /= 255;\n                      shapes[i].c.k[3] /= 255;\n                    }\n                  }\n                }\n              }\n\n              function iterateLayers(layers) {\n                var i;\n                var len = layers.length;\n\n                for (i = 0; i < len; i += 1) {\n                  if (layers[i].ty === 4) {\n                    iterateShapes(layers[i].shapes);\n                  }\n                }\n              }\n\n              return function (animationData) {\n                if (checkVersion(minimumVersion, animationData.v)) {\n                  iterateLayers(animationData.layers);\n\n                  if (animationData.assets) {\n                    var i;\n                    var len = animationData.assets.length;\n\n                    for (i = 0; i < len; i += 1) {\n                      if (animationData.assets[i].layers) {\n                        iterateLayers(animationData.assets[i].layers);\n                      }\n                    }\n                  }\n                }\n              };\n            }();\n\n            var checkShapes = function () {\n              var minimumVersion = [4, 4, 18];\n\n              function completeClosingShapes(arr) {\n                var i;\n                var len = arr.length;\n                var j;\n                var jLen;\n\n                for (i = len - 1; i >= 0; i -= 1) {\n                  if (arr[i].ty === 'sh') {\n                    if (arr[i].ks.k.i) {\n                      arr[i].ks.k.c = arr[i].closed;\n                    } else {\n                      jLen = arr[i].ks.k.length;\n\n                      for (j = 0; j < jLen; j += 1) {\n                        if (arr[i].ks.k[j].s) {\n                          arr[i].ks.k[j].s[0].c = arr[i].closed;\n                        }\n\n                        if (arr[i].ks.k[j].e) {\n                          arr[i].ks.k[j].e[0].c = arr[i].closed;\n                        }\n                      }\n                    }\n                  } else if (arr[i].ty === 'gr') {\n                    completeClosingShapes(arr[i].it);\n                  }\n                }\n              }\n\n              function iterateLayers(layers) {\n                var layerData;\n                var i;\n                var len = layers.length;\n                var j;\n                var jLen;\n                var k;\n                var kLen;\n\n                for (i = 0; i < len; i += 1) {\n                  layerData = layers[i];\n\n                  if (layerData.hasMask) {\n                    var maskProps = layerData.masksProperties;\n                    jLen = maskProps.length;\n\n                    for (j = 0; j < jLen; j += 1) {\n                      if (maskProps[j].pt.k.i) {\n                        maskProps[j].pt.k.c = maskProps[j].cl;\n                      } else {\n                        kLen = maskProps[j].pt.k.length;\n\n                        for (k = 0; k < kLen; k += 1) {\n                          if (maskProps[j].pt.k[k].s) {\n                            maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;\n                          }\n\n                          if (maskProps[j].pt.k[k].e) {\n                            maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;\n                          }\n                        }\n                      }\n                    }\n                  }\n\n                  if (layerData.ty === 4) {\n                    completeClosingShapes(layerData.shapes);\n                  }\n                }\n              }\n\n              return function (animationData) {\n                if (checkVersion(minimumVersion, animationData.v)) {\n                  iterateLayers(animationData.layers);\n\n                  if (animationData.assets) {\n                    var i;\n                    var len = animationData.assets.length;\n\n                    for (i = 0; i < len; i += 1) {\n                      if (animationData.assets[i].layers) {\n                        iterateLayers(animationData.assets[i].layers);\n                      }\n                    }\n                  }\n                }\n              };\n            }();\n\n            function completeData(animationData) {\n              if (animationData.__complete) {\n                return;\n              }\n\n              checkColors(animationData);\n              checkText(animationData);\n              checkChars(animationData);\n              checkPathProperties(animationData);\n              checkShapes(animationData);\n              completeLayers(animationData.layers, animationData.assets);\n              completeChars(animationData.chars, animationData.assets);\n              animationData.__complete = true;\n            }\n\n            function completeText(data) {\n              if (data.t.a.length === 0 && !('m' in data.t.p)) {// data.singleShape = true;\n              }\n            }\n\n            var moduleOb = {};\n            moduleOb.completeData = completeData;\n            moduleOb.checkColors = checkColors;\n            moduleOb.checkChars = checkChars;\n            moduleOb.checkPathProperties = checkPathProperties;\n            moduleOb.checkShapes = checkShapes;\n            moduleOb.completeLayers = completeLayers;\n            return moduleOb;\n          }\n\n          if (!_workerSelf.dataManager) {\n            _workerSelf.dataManager = dataFunctionManager();\n          }\n\n          if (!_workerSelf.assetLoader) {\n            _workerSelf.assetLoader = function () {\n              function formatResponse(xhr) {\n                // using typeof doubles the time of execution of this method,\n                // so if available, it's better to use the header to validate the type\n                var contentTypeHeader = xhr.getResponseHeader('content-type');\n\n                if (contentTypeHeader && xhr.responseType === 'json' && contentTypeHeader.indexOf('json') !== -1) {\n                  return xhr.response;\n                }\n\n                if (xhr.response && _typeof$5(xhr.response) === 'object') {\n                  return xhr.response;\n                }\n\n                if (xhr.response && typeof xhr.response === 'string') {\n                  return JSON.parse(xhr.response);\n                }\n\n                if (xhr.responseText) {\n                  return JSON.parse(xhr.responseText);\n                }\n\n                return null;\n              }\n\n              function loadAsset(path, fullPath, callback, errorCallback) {\n                var response;\n                var xhr = new XMLHttpRequest(); // set responseType after calling open or IE will break.\n\n                try {\n                  // This crashes on Android WebView prior to KitKat\n                  xhr.responseType = 'json';\n                } catch (err) {} // eslint-disable-line no-empty\n\n\n                xhr.onreadystatechange = function () {\n                  if (xhr.readyState === 4) {\n                    if (xhr.status === 200) {\n                      response = formatResponse(xhr);\n                      callback(response);\n                    } else {\n                      try {\n                        response = formatResponse(xhr);\n                        callback(response);\n                      } catch (err) {\n                        if (errorCallback) {\n                          errorCallback(err);\n                        }\n                      }\n                    }\n                  }\n                };\n\n                try {\n                  // Hack to workaround banner validation\n                  xhr.open(['G', 'E', 'T'].join(''), path, true);\n                } catch (error) {\n                  // Hack to workaround banner validation\n                  xhr.open(['G', 'E', 'T'].join(''), fullPath + '/' + path, true);\n                }\n\n                xhr.send();\n              }\n\n              return {\n                load: loadAsset\n              };\n            }();\n          }\n\n          if (e.data.type === 'loadAnimation') {\n            _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function (data) {\n              _workerSelf.dataManager.completeData(data);\n\n              _workerSelf.postMessage({\n                id: e.data.id,\n                payload: data,\n                status: 'success'\n              });\n            }, function () {\n              _workerSelf.postMessage({\n                id: e.data.id,\n                status: 'error'\n              });\n            });\n          } else if (e.data.type === 'complete') {\n            var animation = e.data.animation;\n\n            _workerSelf.dataManager.completeData(animation);\n\n            _workerSelf.postMessage({\n              id: e.data.id,\n              payload: animation,\n              status: 'success'\n            });\n          } else if (e.data.type === 'loadData') {\n            _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function (data) {\n              _workerSelf.postMessage({\n                id: e.data.id,\n                payload: data,\n                status: 'success'\n              });\n            }, function () {\n              _workerSelf.postMessage({\n                id: e.data.id,\n                status: 'error'\n              });\n            });\n          }\n        });\n\n        workerInstance.onmessage = function (event) {\n          var data = event.data;\n          var id = data.id;\n          var process = processes[id];\n          processes[id] = null;\n\n          if (data.status === 'success') {\n            process.onComplete(data.payload);\n          } else if (process.onError) {\n            process.onError();\n          }\n        };\n      }\n    }\n\n    function createProcess(onComplete, onError) {\n      _counterId += 1;\n      var id = 'processId_' + _counterId;\n      processes[id] = {\n        onComplete: onComplete,\n        onError: onError\n      };\n      return id;\n    }\n\n    function loadAnimation(path, onComplete, onError) {\n      setupWorker();\n      var processId = createProcess(onComplete, onError);\n      workerInstance.postMessage({\n        type: 'loadAnimation',\n        path: path,\n        fullPath: window.location.origin + window.location.pathname,\n        id: processId\n      });\n    }\n\n    function loadData(path, onComplete, onError) {\n      setupWorker();\n      var processId = createProcess(onComplete, onError);\n      workerInstance.postMessage({\n        type: 'loadData',\n        path: path,\n        fullPath: window.location.origin + window.location.pathname,\n        id: processId\n      });\n    }\n\n    function completeAnimation(anim, onComplete, onError) {\n      setupWorker();\n      var processId = createProcess(onComplete, onError);\n      workerInstance.postMessage({\n        type: 'complete',\n        animation: anim,\n        id: processId\n      });\n    }\n\n    return {\n      loadAnimation: loadAnimation,\n      loadData: loadData,\n      completeAnimation: completeAnimation\n    };\n  }();\n\n  var ImagePreloader = function () {\n    var proxyImage = function () {\n      var canvas = createTag('canvas');\n      canvas.width = 1;\n      canvas.height = 1;\n      var ctx = canvas.getContext('2d');\n      ctx.fillStyle = 'rgba(0,0,0,0)';\n      ctx.fillRect(0, 0, 1, 1);\n      return canvas;\n    }();\n\n    function imageLoaded() {\n      this.loadedAssets += 1;\n\n      if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {\n        if (this.imagesLoadedCb) {\n          this.imagesLoadedCb(null);\n        }\n      }\n    }\n\n    function footageLoaded() {\n      this.loadedFootagesCount += 1;\n\n      if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {\n        if (this.imagesLoadedCb) {\n          this.imagesLoadedCb(null);\n        }\n      }\n    }\n\n    function getAssetsPath(assetData, assetsPath, originalPath) {\n      var path = '';\n\n      if (assetData.e) {\n        path = assetData.p;\n      } else if (assetsPath) {\n        var imagePath = assetData.p;\n\n        if (imagePath.indexOf('images/') !== -1) {\n          imagePath = imagePath.split('/')[1];\n        }\n\n        path = assetsPath + imagePath;\n      } else {\n        path = originalPath;\n        path += assetData.u ? assetData.u : '';\n        path += assetData.p;\n      }\n\n      return path;\n    }\n\n    function testImageLoaded(img) {\n      var _count = 0;\n      var intervalId = setInterval(function () {\n        var box = img.getBBox();\n\n        if (box.width || _count > 500) {\n          this._imageLoaded();\n\n          clearInterval(intervalId);\n        }\n\n        _count += 1;\n      }.bind(this), 50);\n    }\n\n    function createImageData(assetData) {\n      var path = getAssetsPath(assetData, this.assetsPath, this.path);\n      var img = createNS('image');\n\n      if (isSafari) {\n        this.testImageLoaded(img);\n      } else {\n        img.addEventListener('load', this._imageLoaded, false);\n      }\n\n      img.addEventListener('error', function () {\n        ob.img = proxyImage;\n\n        this._imageLoaded();\n      }.bind(this), false);\n      img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path);\n\n      if (this._elementHelper.append) {\n        this._elementHelper.append(img);\n      } else {\n        this._elementHelper.appendChild(img);\n      }\n\n      var ob = {\n        img: img,\n        assetData: assetData\n      };\n      return ob;\n    }\n\n    function createImgData(assetData) {\n      var path = getAssetsPath(assetData, this.assetsPath, this.path);\n      var img = createTag('img');\n      img.crossOrigin = 'anonymous';\n      img.addEventListener('load', this._imageLoaded, false);\n      img.addEventListener('error', function () {\n        ob.img = proxyImage;\n\n        this._imageLoaded();\n      }.bind(this), false);\n      img.src = path;\n      var ob = {\n        img: img,\n        assetData: assetData\n      };\n      return ob;\n    }\n\n    function createFootageData(data) {\n      var ob = {\n        assetData: data\n      };\n      var path = getAssetsPath(data, this.assetsPath, this.path);\n      dataManager.loadData(path, function (footageData) {\n        ob.img = footageData;\n\n        this._footageLoaded();\n      }.bind(this), function () {\n        ob.img = {};\n\n        this._footageLoaded();\n      }.bind(this));\n      return ob;\n    }\n\n    function loadAssets(assets, cb) {\n      this.imagesLoadedCb = cb;\n      var i;\n      var len = assets.length;\n\n      for (i = 0; i < len; i += 1) {\n        if (!assets[i].layers) {\n          if (!assets[i].t || assets[i].t === 'seq') {\n            this.totalImages += 1;\n            this.images.push(this._createImageData(assets[i]));\n          } else if (assets[i].t === 3) {\n            this.totalFootages += 1;\n            this.images.push(this.createFootageData(assets[i]));\n          }\n        }\n      }\n    }\n\n    function setPath(path) {\n      this.path = path || '';\n    }\n\n    function setAssetsPath(path) {\n      this.assetsPath = path || '';\n    }\n\n    function getAsset(assetData) {\n      var i = 0;\n      var len = this.images.length;\n\n      while (i < len) {\n        if (this.images[i].assetData === assetData) {\n          return this.images[i].img;\n        }\n\n        i += 1;\n      }\n\n      return null;\n    }\n\n    function destroy() {\n      this.imagesLoadedCb = null;\n      this.images.length = 0;\n    }\n\n    function loadedImages() {\n      return this.totalImages === this.loadedAssets;\n    }\n\n    function loadedFootages() {\n      return this.totalFootages === this.loadedFootagesCount;\n    }\n\n    function setCacheType(type, elementHelper) {\n      if (type === 'svg') {\n        this._elementHelper = elementHelper;\n        this._createImageData = this.createImageData.bind(this);\n      } else {\n        this._createImageData = this.createImgData.bind(this);\n      }\n    }\n\n    function ImagePreloaderFactory() {\n      this._imageLoaded = imageLoaded.bind(this);\n      this._footageLoaded = footageLoaded.bind(this);\n      this.testImageLoaded = testImageLoaded.bind(this);\n      this.createFootageData = createFootageData.bind(this);\n      this.assetsPath = '';\n      this.path = '';\n      this.totalImages = 0;\n      this.totalFootages = 0;\n      this.loadedAssets = 0;\n      this.loadedFootagesCount = 0;\n      this.imagesLoadedCb = null;\n      this.images = [];\n    }\n\n    ImagePreloaderFactory.prototype = {\n      loadAssets: loadAssets,\n      setAssetsPath: setAssetsPath,\n      setPath: setPath,\n      loadedImages: loadedImages,\n      loadedFootages: loadedFootages,\n      destroy: destroy,\n      getAsset: getAsset,\n      createImgData: createImgData,\n      createImageData: createImageData,\n      imageLoaded: imageLoaded,\n      footageLoaded: footageLoaded,\n      setCacheType: setCacheType\n    };\n    return ImagePreloaderFactory;\n  }();\n\n  function BaseEvent() {}\n\n  BaseEvent.prototype = {\n    triggerEvent: function triggerEvent(eventName, args) {\n      if (this._cbs[eventName]) {\n        var callbacks = this._cbs[eventName];\n\n        for (var i = 0; i < callbacks.length; i += 1) {\n          callbacks[i](args);\n        }\n      }\n    },\n    addEventListener: function addEventListener(eventName, callback) {\n      if (!this._cbs[eventName]) {\n        this._cbs[eventName] = [];\n      }\n\n      this._cbs[eventName].push(callback);\n\n      return function () {\n        this.removeEventListener(eventName, callback);\n      }.bind(this);\n    },\n    removeEventListener: function removeEventListener(eventName, callback) {\n      if (!callback) {\n        this._cbs[eventName] = null;\n      } else if (this._cbs[eventName]) {\n        var i = 0;\n        var len = this._cbs[eventName].length;\n\n        while (i < len) {\n          if (this._cbs[eventName][i] === callback) {\n            this._cbs[eventName].splice(i, 1);\n\n            i -= 1;\n            len -= 1;\n          }\n\n          i += 1;\n        }\n\n        if (!this._cbs[eventName].length) {\n          this._cbs[eventName] = null;\n        }\n      }\n    }\n  };\n\n  var markerParser = function () {\n    function parsePayloadLines(payload) {\n      var lines = payload.split('\\r\\n');\n      var keys = {};\n      var line;\n      var keysCount = 0;\n\n      for (var i = 0; i < lines.length; i += 1) {\n        line = lines[i].split(':');\n\n        if (line.length === 2) {\n          keys[line[0]] = line[1].trim();\n          keysCount += 1;\n        }\n      }\n\n      if (keysCount === 0) {\n        throw new Error();\n      }\n\n      return keys;\n    }\n\n    return function (_markers) {\n      var markers = [];\n\n      for (var i = 0; i < _markers.length; i += 1) {\n        var _marker = _markers[i];\n        var markerData = {\n          time: _marker.tm,\n          duration: _marker.dr\n        };\n\n        try {\n          markerData.payload = JSON.parse(_markers[i].cm);\n        } catch (_) {\n          try {\n            markerData.payload = parsePayloadLines(_markers[i].cm);\n          } catch (__) {\n            markerData.payload = {\n              name: _markers[i].cm\n            };\n          }\n        }\n\n        markers.push(markerData);\n      }\n\n      return markers;\n    };\n  }();\n\n  var ProjectInterface = function () {\n    function registerComposition(comp) {\n      this.compositions.push(comp);\n    }\n\n    return function () {\n      function _thisProjectFunction(name) {\n        var i = 0;\n        var len = this.compositions.length;\n\n        while (i < len) {\n          if (this.compositions[i].data && this.compositions[i].data.nm === name) {\n            if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) {\n              this.compositions[i].prepareFrame(this.currentFrame);\n            }\n\n            return this.compositions[i].compInterface;\n          }\n\n          i += 1;\n        }\n\n        return null;\n      }\n\n      _thisProjectFunction.compositions = [];\n      _thisProjectFunction.currentFrame = 0;\n      _thisProjectFunction.registerComposition = registerComposition;\n      return _thisProjectFunction;\n    };\n  }();\n\n  var renderers = {};\n\n  var registerRenderer = function registerRenderer(key, value) {\n    renderers[key] = value;\n  };\n\n  function getRenderer(key) {\n    return renderers[key];\n  }\n\n  function getRegisteredRenderer() {\n    // Returns canvas by default for compatibility\n    if (renderers.canvas) {\n      return 'canvas';\n    } // Returns any renderer that is registered\n\n\n    for (var key in renderers) {\n      if (renderers[key]) {\n        return key;\n      }\n    }\n\n    return '';\n  }\n\n  function _typeof$4(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof$4 = function _typeof(obj) { return typeof obj; }; } else { _typeof$4 = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof$4(obj); }\n\n  var AnimationItem = function AnimationItem() {\n    this._cbs = [];\n    this.name = '';\n    this.path = '';\n    this.isLoaded = false;\n    this.currentFrame = 0;\n    this.currentRawFrame = 0;\n    this.firstFrame = 0;\n    this.totalFrames = 0;\n    this.frameRate = 0;\n    this.frameMult = 0;\n    this.playSpeed = 1;\n    this.playDirection = 1;\n    this.playCount = 0;\n    this.animationData = {};\n    this.assets = [];\n    this.isPaused = true;\n    this.autoplay = false;\n    this.loop = true;\n    this.renderer = null;\n    this.animationID = createElementID();\n    this.assetsPath = '';\n    this.timeCompleted = 0;\n    this.segmentPos = 0;\n    this.isSubframeEnabled = getSubframeEnabled();\n    this.segments = [];\n    this._idle = true;\n    this._completedLoop = false;\n    this.projectInterface = ProjectInterface();\n    this.imagePreloader = new ImagePreloader();\n    this.audioController = audioControllerFactory();\n    this.markers = [];\n    this.configAnimation = this.configAnimation.bind(this);\n    this.onSetupError = this.onSetupError.bind(this);\n    this.onSegmentComplete = this.onSegmentComplete.bind(this);\n    this.drawnFrameEvent = new BMEnterFrameEvent('drawnFrame', 0, 0, 0);\n    this.expressionsPlugin = getExpressionsPlugin();\n  };\n\n  extendPrototype([BaseEvent], AnimationItem);\n\n  AnimationItem.prototype.setParams = function (params) {\n    if (params.wrapper || params.container) {\n      this.wrapper = params.wrapper || params.container;\n    }\n\n    var animType = 'svg';\n\n    if (params.animType) {\n      animType = params.animType;\n    } else if (params.renderer) {\n      animType = params.renderer;\n    }\n\n    var RendererClass = getRenderer(animType);\n    this.renderer = new RendererClass(this, params.rendererSettings);\n    this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);\n    this.renderer.setProjectInterface(this.projectInterface);\n    this.animType = animType;\n\n    if (params.loop === '' || params.loop === null || params.loop === undefined || params.loop === true) {\n      this.loop = true;\n    } else if (params.loop === false) {\n      this.loop = false;\n    } else {\n      this.loop = parseInt(params.loop, 10);\n    }\n\n    this.autoplay = 'autoplay' in params ? params.autoplay : true;\n    this.name = params.name ? params.name : '';\n    this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, 'autoloadSegments') ? params.autoloadSegments : true;\n    this.assetsPath = params.assetsPath;\n    this.initialSegment = params.initialSegment;\n\n    if (params.audioFactory) {\n      this.audioController.setAudioFactory(params.audioFactory);\n    }\n\n    if (params.animationData) {\n      this.setupAnimation(params.animationData);\n    } else if (params.path) {\n      if (params.path.lastIndexOf('\\\\') !== -1) {\n        this.path = params.path.substr(0, params.path.lastIndexOf('\\\\') + 1);\n      } else {\n        this.path = params.path.substr(0, params.path.lastIndexOf('/') + 1);\n      }\n\n      this.fileName = params.path.substr(params.path.lastIndexOf('/') + 1);\n      this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf('.json'));\n      dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);\n    }\n  };\n\n  AnimationItem.prototype.onSetupError = function () {\n    this.trigger('data_failed');\n  };\n\n  AnimationItem.prototype.setupAnimation = function (data) {\n    dataManager.completeAnimation(data, this.configAnimation);\n  };\n\n  AnimationItem.prototype.setData = function (wrapper, animationData) {\n    if (animationData) {\n      if (_typeof$4(animationData) !== 'object') {\n        animationData = JSON.parse(animationData);\n      }\n    }\n\n    var params = {\n      wrapper: wrapper,\n      animationData: animationData\n    };\n    var wrapperAttributes = wrapper.attributes;\n    params.path = wrapperAttributes.getNamedItem('data-animation-path') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-animation-path').value : wrapperAttributes.getNamedItem('data-bm-path') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-bm-path').value : wrapperAttributes.getNamedItem('bm-path') ? wrapperAttributes.getNamedItem('bm-path').value : '';\n    params.animType = wrapperAttributes.getNamedItem('data-anim-type') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-anim-type').value : wrapperAttributes.getNamedItem('data-bm-type') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-bm-type').value : wrapperAttributes.getNamedItem('bm-type') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('bm-type').value : wrapperAttributes.getNamedItem('data-bm-renderer') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-bm-renderer').value : wrapperAttributes.getNamedItem('bm-renderer') ? wrapperAttributes.getNamedItem('bm-renderer').value : getRegisteredRenderer() || 'canvas';\n    var loop = wrapperAttributes.getNamedItem('data-anim-loop') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-anim-loop').value : wrapperAttributes.getNamedItem('data-bm-loop') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-bm-loop').value : wrapperAttributes.getNamedItem('bm-loop') ? wrapperAttributes.getNamedItem('bm-loop').value : '';\n\n    if (loop === 'false') {\n      params.loop = false;\n    } else if (loop === 'true') {\n      params.loop = true;\n    } else if (loop !== '') {\n      params.loop = parseInt(loop, 10);\n    }\n\n    var autoplay = wrapperAttributes.getNamedItem('data-anim-autoplay') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-anim-autoplay').value : wrapperAttributes.getNamedItem('data-bm-autoplay') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-bm-autoplay').value : wrapperAttributes.getNamedItem('bm-autoplay') ? wrapperAttributes.getNamedItem('bm-autoplay').value : true;\n    params.autoplay = autoplay !== 'false';\n    params.name = wrapperAttributes.getNamedItem('data-name') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-name').value : wrapperAttributes.getNamedItem('data-bm-name') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-bm-name').value : wrapperAttributes.getNamedItem('bm-name') ? wrapperAttributes.getNamedItem('bm-name').value : '';\n    var prerender = wrapperAttributes.getNamedItem('data-anim-prerender') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-anim-prerender').value : wrapperAttributes.getNamedItem('data-bm-prerender') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-bm-prerender').value : wrapperAttributes.getNamedItem('bm-prerender') ? wrapperAttributes.getNamedItem('bm-prerender').value : '';\n\n    if (prerender === 'false') {\n      params.prerender = false;\n    }\n\n    if (!params.path) {\n      this.trigger('destroy');\n    } else {\n      this.setParams(params);\n    }\n  };\n\n  AnimationItem.prototype.includeLayers = function (data) {\n    if (data.op > this.animationData.op) {\n      this.animationData.op = data.op;\n      this.totalFrames = Math.floor(data.op - this.animationData.ip);\n    }\n\n    var layers = this.animationData.layers;\n    var i;\n    var len = layers.length;\n    var newLayers = data.layers;\n    var j;\n    var jLen = newLayers.length;\n\n    for (j = 0; j < jLen; j += 1) {\n      i = 0;\n\n      while (i < len) {\n        if (layers[i].id === newLayers[j].id) {\n          layers[i] = newLayers[j];\n          break;\n        }\n\n        i += 1;\n      }\n    }\n\n    if (data.chars || data.fonts) {\n      this.renderer.globalData.fontManager.addChars(data.chars);\n      this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);\n    }\n\n    if (data.assets) {\n      len = data.assets.length;\n\n      for (i = 0; i < len; i += 1) {\n        this.animationData.assets.push(data.assets[i]);\n      }\n    }\n\n    this.animationData.__complete = false;\n    dataManager.completeAnimation(this.animationData, this.onSegmentComplete);\n  };\n\n  AnimationItem.prototype.onSegmentComplete = function (data) {\n    this.animationData = data;\n    var expressionsPlugin = getExpressionsPlugin();\n\n    if (expressionsPlugin) {\n      expressionsPlugin.initExpressions(this);\n    }\n\n    this.loadNextSegment();\n  };\n\n  AnimationItem.prototype.loadNextSegment = function () {\n    var segments = this.animationData.segments;\n\n    if (!segments || segments.length === 0 || !this.autoloadSegments) {\n      this.trigger('data_ready');\n      this.timeCompleted = this.totalFrames;\n      return;\n    }\n\n    var segment = segments.shift();\n    this.timeCompleted = segment.time * this.frameRate;\n    var segmentPath = this.path + this.fileName + '_' + this.segmentPos + '.json';\n    this.segmentPos += 1;\n    dataManager.loadData(segmentPath, this.includeLayers.bind(this), function () {\n      this.trigger('data_failed');\n    }.bind(this));\n  };\n\n  AnimationItem.prototype.loadSegments = function () {\n    var segments = this.animationData.segments;\n\n    if (!segments) {\n      this.timeCompleted = this.totalFrames;\n    }\n\n    this.loadNextSegment();\n  };\n\n  AnimationItem.prototype.imagesLoaded = function () {\n    this.trigger('loaded_images');\n    this.checkLoaded();\n  };\n\n  AnimationItem.prototype.preloadImages = function () {\n    this.imagePreloader.setAssetsPath(this.assetsPath);\n    this.imagePreloader.setPath(this.path);\n    this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));\n  };\n\n  AnimationItem.prototype.configAnimation = function (animData) {\n    if (!this.renderer) {\n      return;\n    }\n\n    try {\n      this.animationData = animData;\n\n      if (this.initialSegment) {\n        this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);\n        this.firstFrame = Math.round(this.initialSegment[0]);\n      } else {\n        this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);\n        this.firstFrame = Math.round(this.animationData.ip);\n      }\n\n      this.renderer.configAnimation(animData);\n\n      if (!animData.assets) {\n        animData.assets = [];\n      }\n\n      this.assets = this.animationData.assets;\n      this.frameRate = this.animationData.fr;\n      this.frameMult = this.animationData.fr / 1000;\n      this.renderer.searchExtraCompositions(animData.assets);\n      this.markers = markerParser(animData.markers || []);\n      this.trigger('config_ready');\n      this.preloadImages();\n      this.loadSegments();\n      this.updaFrameModifier();\n      this.waitForFontsLoaded();\n\n      if (this.isPaused) {\n        this.audioController.pause();\n      }\n    } catch (error) {\n      this.triggerConfigError(error);\n    }\n  };\n\n  AnimationItem.prototype.waitForFontsLoaded = function () {\n    if (!this.renderer) {\n      return;\n    }\n\n    if (this.renderer.globalData.fontManager.isLoaded) {\n      this.checkLoaded();\n    } else {\n      setTimeout(this.waitForFontsLoaded.bind(this), 20);\n    }\n  };\n\n  AnimationItem.prototype.checkLoaded = function () {\n    if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== 'canvas') && this.imagePreloader.loadedFootages()) {\n      this.isLoaded = true;\n      var expressionsPlugin = getExpressionsPlugin();\n\n      if (expressionsPlugin) {\n        expressionsPlugin.initExpressions(this);\n      }\n\n      this.renderer.initItems();\n      setTimeout(function () {\n        this.trigger('DOMLoaded');\n      }.bind(this), 0);\n      this.gotoFrame();\n\n      if (this.autoplay) {\n        this.play();\n      }\n    }\n  };\n\n  AnimationItem.prototype.resize = function (width, height) {\n    // Adding this validation for backwards compatibility in case an event object was being passed down\n    var _width = typeof width === 'number' ? width : undefined;\n\n    var _height = typeof height === 'number' ? height : undefined;\n\n    this.renderer.updateContainerSize(_width, _height);\n  };\n\n  AnimationItem.prototype.setSubframe = function (flag) {\n    this.isSubframeEnabled = !!flag;\n  };\n\n  AnimationItem.prototype.gotoFrame = function () {\n    this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame; // eslint-disable-line no-bitwise\n\n    if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {\n      this.currentFrame = this.timeCompleted;\n    }\n\n    this.trigger('enterFrame');\n    this.renderFrame();\n    this.trigger('drawnFrame');\n  };\n\n  AnimationItem.prototype.renderFrame = function () {\n    if (this.isLoaded === false || !this.renderer) {\n      return;\n    }\n\n    try {\n      if (this.expressionsPlugin) {\n        this.expressionsPlugin.resetFrame();\n      }\n\n      this.renderer.renderFrame(this.currentFrame + this.firstFrame);\n    } catch (error) {\n      this.triggerRenderFrameError(error);\n    }\n  };\n\n  AnimationItem.prototype.play = function (name) {\n    if (name && this.name !== name) {\n      return;\n    }\n\n    if (this.isPaused === true) {\n      this.isPaused = false;\n      this.trigger('_play');\n      this.audioController.resume();\n\n      if (this._idle) {\n        this._idle = false;\n        this.trigger('_active');\n      }\n    }\n  };\n\n  AnimationItem.prototype.pause = function (name) {\n    if (name && this.name !== name) {\n      return;\n    }\n\n    if (this.isPaused === false) {\n      this.isPaused = true;\n      this.trigger('_pause');\n      this._idle = true;\n      this.trigger('_idle');\n      this.audioController.pause();\n    }\n  };\n\n  AnimationItem.prototype.togglePause = function (name) {\n    if (name && this.name !== name) {\n      return;\n    }\n\n    if (this.isPaused === true) {\n      this.play();\n    } else {\n      this.pause();\n    }\n  };\n\n  AnimationItem.prototype.stop = function (name) {\n    if (name && this.name !== name) {\n      return;\n    }\n\n    this.pause();\n    this.playCount = 0;\n    this._completedLoop = false;\n    this.setCurrentRawFrameValue(0);\n  };\n\n  AnimationItem.prototype.getMarkerData = function (markerName) {\n    var marker;\n\n    for (var i = 0; i < this.markers.length; i += 1) {\n      marker = this.markers[i];\n\n      if (marker.payload && marker.payload.name === markerName) {\n        return marker;\n      }\n    }\n\n    return null;\n  };\n\n  AnimationItem.prototype.goToAndStop = function (value, isFrame, name) {\n    if (name && this.name !== name) {\n      return;\n    }\n\n    var numValue = Number(value);\n\n    if (isNaN(numValue)) {\n      var marker = this.getMarkerData(value);\n\n      if (marker) {\n        this.goToAndStop(marker.time, true);\n      }\n    } else if (isFrame) {\n      this.setCurrentRawFrameValue(value);\n    } else {\n      this.setCurrentRawFrameValue(value * this.frameModifier);\n    }\n\n    this.pause();\n  };\n\n  AnimationItem.prototype.goToAndPlay = function (value, isFrame, name) {\n    if (name && this.name !== name) {\n      return;\n    }\n\n    var numValue = Number(value);\n\n    if (isNaN(numValue)) {\n      var marker = this.getMarkerData(value);\n\n      if (marker) {\n        if (!marker.duration) {\n          this.goToAndStop(marker.time, true);\n        } else {\n          this.playSegments([marker.time, marker.time + marker.duration], true);\n        }\n      }\n    } else {\n      this.goToAndStop(numValue, isFrame, name);\n    }\n\n    this.play();\n  };\n\n  AnimationItem.prototype.advanceTime = function (value) {\n    if (this.isPaused === true || this.isLoaded === false) {\n      return;\n    }\n\n    var nextValue = this.currentRawFrame + value * this.frameModifier;\n    var _isComplete = false; // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.\n    // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.\n\n    if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {\n      if (!this.loop || this.playCount === this.loop) {\n        if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {\n          _isComplete = true;\n          nextValue = this.totalFrames - 1;\n        }\n      } else if (nextValue >= this.totalFrames) {\n        this.playCount += 1;\n\n        if (!this.checkSegments(nextValue % this.totalFrames)) {\n          this.setCurrentRawFrameValue(nextValue % this.totalFrames);\n          this._completedLoop = true;\n          this.trigger('loopComplete');\n        }\n      } else {\n        this.setCurrentRawFrameValue(nextValue);\n      }\n    } else if (nextValue < 0) {\n      if (!this.checkSegments(nextValue % this.totalFrames)) {\n        if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {\n          // eslint-disable-line no-plusplus\n          this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);\n\n          if (!this._completedLoop) {\n            this._completedLoop = true;\n          } else {\n            this.trigger('loopComplete');\n          }\n        } else {\n          _isComplete = true;\n          nextValue = 0;\n        }\n      }\n    } else {\n      this.setCurrentRawFrameValue(nextValue);\n    }\n\n    if (_isComplete) {\n      this.setCurrentRawFrameValue(nextValue);\n      this.pause();\n      this.trigger('complete');\n    }\n  };\n\n  AnimationItem.prototype.adjustSegment = function (arr, offset) {\n    this.playCount = 0;\n\n    if (arr[1] < arr[0]) {\n      if (this.frameModifier > 0) {\n        if (this.playSpeed < 0) {\n          this.setSpeed(-this.playSpeed);\n        } else {\n          this.setDirection(-1);\n        }\n      }\n\n      this.totalFrames = arr[0] - arr[1];\n      this.timeCompleted = this.totalFrames;\n      this.firstFrame = arr[1];\n      this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);\n    } else if (arr[1] > arr[0]) {\n      if (this.frameModifier < 0) {\n        if (this.playSpeed < 0) {\n          this.setSpeed(-this.playSpeed);\n        } else {\n          this.setDirection(1);\n        }\n      }\n\n      this.totalFrames = arr[1] - arr[0];\n      this.timeCompleted = this.totalFrames;\n      this.firstFrame = arr[0];\n      this.setCurrentRawFrameValue(0.001 + offset);\n    }\n\n    this.trigger('segmentStart');\n  };\n\n  AnimationItem.prototype.setSegment = function (init, end) {\n    var pendingFrame = -1;\n\n    if (this.isPaused) {\n      if (this.currentRawFrame + this.firstFrame < init) {\n        pendingFrame = init;\n      } else if (this.currentRawFrame + this.firstFrame > end) {\n        pendingFrame = end - init;\n      }\n    }\n\n    this.firstFrame = init;\n    this.totalFrames = end - init;\n    this.timeCompleted = this.totalFrames;\n\n    if (pendingFrame !== -1) {\n      this.goToAndStop(pendingFrame, true);\n    }\n  };\n\n  AnimationItem.prototype.playSegments = function (arr, forceFlag) {\n    if (forceFlag) {\n      this.segments.length = 0;\n    }\n\n    if (_typeof$4(arr[0]) === 'object') {\n      var i;\n      var len = arr.length;\n\n      for (i = 0; i < len; i += 1) {\n        this.segments.push(arr[i]);\n      }\n    } else {\n      this.segments.push(arr);\n    }\n\n    if (this.segments.length && forceFlag) {\n      this.adjustSegment(this.segments.shift(), 0);\n    }\n\n    if (this.isPaused) {\n      this.play();\n    }\n  };\n\n  AnimationItem.prototype.resetSegments = function (forceFlag) {\n    this.segments.length = 0;\n    this.segments.push([this.animationData.ip, this.animationData.op]);\n\n    if (forceFlag) {\n      this.checkSegments(0);\n    }\n  };\n\n  AnimationItem.prototype.checkSegments = function (offset) {\n    if (this.segments.length) {\n      this.adjustSegment(this.segments.shift(), offset);\n      return true;\n    }\n\n    return false;\n  };\n\n  AnimationItem.prototype.destroy = function (name) {\n    if (name && this.name !== name || !this.renderer) {\n      return;\n    }\n\n    this.renderer.destroy();\n    this.imagePreloader.destroy();\n    this.trigger('destroy');\n    this._cbs = null;\n    this.onEnterFrame = null;\n    this.onLoopComplete = null;\n    this.onComplete = null;\n    this.onSegmentStart = null;\n    this.onDestroy = null;\n    this.renderer = null;\n    this.expressionsPlugin = null;\n    this.imagePreloader = null;\n    this.projectInterface = null;\n  };\n\n  AnimationItem.prototype.setCurrentRawFrameValue = function (value) {\n    this.currentRawFrame = value;\n    this.gotoFrame();\n  };\n\n  AnimationItem.prototype.setSpeed = function (val) {\n    this.playSpeed = val;\n    this.updaFrameModifier();\n  };\n\n  AnimationItem.prototype.setDirection = function (val) {\n    this.playDirection = val < 0 ? -1 : 1;\n    this.updaFrameModifier();\n  };\n\n  AnimationItem.prototype.setLoop = function (isLooping) {\n    this.loop = isLooping;\n  };\n\n  AnimationItem.prototype.setVolume = function (val, name) {\n    if (name && this.name !== name) {\n      return;\n    }\n\n    this.audioController.setVolume(val);\n  };\n\n  AnimationItem.prototype.getVolume = function () {\n    return this.audioController.getVolume();\n  };\n\n  AnimationItem.prototype.mute = function (name) {\n    if (name && this.name !== name) {\n      return;\n    }\n\n    this.audioController.mute();\n  };\n\n  AnimationItem.prototype.unmute = function (name) {\n    if (name && this.name !== name) {\n      return;\n    }\n\n    this.audioController.unmute();\n  };\n\n  AnimationItem.prototype.updaFrameModifier = function () {\n    this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;\n    this.audioController.setRate(this.playSpeed * this.playDirection);\n  };\n\n  AnimationItem.prototype.getPath = function () {\n    return this.path;\n  };\n\n  AnimationItem.prototype.getAssetsPath = function (assetData) {\n    var path = '';\n\n    if (assetData.e) {\n      path = assetData.p;\n    } else if (this.assetsPath) {\n      var imagePath = assetData.p;\n\n      if (imagePath.indexOf('images/') !== -1) {\n        imagePath = imagePath.split('/')[1];\n      }\n\n      path = this.assetsPath + imagePath;\n    } else {\n      path = this.path;\n      path += assetData.u ? assetData.u : '';\n      path += assetData.p;\n    }\n\n    return path;\n  };\n\n  AnimationItem.prototype.getAssetData = function (id) {\n    var i = 0;\n    var len = this.assets.length;\n\n    while (i < len) {\n      if (id === this.assets[i].id) {\n        return this.assets[i];\n      }\n\n      i += 1;\n    }\n\n    return null;\n  };\n\n  AnimationItem.prototype.hide = function () {\n    this.renderer.hide();\n  };\n\n  AnimationItem.prototype.show = function () {\n    this.renderer.show();\n  };\n\n  AnimationItem.prototype.getDuration = function (isFrame) {\n    return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;\n  };\n\n  AnimationItem.prototype.updateDocumentData = function (path, documentData, index) {\n    try {\n      var element = this.renderer.getElementByPath(path);\n      element.updateDocumentData(documentData, index);\n    } catch (error) {// TODO: decide how to handle catch case\n    }\n  };\n\n  AnimationItem.prototype.trigger = function (name) {\n    if (this._cbs && this._cbs[name]) {\n      switch (name) {\n        case 'enterFrame':\n          this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));\n          break;\n\n        case 'drawnFrame':\n          this.drawnFrameEvent.currentTime = this.currentFrame;\n          this.drawnFrameEvent.totalTime = this.totalFrames;\n          this.drawnFrameEvent.direction = this.frameModifier;\n          this.triggerEvent(name, this.drawnFrameEvent);\n          break;\n\n        case 'loopComplete':\n          this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));\n          break;\n\n        case 'complete':\n          this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));\n          break;\n\n        case 'segmentStart':\n          this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));\n          break;\n\n        case 'destroy':\n          this.triggerEvent(name, new BMDestroyEvent(name, this));\n          break;\n\n        default:\n          this.triggerEvent(name);\n      }\n    }\n\n    if (name === 'enterFrame' && this.onEnterFrame) {\n      this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult));\n    }\n\n    if (name === 'loopComplete' && this.onLoopComplete) {\n      this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));\n    }\n\n    if (name === 'complete' && this.onComplete) {\n      this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult));\n    }\n\n    if (name === 'segmentStart' && this.onSegmentStart) {\n      this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));\n    }\n\n    if (name === 'destroy' && this.onDestroy) {\n      this.onDestroy.call(this, new BMDestroyEvent(name, this));\n    }\n  };\n\n  AnimationItem.prototype.triggerRenderFrameError = function (nativeError) {\n    var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);\n    this.triggerEvent('error', error);\n\n    if (this.onError) {\n      this.onError.call(this, error);\n    }\n  };\n\n  AnimationItem.prototype.triggerConfigError = function (nativeError) {\n    var error = new BMConfigErrorEvent(nativeError, this.currentFrame);\n    this.triggerEvent('error', error);\n\n    if (this.onError) {\n      this.onError.call(this, error);\n    }\n  };\n\n  var animationManager = function () {\n    var moduleOb = {};\n    var registeredAnimations = [];\n    var initTime = 0;\n    var len = 0;\n    var playingAnimationsNum = 0;\n    var _stopped = true;\n    var _isFrozen = false;\n\n    function removeElement(ev) {\n      var i = 0;\n      var animItem = ev.target;\n\n      while (i < len) {\n        if (registeredAnimations[i].animation === animItem) {\n          registeredAnimations.splice(i, 1);\n          i -= 1;\n          len -= 1;\n\n          if (!animItem.isPaused) {\n            subtractPlayingCount();\n          }\n        }\n\n        i += 1;\n      }\n    }\n\n    function registerAnimation(element, animationData) {\n      if (!element) {\n        return null;\n      }\n\n      var i = 0;\n\n      while (i < len) {\n        if (registeredAnimations[i].elem === element && registeredAnimations[i].elem !== null) {\n          return registeredAnimations[i].animation;\n        }\n\n        i += 1;\n      }\n\n      var animItem = new AnimationItem();\n      setupAnimation(animItem, element);\n      animItem.setData(element, animationData);\n      return animItem;\n    }\n\n    function getRegisteredAnimations() {\n      var i;\n      var lenAnims = registeredAnimations.length;\n      var animations = [];\n\n      for (i = 0; i < lenAnims; i += 1) {\n        animations.push(registeredAnimations[i].animation);\n      }\n\n      return animations;\n    }\n\n    function addPlayingCount() {\n      playingAnimationsNum += 1;\n      activate();\n    }\n\n    function subtractPlayingCount() {\n      playingAnimationsNum -= 1;\n    }\n\n    function setupAnimation(animItem, element) {\n      animItem.addEventListener('destroy', removeElement);\n      animItem.addEventListener('_active', addPlayingCount);\n      animItem.addEventListener('_idle', subtractPlayingCount);\n      registeredAnimations.push({\n        elem: element,\n        animation: animItem\n      });\n      len += 1;\n    }\n\n    function loadAnimation(params) {\n      var animItem = new AnimationItem();\n      setupAnimation(animItem, null);\n      animItem.setParams(params);\n      return animItem;\n    }\n\n    function setSpeed(val, animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.setSpeed(val, animation);\n      }\n    }\n\n    function setDirection(val, animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.setDirection(val, animation);\n      }\n    }\n\n    function play(animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.play(animation);\n      }\n    }\n\n    function resume(nowTime) {\n      var elapsedTime = nowTime - initTime;\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.advanceTime(elapsedTime);\n      }\n\n      initTime = nowTime;\n\n      if (playingAnimationsNum && !_isFrozen) {\n        window.requestAnimationFrame(resume);\n      } else {\n        _stopped = true;\n      }\n    }\n\n    function first(nowTime) {\n      initTime = nowTime;\n      window.requestAnimationFrame(resume);\n    }\n\n    function pause(animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.pause(animation);\n      }\n    }\n\n    function goToAndStop(value, isFrame, animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.goToAndStop(value, isFrame, animation);\n      }\n    }\n\n    function stop(animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.stop(animation);\n      }\n    }\n\n    function togglePause(animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.togglePause(animation);\n      }\n    }\n\n    function destroy(animation) {\n      var i;\n\n      for (i = len - 1; i >= 0; i -= 1) {\n        registeredAnimations[i].animation.destroy(animation);\n      }\n    }\n\n    function searchAnimations(animationData, standalone, renderer) {\n      var animElements = [].concat([].slice.call(document.getElementsByClassName('lottie')), [].slice.call(document.getElementsByClassName('bodymovin')));\n      var i;\n      var lenAnims = animElements.length;\n\n      for (i = 0; i < lenAnims; i += 1) {\n        if (renderer) {\n          animElements[i].setAttribute('data-bm-type', renderer);\n        }\n\n        registerAnimation(animElements[i], animationData);\n      }\n\n      if (standalone && lenAnims === 0) {\n        if (!renderer) {\n          renderer = 'svg';\n        }\n\n        var body = document.getElementsByTagName('body')[0];\n        body.innerText = '';\n        var div = createTag('div');\n        div.style.width = '100%';\n        div.style.height = '100%';\n        div.setAttribute('data-bm-type', renderer);\n        body.appendChild(div);\n        registerAnimation(div, animationData);\n      }\n    }\n\n    function resize() {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.resize();\n      }\n    }\n\n    function activate() {\n      if (!_isFrozen && playingAnimationsNum) {\n        if (_stopped) {\n          window.requestAnimationFrame(first);\n          _stopped = false;\n        }\n      }\n    }\n\n    function freeze() {\n      _isFrozen = true;\n    }\n\n    function unfreeze() {\n      _isFrozen = false;\n      activate();\n    }\n\n    function setVolume(val, animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.setVolume(val, animation);\n      }\n    }\n\n    function mute(animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.mute(animation);\n      }\n    }\n\n    function unmute(animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.unmute(animation);\n      }\n    }\n\n    moduleOb.registerAnimation = registerAnimation;\n    moduleOb.loadAnimation = loadAnimation;\n    moduleOb.setSpeed = setSpeed;\n    moduleOb.setDirection = setDirection;\n    moduleOb.play = play;\n    moduleOb.pause = pause;\n    moduleOb.stop = stop;\n    moduleOb.togglePause = togglePause;\n    moduleOb.searchAnimations = searchAnimations;\n    moduleOb.resize = resize; // moduleOb.start = start;\n\n    moduleOb.goToAndStop = goToAndStop;\n    moduleOb.destroy = destroy;\n    moduleOb.freeze = freeze;\n    moduleOb.unfreeze = unfreeze;\n    moduleOb.setVolume = setVolume;\n    moduleOb.mute = mute;\n    moduleOb.unmute = unmute;\n    moduleOb.getRegisteredAnimations = getRegisteredAnimations;\n    return moduleOb;\n  }();\n\n  /* eslint-disable */\n  var BezierFactory = function () {\n    /**\r\n       * BezierEasing - use bezier curve for transition easing function\r\n       * by Gaëtan Renaudeau 2014 - 2015 – MIT License\r\n       *\r\n       * Credits: is based on Firefox's nsSMILKeySpline.cpp\r\n       * Usage:\r\n       * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])\r\n       * spline.get(x) => returns the easing value | x must be in [0, 1] range\r\n       *\r\n       */\n    var ob = {};\n    ob.getBezierEasing = getBezierEasing;\n    var beziers = {};\n\n    function getBezierEasing(a, b, c, d, nm) {\n      var str = nm || ('bez_' + a + '_' + b + '_' + c + '_' + d).replace(/\\./g, 'p');\n\n      if (beziers[str]) {\n        return beziers[str];\n      }\n\n      var bezEasing = new BezierEasing([a, b, c, d]);\n      beziers[str] = bezEasing;\n      return bezEasing;\n    } // These values are established by empiricism with tests (tradeoff: performance VS precision)\n\n\n    var NEWTON_ITERATIONS = 4;\n    var NEWTON_MIN_SLOPE = 0.001;\n    var SUBDIVISION_PRECISION = 0.0000001;\n    var SUBDIVISION_MAX_ITERATIONS = 10;\n    var kSplineTableSize = 11;\n    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n    var float32ArraySupported = typeof Float32Array === 'function';\n\n    function A(aA1, aA2) {\n      return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n    }\n\n    function B(aA1, aA2) {\n      return 3.0 * aA2 - 6.0 * aA1;\n    }\n\n    function C(aA1) {\n      return 3.0 * aA1;\n    } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n\n\n    function calcBezier(aT, aA1, aA2) {\n      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n    } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n\n\n    function getSlope(aT, aA1, aA2) {\n      return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n    }\n\n    function binarySubdivide(aX, aA, aB, mX1, mX2) {\n      var currentX,\n          currentT,\n          i = 0;\n\n      do {\n        currentT = aA + (aB - aA) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n        if (currentX > 0.0) {\n          aB = currentT;\n        } else {\n          aA = currentT;\n        }\n      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n      return currentT;\n    }\n\n    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n      for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n        var currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0.0) return aGuessT;\n        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n      }\n\n      return aGuessT;\n    }\n    /**\r\n       * points is an array of [ mX1, mY1, mX2, mY2 ]\r\n       */\n\n\n    function BezierEasing(points) {\n      this._p = points;\n      this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n      this._precomputed = false;\n      this.get = this.get.bind(this);\n    }\n\n    BezierEasing.prototype = {\n      get: function get(x) {\n        var mX1 = this._p[0],\n            mY1 = this._p[1],\n            mX2 = this._p[2],\n            mY2 = this._p[3];\n        if (!this._precomputed) this._precompute();\n        if (mX1 === mY1 && mX2 === mY2) return x; // linear\n        // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n\n        if (x === 0) return 0;\n        if (x === 1) return 1;\n        return calcBezier(this._getTForX(x), mY1, mY2);\n      },\n      // Private part\n      _precompute: function _precompute() {\n        var mX1 = this._p[0],\n            mY1 = this._p[1],\n            mX2 = this._p[2],\n            mY2 = this._p[3];\n        this._precomputed = true;\n\n        if (mX1 !== mY1 || mX2 !== mY2) {\n          this._calcSampleValues();\n        }\n      },\n      _calcSampleValues: function _calcSampleValues() {\n        var mX1 = this._p[0],\n            mX2 = this._p[2];\n\n        for (var i = 0; i < kSplineTableSize; ++i) {\n          this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n        }\n      },\n\n      /**\r\n           * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.\r\n           */\n      _getTForX: function _getTForX(aX) {\n        var mX1 = this._p[0],\n            mX2 = this._p[2],\n            mSampleValues = this._mSampleValues;\n        var intervalStart = 0.0;\n        var currentSample = 1;\n        var lastSample = kSplineTableSize - 1;\n\n        for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {\n          intervalStart += kSampleStepSize;\n        }\n\n        --currentSample; // Interpolate to provide an initial guess for t\n\n        var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);\n        var guessForT = intervalStart + dist * kSampleStepSize;\n        var initialSlope = getSlope(guessForT, mX1, mX2);\n\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\n          return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        }\n\n        if (initialSlope === 0.0) {\n          return guessForT;\n        }\n\n        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n      }\n    };\n    return ob;\n  }();\n\n  var pooling = function () {\n    function _double(arr) {\n      return arr.concat(createSizedArray(arr.length));\n    }\n\n    return {\n      \"double\": _double\n    };\n  }();\n\n  var poolFactory = function () {\n    return function (initialLength, _create, _release) {\n      var _length = 0;\n      var _maxLength = initialLength;\n      var pool = createSizedArray(_maxLength);\n      var ob = {\n        newElement: newElement,\n        release: release\n      };\n\n      function newElement() {\n        var element;\n\n        if (_length) {\n          _length -= 1;\n          element = pool[_length];\n        } else {\n          element = _create();\n        }\n\n        return element;\n      }\n\n      function release(element) {\n        if (_length === _maxLength) {\n          pool = pooling[\"double\"](pool);\n          _maxLength *= 2;\n        }\n\n        if (_release) {\n          _release(element);\n        }\n\n        pool[_length] = element;\n        _length += 1;\n      }\n\n      return ob;\n    };\n  }();\n\n  var bezierLengthPool = function () {\n    function create() {\n      return {\n        addedLength: 0,\n        percents: createTypedArray('float32', getDefaultCurveSegments()),\n        lengths: createTypedArray('float32', getDefaultCurveSegments())\n      };\n    }\n\n    return poolFactory(8, create);\n  }();\n\n  var segmentsLengthPool = function () {\n    function create() {\n      return {\n        lengths: [],\n        totalLength: 0\n      };\n    }\n\n    function release(element) {\n      var i;\n      var len = element.lengths.length;\n\n      for (i = 0; i < len; i += 1) {\n        bezierLengthPool.release(element.lengths[i]);\n      }\n\n      element.lengths.length = 0;\n    }\n\n    return poolFactory(8, create, release);\n  }();\n\n  function bezFunction() {\n    var math = Math;\n\n    function pointOnLine2D(x1, y1, x2, y2, x3, y3) {\n      var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;\n      return det1 > -0.001 && det1 < 0.001;\n    }\n\n    function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {\n      if (z1 === 0 && z2 === 0 && z3 === 0) {\n        return pointOnLine2D(x1, y1, x2, y2, x3, y3);\n      }\n\n      var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));\n      var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));\n      var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));\n      var diffDist;\n\n      if (dist1 > dist2) {\n        if (dist1 > dist3) {\n          diffDist = dist1 - dist2 - dist3;\n        } else {\n          diffDist = dist3 - dist2 - dist1;\n        }\n      } else if (dist3 > dist2) {\n        diffDist = dist3 - dist2 - dist1;\n      } else {\n        diffDist = dist2 - dist1 - dist3;\n      }\n\n      return diffDist > -0.0001 && diffDist < 0.0001;\n    }\n\n    var getBezierLength = function () {\n      return function (pt1, pt2, pt3, pt4) {\n        var curveSegments = getDefaultCurveSegments();\n        var k;\n        var i;\n        var len;\n        var ptCoord;\n        var perc;\n        var addedLength = 0;\n        var ptDistance;\n        var point = [];\n        var lastPoint = [];\n        var lengthData = bezierLengthPool.newElement();\n        len = pt3.length;\n\n        for (k = 0; k < curveSegments; k += 1) {\n          perc = k / (curveSegments - 1);\n          ptDistance = 0;\n\n          for (i = 0; i < len; i += 1) {\n            ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i] + bmPow(perc, 3) * pt2[i];\n            point[i] = ptCoord;\n\n            if (lastPoint[i] !== null) {\n              ptDistance += bmPow(point[i] - lastPoint[i], 2);\n            }\n\n            lastPoint[i] = point[i];\n          }\n\n          if (ptDistance) {\n            ptDistance = bmSqrt(ptDistance);\n            addedLength += ptDistance;\n          }\n\n          lengthData.percents[k] = perc;\n          lengthData.lengths[k] = addedLength;\n        }\n\n        lengthData.addedLength = addedLength;\n        return lengthData;\n      };\n    }();\n\n    function getSegmentsLength(shapeData) {\n      var segmentsLength = segmentsLengthPool.newElement();\n      var closed = shapeData.c;\n      var pathV = shapeData.v;\n      var pathO = shapeData.o;\n      var pathI = shapeData.i;\n      var i;\n      var len = shapeData._length;\n      var lengths = segmentsLength.lengths;\n      var totalLength = 0;\n\n      for (i = 0; i < len - 1; i += 1) {\n        lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]);\n        totalLength += lengths[i].addedLength;\n      }\n\n      if (closed && len) {\n        lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]);\n        totalLength += lengths[i].addedLength;\n      }\n\n      segmentsLength.totalLength = totalLength;\n      return segmentsLength;\n    }\n\n    function BezierData(length) {\n      this.segmentLength = 0;\n      this.points = new Array(length);\n    }\n\n    function PointData(partial, point) {\n      this.partialLength = partial;\n      this.point = point;\n    }\n\n    var buildBezierData = function () {\n      var storedData = {};\n      return function (pt1, pt2, pt3, pt4) {\n        var bezierName = (pt1[0] + '_' + pt1[1] + '_' + pt2[0] + '_' + pt2[1] + '_' + pt3[0] + '_' + pt3[1] + '_' + pt4[0] + '_' + pt4[1]).replace(/\\./g, 'p');\n\n        if (!storedData[bezierName]) {\n          var curveSegments = getDefaultCurveSegments();\n          var k;\n          var i;\n          var len;\n          var ptCoord;\n          var perc;\n          var addedLength = 0;\n          var ptDistance;\n          var point;\n          var lastPoint = null;\n\n          if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {\n            curveSegments = 2;\n          }\n\n          var bezierData = new BezierData(curveSegments);\n          len = pt3.length;\n\n          for (k = 0; k < curveSegments; k += 1) {\n            point = createSizedArray(len);\n            perc = k / (curveSegments - 1);\n            ptDistance = 0;\n\n            for (i = 0; i < len; i += 1) {\n              ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) + bmPow(perc, 3) * pt2[i];\n              point[i] = ptCoord;\n\n              if (lastPoint !== null) {\n                ptDistance += bmPow(point[i] - lastPoint[i], 2);\n              }\n            }\n\n            ptDistance = bmSqrt(ptDistance);\n            addedLength += ptDistance;\n            bezierData.points[k] = new PointData(ptDistance, point);\n            lastPoint = point;\n          }\n\n          bezierData.segmentLength = addedLength;\n          storedData[bezierName] = bezierData;\n        }\n\n        return storedData[bezierName];\n      };\n    }();\n\n    function getDistancePerc(perc, bezierData) {\n      var percents = bezierData.percents;\n      var lengths = bezierData.lengths;\n      var len = percents.length;\n      var initPos = bmFloor((len - 1) * perc);\n      var lengthPos = perc * bezierData.addedLength;\n      var lPerc = 0;\n\n      if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {\n        return percents[initPos];\n      }\n\n      var dir = lengths[initPos] > lengthPos ? -1 : 1;\n      var flag = true;\n\n      while (flag) {\n        if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {\n          lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);\n          flag = false;\n        } else {\n          initPos += dir;\n        }\n\n        if (initPos < 0 || initPos >= len - 1) {\n          // FIX for TypedArrays that don't store floating point values with enough accuracy\n          if (initPos === len - 1) {\n            return percents[initPos];\n          }\n\n          flag = false;\n        }\n      }\n\n      return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;\n    }\n\n    function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {\n      var t1 = getDistancePerc(percent, bezierData);\n      var u1 = 1 - t1;\n      var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1000) / 1000;\n      var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1000) / 1000;\n      return [ptX, ptY];\n    }\n\n    var bezierSegmentPoints = createTypedArray('float32', 8);\n\n    function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {\n      if (startPerc < 0) {\n        startPerc = 0;\n      } else if (startPerc > 1) {\n        startPerc = 1;\n      }\n\n      var t0 = getDistancePerc(startPerc, bezierData);\n      endPerc = endPerc > 1 ? 1 : endPerc;\n      var t1 = getDistancePerc(endPerc, bezierData);\n      var i;\n      var len = pt1.length;\n      var u0 = 1 - t0;\n      var u1 = 1 - t1;\n      var u0u0u0 = u0 * u0 * u0;\n      var t0u0u0_3 = t0 * u0 * u0 * 3; // eslint-disable-line camelcase\n\n      var t0t0u0_3 = t0 * t0 * u0 * 3; // eslint-disable-line camelcase\n\n      var t0t0t0 = t0 * t0 * t0; //\n\n      var u0u0u1 = u0 * u0 * u1;\n      var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1; // eslint-disable-line camelcase\n\n      var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1; // eslint-disable-line camelcase\n\n      var t0t0t1 = t0 * t0 * t1; //\n\n      var u0u1u1 = u0 * u1 * u1;\n      var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1; // eslint-disable-line camelcase\n\n      var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1; // eslint-disable-line camelcase\n\n      var t0t1t1 = t0 * t1 * t1; //\n\n      var u1u1u1 = u1 * u1 * u1;\n      var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1; // eslint-disable-line camelcase\n\n      var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1; // eslint-disable-line camelcase\n\n      var t1t1t1 = t1 * t1 * t1;\n\n      for (i = 0; i < len; i += 1) {\n        bezierSegmentPoints[i * 4] = math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n\n        bezierSegmentPoints[i * 4 + 1] = math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n\n        bezierSegmentPoints[i * 4 + 2] = math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n\n        bezierSegmentPoints[i * 4 + 3] = math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n      }\n\n      return bezierSegmentPoints;\n    }\n\n    return {\n      getSegmentsLength: getSegmentsLength,\n      getNewSegment: getNewSegment,\n      getPointInSegment: getPointInSegment,\n      buildBezierData: buildBezierData,\n      pointOnLine2D: pointOnLine2D,\n      pointOnLine3D: pointOnLine3D\n    };\n  }\n\n  var bez = bezFunction();\n\n  var initFrame = initialDefaultFrame;\n  var mathAbs = Math.abs;\n\n  function interpolateValue(frameNum, caching) {\n    var offsetTime = this.offsetTime;\n    var newValue;\n\n    if (this.propType === 'multidimensional') {\n      newValue = createTypedArray('float32', this.pv.length);\n    }\n\n    var iterationIndex = caching.lastIndex;\n    var i = iterationIndex;\n    var len = this.keyframes.length - 1;\n    var flag = true;\n    var keyData;\n    var nextKeyData;\n    var keyframeMetadata;\n\n    while (flag) {\n      keyData = this.keyframes[i];\n      nextKeyData = this.keyframes[i + 1];\n\n      if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {\n        if (keyData.h) {\n          keyData = nextKeyData;\n        }\n\n        iterationIndex = 0;\n        break;\n      }\n\n      if (nextKeyData.t - offsetTime > frameNum) {\n        iterationIndex = i;\n        break;\n      }\n\n      if (i < len - 1) {\n        i += 1;\n      } else {\n        iterationIndex = 0;\n        flag = false;\n      }\n    }\n\n    keyframeMetadata = this.keyframesMetadata[i] || {};\n    var k;\n    var kLen;\n    var perc;\n    var jLen;\n    var j;\n    var fnc;\n    var nextKeyTime = nextKeyData.t - offsetTime;\n    var keyTime = keyData.t - offsetTime;\n    var endValue;\n\n    if (keyData.to) {\n      if (!keyframeMetadata.bezierData) {\n        keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);\n      }\n\n      var bezierData = keyframeMetadata.bezierData;\n\n      if (frameNum >= nextKeyTime || frameNum < keyTime) {\n        var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;\n        kLen = bezierData.points[ind].point.length;\n\n        for (k = 0; k < kLen; k += 1) {\n          newValue[k] = bezierData.points[ind].point[k];\n        } // caching._lastKeyframeIndex = -1;\n\n      } else {\n        if (keyframeMetadata.__fnct) {\n          fnc = keyframeMetadata.__fnct;\n        } else {\n          fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;\n          keyframeMetadata.__fnct = fnc;\n        }\n\n        perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));\n        var distanceInLine = bezierData.segmentLength * perc;\n        var segmentPerc;\n        var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastAddedLength : 0;\n        j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastPoint : 0;\n        flag = true;\n        jLen = bezierData.points.length;\n\n        while (flag) {\n          addedLength += bezierData.points[j].partialLength;\n\n          if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {\n            kLen = bezierData.points[j].point.length;\n\n            for (k = 0; k < kLen; k += 1) {\n              newValue[k] = bezierData.points[j].point[k];\n            }\n\n            break;\n          } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {\n            segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;\n            kLen = bezierData.points[j].point.length;\n\n            for (k = 0; k < kLen; k += 1) {\n              newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;\n            }\n\n            break;\n          }\n\n          if (j < jLen - 1) {\n            j += 1;\n          } else {\n            flag = false;\n          }\n        }\n\n        caching._lastPoint = j;\n        caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;\n        caching._lastKeyframeIndex = i;\n      }\n    } else {\n      var outX;\n      var outY;\n      var inX;\n      var inY;\n      var keyValue;\n      len = keyData.s.length;\n      endValue = nextKeyData.s || keyData.e;\n\n      if (this.sh && keyData.h !== 1) {\n        if (frameNum >= nextKeyTime) {\n          newValue[0] = endValue[0];\n          newValue[1] = endValue[1];\n          newValue[2] = endValue[2];\n        } else if (frameNum <= keyTime) {\n          newValue[0] = keyData.s[0];\n          newValue[1] = keyData.s[1];\n          newValue[2] = keyData.s[2];\n        } else {\n          var quatStart = createQuaternion(keyData.s);\n          var quatEnd = createQuaternion(endValue);\n          var time = (frameNum - keyTime) / (nextKeyTime - keyTime);\n          quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));\n        }\n      } else {\n        for (i = 0; i < len; i += 1) {\n          if (keyData.h !== 1) {\n            if (frameNum >= nextKeyTime) {\n              perc = 1;\n            } else if (frameNum < keyTime) {\n              perc = 0;\n            } else {\n              if (keyData.o.x.constructor === Array) {\n                if (!keyframeMetadata.__fnct) {\n                  keyframeMetadata.__fnct = [];\n                }\n\n                if (!keyframeMetadata.__fnct[i]) {\n                  outX = keyData.o.x[i] === undefined ? keyData.o.x[0] : keyData.o.x[i];\n                  outY = keyData.o.y[i] === undefined ? keyData.o.y[0] : keyData.o.y[i];\n                  inX = keyData.i.x[i] === undefined ? keyData.i.x[0] : keyData.i.x[i];\n                  inY = keyData.i.y[i] === undefined ? keyData.i.y[0] : keyData.i.y[i];\n                  fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;\n                  keyframeMetadata.__fnct[i] = fnc;\n                } else {\n                  fnc = keyframeMetadata.__fnct[i];\n                }\n              } else if (!keyframeMetadata.__fnct) {\n                outX = keyData.o.x;\n                outY = keyData.o.y;\n                inX = keyData.i.x;\n                inY = keyData.i.y;\n                fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;\n                keyData.keyframeMetadata = fnc;\n              } else {\n                fnc = keyframeMetadata.__fnct;\n              }\n\n              perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));\n            }\n          }\n\n          endValue = nextKeyData.s || keyData.e;\n          keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;\n\n          if (this.propType === 'multidimensional') {\n            newValue[i] = keyValue;\n          } else {\n            newValue = keyValue;\n          }\n        }\n      }\n    }\n\n    caching.lastIndex = iterationIndex;\n    return newValue;\n  } // based on @Toji's https://github.com/toji/gl-matrix/\n\n\n  function slerp(a, b, t) {\n    var out = [];\n    var ax = a[0];\n    var ay = a[1];\n    var az = a[2];\n    var aw = a[3];\n    var bx = b[0];\n    var by = b[1];\n    var bz = b[2];\n    var bw = b[3];\n    var omega;\n    var cosom;\n    var sinom;\n    var scale0;\n    var scale1;\n    cosom = ax * bx + ay * by + az * bz + aw * bw;\n\n    if (cosom < 0.0) {\n      cosom = -cosom;\n      bx = -bx;\n      by = -by;\n      bz = -bz;\n      bw = -bw;\n    }\n\n    if (1.0 - cosom > 0.000001) {\n      omega = Math.acos(cosom);\n      sinom = Math.sin(omega);\n      scale0 = Math.sin((1.0 - t) * omega) / sinom;\n      scale1 = Math.sin(t * omega) / sinom;\n    } else {\n      scale0 = 1.0 - t;\n      scale1 = t;\n    }\n\n    out[0] = scale0 * ax + scale1 * bx;\n    out[1] = scale0 * ay + scale1 * by;\n    out[2] = scale0 * az + scale1 * bz;\n    out[3] = scale0 * aw + scale1 * bw;\n    return out;\n  }\n\n  function quaternionToEuler(out, quat) {\n    var qx = quat[0];\n    var qy = quat[1];\n    var qz = quat[2];\n    var qw = quat[3];\n    var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);\n    var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);\n    var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);\n    out[0] = heading / degToRads;\n    out[1] = attitude / degToRads;\n    out[2] = bank / degToRads;\n  }\n\n  function createQuaternion(values) {\n    var heading = values[0] * degToRads;\n    var attitude = values[1] * degToRads;\n    var bank = values[2] * degToRads;\n    var c1 = Math.cos(heading / 2);\n    var c2 = Math.cos(attitude / 2);\n    var c3 = Math.cos(bank / 2);\n    var s1 = Math.sin(heading / 2);\n    var s2 = Math.sin(attitude / 2);\n    var s3 = Math.sin(bank / 2);\n    var w = c1 * c2 * c3 - s1 * s2 * s3;\n    var x = s1 * s2 * c3 + c1 * c2 * s3;\n    var y = s1 * c2 * c3 + c1 * s2 * s3;\n    var z = c1 * s2 * c3 - s1 * c2 * s3;\n    return [x, y, z, w];\n  }\n\n  function getValueAtCurrentTime() {\n    var frameNum = this.comp.renderedFrame - this.offsetTime;\n    var initTime = this.keyframes[0].t - this.offsetTime;\n    var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;\n\n    if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {\n      if (this._caching.lastFrame >= frameNum) {\n        this._caching._lastKeyframeIndex = -1;\n        this._caching.lastIndex = 0;\n      }\n\n      var renderResult = this.interpolateValue(frameNum, this._caching);\n      this.pv = renderResult;\n    }\n\n    this._caching.lastFrame = frameNum;\n    return this.pv;\n  }\n\n  function setVValue(val) {\n    var multipliedValue;\n\n    if (this.propType === 'unidimensional') {\n      multipliedValue = val * this.mult;\n\n      if (mathAbs(this.v - multipliedValue) > 0.00001) {\n        this.v = multipliedValue;\n        this._mdf = true;\n      }\n    } else {\n      var i = 0;\n      var len = this.v.length;\n\n      while (i < len) {\n        multipliedValue = val[i] * this.mult;\n\n        if (mathAbs(this.v[i] - multipliedValue) > 0.00001) {\n          this.v[i] = multipliedValue;\n          this._mdf = true;\n        }\n\n        i += 1;\n      }\n    }\n  }\n\n  function processEffectsSequence() {\n    if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {\n      return;\n    }\n\n    if (this.lock) {\n      this.setVValue(this.pv);\n      return;\n    }\n\n    this.lock = true;\n    this._mdf = this._isFirstFrame;\n    var i;\n    var len = this.effectsSequence.length;\n    var finalValue = this.kf ? this.pv : this.data.k;\n\n    for (i = 0; i < len; i += 1) {\n      finalValue = this.effectsSequence[i](finalValue);\n    }\n\n    this.setVValue(finalValue);\n    this._isFirstFrame = false;\n    this.lock = false;\n    this.frameId = this.elem.globalData.frameId;\n  }\n\n  function addEffect(effectFunction) {\n    this.effectsSequence.push(effectFunction);\n    this.container.addDynamicProperty(this);\n  }\n\n  function ValueProperty(elem, data, mult, container) {\n    this.propType = 'unidimensional';\n    this.mult = mult || 1;\n    this.data = data;\n    this.v = mult ? data.k * mult : data.k;\n    this.pv = data.k;\n    this._mdf = false;\n    this.elem = elem;\n    this.container = container;\n    this.comp = elem.comp;\n    this.k = false;\n    this.kf = false;\n    this.vel = 0;\n    this.effectsSequence = [];\n    this._isFirstFrame = true;\n    this.getValue = processEffectsSequence;\n    this.setVValue = setVValue;\n    this.addEffect = addEffect;\n  }\n\n  function MultiDimensionalProperty(elem, data, mult, container) {\n    this.propType = 'multidimensional';\n    this.mult = mult || 1;\n    this.data = data;\n    this._mdf = false;\n    this.elem = elem;\n    this.container = container;\n    this.comp = elem.comp;\n    this.k = false;\n    this.kf = false;\n    this.frameId = -1;\n    var i;\n    var len = data.k.length;\n    this.v = createTypedArray('float32', len);\n    this.pv = createTypedArray('float32', len);\n    this.vel = createTypedArray('float32', len);\n\n    for (i = 0; i < len; i += 1) {\n      this.v[i] = data.k[i] * this.mult;\n      this.pv[i] = data.k[i];\n    }\n\n    this._isFirstFrame = true;\n    this.effectsSequence = [];\n    this.getValue = processEffectsSequence;\n    this.setVValue = setVValue;\n    this.addEffect = addEffect;\n  }\n\n  function KeyframedValueProperty(elem, data, mult, container) {\n    this.propType = 'unidimensional';\n    this.keyframes = data.k;\n    this.keyframesMetadata = [];\n    this.offsetTime = elem.data.st;\n    this.frameId = -1;\n    this._caching = {\n      lastFrame: initFrame,\n      lastIndex: 0,\n      value: 0,\n      _lastKeyframeIndex: -1\n    };\n    this.k = true;\n    this.kf = true;\n    this.data = data;\n    this.mult = mult || 1;\n    this.elem = elem;\n    this.container = container;\n    this.comp = elem.comp;\n    this.v = initFrame;\n    this.pv = initFrame;\n    this._isFirstFrame = true;\n    this.getValue = processEffectsSequence;\n    this.setVValue = setVValue;\n    this.interpolateValue = interpolateValue;\n    this.effectsSequence = [getValueAtCurrentTime.bind(this)];\n    this.addEffect = addEffect;\n  }\n\n  function KeyframedMultidimensionalProperty(elem, data, mult, container) {\n    this.propType = 'multidimensional';\n    var i;\n    var len = data.k.length;\n    var s;\n    var e;\n    var to;\n    var ti;\n\n    for (i = 0; i < len - 1; i += 1) {\n      if (data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s) {\n        s = data.k[i].s;\n        e = data.k[i + 1].s;\n        to = data.k[i].to;\n        ti = data.k[i].ti;\n\n        if (s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1]) || s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2])) {\n          data.k[i].to = null;\n          data.k[i].ti = null;\n        }\n\n        if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {\n          if (s.length === 2 || s[2] === e[2] && to[2] === 0 && ti[2] === 0) {\n            data.k[i].to = null;\n            data.k[i].ti = null;\n          }\n        }\n      }\n    }\n\n    this.effectsSequence = [getValueAtCurrentTime.bind(this)];\n    this.data = data;\n    this.keyframes = data.k;\n    this.keyframesMetadata = [];\n    this.offsetTime = elem.data.st;\n    this.k = true;\n    this.kf = true;\n    this._isFirstFrame = true;\n    this.mult = mult || 1;\n    this.elem = elem;\n    this.container = container;\n    this.comp = elem.comp;\n    this.getValue = processEffectsSequence;\n    this.setVValue = setVValue;\n    this.interpolateValue = interpolateValue;\n    this.frameId = -1;\n    var arrLen = data.k[0].s.length;\n    this.v = createTypedArray('float32', arrLen);\n    this.pv = createTypedArray('float32', arrLen);\n\n    for (i = 0; i < arrLen; i += 1) {\n      this.v[i] = initFrame;\n      this.pv[i] = initFrame;\n    }\n\n    this._caching = {\n      lastFrame: initFrame,\n      lastIndex: 0,\n      value: createTypedArray('float32', arrLen)\n    };\n    this.addEffect = addEffect;\n  }\n\n  var PropertyFactory = function () {\n    function getProp(elem, data, type, mult, container) {\n      if (data.sid) {\n        data = elem.globalData.slotManager.getProp(data);\n      }\n\n      var p;\n\n      if (!data.k.length) {\n        p = new ValueProperty(elem, data, mult, container);\n      } else if (typeof data.k[0] === 'number') {\n        p = new MultiDimensionalProperty(elem, data, mult, container);\n      } else {\n        switch (type) {\n          case 0:\n            p = new KeyframedValueProperty(elem, data, mult, container);\n            break;\n\n          case 1:\n            p = new KeyframedMultidimensionalProperty(elem, data, mult, container);\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      if (p.effectsSequence.length) {\n        container.addDynamicProperty(p);\n      }\n\n      return p;\n    }\n\n    var ob = {\n      getProp: getProp\n    };\n    return ob;\n  }();\n\n  function DynamicPropertyContainer() {}\n\n  DynamicPropertyContainer.prototype = {\n    addDynamicProperty: function addDynamicProperty(prop) {\n      if (this.dynamicProperties.indexOf(prop) === -1) {\n        this.dynamicProperties.push(prop);\n        this.container.addDynamicProperty(this);\n        this._isAnimated = true;\n      }\n    },\n    iterateDynamicProperties: function iterateDynamicProperties() {\n      this._mdf = false;\n      var i;\n      var len = this.dynamicProperties.length;\n\n      for (i = 0; i < len; i += 1) {\n        this.dynamicProperties[i].getValue();\n\n        if (this.dynamicProperties[i]._mdf) {\n          this._mdf = true;\n        }\n      }\n    },\n    initDynamicPropertyContainer: function initDynamicPropertyContainer(container) {\n      this.container = container;\n      this.dynamicProperties = [];\n      this._mdf = false;\n      this._isAnimated = false;\n    }\n  };\n\n  var pointPool = function () {\n    function create() {\n      return createTypedArray('float32', 2);\n    }\n\n    return poolFactory(8, create);\n  }();\n\n  function ShapePath() {\n    this.c = false;\n    this._length = 0;\n    this._maxLength = 8;\n    this.v = createSizedArray(this._maxLength);\n    this.o = createSizedArray(this._maxLength);\n    this.i = createSizedArray(this._maxLength);\n  }\n\n  ShapePath.prototype.setPathData = function (closed, len) {\n    this.c = closed;\n    this.setLength(len);\n    var i = 0;\n\n    while (i < len) {\n      this.v[i] = pointPool.newElement();\n      this.o[i] = pointPool.newElement();\n      this.i[i] = pointPool.newElement();\n      i += 1;\n    }\n  };\n\n  ShapePath.prototype.setLength = function (len) {\n    while (this._maxLength < len) {\n      this.doubleArrayLength();\n    }\n\n    this._length = len;\n  };\n\n  ShapePath.prototype.doubleArrayLength = function () {\n    this.v = this.v.concat(createSizedArray(this._maxLength));\n    this.i = this.i.concat(createSizedArray(this._maxLength));\n    this.o = this.o.concat(createSizedArray(this._maxLength));\n    this._maxLength *= 2;\n  };\n\n  ShapePath.prototype.setXYAt = function (x, y, type, pos, replace) {\n    var arr;\n    this._length = Math.max(this._length, pos + 1);\n\n    if (this._length >= this._maxLength) {\n      this.doubleArrayLength();\n    }\n\n    switch (type) {\n      case 'v':\n        arr = this.v;\n        break;\n\n      case 'i':\n        arr = this.i;\n        break;\n\n      case 'o':\n        arr = this.o;\n        break;\n\n      default:\n        arr = [];\n        break;\n    }\n\n    if (!arr[pos] || arr[pos] && !replace) {\n      arr[pos] = pointPool.newElement();\n    }\n\n    arr[pos][0] = x;\n    arr[pos][1] = y;\n  };\n\n  ShapePath.prototype.setTripleAt = function (vX, vY, oX, oY, iX, iY, pos, replace) {\n    this.setXYAt(vX, vY, 'v', pos, replace);\n    this.setXYAt(oX, oY, 'o', pos, replace);\n    this.setXYAt(iX, iY, 'i', pos, replace);\n  };\n\n  ShapePath.prototype.reverse = function () {\n    var newPath = new ShapePath();\n    newPath.setPathData(this.c, this._length);\n    var vertices = this.v;\n    var outPoints = this.o;\n    var inPoints = this.i;\n    var init = 0;\n\n    if (this.c) {\n      newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);\n      init = 1;\n    }\n\n    var cnt = this._length - 1;\n    var len = this._length;\n    var i;\n\n    for (i = init; i < len; i += 1) {\n      newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);\n      cnt -= 1;\n    }\n\n    return newPath;\n  };\n\n  ShapePath.prototype.length = function () {\n    return this._length;\n  };\n\n  var shapePool = function () {\n    function create() {\n      return new ShapePath();\n    }\n\n    function release(shapePath) {\n      var len = shapePath._length;\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        pointPool.release(shapePath.v[i]);\n        pointPool.release(shapePath.i[i]);\n        pointPool.release(shapePath.o[i]);\n        shapePath.v[i] = null;\n        shapePath.i[i] = null;\n        shapePath.o[i] = null;\n      }\n\n      shapePath._length = 0;\n      shapePath.c = false;\n    }\n\n    function clone(shape) {\n      var cloned = factory.newElement();\n      var i;\n      var len = shape._length === undefined ? shape.v.length : shape._length;\n      cloned.setLength(len);\n      cloned.c = shape.c;\n\n      for (i = 0; i < len; i += 1) {\n        cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);\n      }\n\n      return cloned;\n    }\n\n    var factory = poolFactory(4, create, release);\n    factory.clone = clone;\n    return factory;\n  }();\n\n  function ShapeCollection() {\n    this._length = 0;\n    this._maxLength = 4;\n    this.shapes = createSizedArray(this._maxLength);\n  }\n\n  ShapeCollection.prototype.addShape = function (shapeData) {\n    if (this._length === this._maxLength) {\n      this.shapes = this.shapes.concat(createSizedArray(this._maxLength));\n      this._maxLength *= 2;\n    }\n\n    this.shapes[this._length] = shapeData;\n    this._length += 1;\n  };\n\n  ShapeCollection.prototype.releaseShapes = function () {\n    var i;\n\n    for (i = 0; i < this._length; i += 1) {\n      shapePool.release(this.shapes[i]);\n    }\n\n    this._length = 0;\n  };\n\n  var shapeCollectionPool = function () {\n    var ob = {\n      newShapeCollection: newShapeCollection,\n      release: release\n    };\n    var _length = 0;\n    var _maxLength = 4;\n    var pool = createSizedArray(_maxLength);\n\n    function newShapeCollection() {\n      var shapeCollection;\n\n      if (_length) {\n        _length -= 1;\n        shapeCollection = pool[_length];\n      } else {\n        shapeCollection = new ShapeCollection();\n      }\n\n      return shapeCollection;\n    }\n\n    function release(shapeCollection) {\n      var i;\n      var len = shapeCollection._length;\n\n      for (i = 0; i < len; i += 1) {\n        shapePool.release(shapeCollection.shapes[i]);\n      }\n\n      shapeCollection._length = 0;\n\n      if (_length === _maxLength) {\n        pool = pooling[\"double\"](pool);\n        _maxLength *= 2;\n      }\n\n      pool[_length] = shapeCollection;\n      _length += 1;\n    }\n\n    return ob;\n  }();\n\n  var ShapePropertyFactory = function () {\n    var initFrame = -999999;\n\n    function interpolateShape(frameNum, previousValue, caching) {\n      var iterationIndex = caching.lastIndex;\n      var keyPropS;\n      var keyPropE;\n      var isHold;\n      var j;\n      var k;\n      var jLen;\n      var kLen;\n      var perc;\n      var vertexValue;\n      var kf = this.keyframes;\n\n      if (frameNum < kf[0].t - this.offsetTime) {\n        keyPropS = kf[0].s[0];\n        isHold = true;\n        iterationIndex = 0;\n      } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {\n        keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];\n        /* if(kf[kf.length - 1].s){\r\n                  keyPropS = kf[kf.length - 1].s[0];\r\n              }else{\r\n                  keyPropS = kf[kf.length - 2].e[0];\r\n              } */\n\n        isHold = true;\n      } else {\n        var i = iterationIndex;\n        var len = kf.length - 1;\n        var flag = true;\n        var keyData;\n        var nextKeyData;\n        var keyframeMetadata;\n\n        while (flag) {\n          keyData = kf[i];\n          nextKeyData = kf[i + 1];\n\n          if (nextKeyData.t - this.offsetTime > frameNum) {\n            break;\n          }\n\n          if (i < len - 1) {\n            i += 1;\n          } else {\n            flag = false;\n          }\n        }\n\n        keyframeMetadata = this.keyframesMetadata[i] || {};\n        isHold = keyData.h === 1;\n        iterationIndex = i;\n\n        if (!isHold) {\n          if (frameNum >= nextKeyData.t - this.offsetTime) {\n            perc = 1;\n          } else if (frameNum < keyData.t - this.offsetTime) {\n            perc = 0;\n          } else {\n            var fnc;\n\n            if (keyframeMetadata.__fnct) {\n              fnc = keyframeMetadata.__fnct;\n            } else {\n              fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;\n              keyframeMetadata.__fnct = fnc;\n            }\n\n            perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));\n          }\n\n          keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];\n        }\n\n        keyPropS = keyData.s[0];\n      }\n\n      jLen = previousValue._length;\n      kLen = keyPropS.i[0].length;\n      caching.lastIndex = iterationIndex;\n\n      for (j = 0; j < jLen; j += 1) {\n        for (k = 0; k < kLen; k += 1) {\n          vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;\n          previousValue.i[j][k] = vertexValue;\n          vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;\n          previousValue.o[j][k] = vertexValue;\n          vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;\n          previousValue.v[j][k] = vertexValue;\n        }\n      }\n    }\n\n    function interpolateShapeCurrentTime() {\n      var frameNum = this.comp.renderedFrame - this.offsetTime;\n      var initTime = this.keyframes[0].t - this.offsetTime;\n      var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;\n      var lastFrame = this._caching.lastFrame;\n\n      if (!(lastFrame !== initFrame && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {\n        /// /\n        this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;\n        this.interpolateShape(frameNum, this.pv, this._caching); /// /\n      }\n\n      this._caching.lastFrame = frameNum;\n      return this.pv;\n    }\n\n    function resetShape() {\n      this.paths = this.localShapeCollection;\n    }\n\n    function shapesEqual(shape1, shape2) {\n      if (shape1._length !== shape2._length || shape1.c !== shape2.c) {\n        return false;\n      }\n\n      var i;\n      var len = shape1._length;\n\n      for (i = 0; i < len; i += 1) {\n        if (shape1.v[i][0] !== shape2.v[i][0] || shape1.v[i][1] !== shape2.v[i][1] || shape1.o[i][0] !== shape2.o[i][0] || shape1.o[i][1] !== shape2.o[i][1] || shape1.i[i][0] !== shape2.i[i][0] || shape1.i[i][1] !== shape2.i[i][1]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    function setVValue(newPath) {\n      if (!shapesEqual(this.v, newPath)) {\n        this.v = shapePool.clone(newPath);\n        this.localShapeCollection.releaseShapes();\n        this.localShapeCollection.addShape(this.v);\n        this._mdf = true;\n        this.paths = this.localShapeCollection;\n      }\n    }\n\n    function processEffectsSequence() {\n      if (this.elem.globalData.frameId === this.frameId) {\n        return;\n      }\n\n      if (!this.effectsSequence.length) {\n        this._mdf = false;\n        return;\n      }\n\n      if (this.lock) {\n        this.setVValue(this.pv);\n        return;\n      }\n\n      this.lock = true;\n      this._mdf = false;\n      var finalValue;\n\n      if (this.kf) {\n        finalValue = this.pv;\n      } else if (this.data.ks) {\n        finalValue = this.data.ks.k;\n      } else {\n        finalValue = this.data.pt.k;\n      }\n\n      var i;\n      var len = this.effectsSequence.length;\n\n      for (i = 0; i < len; i += 1) {\n        finalValue = this.effectsSequence[i](finalValue);\n      }\n\n      this.setVValue(finalValue);\n      this.lock = false;\n      this.frameId = this.elem.globalData.frameId;\n    }\n\n    function ShapeProperty(elem, data, type) {\n      this.propType = 'shape';\n      this.comp = elem.comp;\n      this.container = elem;\n      this.elem = elem;\n      this.data = data;\n      this.k = false;\n      this.kf = false;\n      this._mdf = false;\n      var pathData = type === 3 ? data.pt.k : data.ks.k;\n      this.v = shapePool.clone(pathData);\n      this.pv = shapePool.clone(this.v);\n      this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n      this.paths = this.localShapeCollection;\n      this.paths.addShape(this.v);\n      this.reset = resetShape;\n      this.effectsSequence = [];\n    }\n\n    function addEffect(effectFunction) {\n      this.effectsSequence.push(effectFunction);\n      this.container.addDynamicProperty(this);\n    }\n\n    ShapeProperty.prototype.interpolateShape = interpolateShape;\n    ShapeProperty.prototype.getValue = processEffectsSequence;\n    ShapeProperty.prototype.setVValue = setVValue;\n    ShapeProperty.prototype.addEffect = addEffect;\n\n    function KeyframedShapeProperty(elem, data, type) {\n      this.propType = 'shape';\n      this.comp = elem.comp;\n      this.elem = elem;\n      this.container = elem;\n      this.offsetTime = elem.data.st;\n      this.keyframes = type === 3 ? data.pt.k : data.ks.k;\n      this.keyframesMetadata = [];\n      this.k = true;\n      this.kf = true;\n      var len = this.keyframes[0].s[0].i.length;\n      this.v = shapePool.newElement();\n      this.v.setPathData(this.keyframes[0].s[0].c, len);\n      this.pv = shapePool.clone(this.v);\n      this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n      this.paths = this.localShapeCollection;\n      this.paths.addShape(this.v);\n      this.lastFrame = initFrame;\n      this.reset = resetShape;\n      this._caching = {\n        lastFrame: initFrame,\n        lastIndex: 0\n      };\n      this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];\n    }\n\n    KeyframedShapeProperty.prototype.getValue = processEffectsSequence;\n    KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;\n    KeyframedShapeProperty.prototype.setVValue = setVValue;\n    KeyframedShapeProperty.prototype.addEffect = addEffect;\n\n    var EllShapeProperty = function () {\n      var cPoint = roundCorner;\n\n      function EllShapePropertyFactory(elem, data) {\n        this.v = shapePool.newElement();\n        this.v.setPathData(true, 4);\n        this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n        this.paths = this.localShapeCollection;\n        this.localShapeCollection.addShape(this.v);\n        this.d = data.d;\n        this.elem = elem;\n        this.comp = elem.comp;\n        this.frameId = -1;\n        this.initDynamicPropertyContainer(elem);\n        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);\n        this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);\n\n        if (this.dynamicProperties.length) {\n          this.k = true;\n        } else {\n          this.k = false;\n          this.convertEllToPath();\n        }\n      }\n\n      EllShapePropertyFactory.prototype = {\n        reset: resetShape,\n        getValue: function getValue() {\n          if (this.elem.globalData.frameId === this.frameId) {\n            return;\n          }\n\n          this.frameId = this.elem.globalData.frameId;\n          this.iterateDynamicProperties();\n\n          if (this._mdf) {\n            this.convertEllToPath();\n          }\n        },\n        convertEllToPath: function convertEllToPath() {\n          var p0 = this.p.v[0];\n          var p1 = this.p.v[1];\n          var s0 = this.s.v[0] / 2;\n          var s1 = this.s.v[1] / 2;\n\n          var _cw = this.d !== 3;\n\n          var _v = this.v;\n          _v.v[0][0] = p0;\n          _v.v[0][1] = p1 - s1;\n          _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;\n          _v.v[1][1] = p1;\n          _v.v[2][0] = p0;\n          _v.v[2][1] = p1 + s1;\n          _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;\n          _v.v[3][1] = p1;\n          _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;\n          _v.i[0][1] = p1 - s1;\n          _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;\n          _v.i[1][1] = p1 - s1 * cPoint;\n          _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;\n          _v.i[2][1] = p1 + s1;\n          _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;\n          _v.i[3][1] = p1 + s1 * cPoint;\n          _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;\n          _v.o[0][1] = p1 - s1;\n          _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;\n          _v.o[1][1] = p1 + s1 * cPoint;\n          _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;\n          _v.o[2][1] = p1 + s1;\n          _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;\n          _v.o[3][1] = p1 - s1 * cPoint;\n        }\n      };\n      extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);\n      return EllShapePropertyFactory;\n    }();\n\n    var StarShapeProperty = function () {\n      function StarShapePropertyFactory(elem, data) {\n        this.v = shapePool.newElement();\n        this.v.setPathData(true, 0);\n        this.elem = elem;\n        this.comp = elem.comp;\n        this.data = data;\n        this.frameId = -1;\n        this.d = data.d;\n        this.initDynamicPropertyContainer(elem);\n\n        if (data.sy === 1) {\n          this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);\n          this.is = PropertyFactory.getProp(elem, data.is, 0, 0.01, this);\n          this.convertToPath = this.convertStarToPath;\n        } else {\n          this.convertToPath = this.convertPolygonToPath;\n        }\n\n        this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);\n        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);\n        this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);\n        this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);\n        this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this);\n        this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n        this.localShapeCollection.addShape(this.v);\n        this.paths = this.localShapeCollection;\n\n        if (this.dynamicProperties.length) {\n          this.k = true;\n        } else {\n          this.k = false;\n          this.convertToPath();\n        }\n      }\n\n      StarShapePropertyFactory.prototype = {\n        reset: resetShape,\n        getValue: function getValue() {\n          if (this.elem.globalData.frameId === this.frameId) {\n            return;\n          }\n\n          this.frameId = this.elem.globalData.frameId;\n          this.iterateDynamicProperties();\n\n          if (this._mdf) {\n            this.convertToPath();\n          }\n        },\n        convertStarToPath: function convertStarToPath() {\n          var numPts = Math.floor(this.pt.v) * 2;\n          var angle = Math.PI * 2 / numPts;\n          /* this.v.v.length = numPts;\r\n                  this.v.i.length = numPts;\r\n                  this.v.o.length = numPts; */\n\n          var longFlag = true;\n          var longRad = this.or.v;\n          var shortRad = this.ir.v;\n          var longRound = this.os.v;\n          var shortRound = this.is.v;\n          var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);\n          var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);\n          var i;\n          var rad;\n          var roundness;\n          var perimSegment;\n          var currentAng = -Math.PI / 2;\n          currentAng += this.r.v;\n          var dir = this.data.d === 3 ? -1 : 1;\n          this.v._length = 0;\n\n          for (i = 0; i < numPts; i += 1) {\n            rad = longFlag ? longRad : shortRad;\n            roundness = longFlag ? longRound : shortRound;\n            perimSegment = longFlag ? longPerimSegment : shortPerimSegment;\n            var x = rad * Math.cos(currentAng);\n            var y = rad * Math.sin(currentAng);\n            var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);\n            var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);\n            x += +this.p.v[0];\n            y += +this.p.v[1];\n            this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);\n            /* this.v.v[i] = [x,y];\r\n                      this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];\r\n                      this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];\r\n                      this.v._length = numPts; */\n\n            longFlag = !longFlag;\n            currentAng += angle * dir;\n          }\n        },\n        convertPolygonToPath: function convertPolygonToPath() {\n          var numPts = Math.floor(this.pt.v);\n          var angle = Math.PI * 2 / numPts;\n          var rad = this.or.v;\n          var roundness = this.os.v;\n          var perimSegment = 2 * Math.PI * rad / (numPts * 4);\n          var i;\n          var currentAng = -Math.PI * 0.5;\n          var dir = this.data.d === 3 ? -1 : 1;\n          currentAng += this.r.v;\n          this.v._length = 0;\n\n          for (i = 0; i < numPts; i += 1) {\n            var x = rad * Math.cos(currentAng);\n            var y = rad * Math.sin(currentAng);\n            var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);\n            var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);\n            x += +this.p.v[0];\n            y += +this.p.v[1];\n            this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);\n            currentAng += angle * dir;\n          }\n\n          this.paths.length = 0;\n          this.paths[0] = this.v;\n        }\n      };\n      extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);\n      return StarShapePropertyFactory;\n    }();\n\n    var RectShapeProperty = function () {\n      function RectShapePropertyFactory(elem, data) {\n        this.v = shapePool.newElement();\n        this.v.c = true;\n        this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n        this.localShapeCollection.addShape(this.v);\n        this.paths = this.localShapeCollection;\n        this.elem = elem;\n        this.comp = elem.comp;\n        this.frameId = -1;\n        this.d = data.d;\n        this.initDynamicPropertyContainer(elem);\n        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);\n        this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);\n        this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);\n\n        if (this.dynamicProperties.length) {\n          this.k = true;\n        } else {\n          this.k = false;\n          this.convertRectToPath();\n        }\n      }\n\n      RectShapePropertyFactory.prototype = {\n        convertRectToPath: function convertRectToPath() {\n          var p0 = this.p.v[0];\n          var p1 = this.p.v[1];\n          var v0 = this.s.v[0] / 2;\n          var v1 = this.s.v[1] / 2;\n          var round = bmMin(v0, v1, this.r.v);\n          var cPoint = round * (1 - roundCorner);\n          this.v._length = 0;\n\n          if (this.d === 2 || this.d === 1) {\n            this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);\n            this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);\n\n            if (round !== 0) {\n              this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);\n              this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);\n              this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);\n              this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);\n              this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);\n              this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);\n            } else {\n              this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);\n              this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);\n            }\n          } else {\n            this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);\n\n            if (round !== 0) {\n              this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);\n              this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);\n              this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);\n              this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);\n              this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);\n              this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);\n              this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);\n            } else {\n              this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);\n              this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);\n              this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);\n            }\n          }\n        },\n        getValue: function getValue() {\n          if (this.elem.globalData.frameId === this.frameId) {\n            return;\n          }\n\n          this.frameId = this.elem.globalData.frameId;\n          this.iterateDynamicProperties();\n\n          if (this._mdf) {\n            this.convertRectToPath();\n          }\n        },\n        reset: resetShape\n      };\n      extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);\n      return RectShapePropertyFactory;\n    }();\n\n    function getShapeProp(elem, data, type) {\n      var prop;\n\n      if (type === 3 || type === 4) {\n        var dataProp = type === 3 ? data.pt : data.ks;\n        var keys = dataProp.k;\n\n        if (keys.length) {\n          prop = new KeyframedShapeProperty(elem, data, type);\n        } else {\n          prop = new ShapeProperty(elem, data, type);\n        }\n      } else if (type === 5) {\n        prop = new RectShapeProperty(elem, data);\n      } else if (type === 6) {\n        prop = new EllShapeProperty(elem, data);\n      } else if (type === 7) {\n        prop = new StarShapeProperty(elem, data);\n      }\n\n      if (prop.k) {\n        elem.addDynamicProperty(prop);\n      }\n\n      return prop;\n    }\n\n    function getConstructorFunction() {\n      return ShapeProperty;\n    }\n\n    function getKeyframedConstructorFunction() {\n      return KeyframedShapeProperty;\n    }\n\n    var ob = {};\n    ob.getShapeProp = getShapeProp;\n    ob.getConstructorFunction = getConstructorFunction;\n    ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;\n    return ob;\n  }();\n\n  /*!\r\n   Transformation Matrix v2.0\r\n   (c) Epistemex 2014-2015\r\n   www.epistemex.com\r\n   By Ken Fyrstenberg\r\n   Contributions by leeoniya.\r\n   License: MIT, header required.\r\n   */\n\n  /**\r\n   * 2D transformation matrix object initialized with identity matrix.\r\n   *\r\n   * The matrix can synchronize a canvas context by supplying the context\r\n   * as an argument, or later apply current absolute transform to an\r\n   * existing context.\r\n   *\r\n   * All values are handled as floating point values.\r\n   *\r\n   * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix\r\n   * @prop {number} a - scale x\r\n   * @prop {number} b - shear y\r\n   * @prop {number} c - shear x\r\n   * @prop {number} d - scale y\r\n   * @prop {number} e - translate x\r\n   * @prop {number} f - translate y\r\n   * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context\r\n   * @constructor\r\n   */\n\n  var Matrix = function () {\n    var _cos = Math.cos;\n    var _sin = Math.sin;\n    var _tan = Math.tan;\n    var _rnd = Math.round;\n\n    function reset() {\n      this.props[0] = 1;\n      this.props[1] = 0;\n      this.props[2] = 0;\n      this.props[3] = 0;\n      this.props[4] = 0;\n      this.props[5] = 1;\n      this.props[6] = 0;\n      this.props[7] = 0;\n      this.props[8] = 0;\n      this.props[9] = 0;\n      this.props[10] = 1;\n      this.props[11] = 0;\n      this.props[12] = 0;\n      this.props[13] = 0;\n      this.props[14] = 0;\n      this.props[15] = 1;\n      return this;\n    }\n\n    function rotate(angle) {\n      if (angle === 0) {\n        return this;\n      }\n\n      var mCos = _cos(angle);\n\n      var mSin = _sin(angle);\n\n      return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    }\n\n    function rotateX(angle) {\n      if (angle === 0) {\n        return this;\n      }\n\n      var mCos = _cos(angle);\n\n      var mSin = _sin(angle);\n\n      return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);\n    }\n\n    function rotateY(angle) {\n      if (angle === 0) {\n        return this;\n      }\n\n      var mCos = _cos(angle);\n\n      var mSin = _sin(angle);\n\n      return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);\n    }\n\n    function rotateZ(angle) {\n      if (angle === 0) {\n        return this;\n      }\n\n      var mCos = _cos(angle);\n\n      var mSin = _sin(angle);\n\n      return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    }\n\n    function shear(sx, sy) {\n      return this._t(1, sy, sx, 1, 0, 0);\n    }\n\n    function skew(ax, ay) {\n      return this.shear(_tan(ax), _tan(ay));\n    }\n\n    function skewFromAxis(ax, angle) {\n      var mCos = _cos(angle);\n\n      var mSin = _sin(angle);\n\n      return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); // return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);\n    }\n\n    function scale(sx, sy, sz) {\n      if (!sz && sz !== 0) {\n        sz = 1;\n      }\n\n      if (sx === 1 && sy === 1 && sz === 1) {\n        return this;\n      }\n\n      return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);\n    }\n\n    function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {\n      this.props[0] = a;\n      this.props[1] = b;\n      this.props[2] = c;\n      this.props[3] = d;\n      this.props[4] = e;\n      this.props[5] = f;\n      this.props[6] = g;\n      this.props[7] = h;\n      this.props[8] = i;\n      this.props[9] = j;\n      this.props[10] = k;\n      this.props[11] = l;\n      this.props[12] = m;\n      this.props[13] = n;\n      this.props[14] = o;\n      this.props[15] = p;\n      return this;\n    }\n\n    function translate(tx, ty, tz) {\n      tz = tz || 0;\n\n      if (tx !== 0 || ty !== 0 || tz !== 0) {\n        return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);\n      }\n\n      return this;\n    }\n\n    function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {\n      var _p = this.props;\n\n      if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {\n        // NOTE: commenting this condition because TurboFan deoptimizes code when present\n        // if(m2 !== 0 || n2 !== 0 || o2 !== 0){\n        _p[12] = _p[12] * a2 + _p[15] * m2;\n        _p[13] = _p[13] * f2 + _p[15] * n2;\n        _p[14] = _p[14] * k2 + _p[15] * o2;\n        _p[15] *= p2; // }\n\n        this._identityCalculated = false;\n        return this;\n      }\n\n      var a1 = _p[0];\n      var b1 = _p[1];\n      var c1 = _p[2];\n      var d1 = _p[3];\n      var e1 = _p[4];\n      var f1 = _p[5];\n      var g1 = _p[6];\n      var h1 = _p[7];\n      var i1 = _p[8];\n      var j1 = _p[9];\n      var k1 = _p[10];\n      var l1 = _p[11];\n      var m1 = _p[12];\n      var n1 = _p[13];\n      var o1 = _p[14];\n      var p1 = _p[15];\n      /* matrix order (canvas compatible):\r\n           * ace\r\n           * bdf\r\n           * 001\r\n           */\n\n      _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;\n      _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;\n      _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;\n      _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;\n      _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;\n      _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;\n      _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;\n      _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;\n      _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;\n      _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;\n      _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;\n      _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;\n      _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;\n      _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;\n      _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;\n      _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;\n      this._identityCalculated = false;\n      return this;\n    }\n\n    function multiply(matrix) {\n      var matrixProps = matrix.props;\n      return this.transform(matrixProps[0], matrixProps[1], matrixProps[2], matrixProps[3], matrixProps[4], matrixProps[5], matrixProps[6], matrixProps[7], matrixProps[8], matrixProps[9], matrixProps[10], matrixProps[11], matrixProps[12], matrixProps[13], matrixProps[14], matrixProps[15]);\n    }\n\n    function isIdentity() {\n      if (!this._identityCalculated) {\n        this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);\n        this._identityCalculated = true;\n      }\n\n      return this._identity;\n    }\n\n    function equals(matr) {\n      var i = 0;\n\n      while (i < 16) {\n        if (matr.props[i] !== this.props[i]) {\n          return false;\n        }\n\n        i += 1;\n      }\n\n      return true;\n    }\n\n    function clone(matr) {\n      var i;\n\n      for (i = 0; i < 16; i += 1) {\n        matr.props[i] = this.props[i];\n      }\n\n      return matr;\n    }\n\n    function cloneFromProps(props) {\n      var i;\n\n      for (i = 0; i < 16; i += 1) {\n        this.props[i] = props[i];\n      }\n    }\n\n    function applyToPoint(x, y, z) {\n      return {\n        x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],\n        y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],\n        z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]\n      };\n      /* return {\r\n           x: x * me.a + y * me.c + me.e,\r\n           y: x * me.b + y * me.d + me.f\r\n           }; */\n    }\n\n    function applyToX(x, y, z) {\n      return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];\n    }\n\n    function applyToY(x, y, z) {\n      return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];\n    }\n\n    function applyToZ(x, y, z) {\n      return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];\n    }\n\n    function getInverseMatrix() {\n      var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];\n      var a = this.props[5] / determinant;\n      var b = -this.props[1] / determinant;\n      var c = -this.props[4] / determinant;\n      var d = this.props[0] / determinant;\n      var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;\n      var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;\n      var inverseMatrix = new Matrix();\n      inverseMatrix.props[0] = a;\n      inverseMatrix.props[1] = b;\n      inverseMatrix.props[4] = c;\n      inverseMatrix.props[5] = d;\n      inverseMatrix.props[12] = e;\n      inverseMatrix.props[13] = f;\n      return inverseMatrix;\n    }\n\n    function inversePoint(pt) {\n      var inverseMatrix = this.getInverseMatrix();\n      return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);\n    }\n\n    function inversePoints(pts) {\n      var i;\n      var len = pts.length;\n      var retPts = [];\n\n      for (i = 0; i < len; i += 1) {\n        retPts[i] = inversePoint(pts[i]);\n      }\n\n      return retPts;\n    }\n\n    function applyToTriplePoints(pt1, pt2, pt3) {\n      var arr = createTypedArray('float32', 6);\n\n      if (this.isIdentity()) {\n        arr[0] = pt1[0];\n        arr[1] = pt1[1];\n        arr[2] = pt2[0];\n        arr[3] = pt2[1];\n        arr[4] = pt3[0];\n        arr[5] = pt3[1];\n      } else {\n        var p0 = this.props[0];\n        var p1 = this.props[1];\n        var p4 = this.props[4];\n        var p5 = this.props[5];\n        var p12 = this.props[12];\n        var p13 = this.props[13];\n        arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;\n        arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;\n        arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;\n        arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;\n        arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;\n        arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;\n      }\n\n      return arr;\n    }\n\n    function applyToPointArray(x, y, z) {\n      var arr;\n\n      if (this.isIdentity()) {\n        arr = [x, y, z];\n      } else {\n        arr = [x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12], x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13], x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]];\n      }\n\n      return arr;\n    }\n\n    function applyToPointStringified(x, y) {\n      if (this.isIdentity()) {\n        return x + ',' + y;\n      }\n\n      var _p = this.props;\n      return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + ',' + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;\n    }\n\n    function toCSS() {\n      // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.\n\n      /* if(this.isIdentity()) {\r\n              return '';\r\n          } */\n      var i = 0;\n      var props = this.props;\n      var cssValue = 'matrix3d(';\n      var v = 10000;\n\n      while (i < 16) {\n        cssValue += _rnd(props[i] * v) / v;\n        cssValue += i === 15 ? ')' : ',';\n        i += 1;\n      }\n\n      return cssValue;\n    }\n\n    function roundMatrixProperty(val) {\n      var v = 10000;\n\n      if (val < 0.000001 && val > 0 || val > -0.000001 && val < 0) {\n        return _rnd(val * v) / v;\n      }\n\n      return val;\n    }\n\n    function to2dCSS() {\n      // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.\n\n      /* if(this.isIdentity()) {\r\n              return '';\r\n          } */\n      var props = this.props;\n\n      var _a = roundMatrixProperty(props[0]);\n\n      var _b = roundMatrixProperty(props[1]);\n\n      var _c = roundMatrixProperty(props[4]);\n\n      var _d = roundMatrixProperty(props[5]);\n\n      var _e = roundMatrixProperty(props[12]);\n\n      var _f = roundMatrixProperty(props[13]);\n\n      return 'matrix(' + _a + ',' + _b + ',' + _c + ',' + _d + ',' + _e + ',' + _f + ')';\n    }\n\n    return function () {\n      this.reset = reset;\n      this.rotate = rotate;\n      this.rotateX = rotateX;\n      this.rotateY = rotateY;\n      this.rotateZ = rotateZ;\n      this.skew = skew;\n      this.skewFromAxis = skewFromAxis;\n      this.shear = shear;\n      this.scale = scale;\n      this.setTransform = setTransform;\n      this.translate = translate;\n      this.transform = transform;\n      this.multiply = multiply;\n      this.applyToPoint = applyToPoint;\n      this.applyToX = applyToX;\n      this.applyToY = applyToY;\n      this.applyToZ = applyToZ;\n      this.applyToPointArray = applyToPointArray;\n      this.applyToTriplePoints = applyToTriplePoints;\n      this.applyToPointStringified = applyToPointStringified;\n      this.toCSS = toCSS;\n      this.to2dCSS = to2dCSS;\n      this.clone = clone;\n      this.cloneFromProps = cloneFromProps;\n      this.equals = equals;\n      this.inversePoints = inversePoints;\n      this.inversePoint = inversePoint;\n      this.getInverseMatrix = getInverseMatrix;\n      this._t = this.transform;\n      this.isIdentity = isIdentity;\n      this._identity = true;\n      this._identityCalculated = false;\n      this.props = createTypedArray('float32', 16);\n      this.reset();\n    };\n  }();\n\n  function _typeof$3(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof$3 = function _typeof(obj) { return typeof obj; }; } else { _typeof$3 = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof$3(obj); }\n  var lottie = {};\n  var standalone = '__[STANDALONE]__';\n  var animationData = '__[ANIMATIONDATA]__';\n  var renderer = '';\n\n  function setLocation(href) {\n    setLocationHref(href);\n  }\n\n  function searchAnimations() {\n    if (standalone === true) {\n      animationManager.searchAnimations(animationData, standalone, renderer);\n    } else {\n      animationManager.searchAnimations();\n    }\n  }\n\n  function setSubframeRendering(flag) {\n    setSubframeEnabled(flag);\n  }\n\n  function setPrefix(prefix) {\n    setIdPrefix(prefix);\n  }\n\n  function loadAnimation(params) {\n    if (standalone === true) {\n      params.animationData = JSON.parse(animationData);\n    }\n\n    return animationManager.loadAnimation(params);\n  }\n\n  function setQuality(value) {\n    if (typeof value === 'string') {\n      switch (value) {\n        case 'high':\n          setDefaultCurveSegments(200);\n          break;\n\n        default:\n        case 'medium':\n          setDefaultCurveSegments(50);\n          break;\n\n        case 'low':\n          setDefaultCurveSegments(10);\n          break;\n      }\n    } else if (!isNaN(value) && value > 1) {\n      setDefaultCurveSegments(value);\n    }\n\n    if (getDefaultCurveSegments() >= 50) {\n      roundValues(false);\n    } else {\n      roundValues(true);\n    }\n  }\n\n  function inBrowser() {\n    return typeof navigator !== 'undefined';\n  }\n\n  function installPlugin(type, plugin) {\n    if (type === 'expressions') {\n      setExpressionsPlugin(plugin);\n    }\n  }\n\n  function getFactory(name) {\n    switch (name) {\n      case 'propertyFactory':\n        return PropertyFactory;\n\n      case 'shapePropertyFactory':\n        return ShapePropertyFactory;\n\n      case 'matrix':\n        return Matrix;\n\n      default:\n        return null;\n    }\n  }\n\n  lottie.play = animationManager.play;\n  lottie.pause = animationManager.pause;\n  lottie.setLocationHref = setLocation;\n  lottie.togglePause = animationManager.togglePause;\n  lottie.setSpeed = animationManager.setSpeed;\n  lottie.setDirection = animationManager.setDirection;\n  lottie.stop = animationManager.stop;\n  lottie.searchAnimations = searchAnimations;\n  lottie.registerAnimation = animationManager.registerAnimation;\n  lottie.loadAnimation = loadAnimation;\n  lottie.setSubframeRendering = setSubframeRendering;\n  lottie.resize = animationManager.resize; // lottie.start = start;\n\n  lottie.goToAndStop = animationManager.goToAndStop;\n  lottie.destroy = animationManager.destroy;\n  lottie.setQuality = setQuality;\n  lottie.inBrowser = inBrowser;\n  lottie.installPlugin = installPlugin;\n  lottie.freeze = animationManager.freeze;\n  lottie.unfreeze = animationManager.unfreeze;\n  lottie.setVolume = animationManager.setVolume;\n  lottie.mute = animationManager.mute;\n  lottie.unmute = animationManager.unmute;\n  lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;\n  lottie.useWebWorker = setWebWorker;\n  lottie.setIDPrefix = setPrefix;\n  lottie.__getFactory = getFactory;\n  lottie.version = '5.12.2';\n\n  function checkReady() {\n    if (document.readyState === 'complete') {\n      clearInterval(readyStateCheckInterval);\n      searchAnimations();\n    }\n  }\n\n  function getQueryVariable(variable) {\n    var vars = queryString.split('&');\n\n    for (var i = 0; i < vars.length; i += 1) {\n      var pair = vars[i].split('=');\n\n      if (decodeURIComponent(pair[0]) == variable) {\n        // eslint-disable-line eqeqeq\n        return decodeURIComponent(pair[1]);\n      }\n    }\n\n    return null;\n  }\n\n  var queryString = '';\n\n  if (standalone) {\n    var scripts = document.getElementsByTagName('script');\n    var index = scripts.length - 1;\n    var myScript = scripts[index] || {\n      src: ''\n    };\n    queryString = myScript.src ? myScript.src.replace(/^[^\\?]+\\??/, '') : ''; // eslint-disable-line no-useless-escape\n\n    renderer = getQueryVariable('renderer');\n  }\n\n  var readyStateCheckInterval = setInterval(checkReady, 100); // this adds bodymovin to the window object for backwards compatibility\n\n  try {\n    if (!(( false ? 0 : _typeof$3(exports)) === 'object' && \"object\" !== 'undefined') && !( true && __webpack_require__.amdO) // eslint-disable-line no-undef\n    ) {}\n  } catch (err) {//\n  }\n\n  var ShapeModifiers = function () {\n    var ob = {};\n    var modifiers = {};\n    ob.registerModifier = registerModifier;\n    ob.getModifier = getModifier;\n\n    function registerModifier(nm, factory) {\n      if (!modifiers[nm]) {\n        modifiers[nm] = factory;\n      }\n    }\n\n    function getModifier(nm, elem, data) {\n      return new modifiers[nm](elem, data);\n    }\n\n    return ob;\n  }();\n\n  function ShapeModifier() {}\n\n  ShapeModifier.prototype.initModifierProperties = function () {};\n\n  ShapeModifier.prototype.addShapeToModifier = function () {};\n\n  ShapeModifier.prototype.addShape = function (data) {\n    if (!this.closed) {\n      // Adding shape to dynamic properties. It covers the case where a shape has no effects applied, to reset it's _mdf state on every tick.\n      data.sh.container.addDynamicProperty(data.sh);\n      var shapeData = {\n        shape: data.sh,\n        data: data,\n        localShapeCollection: shapeCollectionPool.newShapeCollection()\n      };\n      this.shapes.push(shapeData);\n      this.addShapeToModifier(shapeData);\n\n      if (this._isAnimated) {\n        data.setAsAnimated();\n      }\n    }\n  };\n\n  ShapeModifier.prototype.init = function (elem, data) {\n    this.shapes = [];\n    this.elem = elem;\n    this.initDynamicPropertyContainer(elem);\n    this.initModifierProperties(elem, data);\n    this.frameId = initialDefaultFrame;\n    this.closed = false;\n    this.k = false;\n\n    if (this.dynamicProperties.length) {\n      this.k = true;\n    } else {\n      this.getValue(true);\n    }\n  };\n\n  ShapeModifier.prototype.processKeys = function () {\n    if (this.elem.globalData.frameId === this.frameId) {\n      return;\n    }\n\n    this.frameId = this.elem.globalData.frameId;\n    this.iterateDynamicProperties();\n  };\n\n  extendPrototype([DynamicPropertyContainer], ShapeModifier);\n\n  function TrimModifier() {}\n\n  extendPrototype([ShapeModifier], TrimModifier);\n\n  TrimModifier.prototype.initModifierProperties = function (elem, data) {\n    this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);\n    this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);\n    this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);\n    this.sValue = 0;\n    this.eValue = 0;\n    this.getValue = this.processKeys;\n    this.m = data.m;\n    this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;\n  };\n\n  TrimModifier.prototype.addShapeToModifier = function (shapeData) {\n    shapeData.pathsData = [];\n  };\n\n  TrimModifier.prototype.calculateShapeEdges = function (s, e, shapeLength, addedLength, totalModifierLength) {\n    var segments = [];\n\n    if (e <= 1) {\n      segments.push({\n        s: s,\n        e: e\n      });\n    } else if (s >= 1) {\n      segments.push({\n        s: s - 1,\n        e: e - 1\n      });\n    } else {\n      segments.push({\n        s: s,\n        e: 1\n      });\n      segments.push({\n        s: 0,\n        e: e - 1\n      });\n    }\n\n    var shapeSegments = [];\n    var i;\n    var len = segments.length;\n    var segmentOb;\n\n    for (i = 0; i < len; i += 1) {\n      segmentOb = segments[i];\n\n      if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {\n        var shapeS;\n        var shapeE;\n\n        if (segmentOb.s * totalModifierLength <= addedLength) {\n          shapeS = 0;\n        } else {\n          shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;\n        }\n\n        if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {\n          shapeE = 1;\n        } else {\n          shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;\n        }\n\n        shapeSegments.push([shapeS, shapeE]);\n      }\n    }\n\n    if (!shapeSegments.length) {\n      shapeSegments.push([0, 0]);\n    }\n\n    return shapeSegments;\n  };\n\n  TrimModifier.prototype.releasePathsData = function (pathsData) {\n    var i;\n    var len = pathsData.length;\n\n    for (i = 0; i < len; i += 1) {\n      segmentsLengthPool.release(pathsData[i]);\n    }\n\n    pathsData.length = 0;\n    return pathsData;\n  };\n\n  TrimModifier.prototype.processShapes = function (_isFirstFrame) {\n    var s;\n    var e;\n\n    if (this._mdf || _isFirstFrame) {\n      var o = this.o.v % 360 / 360;\n\n      if (o < 0) {\n        o += 1;\n      }\n\n      if (this.s.v > 1) {\n        s = 1 + o;\n      } else if (this.s.v < 0) {\n        s = 0 + o;\n      } else {\n        s = this.s.v + o;\n      }\n\n      if (this.e.v > 1) {\n        e = 1 + o;\n      } else if (this.e.v < 0) {\n        e = 0 + o;\n      } else {\n        e = this.e.v + o;\n      }\n\n      if (s > e) {\n        var _s = s;\n        s = e;\n        e = _s;\n      }\n\n      s = Math.round(s * 10000) * 0.0001;\n      e = Math.round(e * 10000) * 0.0001;\n      this.sValue = s;\n      this.eValue = e;\n    } else {\n      s = this.sValue;\n      e = this.eValue;\n    }\n\n    var shapePaths;\n    var i;\n    var len = this.shapes.length;\n    var j;\n    var jLen;\n    var pathsData;\n    var pathData;\n    var totalShapeLength;\n    var totalModifierLength = 0;\n\n    if (e === s) {\n      for (i = 0; i < len; i += 1) {\n        this.shapes[i].localShapeCollection.releaseShapes();\n        this.shapes[i].shape._mdf = true;\n        this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;\n\n        if (this._mdf) {\n          this.shapes[i].pathsData.length = 0;\n        }\n      }\n    } else if (!(e === 1 && s === 0 || e === 0 && s === 1)) {\n      var segments = [];\n      var shapeData;\n      var localShapeCollection;\n\n      for (i = 0; i < len; i += 1) {\n        shapeData = this.shapes[i]; // if shape hasn't changed and trim properties haven't changed, cached previous path can be used\n\n        if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {\n          shapeData.shape.paths = shapeData.localShapeCollection;\n        } else {\n          shapePaths = shapeData.shape.paths;\n          jLen = shapePaths._length;\n          totalShapeLength = 0;\n\n          if (!shapeData.shape._mdf && shapeData.pathsData.length) {\n            totalShapeLength = shapeData.totalShapeLength;\n          } else {\n            pathsData = this.releasePathsData(shapeData.pathsData);\n\n            for (j = 0; j < jLen; j += 1) {\n              pathData = bez.getSegmentsLength(shapePaths.shapes[j]);\n              pathsData.push(pathData);\n              totalShapeLength += pathData.totalLength;\n            }\n\n            shapeData.totalShapeLength = totalShapeLength;\n            shapeData.pathsData = pathsData;\n          }\n\n          totalModifierLength += totalShapeLength;\n          shapeData.shape._mdf = true;\n        }\n      }\n\n      var shapeS = s;\n      var shapeE = e;\n      var addedLength = 0;\n      var edges;\n\n      for (i = len - 1; i >= 0; i -= 1) {\n        shapeData = this.shapes[i];\n\n        if (shapeData.shape._mdf) {\n          localShapeCollection = shapeData.localShapeCollection;\n          localShapeCollection.releaseShapes(); // if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group\n\n          if (this.m === 2 && len > 1) {\n            edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);\n            addedLength += shapeData.totalShapeLength;\n          } else {\n            edges = [[shapeS, shapeE]];\n          }\n\n          jLen = edges.length;\n\n          for (j = 0; j < jLen; j += 1) {\n            shapeS = edges[j][0];\n            shapeE = edges[j][1];\n            segments.length = 0;\n\n            if (shapeE <= 1) {\n              segments.push({\n                s: shapeData.totalShapeLength * shapeS,\n                e: shapeData.totalShapeLength * shapeE\n              });\n            } else if (shapeS >= 1) {\n              segments.push({\n                s: shapeData.totalShapeLength * (shapeS - 1),\n                e: shapeData.totalShapeLength * (shapeE - 1)\n              });\n            } else {\n              segments.push({\n                s: shapeData.totalShapeLength * shapeS,\n                e: shapeData.totalShapeLength\n              });\n              segments.push({\n                s: 0,\n                e: shapeData.totalShapeLength * (shapeE - 1)\n              });\n            }\n\n            var newShapesData = this.addShapes(shapeData, segments[0]);\n\n            if (segments[0].s !== segments[0].e) {\n              if (segments.length > 1) {\n                var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];\n\n                if (lastShapeInCollection.c) {\n                  var lastShape = newShapesData.pop();\n                  this.addPaths(newShapesData, localShapeCollection);\n                  newShapesData = this.addShapes(shapeData, segments[1], lastShape);\n                } else {\n                  this.addPaths(newShapesData, localShapeCollection);\n                  newShapesData = this.addShapes(shapeData, segments[1]);\n                }\n              }\n\n              this.addPaths(newShapesData, localShapeCollection);\n            }\n          }\n\n          shapeData.shape.paths = localShapeCollection;\n        }\n      }\n    } else if (this._mdf) {\n      for (i = 0; i < len; i += 1) {\n        // Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.\n        // Don't remove this even if it's losing cached info.\n        this.shapes[i].pathsData.length = 0;\n        this.shapes[i].shape._mdf = true;\n      }\n    }\n  };\n\n  TrimModifier.prototype.addPaths = function (newPaths, localShapeCollection) {\n    var i;\n    var len = newPaths.length;\n\n    for (i = 0; i < len; i += 1) {\n      localShapeCollection.addShape(newPaths[i]);\n    }\n  };\n\n  TrimModifier.prototype.addSegment = function (pt1, pt2, pt3, pt4, shapePath, pos, newShape) {\n    shapePath.setXYAt(pt2[0], pt2[1], 'o', pos);\n    shapePath.setXYAt(pt3[0], pt3[1], 'i', pos + 1);\n\n    if (newShape) {\n      shapePath.setXYAt(pt1[0], pt1[1], 'v', pos);\n    }\n\n    shapePath.setXYAt(pt4[0], pt4[1], 'v', pos + 1);\n  };\n\n  TrimModifier.prototype.addSegmentFromArray = function (points, shapePath, pos, newShape) {\n    shapePath.setXYAt(points[1], points[5], 'o', pos);\n    shapePath.setXYAt(points[2], points[6], 'i', pos + 1);\n\n    if (newShape) {\n      shapePath.setXYAt(points[0], points[4], 'v', pos);\n    }\n\n    shapePath.setXYAt(points[3], points[7], 'v', pos + 1);\n  };\n\n  TrimModifier.prototype.addShapes = function (shapeData, shapeSegment, shapePath) {\n    var pathsData = shapeData.pathsData;\n    var shapePaths = shapeData.shape.paths.shapes;\n    var i;\n    var len = shapeData.shape.paths._length;\n    var j;\n    var jLen;\n    var addedLength = 0;\n    var currentLengthData;\n    var segmentCount;\n    var lengths;\n    var segment;\n    var shapes = [];\n    var initPos;\n    var newShape = true;\n\n    if (!shapePath) {\n      shapePath = shapePool.newElement();\n      segmentCount = 0;\n      initPos = 0;\n    } else {\n      segmentCount = shapePath._length;\n      initPos = shapePath._length;\n    }\n\n    shapes.push(shapePath);\n\n    for (i = 0; i < len; i += 1) {\n      lengths = pathsData[i].lengths;\n      shapePath.c = shapePaths[i].c;\n      jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;\n\n      for (j = 1; j < jLen; j += 1) {\n        currentLengthData = lengths[j - 1];\n\n        if (addedLength + currentLengthData.addedLength < shapeSegment.s) {\n          addedLength += currentLengthData.addedLength;\n          shapePath.c = false;\n        } else if (addedLength > shapeSegment.e) {\n          shapePath.c = false;\n          break;\n        } else {\n          if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {\n            this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);\n            newShape = false;\n          } else {\n            segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);\n            this.addSegmentFromArray(segment, shapePath, segmentCount, newShape); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);\n\n            newShape = false;\n            shapePath.c = false;\n          }\n\n          addedLength += currentLengthData.addedLength;\n          segmentCount += 1;\n        }\n      }\n\n      if (shapePaths[i].c && lengths.length) {\n        currentLengthData = lengths[j - 1];\n\n        if (addedLength <= shapeSegment.e) {\n          var segmentLength = lengths[j - 1].addedLength;\n\n          if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {\n            this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);\n            newShape = false;\n          } else {\n            segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);\n            this.addSegmentFromArray(segment, shapePath, segmentCount, newShape); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);\n\n            newShape = false;\n            shapePath.c = false;\n          }\n        } else {\n          shapePath.c = false;\n        }\n\n        addedLength += currentLengthData.addedLength;\n        segmentCount += 1;\n      }\n\n      if (shapePath._length) {\n        shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], 'i', initPos);\n        shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], 'o', shapePath._length - 1);\n      }\n\n      if (addedLength > shapeSegment.e) {\n        break;\n      }\n\n      if (i < len - 1) {\n        shapePath = shapePool.newElement();\n        newShape = true;\n        shapes.push(shapePath);\n        segmentCount = 0;\n      }\n    }\n\n    return shapes;\n  };\n\n  function PuckerAndBloatModifier() {}\n\n  extendPrototype([ShapeModifier], PuckerAndBloatModifier);\n\n  PuckerAndBloatModifier.prototype.initModifierProperties = function (elem, data) {\n    this.getValue = this.processKeys;\n    this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);\n    this._isAnimated = !!this.amount.effectsSequence.length;\n  };\n\n  PuckerAndBloatModifier.prototype.processPath = function (path, amount) {\n    var percent = amount / 100;\n    var centerPoint = [0, 0];\n    var pathLength = path._length;\n    var i = 0;\n\n    for (i = 0; i < pathLength; i += 1) {\n      centerPoint[0] += path.v[i][0];\n      centerPoint[1] += path.v[i][1];\n    }\n\n    centerPoint[0] /= pathLength;\n    centerPoint[1] /= pathLength;\n    var clonedPath = shapePool.newElement();\n    clonedPath.c = path.c;\n    var vX;\n    var vY;\n    var oX;\n    var oY;\n    var iX;\n    var iY;\n\n    for (i = 0; i < pathLength; i += 1) {\n      vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;\n      vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;\n      oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;\n      oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;\n      iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;\n      iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;\n      clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);\n    }\n\n    return clonedPath;\n  };\n\n  PuckerAndBloatModifier.prototype.processShapes = function (_isFirstFrame) {\n    var shapePaths;\n    var i;\n    var len = this.shapes.length;\n    var j;\n    var jLen;\n    var amount = this.amount.v;\n\n    if (amount !== 0) {\n      var shapeData;\n      var localShapeCollection;\n\n      for (i = 0; i < len; i += 1) {\n        shapeData = this.shapes[i];\n        localShapeCollection = shapeData.localShapeCollection;\n\n        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n          localShapeCollection.releaseShapes();\n          shapeData.shape._mdf = true;\n          shapePaths = shapeData.shape.paths.shapes;\n          jLen = shapeData.shape.paths._length;\n\n          for (j = 0; j < jLen; j += 1) {\n            localShapeCollection.addShape(this.processPath(shapePaths[j], amount));\n          }\n        }\n\n        shapeData.shape.paths = shapeData.localShapeCollection;\n      }\n    }\n\n    if (!this.dynamicProperties.length) {\n      this._mdf = false;\n    }\n  };\n\n  var TransformPropertyFactory = function () {\n    var defaultVector = [0, 0];\n\n    function applyToMatrix(mat) {\n      var _mdf = this._mdf;\n      this.iterateDynamicProperties();\n      this._mdf = this._mdf || _mdf;\n\n      if (this.a) {\n        mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);\n      }\n\n      if (this.s) {\n        mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);\n      }\n\n      if (this.sk) {\n        mat.skewFromAxis(-this.sk.v, this.sa.v);\n      }\n\n      if (this.r) {\n        mat.rotate(-this.r.v);\n      } else {\n        mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);\n      }\n\n      if (this.data.p.s) {\n        if (this.data.p.z) {\n          mat.translate(this.px.v, this.py.v, -this.pz.v);\n        } else {\n          mat.translate(this.px.v, this.py.v, 0);\n        }\n      } else {\n        mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);\n      }\n    }\n\n    function processKeys(forceRender) {\n      if (this.elem.globalData.frameId === this.frameId) {\n        return;\n      }\n\n      if (this._isDirty) {\n        this.precalculateMatrix();\n        this._isDirty = false;\n      }\n\n      this.iterateDynamicProperties();\n\n      if (this._mdf || forceRender) {\n        var frameRate;\n        this.v.cloneFromProps(this.pre.props);\n\n        if (this.appliedTransformations < 1) {\n          this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);\n        }\n\n        if (this.appliedTransformations < 2) {\n          this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);\n        }\n\n        if (this.sk && this.appliedTransformations < 3) {\n          this.v.skewFromAxis(-this.sk.v, this.sa.v);\n        }\n\n        if (this.r && this.appliedTransformations < 4) {\n          this.v.rotate(-this.r.v);\n        } else if (!this.r && this.appliedTransformations < 4) {\n          this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);\n        }\n\n        if (this.autoOriented) {\n          var v1;\n          var v2;\n          frameRate = this.elem.globalData.frameRate;\n\n          if (this.p && this.p.keyframes && this.p.getValueAtTime) {\n            if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {\n              v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);\n              v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);\n            } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {\n              v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);\n              v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);\n            } else {\n              v1 = this.p.pv;\n              v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);\n            }\n          } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {\n            v1 = [];\n            v2 = [];\n            var px = this.px;\n            var py = this.py;\n\n            if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {\n              v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);\n              v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);\n              v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);\n              v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);\n            } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {\n              v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);\n              v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);\n              v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);\n              v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);\n            } else {\n              v1 = [px.pv, py.pv];\n              v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);\n              v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);\n            }\n          } else {\n            v2 = defaultVector;\n            v1 = v2;\n          }\n\n          this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));\n        }\n\n        if (this.data.p && this.data.p.s) {\n          if (this.data.p.z) {\n            this.v.translate(this.px.v, this.py.v, -this.pz.v);\n          } else {\n            this.v.translate(this.px.v, this.py.v, 0);\n          }\n        } else {\n          this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);\n        }\n      }\n\n      this.frameId = this.elem.globalData.frameId;\n    }\n\n    function precalculateMatrix() {\n      this.appliedTransformations = 0;\n      this.pre.reset();\n\n      if (!this.a.effectsSequence.length) {\n        this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);\n        this.appliedTransformations = 1;\n      } else {\n        return;\n      }\n\n      if (!this.s.effectsSequence.length) {\n        this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);\n        this.appliedTransformations = 2;\n      } else {\n        return;\n      }\n\n      if (this.sk) {\n        if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {\n          this.pre.skewFromAxis(-this.sk.v, this.sa.v);\n          this.appliedTransformations = 3;\n        } else {\n          return;\n        }\n      }\n\n      if (this.r) {\n        if (!this.r.effectsSequence.length) {\n          this.pre.rotate(-this.r.v);\n          this.appliedTransformations = 4;\n        }\n      } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {\n        this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);\n        this.appliedTransformations = 4;\n      }\n    }\n\n    function autoOrient() {//\n      // var prevP = this.getValueAtTime();\n    }\n\n    function addDynamicProperty(prop) {\n      this._addDynamicProperty(prop);\n\n      this.elem.addDynamicProperty(prop);\n      this._isDirty = true;\n    }\n\n    function TransformProperty(elem, data, container) {\n      this.elem = elem;\n      this.frameId = -1;\n      this.propType = 'transform';\n      this.data = data;\n      this.v = new Matrix(); // Precalculated matrix with non animated properties\n\n      this.pre = new Matrix();\n      this.appliedTransformations = 0;\n      this.initDynamicPropertyContainer(container || elem);\n\n      if (data.p && data.p.s) {\n        this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);\n        this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);\n\n        if (data.p.z) {\n          this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);\n        }\n      } else {\n        this.p = PropertyFactory.getProp(elem, data.p || {\n          k: [0, 0, 0]\n        }, 1, 0, this);\n      }\n\n      if (data.rx) {\n        this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);\n        this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);\n        this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);\n\n        if (data.or.k[0].ti) {\n          var i;\n          var len = data.or.k.length;\n\n          for (i = 0; i < len; i += 1) {\n            data.or.k[i].to = null;\n            data.or.k[i].ti = null;\n          }\n        }\n\n        this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this); // sh Indicates it needs to be capped between -180 and 180\n\n        this.or.sh = true;\n      } else {\n        this.r = PropertyFactory.getProp(elem, data.r || {\n          k: 0\n        }, 0, degToRads, this);\n      }\n\n      if (data.sk) {\n        this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);\n        this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);\n      }\n\n      this.a = PropertyFactory.getProp(elem, data.a || {\n        k: [0, 0, 0]\n      }, 1, 0, this);\n      this.s = PropertyFactory.getProp(elem, data.s || {\n        k: [100, 100, 100]\n      }, 1, 0.01, this); // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.\n\n      if (data.o) {\n        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem);\n      } else {\n        this.o = {\n          _mdf: false,\n          v: 1\n        };\n      }\n\n      this._isDirty = true;\n\n      if (!this.dynamicProperties.length) {\n        this.getValue(true);\n      }\n    }\n\n    TransformProperty.prototype = {\n      applyToMatrix: applyToMatrix,\n      getValue: processKeys,\n      precalculateMatrix: precalculateMatrix,\n      autoOrient: autoOrient\n    };\n    extendPrototype([DynamicPropertyContainer], TransformProperty);\n    TransformProperty.prototype.addDynamicProperty = addDynamicProperty;\n    TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;\n\n    function getTransformProperty(elem, data, container) {\n      return new TransformProperty(elem, data, container);\n    }\n\n    return {\n      getTransformProperty: getTransformProperty\n    };\n  }();\n\n  function RepeaterModifier() {}\n\n  extendPrototype([ShapeModifier], RepeaterModifier);\n\n  RepeaterModifier.prototype.initModifierProperties = function (elem, data) {\n    this.getValue = this.processKeys;\n    this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);\n    this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);\n    this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this);\n    this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this);\n    this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this);\n    this.data = data;\n\n    if (!this.dynamicProperties.length) {\n      this.getValue(true);\n    }\n\n    this._isAnimated = !!this.dynamicProperties.length;\n    this.pMatrix = new Matrix();\n    this.rMatrix = new Matrix();\n    this.sMatrix = new Matrix();\n    this.tMatrix = new Matrix();\n    this.matrix = new Matrix();\n  };\n\n  RepeaterModifier.prototype.applyTransforms = function (pMatrix, rMatrix, sMatrix, transform, perc, inv) {\n    var dir = inv ? -1 : 1;\n    var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);\n    var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);\n    pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);\n    rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);\n    rMatrix.rotate(-transform.r.v * dir * perc);\n    rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);\n    sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);\n    sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);\n    sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);\n  };\n\n  RepeaterModifier.prototype.init = function (elem, arr, pos, elemsData) {\n    this.elem = elem;\n    this.arr = arr;\n    this.pos = pos;\n    this.elemsData = elemsData;\n    this._currentCopies = 0;\n    this._elements = [];\n    this._groups = [];\n    this.frameId = -1;\n    this.initDynamicPropertyContainer(elem);\n    this.initModifierProperties(elem, arr[pos]);\n\n    while (pos > 0) {\n      pos -= 1; // this._elements.unshift(arr.splice(pos,1)[0]);\n\n      this._elements.unshift(arr[pos]);\n    }\n\n    if (this.dynamicProperties.length) {\n      this.k = true;\n    } else {\n      this.getValue(true);\n    }\n  };\n\n  RepeaterModifier.prototype.resetElements = function (elements) {\n    var i;\n    var len = elements.length;\n\n    for (i = 0; i < len; i += 1) {\n      elements[i]._processed = false;\n\n      if (elements[i].ty === 'gr') {\n        this.resetElements(elements[i].it);\n      }\n    }\n  };\n\n  RepeaterModifier.prototype.cloneElements = function (elements) {\n    var newElements = JSON.parse(JSON.stringify(elements));\n    this.resetElements(newElements);\n    return newElements;\n  };\n\n  RepeaterModifier.prototype.changeGroupRender = function (elements, renderFlag) {\n    var i;\n    var len = elements.length;\n\n    for (i = 0; i < len; i += 1) {\n      elements[i]._render = renderFlag;\n\n      if (elements[i].ty === 'gr') {\n        this.changeGroupRender(elements[i].it, renderFlag);\n      }\n    }\n  };\n\n  RepeaterModifier.prototype.processShapes = function (_isFirstFrame) {\n    var items;\n    var itemsTransform;\n    var i;\n    var dir;\n    var cont;\n    var hasReloaded = false;\n\n    if (this._mdf || _isFirstFrame) {\n      var copies = Math.ceil(this.c.v);\n\n      if (this._groups.length < copies) {\n        while (this._groups.length < copies) {\n          var group = {\n            it: this.cloneElements(this._elements),\n            ty: 'gr'\n          };\n          group.it.push({\n            a: {\n              a: 0,\n              ix: 1,\n              k: [0, 0]\n            },\n            nm: 'Transform',\n            o: {\n              a: 0,\n              ix: 7,\n              k: 100\n            },\n            p: {\n              a: 0,\n              ix: 2,\n              k: [0, 0]\n            },\n            r: {\n              a: 1,\n              ix: 6,\n              k: [{\n                s: 0,\n                e: 0,\n                t: 0\n              }, {\n                s: 0,\n                e: 0,\n                t: 1\n              }]\n            },\n            s: {\n              a: 0,\n              ix: 3,\n              k: [100, 100]\n            },\n            sa: {\n              a: 0,\n              ix: 5,\n              k: 0\n            },\n            sk: {\n              a: 0,\n              ix: 4,\n              k: 0\n            },\n            ty: 'tr'\n          });\n          this.arr.splice(0, 0, group);\n\n          this._groups.splice(0, 0, group);\n\n          this._currentCopies += 1;\n        }\n\n        this.elem.reloadShapes();\n        hasReloaded = true;\n      }\n\n      cont = 0;\n      var renderFlag;\n\n      for (i = 0; i <= this._groups.length - 1; i += 1) {\n        renderFlag = cont < copies;\n        this._groups[i]._render = renderFlag;\n        this.changeGroupRender(this._groups[i].it, renderFlag);\n\n        if (!renderFlag) {\n          var elems = this.elemsData[i].it;\n          var transformData = elems[elems.length - 1];\n\n          if (transformData.transform.op.v !== 0) {\n            transformData.transform.op._mdf = true;\n            transformData.transform.op.v = 0;\n          } else {\n            transformData.transform.op._mdf = false;\n          }\n        }\n\n        cont += 1;\n      }\n\n      this._currentCopies = copies; /// /\n\n      var offset = this.o.v;\n      var offsetModulo = offset % 1;\n      var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);\n      var pProps = this.pMatrix.props;\n      var rProps = this.rMatrix.props;\n      var sProps = this.sMatrix.props;\n      this.pMatrix.reset();\n      this.rMatrix.reset();\n      this.sMatrix.reset();\n      this.tMatrix.reset();\n      this.matrix.reset();\n      var iteration = 0;\n\n      if (offset > 0) {\n        while (iteration < roundOffset) {\n          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);\n          iteration += 1;\n        }\n\n        if (offsetModulo) {\n          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);\n          iteration += offsetModulo;\n        }\n      } else if (offset < 0) {\n        while (iteration > roundOffset) {\n          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);\n          iteration -= 1;\n        }\n\n        if (offsetModulo) {\n          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);\n          iteration -= offsetModulo;\n        }\n      }\n\n      i = this.data.m === 1 ? 0 : this._currentCopies - 1;\n      dir = this.data.m === 1 ? 1 : -1;\n      cont = this._currentCopies;\n      var j;\n      var jLen;\n\n      while (cont) {\n        items = this.elemsData[i].it;\n        itemsTransform = items[items.length - 1].transform.mProps.v.props;\n        jLen = itemsTransform.length;\n        items[items.length - 1].transform.mProps._mdf = true;\n        items[items.length - 1].transform.op._mdf = true;\n        items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));\n\n        if (iteration !== 0) {\n          if (i !== 0 && dir === 1 || i !== this._currentCopies - 1 && dir === -1) {\n            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);\n          }\n\n          this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);\n          this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);\n          this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);\n\n          for (j = 0; j < jLen; j += 1) {\n            itemsTransform[j] = this.matrix.props[j];\n          }\n\n          this.matrix.reset();\n        } else {\n          this.matrix.reset();\n\n          for (j = 0; j < jLen; j += 1) {\n            itemsTransform[j] = this.matrix.props[j];\n          }\n        }\n\n        iteration += 1;\n        cont -= 1;\n        i += dir;\n      }\n    } else {\n      cont = this._currentCopies;\n      i = 0;\n      dir = 1;\n\n      while (cont) {\n        items = this.elemsData[i].it;\n        itemsTransform = items[items.length - 1].transform.mProps.v.props;\n        items[items.length - 1].transform.mProps._mdf = false;\n        items[items.length - 1].transform.op._mdf = false;\n        cont -= 1;\n        i += dir;\n      }\n    }\n\n    return hasReloaded;\n  };\n\n  RepeaterModifier.prototype.addShape = function () {};\n\n  function RoundCornersModifier() {}\n\n  extendPrototype([ShapeModifier], RoundCornersModifier);\n\n  RoundCornersModifier.prototype.initModifierProperties = function (elem, data) {\n    this.getValue = this.processKeys;\n    this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);\n    this._isAnimated = !!this.rd.effectsSequence.length;\n  };\n\n  RoundCornersModifier.prototype.processPath = function (path, round) {\n    var clonedPath = shapePool.newElement();\n    clonedPath.c = path.c;\n    var i;\n    var len = path._length;\n    var currentV;\n    var currentI;\n    var currentO;\n    var closerV;\n    var distance;\n    var newPosPerc;\n    var index = 0;\n    var vX;\n    var vY;\n    var oX;\n    var oY;\n    var iX;\n    var iY;\n\n    for (i = 0; i < len; i += 1) {\n      currentV = path.v[i];\n      currentO = path.o[i];\n      currentI = path.i[i];\n\n      if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {\n        if ((i === 0 || i === len - 1) && !path.c) {\n          clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index);\n          /* clonedPath.v[index] = currentV;\r\n                  clonedPath.o[index] = currentO;\r\n                  clonedPath.i[index] = currentI; */\n\n          index += 1;\n        } else {\n          if (i === 0) {\n            closerV = path.v[len - 1];\n          } else {\n            closerV = path.v[i - 1];\n          }\n\n          distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));\n          newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;\n          iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;\n          vX = iX;\n          iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;\n          vY = iY;\n          oX = vX - (vX - currentV[0]) * roundCorner;\n          oY = vY - (vY - currentV[1]) * roundCorner;\n          clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);\n          index += 1;\n\n          if (i === len - 1) {\n            closerV = path.v[0];\n          } else {\n            closerV = path.v[i + 1];\n          }\n\n          distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));\n          newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;\n          oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;\n          vX = oX;\n          oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;\n          vY = oY;\n          iX = vX - (vX - currentV[0]) * roundCorner;\n          iY = vY - (vY - currentV[1]) * roundCorner;\n          clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);\n          index += 1;\n        }\n      } else {\n        clonedPath.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index);\n        index += 1;\n      }\n    }\n\n    return clonedPath;\n  };\n\n  RoundCornersModifier.prototype.processShapes = function (_isFirstFrame) {\n    var shapePaths;\n    var i;\n    var len = this.shapes.length;\n    var j;\n    var jLen;\n    var rd = this.rd.v;\n\n    if (rd !== 0) {\n      var shapeData;\n      var localShapeCollection;\n\n      for (i = 0; i < len; i += 1) {\n        shapeData = this.shapes[i];\n        localShapeCollection = shapeData.localShapeCollection;\n\n        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n          localShapeCollection.releaseShapes();\n          shapeData.shape._mdf = true;\n          shapePaths = shapeData.shape.paths.shapes;\n          jLen = shapeData.shape.paths._length;\n\n          for (j = 0; j < jLen; j += 1) {\n            localShapeCollection.addShape(this.processPath(shapePaths[j], rd));\n          }\n        }\n\n        shapeData.shape.paths = shapeData.localShapeCollection;\n      }\n    }\n\n    if (!this.dynamicProperties.length) {\n      this._mdf = false;\n    }\n  };\n\n  function floatEqual(a, b) {\n    return Math.abs(a - b) * 100000 <= Math.min(Math.abs(a), Math.abs(b));\n  }\n\n  function floatZero(f) {\n    return Math.abs(f) <= 0.00001;\n  }\n\n  function lerp(p0, p1, amount) {\n    return p0 * (1 - amount) + p1 * amount;\n  }\n\n  function lerpPoint(p0, p1, amount) {\n    return [lerp(p0[0], p1[0], amount), lerp(p0[1], p1[1], amount)];\n  }\n\n  function quadRoots(a, b, c) {\n    // no root\n    if (a === 0) return [];\n    var s = b * b - 4 * a * c; // Complex roots\n\n    if (s < 0) return [];\n    var singleRoot = -b / (2 * a); // 1 root\n\n    if (s === 0) return [singleRoot];\n    var delta = Math.sqrt(s) / (2 * a); // 2 roots\n\n    return [singleRoot - delta, singleRoot + delta];\n  }\n\n  function polynomialCoefficients(p0, p1, p2, p3) {\n    return [-p0 + 3 * p1 - 3 * p2 + p3, 3 * p0 - 6 * p1 + 3 * p2, -3 * p0 + 3 * p1, p0];\n  }\n\n  function singlePoint(p) {\n    return new PolynomialBezier(p, p, p, p, false);\n  }\n\n  function PolynomialBezier(p0, p1, p2, p3, linearize) {\n    if (linearize && pointEqual(p0, p1)) {\n      p1 = lerpPoint(p0, p3, 1 / 3);\n    }\n\n    if (linearize && pointEqual(p2, p3)) {\n      p2 = lerpPoint(p0, p3, 2 / 3);\n    }\n\n    var coeffx = polynomialCoefficients(p0[0], p1[0], p2[0], p3[0]);\n    var coeffy = polynomialCoefficients(p0[1], p1[1], p2[1], p3[1]);\n    this.a = [coeffx[0], coeffy[0]];\n    this.b = [coeffx[1], coeffy[1]];\n    this.c = [coeffx[2], coeffy[2]];\n    this.d = [coeffx[3], coeffy[3]];\n    this.points = [p0, p1, p2, p3];\n  }\n\n  PolynomialBezier.prototype.point = function (t) {\n    return [((this.a[0] * t + this.b[0]) * t + this.c[0]) * t + this.d[0], ((this.a[1] * t + this.b[1]) * t + this.c[1]) * t + this.d[1]];\n  };\n\n  PolynomialBezier.prototype.derivative = function (t) {\n    return [(3 * t * this.a[0] + 2 * this.b[0]) * t + this.c[0], (3 * t * this.a[1] + 2 * this.b[1]) * t + this.c[1]];\n  };\n\n  PolynomialBezier.prototype.tangentAngle = function (t) {\n    var p = this.derivative(t);\n    return Math.atan2(p[1], p[0]);\n  };\n\n  PolynomialBezier.prototype.normalAngle = function (t) {\n    var p = this.derivative(t);\n    return Math.atan2(p[0], p[1]);\n  };\n\n  PolynomialBezier.prototype.inflectionPoints = function () {\n    var denom = this.a[1] * this.b[0] - this.a[0] * this.b[1];\n    if (floatZero(denom)) return [];\n    var tcusp = -0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / denom;\n    var square = tcusp * tcusp - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / denom;\n    if (square < 0) return [];\n    var root = Math.sqrt(square);\n\n    if (floatZero(root)) {\n      if (root > 0 && root < 1) return [tcusp];\n      return [];\n    }\n\n    return [tcusp - root, tcusp + root].filter(function (r) {\n      return r > 0 && r < 1;\n    });\n  };\n\n  PolynomialBezier.prototype.split = function (t) {\n    if (t <= 0) return [singlePoint(this.points[0]), this];\n    if (t >= 1) return [this, singlePoint(this.points[this.points.length - 1])];\n    var p10 = lerpPoint(this.points[0], this.points[1], t);\n    var p11 = lerpPoint(this.points[1], this.points[2], t);\n    var p12 = lerpPoint(this.points[2], this.points[3], t);\n    var p20 = lerpPoint(p10, p11, t);\n    var p21 = lerpPoint(p11, p12, t);\n    var p3 = lerpPoint(p20, p21, t);\n    return [new PolynomialBezier(this.points[0], p10, p20, p3, true), new PolynomialBezier(p3, p21, p12, this.points[3], true)];\n  };\n\n  function extrema(bez, comp) {\n    var min = bez.points[0][comp];\n    var max = bez.points[bez.points.length - 1][comp];\n\n    if (min > max) {\n      var e = max;\n      max = min;\n      min = e;\n    } // Derivative roots to find min/max\n\n\n    var f = quadRoots(3 * bez.a[comp], 2 * bez.b[comp], bez.c[comp]);\n\n    for (var i = 0; i < f.length; i += 1) {\n      if (f[i] > 0 && f[i] < 1) {\n        var val = bez.point(f[i])[comp];\n        if (val < min) min = val;else if (val > max) max = val;\n      }\n    }\n\n    return {\n      min: min,\n      max: max\n    };\n  }\n\n  PolynomialBezier.prototype.bounds = function () {\n    return {\n      x: extrema(this, 0),\n      y: extrema(this, 1)\n    };\n  };\n\n  PolynomialBezier.prototype.boundingBox = function () {\n    var bounds = this.bounds();\n    return {\n      left: bounds.x.min,\n      right: bounds.x.max,\n      top: bounds.y.min,\n      bottom: bounds.y.max,\n      width: bounds.x.max - bounds.x.min,\n      height: bounds.y.max - bounds.y.min,\n      cx: (bounds.x.max + bounds.x.min) / 2,\n      cy: (bounds.y.max + bounds.y.min) / 2\n    };\n  };\n\n  function intersectData(bez, t1, t2) {\n    var box = bez.boundingBox();\n    return {\n      cx: box.cx,\n      cy: box.cy,\n      width: box.width,\n      height: box.height,\n      bez: bez,\n      t: (t1 + t2) / 2,\n      t1: t1,\n      t2: t2\n    };\n  }\n\n  function splitData(data) {\n    var split = data.bez.split(0.5);\n    return [intersectData(split[0], data.t1, data.t), intersectData(split[1], data.t, data.t2)];\n  }\n\n  function boxIntersect(b1, b2) {\n    return Math.abs(b1.cx - b2.cx) * 2 < b1.width + b2.width && Math.abs(b1.cy - b2.cy) * 2 < b1.height + b2.height;\n  }\n\n  function intersectsImpl(d1, d2, depth, tolerance, intersections, maxRecursion) {\n    if (!boxIntersect(d1, d2)) return;\n\n    if (depth >= maxRecursion || d1.width <= tolerance && d1.height <= tolerance && d2.width <= tolerance && d2.height <= tolerance) {\n      intersections.push([d1.t, d2.t]);\n      return;\n    }\n\n    var d1s = splitData(d1);\n    var d2s = splitData(d2);\n    intersectsImpl(d1s[0], d2s[0], depth + 1, tolerance, intersections, maxRecursion);\n    intersectsImpl(d1s[0], d2s[1], depth + 1, tolerance, intersections, maxRecursion);\n    intersectsImpl(d1s[1], d2s[0], depth + 1, tolerance, intersections, maxRecursion);\n    intersectsImpl(d1s[1], d2s[1], depth + 1, tolerance, intersections, maxRecursion);\n  }\n\n  PolynomialBezier.prototype.intersections = function (other, tolerance, maxRecursion) {\n    if (tolerance === undefined) tolerance = 2;\n    if (maxRecursion === undefined) maxRecursion = 7;\n    var intersections = [];\n    intersectsImpl(intersectData(this, 0, 1), intersectData(other, 0, 1), 0, tolerance, intersections, maxRecursion);\n    return intersections;\n  };\n\n  PolynomialBezier.shapeSegment = function (shapePath, index) {\n    var nextIndex = (index + 1) % shapePath.length();\n    return new PolynomialBezier(shapePath.v[index], shapePath.o[index], shapePath.i[nextIndex], shapePath.v[nextIndex], true);\n  };\n\n  PolynomialBezier.shapeSegmentInverted = function (shapePath, index) {\n    var nextIndex = (index + 1) % shapePath.length();\n    return new PolynomialBezier(shapePath.v[nextIndex], shapePath.i[nextIndex], shapePath.o[index], shapePath.v[index], true);\n  };\n\n  function crossProduct(a, b) {\n    return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n  }\n\n  function lineIntersection(start1, end1, start2, end2) {\n    var v1 = [start1[0], start1[1], 1];\n    var v2 = [end1[0], end1[1], 1];\n    var v3 = [start2[0], start2[1], 1];\n    var v4 = [end2[0], end2[1], 1];\n    var r = crossProduct(crossProduct(v1, v2), crossProduct(v3, v4));\n    if (floatZero(r[2])) return null;\n    return [r[0] / r[2], r[1] / r[2]];\n  }\n\n  function polarOffset(p, angle, length) {\n    return [p[0] + Math.cos(angle) * length, p[1] - Math.sin(angle) * length];\n  }\n\n  function pointDistance(p1, p2) {\n    return Math.hypot(p1[0] - p2[0], p1[1] - p2[1]);\n  }\n\n  function pointEqual(p1, p2) {\n    return floatEqual(p1[0], p2[0]) && floatEqual(p1[1], p2[1]);\n  }\n\n  function ZigZagModifier() {}\n\n  extendPrototype([ShapeModifier], ZigZagModifier);\n\n  ZigZagModifier.prototype.initModifierProperties = function (elem, data) {\n    this.getValue = this.processKeys;\n    this.amplitude = PropertyFactory.getProp(elem, data.s, 0, null, this);\n    this.frequency = PropertyFactory.getProp(elem, data.r, 0, null, this);\n    this.pointsType = PropertyFactory.getProp(elem, data.pt, 0, null, this);\n    this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;\n  };\n\n  function setPoint(outputBezier, point, angle, direction, amplitude, outAmplitude, inAmplitude) {\n    var angO = angle - Math.PI / 2;\n    var angI = angle + Math.PI / 2;\n    var px = point[0] + Math.cos(angle) * direction * amplitude;\n    var py = point[1] - Math.sin(angle) * direction * amplitude;\n    outputBezier.setTripleAt(px, py, px + Math.cos(angO) * outAmplitude, py - Math.sin(angO) * outAmplitude, px + Math.cos(angI) * inAmplitude, py - Math.sin(angI) * inAmplitude, outputBezier.length());\n  }\n\n  function getPerpendicularVector(pt1, pt2) {\n    var vector = [pt2[0] - pt1[0], pt2[1] - pt1[1]];\n    var rot = -Math.PI * 0.5;\n    var rotatedVector = [Math.cos(rot) * vector[0] - Math.sin(rot) * vector[1], Math.sin(rot) * vector[0] + Math.cos(rot) * vector[1]];\n    return rotatedVector;\n  }\n\n  function getProjectingAngle(path, cur) {\n    var prevIndex = cur === 0 ? path.length() - 1 : cur - 1;\n    var nextIndex = (cur + 1) % path.length();\n    var prevPoint = path.v[prevIndex];\n    var nextPoint = path.v[nextIndex];\n    var pVector = getPerpendicularVector(prevPoint, nextPoint);\n    return Math.atan2(0, 1) - Math.atan2(pVector[1], pVector[0]);\n  }\n\n  function zigZagCorner(outputBezier, path, cur, amplitude, frequency, pointType, direction) {\n    var angle = getProjectingAngle(path, cur);\n    var point = path.v[cur % path._length];\n    var prevPoint = path.v[cur === 0 ? path._length - 1 : cur - 1];\n    var nextPoint = path.v[(cur + 1) % path._length];\n    var prevDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - prevPoint[0], 2) + Math.pow(point[1] - prevPoint[1], 2)) : 0;\n    var nextDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - nextPoint[0], 2) + Math.pow(point[1] - nextPoint[1], 2)) : 0;\n    setPoint(outputBezier, path.v[cur % path._length], angle, direction, amplitude, nextDist / ((frequency + 1) * 2), prevDist / ((frequency + 1) * 2), pointType);\n  }\n\n  function zigZagSegment(outputBezier, segment, amplitude, frequency, pointType, direction) {\n    for (var i = 0; i < frequency; i += 1) {\n      var t = (i + 1) / (frequency + 1);\n      var dist = pointType === 2 ? Math.sqrt(Math.pow(segment.points[3][0] - segment.points[0][0], 2) + Math.pow(segment.points[3][1] - segment.points[0][1], 2)) : 0;\n      var angle = segment.normalAngle(t);\n      var point = segment.point(t);\n      setPoint(outputBezier, point, angle, direction, amplitude, dist / ((frequency + 1) * 2), dist / ((frequency + 1) * 2), pointType);\n      direction = -direction;\n    }\n\n    return direction;\n  }\n\n  ZigZagModifier.prototype.processPath = function (path, amplitude, frequency, pointType) {\n    var count = path._length;\n    var clonedPath = shapePool.newElement();\n    clonedPath.c = path.c;\n\n    if (!path.c) {\n      count -= 1;\n    }\n\n    if (count === 0) return clonedPath;\n    var direction = -1;\n    var segment = PolynomialBezier.shapeSegment(path, 0);\n    zigZagCorner(clonedPath, path, 0, amplitude, frequency, pointType, direction);\n\n    for (var i = 0; i < count; i += 1) {\n      direction = zigZagSegment(clonedPath, segment, amplitude, frequency, pointType, -direction);\n\n      if (i === count - 1 && !path.c) {\n        segment = null;\n      } else {\n        segment = PolynomialBezier.shapeSegment(path, (i + 1) % count);\n      }\n\n      zigZagCorner(clonedPath, path, i + 1, amplitude, frequency, pointType, direction);\n    }\n\n    return clonedPath;\n  };\n\n  ZigZagModifier.prototype.processShapes = function (_isFirstFrame) {\n    var shapePaths;\n    var i;\n    var len = this.shapes.length;\n    var j;\n    var jLen;\n    var amplitude = this.amplitude.v;\n    var frequency = Math.max(0, Math.round(this.frequency.v));\n    var pointType = this.pointsType.v;\n\n    if (amplitude !== 0) {\n      var shapeData;\n      var localShapeCollection;\n\n      for (i = 0; i < len; i += 1) {\n        shapeData = this.shapes[i];\n        localShapeCollection = shapeData.localShapeCollection;\n\n        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n          localShapeCollection.releaseShapes();\n          shapeData.shape._mdf = true;\n          shapePaths = shapeData.shape.paths.shapes;\n          jLen = shapeData.shape.paths._length;\n\n          for (j = 0; j < jLen; j += 1) {\n            localShapeCollection.addShape(this.processPath(shapePaths[j], amplitude, frequency, pointType));\n          }\n        }\n\n        shapeData.shape.paths = shapeData.localShapeCollection;\n      }\n    }\n\n    if (!this.dynamicProperties.length) {\n      this._mdf = false;\n    }\n  };\n\n  function linearOffset(p1, p2, amount) {\n    var angle = Math.atan2(p2[0] - p1[0], p2[1] - p1[1]);\n    return [polarOffset(p1, angle, amount), polarOffset(p2, angle, amount)];\n  }\n\n  function offsetSegment(segment, amount) {\n    var p0;\n    var p1a;\n    var p1b;\n    var p2b;\n    var p2a;\n    var p3;\n    var e;\n    e = linearOffset(segment.points[0], segment.points[1], amount);\n    p0 = e[0];\n    p1a = e[1];\n    e = linearOffset(segment.points[1], segment.points[2], amount);\n    p1b = e[0];\n    p2b = e[1];\n    e = linearOffset(segment.points[2], segment.points[3], amount);\n    p2a = e[0];\n    p3 = e[1];\n    var p1 = lineIntersection(p0, p1a, p1b, p2b);\n    if (p1 === null) p1 = p1a;\n    var p2 = lineIntersection(p2a, p3, p1b, p2b);\n    if (p2 === null) p2 = p2a;\n    return new PolynomialBezier(p0, p1, p2, p3);\n  }\n\n  function joinLines(outputBezier, seg1, seg2, lineJoin, miterLimit) {\n    var p0 = seg1.points[3];\n    var p1 = seg2.points[0]; // Bevel\n\n    if (lineJoin === 3) return p0; // Connected, they don't need a joint\n\n    if (pointEqual(p0, p1)) return p0; // Round\n\n    if (lineJoin === 2) {\n      var angleOut = -seg1.tangentAngle(1);\n      var angleIn = -seg2.tangentAngle(0) + Math.PI;\n      var center = lineIntersection(p0, polarOffset(p0, angleOut + Math.PI / 2, 100), p1, polarOffset(p1, angleOut + Math.PI / 2, 100));\n      var radius = center ? pointDistance(center, p0) : pointDistance(p0, p1) / 2;\n      var tan = polarOffset(p0, angleOut, 2 * radius * roundCorner);\n      outputBezier.setXYAt(tan[0], tan[1], 'o', outputBezier.length() - 1);\n      tan = polarOffset(p1, angleIn, 2 * radius * roundCorner);\n      outputBezier.setTripleAt(p1[0], p1[1], p1[0], p1[1], tan[0], tan[1], outputBezier.length());\n      return p1;\n    } // Miter\n\n\n    var t0 = pointEqual(p0, seg1.points[2]) ? seg1.points[0] : seg1.points[2];\n    var t1 = pointEqual(p1, seg2.points[1]) ? seg2.points[3] : seg2.points[1];\n    var intersection = lineIntersection(t0, p0, p1, t1);\n\n    if (intersection && pointDistance(intersection, p0) < miterLimit) {\n      outputBezier.setTripleAt(intersection[0], intersection[1], intersection[0], intersection[1], intersection[0], intersection[1], outputBezier.length());\n      return intersection;\n    }\n\n    return p0;\n  }\n\n  function getIntersection(a, b) {\n    var intersect = a.intersections(b);\n    if (intersect.length && floatEqual(intersect[0][0], 1)) intersect.shift();\n    if (intersect.length) return intersect[0];\n    return null;\n  }\n\n  function pruneSegmentIntersection(a, b) {\n    var outa = a.slice();\n    var outb = b.slice();\n    var intersect = getIntersection(a[a.length - 1], b[0]);\n\n    if (intersect) {\n      outa[a.length - 1] = a[a.length - 1].split(intersect[0])[0];\n      outb[0] = b[0].split(intersect[1])[1];\n    }\n\n    if (a.length > 1 && b.length > 1) {\n      intersect = getIntersection(a[0], b[b.length - 1]);\n\n      if (intersect) {\n        return [[a[0].split(intersect[0])[0]], [b[b.length - 1].split(intersect[1])[1]]];\n      }\n    }\n\n    return [outa, outb];\n  }\n\n  function pruneIntersections(segments) {\n    var e;\n\n    for (var i = 1; i < segments.length; i += 1) {\n      e = pruneSegmentIntersection(segments[i - 1], segments[i]);\n      segments[i - 1] = e[0];\n      segments[i] = e[1];\n    }\n\n    if (segments.length > 1) {\n      e = pruneSegmentIntersection(segments[segments.length - 1], segments[0]);\n      segments[segments.length - 1] = e[0];\n      segments[0] = e[1];\n    }\n\n    return segments;\n  }\n\n  function offsetSegmentSplit(segment, amount) {\n    /*\r\n      We split each bezier segment into smaller pieces based\r\n      on inflection points, this ensures the control point\r\n      polygon is convex.\r\n        (A cubic bezier can have none, one, or two inflection points)\r\n    */\n    var flex = segment.inflectionPoints();\n    var left;\n    var right;\n    var split;\n    var mid;\n\n    if (flex.length === 0) {\n      return [offsetSegment(segment, amount)];\n    }\n\n    if (flex.length === 1 || floatEqual(flex[1], 1)) {\n      split = segment.split(flex[0]);\n      left = split[0];\n      right = split[1];\n      return [offsetSegment(left, amount), offsetSegment(right, amount)];\n    }\n\n    split = segment.split(flex[0]);\n    left = split[0];\n    var t = (flex[1] - flex[0]) / (1 - flex[0]);\n    split = split[1].split(t);\n    mid = split[0];\n    right = split[1];\n    return [offsetSegment(left, amount), offsetSegment(mid, amount), offsetSegment(right, amount)];\n  }\n\n  function OffsetPathModifier() {}\n\n  extendPrototype([ShapeModifier], OffsetPathModifier);\n\n  OffsetPathModifier.prototype.initModifierProperties = function (elem, data) {\n    this.getValue = this.processKeys;\n    this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);\n    this.miterLimit = PropertyFactory.getProp(elem, data.ml, 0, null, this);\n    this.lineJoin = data.lj;\n    this._isAnimated = this.amount.effectsSequence.length !== 0;\n  };\n\n  OffsetPathModifier.prototype.processPath = function (inputBezier, amount, lineJoin, miterLimit) {\n    var outputBezier = shapePool.newElement();\n    outputBezier.c = inputBezier.c;\n    var count = inputBezier.length();\n\n    if (!inputBezier.c) {\n      count -= 1;\n    }\n\n    var i;\n    var j;\n    var segment;\n    var multiSegments = [];\n\n    for (i = 0; i < count; i += 1) {\n      segment = PolynomialBezier.shapeSegment(inputBezier, i);\n      multiSegments.push(offsetSegmentSplit(segment, amount));\n    }\n\n    if (!inputBezier.c) {\n      for (i = count - 1; i >= 0; i -= 1) {\n        segment = PolynomialBezier.shapeSegmentInverted(inputBezier, i);\n        multiSegments.push(offsetSegmentSplit(segment, amount));\n      }\n    }\n\n    multiSegments = pruneIntersections(multiSegments); // Add bezier segments to the output and apply line joints\n\n    var lastPoint = null;\n    var lastSeg = null;\n\n    for (i = 0; i < multiSegments.length; i += 1) {\n      var multiSegment = multiSegments[i];\n      if (lastSeg) lastPoint = joinLines(outputBezier, lastSeg, multiSegment[0], lineJoin, miterLimit);\n      lastSeg = multiSegment[multiSegment.length - 1];\n\n      for (j = 0; j < multiSegment.length; j += 1) {\n        segment = multiSegment[j];\n\n        if (lastPoint && pointEqual(segment.points[0], lastPoint)) {\n          outputBezier.setXYAt(segment.points[1][0], segment.points[1][1], 'o', outputBezier.length() - 1);\n        } else {\n          outputBezier.setTripleAt(segment.points[0][0], segment.points[0][1], segment.points[1][0], segment.points[1][1], segment.points[0][0], segment.points[0][1], outputBezier.length());\n        }\n\n        outputBezier.setTripleAt(segment.points[3][0], segment.points[3][1], segment.points[3][0], segment.points[3][1], segment.points[2][0], segment.points[2][1], outputBezier.length());\n        lastPoint = segment.points[3];\n      }\n    }\n\n    if (multiSegments.length) joinLines(outputBezier, lastSeg, multiSegments[0][0], lineJoin, miterLimit);\n    return outputBezier;\n  };\n\n  OffsetPathModifier.prototype.processShapes = function (_isFirstFrame) {\n    var shapePaths;\n    var i;\n    var len = this.shapes.length;\n    var j;\n    var jLen;\n    var amount = this.amount.v;\n    var miterLimit = this.miterLimit.v;\n    var lineJoin = this.lineJoin;\n\n    if (amount !== 0) {\n      var shapeData;\n      var localShapeCollection;\n\n      for (i = 0; i < len; i += 1) {\n        shapeData = this.shapes[i];\n        localShapeCollection = shapeData.localShapeCollection;\n\n        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n          localShapeCollection.releaseShapes();\n          shapeData.shape._mdf = true;\n          shapePaths = shapeData.shape.paths.shapes;\n          jLen = shapeData.shape.paths._length;\n\n          for (j = 0; j < jLen; j += 1) {\n            localShapeCollection.addShape(this.processPath(shapePaths[j], amount, lineJoin, miterLimit));\n          }\n        }\n\n        shapeData.shape.paths = shapeData.localShapeCollection;\n      }\n    }\n\n    if (!this.dynamicProperties.length) {\n      this._mdf = false;\n    }\n  };\n\n  function getFontProperties(fontData) {\n    var styles = fontData.fStyle ? fontData.fStyle.split(' ') : [];\n    var fWeight = 'normal';\n    var fStyle = 'normal';\n    var len = styles.length;\n    var styleName;\n\n    for (var i = 0; i < len; i += 1) {\n      styleName = styles[i].toLowerCase();\n\n      switch (styleName) {\n        case 'italic':\n          fStyle = 'italic';\n          break;\n\n        case 'bold':\n          fWeight = '700';\n          break;\n\n        case 'black':\n          fWeight = '900';\n          break;\n\n        case 'medium':\n          fWeight = '500';\n          break;\n\n        case 'regular':\n        case 'normal':\n          fWeight = '400';\n          break;\n\n        case 'light':\n        case 'thin':\n          fWeight = '200';\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    return {\n      style: fStyle,\n      weight: fontData.fWeight || fWeight\n    };\n  }\n\n  var FontManager = function () {\n    var maxWaitingTime = 5000;\n    var emptyChar = {\n      w: 0,\n      size: 0,\n      shapes: [],\n      data: {\n        shapes: []\n      }\n    };\n    var combinedCharacters = []; // Hindi characters\n\n    combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);\n    var BLACK_FLAG_CODE_POINT = 127988;\n    var CANCEL_TAG_CODE_POINT = 917631;\n    var A_TAG_CODE_POINT = 917601;\n    var Z_TAG_CODE_POINT = 917626;\n    var VARIATION_SELECTOR_16_CODE_POINT = 65039;\n    var ZERO_WIDTH_JOINER_CODE_POINT = 8205;\n    var REGIONAL_CHARACTER_A_CODE_POINT = 127462;\n    var REGIONAL_CHARACTER_Z_CODE_POINT = 127487;\n    var surrogateModifiers = ['d83cdffb', 'd83cdffc', 'd83cdffd', 'd83cdffe', 'd83cdfff'];\n\n    function trimFontOptions(font) {\n      var familyArray = font.split(',');\n      var i;\n      var len = familyArray.length;\n      var enabledFamilies = [];\n\n      for (i = 0; i < len; i += 1) {\n        if (familyArray[i] !== 'sans-serif' && familyArray[i] !== 'monospace') {\n          enabledFamilies.push(familyArray[i]);\n        }\n      }\n\n      return enabledFamilies.join(',');\n    }\n\n    function setUpNode(font, family) {\n      var parentNode = createTag('span'); // Node is invisible to screen readers.\n\n      parentNode.setAttribute('aria-hidden', true);\n      parentNode.style.fontFamily = family;\n      var node = createTag('span'); // Characters that vary significantly among different fonts\n\n      node.innerText = 'giItT1WQy@!-/#'; // Visible - so we can measure it - but not on the screen\n\n      parentNode.style.position = 'absolute';\n      parentNode.style.left = '-10000px';\n      parentNode.style.top = '-10000px'; // Large font size makes even subtle changes obvious\n\n      parentNode.style.fontSize = '300px'; // Reset any font properties\n\n      parentNode.style.fontVariant = 'normal';\n      parentNode.style.fontStyle = 'normal';\n      parentNode.style.fontWeight = 'normal';\n      parentNode.style.letterSpacing = '0';\n      parentNode.appendChild(node);\n      document.body.appendChild(parentNode); // Remember width with no applied web font\n\n      var width = node.offsetWidth;\n      node.style.fontFamily = trimFontOptions(font) + ', ' + family;\n      return {\n        node: node,\n        w: width,\n        parent: parentNode\n      };\n    }\n\n    function checkLoadedFonts() {\n      var i;\n      var len = this.fonts.length;\n      var node;\n      var w;\n      var loadedCount = len;\n\n      for (i = 0; i < len; i += 1) {\n        if (this.fonts[i].loaded) {\n          loadedCount -= 1;\n        } else if (this.fonts[i].fOrigin === 'n' || this.fonts[i].origin === 0) {\n          this.fonts[i].loaded = true;\n        } else {\n          node = this.fonts[i].monoCase.node;\n          w = this.fonts[i].monoCase.w;\n\n          if (node.offsetWidth !== w) {\n            loadedCount -= 1;\n            this.fonts[i].loaded = true;\n          } else {\n            node = this.fonts[i].sansCase.node;\n            w = this.fonts[i].sansCase.w;\n\n            if (node.offsetWidth !== w) {\n              loadedCount -= 1;\n              this.fonts[i].loaded = true;\n            }\n          }\n\n          if (this.fonts[i].loaded) {\n            this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);\n            this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);\n          }\n        }\n      }\n\n      if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {\n        setTimeout(this.checkLoadedFontsBinded, 20);\n      } else {\n        setTimeout(this.setIsLoadedBinded, 10);\n      }\n    }\n\n    function createHelper(fontData, def) {\n      var engine = document.body && def ? 'svg' : 'canvas';\n      var helper;\n      var fontProps = getFontProperties(fontData);\n\n      if (engine === 'svg') {\n        var tHelper = createNS('text');\n        tHelper.style.fontSize = '100px'; // tHelper.style.fontFamily = fontData.fFamily;\n\n        tHelper.setAttribute('font-family', fontData.fFamily);\n        tHelper.setAttribute('font-style', fontProps.style);\n        tHelper.setAttribute('font-weight', fontProps.weight);\n        tHelper.textContent = '1';\n\n        if (fontData.fClass) {\n          tHelper.style.fontFamily = 'inherit';\n          tHelper.setAttribute('class', fontData.fClass);\n        } else {\n          tHelper.style.fontFamily = fontData.fFamily;\n        }\n\n        def.appendChild(tHelper);\n        helper = tHelper;\n      } else {\n        var tCanvasHelper = new OffscreenCanvas(500, 500).getContext('2d');\n        tCanvasHelper.font = fontProps.style + ' ' + fontProps.weight + ' 100px ' + fontData.fFamily;\n        helper = tCanvasHelper;\n      }\n\n      function measure(text) {\n        if (engine === 'svg') {\n          helper.textContent = text;\n          return helper.getComputedTextLength();\n        }\n\n        return helper.measureText(text).width;\n      }\n\n      return {\n        measureText: measure\n      };\n    }\n\n    function addFonts(fontData, defs) {\n      if (!fontData) {\n        this.isLoaded = true;\n        return;\n      }\n\n      if (this.chars) {\n        this.isLoaded = true;\n        this.fonts = fontData.list;\n        return;\n      }\n\n      if (!document.body) {\n        this.isLoaded = true;\n        fontData.list.forEach(function (data) {\n          data.helper = createHelper(data);\n          data.cache = {};\n        });\n        this.fonts = fontData.list;\n        return;\n      }\n\n      var fontArr = fontData.list;\n      var i;\n      var len = fontArr.length;\n      var _pendingFonts = len;\n\n      for (i = 0; i < len; i += 1) {\n        var shouldLoadFont = true;\n        var loadedSelector;\n        var j;\n        fontArr[i].loaded = false;\n        fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, 'monospace');\n        fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, 'sans-serif');\n\n        if (!fontArr[i].fPath) {\n          fontArr[i].loaded = true;\n          _pendingFonts -= 1;\n        } else if (fontArr[i].fOrigin === 'p' || fontArr[i].origin === 3) {\n          loadedSelector = document.querySelectorAll('style[f-forigin=\"p\"][f-family=\"' + fontArr[i].fFamily + '\"], style[f-origin=\"3\"][f-family=\"' + fontArr[i].fFamily + '\"]');\n\n          if (loadedSelector.length > 0) {\n            shouldLoadFont = false;\n          }\n\n          if (shouldLoadFont) {\n            var s = createTag('style');\n            s.setAttribute('f-forigin', fontArr[i].fOrigin);\n            s.setAttribute('f-origin', fontArr[i].origin);\n            s.setAttribute('f-family', fontArr[i].fFamily);\n            s.type = 'text/css';\n            s.innerText = '@font-face {font-family: ' + fontArr[i].fFamily + \"; font-style: normal; src: url('\" + fontArr[i].fPath + \"');}\";\n            defs.appendChild(s);\n          }\n        } else if (fontArr[i].fOrigin === 'g' || fontArr[i].origin === 1) {\n          loadedSelector = document.querySelectorAll('link[f-forigin=\"g\"], link[f-origin=\"1\"]');\n\n          for (j = 0; j < loadedSelector.length; j += 1) {\n            if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {\n              // Font is already loaded\n              shouldLoadFont = false;\n            }\n          }\n\n          if (shouldLoadFont) {\n            var l = createTag('link');\n            l.setAttribute('f-forigin', fontArr[i].fOrigin);\n            l.setAttribute('f-origin', fontArr[i].origin);\n            l.type = 'text/css';\n            l.rel = 'stylesheet';\n            l.href = fontArr[i].fPath;\n            document.body.appendChild(l);\n          }\n        } else if (fontArr[i].fOrigin === 't' || fontArr[i].origin === 2) {\n          loadedSelector = document.querySelectorAll('script[f-forigin=\"t\"], script[f-origin=\"2\"]');\n\n          for (j = 0; j < loadedSelector.length; j += 1) {\n            if (fontArr[i].fPath === loadedSelector[j].src) {\n              // Font is already loaded\n              shouldLoadFont = false;\n            }\n          }\n\n          if (shouldLoadFont) {\n            var sc = createTag('link');\n            sc.setAttribute('f-forigin', fontArr[i].fOrigin);\n            sc.setAttribute('f-origin', fontArr[i].origin);\n            sc.setAttribute('rel', 'stylesheet');\n            sc.setAttribute('href', fontArr[i].fPath);\n            defs.appendChild(sc);\n          }\n        }\n\n        fontArr[i].helper = createHelper(fontArr[i], defs);\n        fontArr[i].cache = {};\n        this.fonts.push(fontArr[i]);\n      }\n\n      if (_pendingFonts === 0) {\n        this.isLoaded = true;\n      } else {\n        // On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.\n        // Adding this timeout seems to fix it\n        setTimeout(this.checkLoadedFonts.bind(this), 100);\n      }\n    }\n\n    function addChars(chars) {\n      if (!chars) {\n        return;\n      }\n\n      if (!this.chars) {\n        this.chars = [];\n      }\n\n      var i;\n      var len = chars.length;\n      var j;\n      var jLen = this.chars.length;\n      var found;\n\n      for (i = 0; i < len; i += 1) {\n        j = 0;\n        found = false;\n\n        while (j < jLen) {\n          if (this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch) {\n            found = true;\n          }\n\n          j += 1;\n        }\n\n        if (!found) {\n          this.chars.push(chars[i]);\n          jLen += 1;\n        }\n      }\n    }\n\n    function getCharData(_char, style, font) {\n      var i = 0;\n      var len = this.chars.length;\n\n      while (i < len) {\n        if (this.chars[i].ch === _char && this.chars[i].style === style && this.chars[i].fFamily === font) {\n          return this.chars[i];\n        }\n\n        i += 1;\n      }\n\n      if ((typeof _char === 'string' && _char.charCodeAt(0) !== 13 || !_char) && console && console.warn // eslint-disable-line no-console\n      && !this._warned) {\n        this._warned = true;\n        console.warn('Missing character from exported characters list: ', _char, style, font); // eslint-disable-line no-console\n      }\n\n      return emptyChar;\n    }\n\n    function measureText(_char2, fontName, size) {\n      var fontData = this.getFontByName(fontName); // Using the char instead of char.charCodeAt(0)\n      // to avoid collisions between equal chars\n\n      var index = _char2;\n\n      if (!fontData.cache[index]) {\n        var tHelper = fontData.helper;\n\n        if (_char2 === ' ') {\n          var doubleSize = tHelper.measureText('|' + _char2 + '|');\n          var singleSize = tHelper.measureText('||');\n          fontData.cache[index] = (doubleSize - singleSize) / 100;\n        } else {\n          fontData.cache[index] = tHelper.measureText(_char2) / 100;\n        }\n      }\n\n      return fontData.cache[index] * size;\n    }\n\n    function getFontByName(name) {\n      var i = 0;\n      var len = this.fonts.length;\n\n      while (i < len) {\n        if (this.fonts[i].fName === name) {\n          return this.fonts[i];\n        }\n\n        i += 1;\n      }\n\n      return this.fonts[0];\n    }\n\n    function getCodePoint(string) {\n      var codePoint = 0;\n      var first = string.charCodeAt(0);\n\n      if (first >= 0xD800 && first <= 0xDBFF) {\n        var second = string.charCodeAt(1);\n\n        if (second >= 0xDC00 && second <= 0xDFFF) {\n          codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n        }\n      }\n\n      return codePoint;\n    } // Skin tone modifiers\n\n\n    function isModifier(firstCharCode, secondCharCode) {\n      var sum = firstCharCode.toString(16) + secondCharCode.toString(16);\n      return surrogateModifiers.indexOf(sum) !== -1;\n    }\n\n    function isZeroWidthJoiner(charCode) {\n      return charCode === ZERO_WIDTH_JOINER_CODE_POINT;\n    } // This codepoint may change the appearance of the preceding character.\n    // If that is a symbol, dingbat or emoji, U+FE0F forces it to be rendered\n    // as a colorful image as compared to a monochrome text variant.\n\n\n    function isVariationSelector(charCode) {\n      return charCode === VARIATION_SELECTOR_16_CODE_POINT;\n    } // The regional indicator symbols are a set of 26 alphabetic Unicode\n    /// characters (A–Z) intended to be used to encode ISO 3166-1 alpha-2\n    // two-letter country codes in a way that allows optional special treatment.\n\n\n    function isRegionalCode(string) {\n      var codePoint = getCodePoint(string);\n\n      if (codePoint >= REGIONAL_CHARACTER_A_CODE_POINT && codePoint <= REGIONAL_CHARACTER_Z_CODE_POINT) {\n        return true;\n      }\n\n      return false;\n    } // Some Emoji implementations represent combinations of\n    // two “regional indicator” letters as a single flag symbol.\n\n\n    function isFlagEmoji(string) {\n      return isRegionalCode(string.substr(0, 2)) && isRegionalCode(string.substr(2, 2));\n    }\n\n    function isCombinedCharacter(_char3) {\n      return combinedCharacters.indexOf(_char3) !== -1;\n    } // Regional flags start with a BLACK_FLAG_CODE_POINT\n    // folowed by 5 chars in the TAG range\n    // and end with a CANCEL_TAG_CODE_POINT\n\n\n    function isRegionalFlag(text, index) {\n      var codePoint = getCodePoint(text.substr(index, 2));\n\n      if (codePoint !== BLACK_FLAG_CODE_POINT) {\n        return false;\n      }\n\n      var count = 0;\n      index += 2;\n\n      while (count < 5) {\n        codePoint = getCodePoint(text.substr(index, 2));\n\n        if (codePoint < A_TAG_CODE_POINT || codePoint > Z_TAG_CODE_POINT) {\n          return false;\n        }\n\n        count += 1;\n        index += 2;\n      }\n\n      return getCodePoint(text.substr(index, 2)) === CANCEL_TAG_CODE_POINT;\n    }\n\n    function setIsLoaded() {\n      this.isLoaded = true;\n    }\n\n    var Font = function Font() {\n      this.fonts = [];\n      this.chars = null;\n      this.typekitLoaded = 0;\n      this.isLoaded = false;\n      this._warned = false;\n      this.initTime = Date.now();\n      this.setIsLoadedBinded = this.setIsLoaded.bind(this);\n      this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);\n    };\n\n    Font.isModifier = isModifier;\n    Font.isZeroWidthJoiner = isZeroWidthJoiner;\n    Font.isFlagEmoji = isFlagEmoji;\n    Font.isRegionalCode = isRegionalCode;\n    Font.isCombinedCharacter = isCombinedCharacter;\n    Font.isRegionalFlag = isRegionalFlag;\n    Font.isVariationSelector = isVariationSelector;\n    Font.BLACK_FLAG_CODE_POINT = BLACK_FLAG_CODE_POINT;\n    var fontPrototype = {\n      addChars: addChars,\n      addFonts: addFonts,\n      getCharData: getCharData,\n      getFontByName: getFontByName,\n      measureText: measureText,\n      checkLoadedFonts: checkLoadedFonts,\n      setIsLoaded: setIsLoaded\n    };\n    Font.prototype = fontPrototype;\n    return Font;\n  }();\n\n  function SlotManager(animationData) {\n    this.animationData = animationData;\n  }\n\n  SlotManager.prototype.getProp = function (data) {\n    if (this.animationData.slots && this.animationData.slots[data.sid]) {\n      return Object.assign(data, this.animationData.slots[data.sid].p);\n    }\n\n    return data;\n  };\n\n  function slotFactory(animationData) {\n    return new SlotManager(animationData);\n  }\n\n  function RenderableElement() {}\n\n  RenderableElement.prototype = {\n    initRenderable: function initRenderable() {\n      // layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange\n      this.isInRange = false; // layer's display state\n\n      this.hidden = false; // If layer's transparency equals 0, it can be hidden\n\n      this.isTransparent = false; // list of animated components\n\n      this.renderableComponents = [];\n    },\n    addRenderableComponent: function addRenderableComponent(component) {\n      if (this.renderableComponents.indexOf(component) === -1) {\n        this.renderableComponents.push(component);\n      }\n    },\n    removeRenderableComponent: function removeRenderableComponent(component) {\n      if (this.renderableComponents.indexOf(component) !== -1) {\n        this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);\n      }\n    },\n    prepareRenderableFrame: function prepareRenderableFrame(num) {\n      this.checkLayerLimits(num);\n    },\n    checkTransparency: function checkTransparency() {\n      if (this.finalTransform.mProp.o.v <= 0) {\n        if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {\n          this.isTransparent = true;\n          this.hide();\n        }\n      } else if (this.isTransparent) {\n        this.isTransparent = false;\n        this.show();\n      }\n    },\n\n    /**\r\n       * @function\r\n       * Initializes frame related properties.\r\n       *\r\n       * @param {number} num\r\n       * current frame number in Layer's time\r\n       *\r\n       */\n    checkLayerLimits: function checkLayerLimits(num) {\n      if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {\n        if (this.isInRange !== true) {\n          this.globalData._mdf = true;\n          this._mdf = true;\n          this.isInRange = true;\n          this.show();\n        }\n      } else if (this.isInRange !== false) {\n        this.globalData._mdf = true;\n        this.isInRange = false;\n        this.hide();\n      }\n    },\n    renderRenderable: function renderRenderable() {\n      var i;\n      var len = this.renderableComponents.length;\n\n      for (i = 0; i < len; i += 1) {\n        this.renderableComponents[i].renderFrame(this._isFirstFrame);\n      }\n      /* this.maskManager.renderFrame(this.finalTransform.mat);\r\n          this.renderableEffectsManager.renderFrame(this._isFirstFrame); */\n\n    },\n    sourceRectAtTime: function sourceRectAtTime() {\n      return {\n        top: 0,\n        left: 0,\n        width: 100,\n        height: 100\n      };\n    },\n    getLayerSize: function getLayerSize() {\n      if (this.data.ty === 5) {\n        return {\n          w: this.data.textData.width,\n          h: this.data.textData.height\n        };\n      }\n\n      return {\n        w: this.data.width,\n        h: this.data.height\n      };\n    }\n  };\n\n  var getBlendMode = function () {\n    var blendModeEnums = {\n      0: 'source-over',\n      1: 'multiply',\n      2: 'screen',\n      3: 'overlay',\n      4: 'darken',\n      5: 'lighten',\n      6: 'color-dodge',\n      7: 'color-burn',\n      8: 'hard-light',\n      9: 'soft-light',\n      10: 'difference',\n      11: 'exclusion',\n      12: 'hue',\n      13: 'saturation',\n      14: 'color',\n      15: 'luminosity'\n    };\n    return function (mode) {\n      return blendModeEnums[mode] || '';\n    };\n  }();\n\n  function SliderEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n  }\n\n  function AngleEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n  }\n\n  function ColorEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);\n  }\n\n  function PointEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);\n  }\n\n  function LayerIndexEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n  }\n\n  function MaskIndexEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n  }\n\n  function CheckboxEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n  }\n\n  function NoValueEffect() {\n    this.p = {};\n  }\n\n  function EffectsManager(data, element) {\n    var effects = data.ef || [];\n    this.effectElements = [];\n    var i;\n    var len = effects.length;\n    var effectItem;\n\n    for (i = 0; i < len; i += 1) {\n      effectItem = new GroupEffect(effects[i], element);\n      this.effectElements.push(effectItem);\n    }\n  }\n\n  function GroupEffect(data, element) {\n    this.init(data, element);\n  }\n\n  extendPrototype([DynamicPropertyContainer], GroupEffect);\n  GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;\n\n  GroupEffect.prototype.init = function (data, element) {\n    this.data = data;\n    this.effectElements = [];\n    this.initDynamicPropertyContainer(element);\n    var i;\n    var len = this.data.ef.length;\n    var eff;\n    var effects = this.data.ef;\n\n    for (i = 0; i < len; i += 1) {\n      eff = null;\n\n      switch (effects[i].ty) {\n        case 0:\n          eff = new SliderEffect(effects[i], element, this);\n          break;\n\n        case 1:\n          eff = new AngleEffect(effects[i], element, this);\n          break;\n\n        case 2:\n          eff = new ColorEffect(effects[i], element, this);\n          break;\n\n        case 3:\n          eff = new PointEffect(effects[i], element, this);\n          break;\n\n        case 4:\n        case 7:\n          eff = new CheckboxEffect(effects[i], element, this);\n          break;\n\n        case 10:\n          eff = new LayerIndexEffect(effects[i], element, this);\n          break;\n\n        case 11:\n          eff = new MaskIndexEffect(effects[i], element, this);\n          break;\n\n        case 5:\n          eff = new EffectsManager(effects[i], element, this);\n          break;\n        // case 6:\n\n        default:\n          eff = new NoValueEffect(effects[i], element, this);\n          break;\n      }\n\n      if (eff) {\n        this.effectElements.push(eff);\n      }\n    }\n  };\n\n  function BaseElement() {}\n\n  BaseElement.prototype = {\n    checkMasks: function checkMasks() {\n      if (!this.data.hasMask) {\n        return false;\n      }\n\n      var i = 0;\n      var len = this.data.masksProperties.length;\n\n      while (i < len) {\n        if (this.data.masksProperties[i].mode !== 'n' && this.data.masksProperties[i].cl !== false) {\n          return true;\n        }\n\n        i += 1;\n      }\n\n      return false;\n    },\n    initExpressions: function initExpressions() {\n      var expressionsInterfaces = getExpressionInterfaces();\n\n      if (!expressionsInterfaces) {\n        return;\n      }\n\n      var LayerExpressionInterface = expressionsInterfaces('layer');\n      var EffectsExpressionInterface = expressionsInterfaces('effects');\n      var ShapeExpressionInterface = expressionsInterfaces('shape');\n      var TextExpressionInterface = expressionsInterfaces('text');\n      var CompExpressionInterface = expressionsInterfaces('comp');\n      this.layerInterface = LayerExpressionInterface(this);\n\n      if (this.data.hasMask && this.maskManager) {\n        this.layerInterface.registerMaskInterface(this.maskManager);\n      }\n\n      var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);\n      this.layerInterface.registerEffectsInterface(effectsInterface);\n\n      if (this.data.ty === 0 || this.data.xt) {\n        this.compInterface = CompExpressionInterface(this);\n      } else if (this.data.ty === 4) {\n        this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface);\n        this.layerInterface.content = this.layerInterface.shapeInterface;\n      } else if (this.data.ty === 5) {\n        this.layerInterface.textInterface = TextExpressionInterface(this);\n        this.layerInterface.text = this.layerInterface.textInterface;\n      }\n    },\n    setBlendMode: function setBlendMode() {\n      var blendModeValue = getBlendMode(this.data.bm);\n      var elem = this.baseElement || this.layerElement;\n      elem.style['mix-blend-mode'] = blendModeValue;\n    },\n    initBaseData: function initBaseData(data, globalData, comp) {\n      this.globalData = globalData;\n      this.comp = comp;\n      this.data = data;\n      this.layerId = createElementID(); // Stretch factor for old animations missing this property.\n\n      if (!this.data.sr) {\n        this.data.sr = 1;\n      } // effects manager\n\n\n      this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);\n    },\n    getType: function getType() {\n      return this.type;\n    },\n    sourceRectAtTime: function sourceRectAtTime() {}\n  };\n\n  /**\r\n   * @file\r\n   * Handles element's layer frame update.\r\n   * Checks layer in point and out point\r\n   *\r\n   */\n  function FrameElement() {}\n\n  FrameElement.prototype = {\n    /**\r\n       * @function\r\n       * Initializes frame related properties.\r\n       *\r\n       */\n    initFrame: function initFrame() {\n      // set to true when inpoint is rendered\n      this._isFirstFrame = false; // list of animated properties\n\n      this.dynamicProperties = []; // If layer has been modified in current tick this will be true\n\n      this._mdf = false;\n    },\n\n    /**\r\n       * @function\r\n       * Calculates all dynamic values\r\n       *\r\n       * @param {number} num\r\n       * current frame number in Layer's time\r\n       * @param {boolean} isVisible\r\n       * if layers is currently in range\r\n       *\r\n       */\n    prepareProperties: function prepareProperties(num, isVisible) {\n      var i;\n      var len = this.dynamicProperties.length;\n\n      for (i = 0; i < len; i += 1) {\n        if (isVisible || this._isParent && this.dynamicProperties[i].propType === 'transform') {\n          this.dynamicProperties[i].getValue();\n\n          if (this.dynamicProperties[i]._mdf) {\n            this.globalData._mdf = true;\n            this._mdf = true;\n          }\n        }\n      }\n    },\n    addDynamicProperty: function addDynamicProperty(prop) {\n      if (this.dynamicProperties.indexOf(prop) === -1) {\n        this.dynamicProperties.push(prop);\n      }\n    }\n  };\n\n  function FootageElement(data, globalData, comp) {\n    this.initFrame();\n    this.initRenderable();\n    this.assetData = globalData.getAssetData(data.refId);\n    this.footageData = globalData.imageLoader.getAsset(this.assetData);\n    this.initBaseData(data, globalData, comp);\n  }\n\n  FootageElement.prototype.prepareFrame = function () {};\n\n  extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement);\n\n  FootageElement.prototype.getBaseElement = function () {\n    return null;\n  };\n\n  FootageElement.prototype.renderFrame = function () {};\n\n  FootageElement.prototype.destroy = function () {};\n\n  FootageElement.prototype.initExpressions = function () {\n    var expressionsInterfaces = getExpressionInterfaces();\n\n    if (!expressionsInterfaces) {\n      return;\n    }\n\n    var FootageInterface = expressionsInterfaces('footage');\n    this.layerInterface = FootageInterface(this);\n  };\n\n  FootageElement.prototype.getFootageData = function () {\n    return this.footageData;\n  };\n\n  function AudioElement(data, globalData, comp) {\n    this.initFrame();\n    this.initRenderable();\n    this.assetData = globalData.getAssetData(data.refId);\n    this.initBaseData(data, globalData, comp);\n    this._isPlaying = false;\n    this._canPlay = false;\n    var assetPath = this.globalData.getAssetsPath(this.assetData);\n    this.audio = this.globalData.audioController.createAudio(assetPath);\n    this._currentTime = 0;\n    this.globalData.audioController.addAudio(this);\n    this._volumeMultiplier = 1;\n    this._volume = 1;\n    this._previousVolume = null;\n    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n      _placeholder: true\n    };\n    this.lv = PropertyFactory.getProp(this, data.au && data.au.lv ? data.au.lv : {\n      k: [100]\n    }, 1, 0.01, this);\n  }\n\n  AudioElement.prototype.prepareFrame = function (num) {\n    this.prepareRenderableFrame(num, true);\n    this.prepareProperties(num, true);\n\n    if (!this.tm._placeholder) {\n      var timeRemapped = this.tm.v;\n      this._currentTime = timeRemapped;\n    } else {\n      this._currentTime = num / this.data.sr;\n    }\n\n    this._volume = this.lv.v[0];\n    var totalVolume = this._volume * this._volumeMultiplier;\n\n    if (this._previousVolume !== totalVolume) {\n      this._previousVolume = totalVolume;\n      this.audio.volume(totalVolume);\n    }\n  };\n\n  extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);\n\n  AudioElement.prototype.renderFrame = function () {\n    if (this.isInRange && this._canPlay) {\n      if (!this._isPlaying) {\n        this.audio.play();\n        this.audio.seek(this._currentTime / this.globalData.frameRate);\n        this._isPlaying = true;\n      } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) {\n        this.audio.seek(this._currentTime / this.globalData.frameRate);\n      }\n    }\n  };\n\n  AudioElement.prototype.show = function () {// this.audio.play()\n  };\n\n  AudioElement.prototype.hide = function () {\n    this.audio.pause();\n    this._isPlaying = false;\n  };\n\n  AudioElement.prototype.pause = function () {\n    this.audio.pause();\n    this._isPlaying = false;\n    this._canPlay = false;\n  };\n\n  AudioElement.prototype.resume = function () {\n    this._canPlay = true;\n  };\n\n  AudioElement.prototype.setRate = function (rateValue) {\n    this.audio.rate(rateValue);\n  };\n\n  AudioElement.prototype.volume = function (volumeValue) {\n    this._volumeMultiplier = volumeValue;\n    this._previousVolume = volumeValue * this._volume;\n    this.audio.volume(this._previousVolume);\n  };\n\n  AudioElement.prototype.getBaseElement = function () {\n    return null;\n  };\n\n  AudioElement.prototype.destroy = function () {};\n\n  AudioElement.prototype.sourceRectAtTime = function () {};\n\n  AudioElement.prototype.initExpressions = function () {};\n\n  function BaseRenderer() {}\n\n  BaseRenderer.prototype.checkLayers = function (num) {\n    var i;\n    var len = this.layers.length;\n    var data;\n    this.completeLayers = true;\n\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (!this.elements[i]) {\n        data = this.layers[i];\n\n        if (data.ip - data.st <= num - this.layers[i].st && data.op - data.st > num - this.layers[i].st) {\n          this.buildItem(i);\n        }\n      }\n\n      this.completeLayers = this.elements[i] ? this.completeLayers : false;\n    }\n\n    this.checkPendingElements();\n  };\n\n  BaseRenderer.prototype.createItem = function (layer) {\n    switch (layer.ty) {\n      case 2:\n        return this.createImage(layer);\n\n      case 0:\n        return this.createComp(layer);\n\n      case 1:\n        return this.createSolid(layer);\n\n      case 3:\n        return this.createNull(layer);\n\n      case 4:\n        return this.createShape(layer);\n\n      case 5:\n        return this.createText(layer);\n\n      case 6:\n        return this.createAudio(layer);\n\n      case 13:\n        return this.createCamera(layer);\n\n      case 15:\n        return this.createFootage(layer);\n\n      default:\n        return this.createNull(layer);\n    }\n  };\n\n  BaseRenderer.prototype.createCamera = function () {\n    throw new Error('You\\'re using a 3d camera. Try the html renderer.');\n  };\n\n  BaseRenderer.prototype.createAudio = function (data) {\n    return new AudioElement(data, this.globalData, this);\n  };\n\n  BaseRenderer.prototype.createFootage = function (data) {\n    return new FootageElement(data, this.globalData, this);\n  };\n\n  BaseRenderer.prototype.buildAllItems = function () {\n    var i;\n    var len = this.layers.length;\n\n    for (i = 0; i < len; i += 1) {\n      this.buildItem(i);\n    }\n\n    this.checkPendingElements();\n  };\n\n  BaseRenderer.prototype.includeLayers = function (newLayers) {\n    this.completeLayers = false;\n    var i;\n    var len = newLayers.length;\n    var j;\n    var jLen = this.layers.length;\n\n    for (i = 0; i < len; i += 1) {\n      j = 0;\n\n      while (j < jLen) {\n        if (this.layers[j].id === newLayers[i].id) {\n          this.layers[j] = newLayers[i];\n          break;\n        }\n\n        j += 1;\n      }\n    }\n  };\n\n  BaseRenderer.prototype.setProjectInterface = function (pInterface) {\n    this.globalData.projectInterface = pInterface;\n  };\n\n  BaseRenderer.prototype.initItems = function () {\n    if (!this.globalData.progressiveLoad) {\n      this.buildAllItems();\n    }\n  };\n\n  BaseRenderer.prototype.buildElementParenting = function (element, parentName, hierarchy) {\n    var elements = this.elements;\n    var layers = this.layers;\n    var i = 0;\n    var len = layers.length;\n\n    while (i < len) {\n      if (layers[i].ind == parentName) {\n        // eslint-disable-line eqeqeq\n        if (!elements[i] || elements[i] === true) {\n          this.buildItem(i);\n          this.addPendingElement(element);\n        } else {\n          hierarchy.push(elements[i]);\n          elements[i].setAsParent();\n\n          if (layers[i].parent !== undefined) {\n            this.buildElementParenting(element, layers[i].parent, hierarchy);\n          } else {\n            element.setHierarchy(hierarchy);\n          }\n        }\n      }\n\n      i += 1;\n    }\n  };\n\n  BaseRenderer.prototype.addPendingElement = function (element) {\n    this.pendingElements.push(element);\n  };\n\n  BaseRenderer.prototype.searchExtraCompositions = function (assets) {\n    var i;\n    var len = assets.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (assets[i].xt) {\n        var comp = this.createComp(assets[i]);\n        comp.initExpressions();\n        this.globalData.projectInterface.registerComposition(comp);\n      }\n    }\n  };\n\n  BaseRenderer.prototype.getElementById = function (ind) {\n    var i;\n    var len = this.elements.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.elements[i].data.ind === ind) {\n        return this.elements[i];\n      }\n    }\n\n    return null;\n  };\n\n  BaseRenderer.prototype.getElementByPath = function (path) {\n    var pathValue = path.shift();\n    var element;\n\n    if (typeof pathValue === 'number') {\n      element = this.elements[pathValue];\n    } else {\n      var i;\n      var len = this.elements.length;\n\n      for (i = 0; i < len; i += 1) {\n        if (this.elements[i].data.nm === pathValue) {\n          element = this.elements[i];\n          break;\n        }\n      }\n    }\n\n    if (path.length === 0) {\n      return element;\n    }\n\n    return element.getElementByPath(path);\n  };\n\n  BaseRenderer.prototype.setupGlobalData = function (animData, fontsContainer) {\n    this.globalData.fontManager = new FontManager();\n    this.globalData.slotManager = slotFactory(animData);\n    this.globalData.fontManager.addChars(animData.chars);\n    this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);\n    this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);\n    this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);\n    this.globalData.imageLoader = this.animationItem.imagePreloader;\n    this.globalData.audioController = this.animationItem.audioController;\n    this.globalData.frameId = 0;\n    this.globalData.frameRate = animData.fr;\n    this.globalData.nm = animData.nm;\n    this.globalData.compSize = {\n      w: animData.w,\n      h: animData.h\n    };\n  };\n\n  var effectTypes = {\n    TRANSFORM_EFFECT: 'transformEFfect'\n  };\n\n  function TransformElement() {}\n\n  TransformElement.prototype = {\n    initTransform: function initTransform() {\n      var mat = new Matrix();\n      this.finalTransform = {\n        mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {\n          o: 0\n        },\n        _matMdf: false,\n        _localMatMdf: false,\n        _opMdf: false,\n        mat: mat,\n        localMat: mat,\n        localOpacity: 1\n      };\n\n      if (this.data.ao) {\n        this.finalTransform.mProp.autoOriented = true;\n      } // TODO: check TYPE 11: Guided elements\n\n\n      if (this.data.ty !== 11) {// this.createElements();\n      }\n    },\n    renderTransform: function renderTransform() {\n      this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;\n      this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;\n\n      if (this.hierarchy) {\n        var mat;\n        var finalMat = this.finalTransform.mat;\n        var i = 0;\n        var len = this.hierarchy.length; // Checking if any of the transformation matrices in the hierarchy chain has changed.\n\n        if (!this.finalTransform._matMdf) {\n          while (i < len) {\n            if (this.hierarchy[i].finalTransform.mProp._mdf) {\n              this.finalTransform._matMdf = true;\n              break;\n            }\n\n            i += 1;\n          }\n        }\n\n        if (this.finalTransform._matMdf) {\n          mat = this.finalTransform.mProp.v.props;\n          finalMat.cloneFromProps(mat);\n\n          for (i = 0; i < len; i += 1) {\n            finalMat.multiply(this.hierarchy[i].finalTransform.mProp.v);\n          }\n        }\n      }\n\n      if (this.finalTransform._matMdf) {\n        this.finalTransform._localMatMdf = this.finalTransform._matMdf;\n      }\n\n      if (this.finalTransform._opMdf) {\n        this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;\n      }\n    },\n    renderLocalTransform: function renderLocalTransform() {\n      if (this.localTransforms) {\n        var i = 0;\n        var len = this.localTransforms.length;\n        this.finalTransform._localMatMdf = this.finalTransform._matMdf;\n\n        if (!this.finalTransform._localMatMdf || !this.finalTransform._opMdf) {\n          while (i < len) {\n            if (this.localTransforms[i]._mdf) {\n              this.finalTransform._localMatMdf = true;\n            }\n\n            if (this.localTransforms[i]._opMdf && !this.finalTransform._opMdf) {\n              this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;\n              this.finalTransform._opMdf = true;\n            }\n\n            i += 1;\n          }\n        }\n\n        if (this.finalTransform._localMatMdf) {\n          var localMat = this.finalTransform.localMat;\n          this.localTransforms[0].matrix.clone(localMat);\n\n          for (i = 1; i < len; i += 1) {\n            var lmat = this.localTransforms[i].matrix;\n            localMat.multiply(lmat);\n          }\n\n          localMat.multiply(this.finalTransform.mat);\n        }\n\n        if (this.finalTransform._opMdf) {\n          var localOp = this.finalTransform.localOpacity;\n\n          for (i = 0; i < len; i += 1) {\n            localOp *= this.localTransforms[i].opacity * 0.01;\n          }\n\n          this.finalTransform.localOpacity = localOp;\n        }\n      }\n    },\n    searchEffectTransforms: function searchEffectTransforms() {\n      if (this.renderableEffectsManager) {\n        var transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);\n\n        if (transformEffects.length) {\n          this.localTransforms = [];\n          this.finalTransform.localMat = new Matrix();\n          var i = 0;\n          var len = transformEffects.length;\n\n          for (i = 0; i < len; i += 1) {\n            this.localTransforms.push(transformEffects[i]);\n          }\n        }\n      }\n    },\n    globalToLocal: function globalToLocal(pt) {\n      var transforms = [];\n      transforms.push(this.finalTransform);\n      var flag = true;\n      var comp = this.comp;\n\n      while (flag) {\n        if (comp.finalTransform) {\n          if (comp.data.hasMask) {\n            transforms.splice(0, 0, comp.finalTransform);\n          }\n\n          comp = comp.comp;\n        } else {\n          flag = false;\n        }\n      }\n\n      var i;\n      var len = transforms.length;\n      var ptNew;\n\n      for (i = 0; i < len; i += 1) {\n        ptNew = transforms[i].mat.applyToPointArray(0, 0, 0); // ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);\n\n        pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];\n      }\n\n      return pt;\n    },\n    mHelper: new Matrix()\n  };\n\n  function MaskElement(data, element, globalData) {\n    this.data = data;\n    this.element = element;\n    this.globalData = globalData;\n    this.storedData = [];\n    this.masksProperties = this.data.masksProperties || [];\n    this.maskElement = null;\n    var defs = this.globalData.defs;\n    var i;\n    var len = this.masksProperties ? this.masksProperties.length : 0;\n    this.viewData = createSizedArray(len);\n    this.solidPath = '';\n    var path;\n    var properties = this.masksProperties;\n    var count = 0;\n    var currentMasks = [];\n    var j;\n    var jLen;\n    var layerId = createElementID();\n    var rect;\n    var expansor;\n    var feMorph;\n    var x;\n    var maskType = 'clipPath';\n    var maskRef = 'clip-path';\n\n    for (i = 0; i < len; i += 1) {\n      if (properties[i].mode !== 'a' && properties[i].mode !== 'n' || properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x) {\n        maskType = 'mask';\n        maskRef = 'mask';\n      }\n\n      if ((properties[i].mode === 's' || properties[i].mode === 'i') && count === 0) {\n        rect = createNS('rect');\n        rect.setAttribute('fill', '#ffffff');\n        rect.setAttribute('width', this.element.comp.data.w || 0);\n        rect.setAttribute('height', this.element.comp.data.h || 0);\n        currentMasks.push(rect);\n      } else {\n        rect = null;\n      }\n\n      path = createNS('path');\n\n      if (properties[i].mode === 'n') {\n        // TODO move this to a factory or to a constructor\n        this.viewData[i] = {\n          op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),\n          prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),\n          elem: path,\n          lastPath: ''\n        };\n        defs.appendChild(path);\n      } else {\n        count += 1;\n        path.setAttribute('fill', properties[i].mode === 's' ? '#000000' : '#ffffff');\n        path.setAttribute('clip-rule', 'nonzero');\n        var filterID;\n\n        if (properties[i].x.k !== 0) {\n          maskType = 'mask';\n          maskRef = 'mask';\n          x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element);\n          filterID = createElementID();\n          expansor = createNS('filter');\n          expansor.setAttribute('id', filterID);\n          feMorph = createNS('feMorphology');\n          feMorph.setAttribute('operator', 'erode');\n          feMorph.setAttribute('in', 'SourceGraphic');\n          feMorph.setAttribute('radius', '0');\n          expansor.appendChild(feMorph);\n          defs.appendChild(expansor);\n          path.setAttribute('stroke', properties[i].mode === 's' ? '#000000' : '#ffffff');\n        } else {\n          feMorph = null;\n          x = null;\n        } // TODO move this to a factory or to a constructor\n\n\n        this.storedData[i] = {\n          elem: path,\n          x: x,\n          expan: feMorph,\n          lastPath: '',\n          lastOperator: '',\n          filterId: filterID,\n          lastRadius: 0\n        };\n\n        if (properties[i].mode === 'i') {\n          jLen = currentMasks.length;\n          var g = createNS('g');\n\n          for (j = 0; j < jLen; j += 1) {\n            g.appendChild(currentMasks[j]);\n          }\n\n          var mask = createNS('mask');\n          mask.setAttribute('mask-type', 'alpha');\n          mask.setAttribute('id', layerId + '_' + count);\n          mask.appendChild(path);\n          defs.appendChild(mask);\n          g.setAttribute('mask', 'url(' + getLocationHref() + '#' + layerId + '_' + count + ')');\n          currentMasks.length = 0;\n          currentMasks.push(g);\n        } else {\n          currentMasks.push(path);\n        }\n\n        if (properties[i].inv && !this.solidPath) {\n          this.solidPath = this.createLayerSolidPath();\n        } // TODO move this to a factory or to a constructor\n\n\n        this.viewData[i] = {\n          elem: path,\n          lastPath: '',\n          op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),\n          prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),\n          invRect: rect\n        };\n\n        if (!this.viewData[i].prop.k) {\n          this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i]);\n        }\n      }\n    }\n\n    this.maskElement = createNS(maskType);\n    len = currentMasks.length;\n\n    for (i = 0; i < len; i += 1) {\n      this.maskElement.appendChild(currentMasks[i]);\n    }\n\n    if (count > 0) {\n      this.maskElement.setAttribute('id', layerId);\n      this.element.maskedElement.setAttribute(maskRef, 'url(' + getLocationHref() + '#' + layerId + ')');\n      defs.appendChild(this.maskElement);\n    }\n\n    if (this.viewData.length) {\n      this.element.addRenderableComponent(this);\n    }\n  }\n\n  MaskElement.prototype.getMaskProperty = function (pos) {\n    return this.viewData[pos].prop;\n  };\n\n  MaskElement.prototype.renderFrame = function (isFirstFrame) {\n    var finalMat = this.element.finalTransform.mat;\n    var i;\n    var len = this.masksProperties.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.viewData[i].prop._mdf || isFirstFrame) {\n        this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]);\n      }\n\n      if (this.viewData[i].op._mdf || isFirstFrame) {\n        this.viewData[i].elem.setAttribute('fill-opacity', this.viewData[i].op.v);\n      }\n\n      if (this.masksProperties[i].mode !== 'n') {\n        if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {\n          this.viewData[i].invRect.setAttribute('transform', finalMat.getInverseMatrix().to2dCSS());\n        }\n\n        if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {\n          var feMorph = this.storedData[i].expan;\n\n          if (this.storedData[i].x.v < 0) {\n            if (this.storedData[i].lastOperator !== 'erode') {\n              this.storedData[i].lastOperator = 'erode';\n              this.storedData[i].elem.setAttribute('filter', 'url(' + getLocationHref() + '#' + this.storedData[i].filterId + ')');\n            }\n\n            feMorph.setAttribute('radius', -this.storedData[i].x.v);\n          } else {\n            if (this.storedData[i].lastOperator !== 'dilate') {\n              this.storedData[i].lastOperator = 'dilate';\n              this.storedData[i].elem.setAttribute('filter', null);\n            }\n\n            this.storedData[i].elem.setAttribute('stroke-width', this.storedData[i].x.v * 2);\n          }\n        }\n      }\n    }\n  };\n\n  MaskElement.prototype.getMaskelement = function () {\n    return this.maskElement;\n  };\n\n  MaskElement.prototype.createLayerSolidPath = function () {\n    var path = 'M0,0 ';\n    path += ' h' + this.globalData.compSize.w;\n    path += ' v' + this.globalData.compSize.h;\n    path += ' h-' + this.globalData.compSize.w;\n    path += ' v-' + this.globalData.compSize.h + ' ';\n    return path;\n  };\n\n  MaskElement.prototype.drawPath = function (pathData, pathNodes, viewData) {\n    var pathString = ' M' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];\n    var i;\n    var len;\n    len = pathNodes._length;\n\n    for (i = 1; i < len; i += 1) {\n      // pathString += \" C\"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + \" \"+pathNodes.i[i][0]+','+pathNodes.i[i][1] + \" \"+pathNodes.v[i][0]+','+pathNodes.v[i][1];\n      pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[i][0] + ',' + pathNodes.i[i][1] + ' ' + pathNodes.v[i][0] + ',' + pathNodes.v[i][1];\n    } // pathString += \" C\"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + \" \"+pathNodes.i[0][0]+','+pathNodes.i[0][1] + \" \"+pathNodes.v[0][0]+','+pathNodes.v[0][1];\n\n\n    if (pathNodes.c && len > 1) {\n      pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[0][0] + ',' + pathNodes.i[0][1] + ' ' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];\n    } // pathNodes.__renderedString = pathString;\n\n\n    if (viewData.lastPath !== pathString) {\n      var pathShapeValue = '';\n\n      if (viewData.elem) {\n        if (pathNodes.c) {\n          pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;\n        }\n\n        viewData.elem.setAttribute('d', pathShapeValue);\n      }\n\n      viewData.lastPath = pathString;\n    }\n  };\n\n  MaskElement.prototype.destroy = function () {\n    this.element = null;\n    this.globalData = null;\n    this.maskElement = null;\n    this.data = null;\n    this.masksProperties = null;\n  };\n\n  var filtersFactory = function () {\n    var ob = {};\n    ob.createFilter = createFilter;\n    ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;\n\n    function createFilter(filId, skipCoordinates) {\n      var fil = createNS('filter');\n      fil.setAttribute('id', filId);\n\n      if (skipCoordinates !== true) {\n        fil.setAttribute('filterUnits', 'objectBoundingBox');\n        fil.setAttribute('x', '0%');\n        fil.setAttribute('y', '0%');\n        fil.setAttribute('width', '100%');\n        fil.setAttribute('height', '100%');\n      }\n\n      return fil;\n    }\n\n    function createAlphaToLuminanceFilter() {\n      var feColorMatrix = createNS('feColorMatrix');\n      feColorMatrix.setAttribute('type', 'matrix');\n      feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');\n      feColorMatrix.setAttribute('values', '0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1');\n      return feColorMatrix;\n    }\n\n    return ob;\n  }();\n\n  var featureSupport = function () {\n    var ob = {\n      maskType: true,\n      svgLumaHidden: true,\n      offscreenCanvas: typeof OffscreenCanvas !== 'undefined'\n    };\n\n    if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\\/\\d./i.test(navigator.userAgent)) {\n      ob.maskType = false;\n    }\n\n    if (/firefox/i.test(navigator.userAgent)) {\n      ob.svgLumaHidden = false;\n    }\n\n    return ob;\n  }();\n\n  var registeredEffects$1 = {};\n  var idPrefix = 'filter_result_';\n\n  function SVGEffects(elem) {\n    var i;\n    var source = 'SourceGraphic';\n    var len = elem.data.ef ? elem.data.ef.length : 0;\n    var filId = createElementID();\n    var fil = filtersFactory.createFilter(filId, true);\n    var count = 0;\n    this.filters = [];\n    var filterManager;\n\n    for (i = 0; i < len; i += 1) {\n      filterManager = null;\n      var type = elem.data.ef[i].ty;\n\n      if (registeredEffects$1[type]) {\n        var Effect = registeredEffects$1[type].effect;\n        filterManager = new Effect(fil, elem.effectsManager.effectElements[i], elem, idPrefix + count, source);\n        source = idPrefix + count;\n\n        if (registeredEffects$1[type].countsAsEffect) {\n          count += 1;\n        }\n      }\n\n      if (filterManager) {\n        this.filters.push(filterManager);\n      }\n    }\n\n    if (count) {\n      elem.globalData.defs.appendChild(fil);\n      elem.layerElement.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');\n    }\n\n    if (this.filters.length) {\n      elem.addRenderableComponent(this);\n    }\n  }\n\n  SVGEffects.prototype.renderFrame = function (_isFirstFrame) {\n    var i;\n    var len = this.filters.length;\n\n    for (i = 0; i < len; i += 1) {\n      this.filters[i].renderFrame(_isFirstFrame);\n    }\n  };\n\n  SVGEffects.prototype.getEffects = function (type) {\n    var i;\n    var len = this.filters.length;\n    var effects = [];\n\n    for (i = 0; i < len; i += 1) {\n      if (this.filters[i].type === type) {\n        effects.push(this.filters[i]);\n      }\n    }\n\n    return effects;\n  };\n\n  function registerEffect$1(id, effect, countsAsEffect) {\n    registeredEffects$1[id] = {\n      effect: effect,\n      countsAsEffect: countsAsEffect\n    };\n  }\n\n  function SVGBaseElement() {}\n\n  SVGBaseElement.prototype = {\n    initRendererElement: function initRendererElement() {\n      this.layerElement = createNS('g');\n    },\n    createContainerElements: function createContainerElements() {\n      this.matteElement = createNS('g');\n      this.transformedElement = this.layerElement;\n      this.maskedElement = this.layerElement;\n      this._sizeChanged = false;\n      var layerElementParent = null; // If this layer acts as a mask for the following layer\n\n      if (this.data.td) {\n        this.matteMasks = {};\n        var gg = createNS('g');\n        gg.setAttribute('id', this.layerId);\n        gg.appendChild(this.layerElement);\n        layerElementParent = gg;\n        this.globalData.defs.appendChild(gg);\n      } else if (this.data.tt) {\n        this.matteElement.appendChild(this.layerElement);\n        layerElementParent = this.matteElement;\n        this.baseElement = this.matteElement;\n      } else {\n        this.baseElement = this.layerElement;\n      }\n\n      if (this.data.ln) {\n        this.layerElement.setAttribute('id', this.data.ln);\n      }\n\n      if (this.data.cl) {\n        this.layerElement.setAttribute('class', this.data.cl);\n      } // Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped\n\n\n      if (this.data.ty === 0 && !this.data.hd) {\n        var cp = createNS('clipPath');\n        var pt = createNS('path');\n        pt.setAttribute('d', 'M0,0 L' + this.data.w + ',0 L' + this.data.w + ',' + this.data.h + ' L0,' + this.data.h + 'z');\n        var clipId = createElementID();\n        cp.setAttribute('id', clipId);\n        cp.appendChild(pt);\n        this.globalData.defs.appendChild(cp);\n\n        if (this.checkMasks()) {\n          var cpGroup = createNS('g');\n          cpGroup.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + clipId + ')');\n          cpGroup.appendChild(this.layerElement);\n          this.transformedElement = cpGroup;\n\n          if (layerElementParent) {\n            layerElementParent.appendChild(this.transformedElement);\n          } else {\n            this.baseElement = this.transformedElement;\n          }\n        } else {\n          this.layerElement.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + clipId + ')');\n        }\n      }\n\n      if (this.data.bm !== 0) {\n        this.setBlendMode();\n      }\n    },\n    renderElement: function renderElement() {\n      if (this.finalTransform._localMatMdf) {\n        this.transformedElement.setAttribute('transform', this.finalTransform.localMat.to2dCSS());\n      }\n\n      if (this.finalTransform._opMdf) {\n        this.transformedElement.setAttribute('opacity', this.finalTransform.localOpacity);\n      }\n    },\n    destroyBaseElement: function destroyBaseElement() {\n      this.layerElement = null;\n      this.matteElement = null;\n      this.maskManager.destroy();\n    },\n    getBaseElement: function getBaseElement() {\n      if (this.data.hd) {\n        return null;\n      }\n\n      return this.baseElement;\n    },\n    createRenderableComponents: function createRenderableComponents() {\n      this.maskManager = new MaskElement(this.data, this, this.globalData);\n      this.renderableEffectsManager = new SVGEffects(this);\n      this.searchEffectTransforms();\n    },\n    getMatte: function getMatte(matteType) {\n      // This should not be a common case. But for backward compatibility, we'll create the matte object.\n      // It solves animations that have two consecutive layers marked as matte masks.\n      // Which is an undefined behavior in AE.\n      if (!this.matteMasks) {\n        this.matteMasks = {};\n      }\n\n      if (!this.matteMasks[matteType]) {\n        var id = this.layerId + '_' + matteType;\n        var filId;\n        var fil;\n        var useElement;\n        var gg;\n\n        if (matteType === 1 || matteType === 3) {\n          var masker = createNS('mask');\n          masker.setAttribute('id', id);\n          masker.setAttribute('mask-type', matteType === 3 ? 'luminance' : 'alpha');\n          useElement = createNS('use');\n          useElement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#' + this.layerId);\n          masker.appendChild(useElement);\n          this.globalData.defs.appendChild(masker);\n\n          if (!featureSupport.maskType && matteType === 1) {\n            masker.setAttribute('mask-type', 'luminance');\n            filId = createElementID();\n            fil = filtersFactory.createFilter(filId);\n            this.globalData.defs.appendChild(fil);\n            fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());\n            gg = createNS('g');\n            gg.appendChild(useElement);\n            masker.appendChild(gg);\n            gg.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');\n          }\n        } else if (matteType === 2) {\n          var maskGroup = createNS('mask');\n          maskGroup.setAttribute('id', id);\n          maskGroup.setAttribute('mask-type', 'alpha');\n          var maskGrouper = createNS('g');\n          maskGroup.appendChild(maskGrouper);\n          filId = createElementID();\n          fil = filtersFactory.createFilter(filId); /// /\n\n          var feCTr = createNS('feComponentTransfer');\n          feCTr.setAttribute('in', 'SourceGraphic');\n          fil.appendChild(feCTr);\n          var feFunc = createNS('feFuncA');\n          feFunc.setAttribute('type', 'table');\n          feFunc.setAttribute('tableValues', '1.0 0.0');\n          feCTr.appendChild(feFunc); /// /\n\n          this.globalData.defs.appendChild(fil);\n          var alphaRect = createNS('rect');\n          alphaRect.setAttribute('width', this.comp.data.w);\n          alphaRect.setAttribute('height', this.comp.data.h);\n          alphaRect.setAttribute('x', '0');\n          alphaRect.setAttribute('y', '0');\n          alphaRect.setAttribute('fill', '#ffffff');\n          alphaRect.setAttribute('opacity', '0');\n          maskGrouper.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');\n          maskGrouper.appendChild(alphaRect);\n          useElement = createNS('use');\n          useElement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#' + this.layerId);\n          maskGrouper.appendChild(useElement);\n\n          if (!featureSupport.maskType) {\n            maskGroup.setAttribute('mask-type', 'luminance');\n            fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());\n            gg = createNS('g');\n            maskGrouper.appendChild(alphaRect);\n            gg.appendChild(this.layerElement);\n            maskGrouper.appendChild(gg);\n          }\n\n          this.globalData.defs.appendChild(maskGroup);\n        }\n\n        this.matteMasks[matteType] = id;\n      }\n\n      return this.matteMasks[matteType];\n    },\n    setMatte: function setMatte(id) {\n      if (!this.matteElement) {\n        return;\n      }\n\n      this.matteElement.setAttribute('mask', 'url(' + getLocationHref() + '#' + id + ')');\n    }\n  };\n\n  /**\r\n   * @file\r\n   * Handles AE's layer parenting property.\r\n   *\r\n   */\n  function HierarchyElement() {}\n\n  HierarchyElement.prototype = {\n    /**\r\n       * @function\r\n       * Initializes hierarchy properties\r\n       *\r\n       */\n    initHierarchy: function initHierarchy() {\n      // element's parent list\n      this.hierarchy = []; // if element is parent of another layer _isParent will be true\n\n      this._isParent = false;\n      this.checkParenting();\n    },\n\n    /**\r\n       * @function\r\n       * Sets layer's hierarchy.\r\n       * @param {array} hierarch\r\n       * layer's parent list\r\n       *\r\n       */\n    setHierarchy: function setHierarchy(hierarchy) {\n      this.hierarchy = hierarchy;\n    },\n\n    /**\r\n       * @function\r\n       * Sets layer as parent.\r\n       *\r\n       */\n    setAsParent: function setAsParent() {\n      this._isParent = true;\n    },\n\n    /**\r\n       * @function\r\n       * Searches layer's parenting chain\r\n       *\r\n       */\n    checkParenting: function checkParenting() {\n      if (this.data.parent !== undefined) {\n        this.comp.buildElementParenting(this, this.data.parent, []);\n      }\n    }\n  };\n\n  function RenderableDOMElement() {}\n\n  (function () {\n    var _prototype = {\n      initElement: function initElement(data, globalData, comp) {\n        this.initFrame();\n        this.initBaseData(data, globalData, comp);\n        this.initTransform(data, globalData, comp);\n        this.initHierarchy();\n        this.initRenderable();\n        this.initRendererElement();\n        this.createContainerElements();\n        this.createRenderableComponents();\n        this.createContent();\n        this.hide();\n      },\n      hide: function hide() {\n        // console.log('HIDE', this);\n        if (!this.hidden && (!this.isInRange || this.isTransparent)) {\n          var elem = this.baseElement || this.layerElement;\n          elem.style.display = 'none';\n          this.hidden = true;\n        }\n      },\n      show: function show() {\n        // console.log('SHOW', this);\n        if (this.isInRange && !this.isTransparent) {\n          if (!this.data.hd) {\n            var elem = this.baseElement || this.layerElement;\n            elem.style.display = 'block';\n          }\n\n          this.hidden = false;\n          this._isFirstFrame = true;\n        }\n      },\n      renderFrame: function renderFrame() {\n        // If it is exported as hidden (data.hd === true) no need to render\n        // If it is not visible no need to render\n        if (this.data.hd || this.hidden) {\n          return;\n        }\n\n        this.renderTransform();\n        this.renderRenderable();\n        this.renderLocalTransform();\n        this.renderElement();\n        this.renderInnerContent();\n\n        if (this._isFirstFrame) {\n          this._isFirstFrame = false;\n        }\n      },\n      renderInnerContent: function renderInnerContent() {},\n      prepareFrame: function prepareFrame(num) {\n        this._mdf = false;\n        this.prepareRenderableFrame(num);\n        this.prepareProperties(num, this.isInRange);\n        this.checkTransparency();\n      },\n      destroy: function destroy() {\n        this.innerElem = null;\n        this.destroyBaseElement();\n      }\n    };\n    extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);\n  })();\n\n  function IImageElement(data, globalData, comp) {\n    this.assetData = globalData.getAssetData(data.refId);\n\n    if (this.assetData && this.assetData.sid) {\n      this.assetData = globalData.slotManager.getProp(this.assetData);\n    }\n\n    this.initElement(data, globalData, comp);\n    this.sourceRect = {\n      top: 0,\n      left: 0,\n      width: this.assetData.w,\n      height: this.assetData.h\n    };\n  }\n\n  extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);\n\n  IImageElement.prototype.createContent = function () {\n    var assetPath = this.globalData.getAssetsPath(this.assetData);\n    this.innerElem = createNS('image');\n    this.innerElem.setAttribute('width', this.assetData.w + 'px');\n    this.innerElem.setAttribute('height', this.assetData.h + 'px');\n    this.innerElem.setAttribute('preserveAspectRatio', this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);\n    this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);\n    this.layerElement.appendChild(this.innerElem);\n  };\n\n  IImageElement.prototype.sourceRectAtTime = function () {\n    return this.sourceRect;\n  };\n\n  function ProcessedElement(element, position) {\n    this.elem = element;\n    this.pos = position;\n  }\n\n  function IShapeElement() {}\n\n  IShapeElement.prototype = {\n    addShapeToModifiers: function addShapeToModifiers(data) {\n      var i;\n      var len = this.shapeModifiers.length;\n\n      for (i = 0; i < len; i += 1) {\n        this.shapeModifiers[i].addShape(data);\n      }\n    },\n    isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data) {\n      var i = 0;\n      var len = this.shapeModifiers.length;\n\n      while (i < len) {\n        if (this.shapeModifiers[i].isAnimatedWithShape(data)) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    renderModifiers: function renderModifiers() {\n      if (!this.shapeModifiers.length) {\n        return;\n      }\n\n      var i;\n      var len = this.shapes.length;\n\n      for (i = 0; i < len; i += 1) {\n        this.shapes[i].sh.reset();\n      }\n\n      len = this.shapeModifiers.length;\n      var shouldBreakProcess;\n\n      for (i = len - 1; i >= 0; i -= 1) {\n        shouldBreakProcess = this.shapeModifiers[i].processShapes(this._isFirstFrame); // workaround to fix cases where a repeater resets the shape so the following processes get called twice\n        // TODO: find a better solution for this\n\n        if (shouldBreakProcess) {\n          break;\n        }\n      }\n    },\n    searchProcessedElement: function searchProcessedElement(elem) {\n      var elements = this.processedElements;\n      var i = 0;\n      var len = elements.length;\n\n      while (i < len) {\n        if (elements[i].elem === elem) {\n          return elements[i].pos;\n        }\n\n        i += 1;\n      }\n\n      return 0;\n    },\n    addProcessedElement: function addProcessedElement(elem, pos) {\n      var elements = this.processedElements;\n      var i = elements.length;\n\n      while (i) {\n        i -= 1;\n\n        if (elements[i].elem === elem) {\n          elements[i].pos = pos;\n          return;\n        }\n      }\n\n      elements.push(new ProcessedElement(elem, pos));\n    },\n    prepareFrame: function prepareFrame(num) {\n      this.prepareRenderableFrame(num);\n      this.prepareProperties(num, this.isInRange);\n    }\n  };\n\n  var lineCapEnum = {\n    1: 'butt',\n    2: 'round',\n    3: 'square'\n  };\n  var lineJoinEnum = {\n    1: 'miter',\n    2: 'round',\n    3: 'bevel'\n  };\n\n  function SVGShapeData(transformers, level, shape) {\n    this.caches = [];\n    this.styles = [];\n    this.transformers = transformers;\n    this.lStr = '';\n    this.sh = shape;\n    this.lvl = level; // TODO find if there are some cases where _isAnimated can be false.\n    // For now, since shapes add up with other shapes. They have to be calculated every time.\n    // One way of finding out is checking if all styles associated to this shape depend only of this shape\n\n    this._isAnimated = !!shape.k; // TODO: commenting this for now since all shapes are animated\n\n    var i = 0;\n    var len = transformers.length;\n\n    while (i < len) {\n      if (transformers[i].mProps.dynamicProperties.length) {\n        this._isAnimated = true;\n        break;\n      }\n\n      i += 1;\n    }\n  }\n\n  SVGShapeData.prototype.setAsAnimated = function () {\n    this._isAnimated = true;\n  };\n\n  function SVGStyleData(data, level) {\n    this.data = data;\n    this.type = data.ty;\n    this.d = '';\n    this.lvl = level;\n    this._mdf = false;\n    this.closed = data.hd === true;\n    this.pElem = createNS('path');\n    this.msElem = null;\n  }\n\n  SVGStyleData.prototype.reset = function () {\n    this.d = '';\n    this._mdf = false;\n  };\n\n  function DashProperty(elem, data, renderer, container) {\n    this.elem = elem;\n    this.frameId = -1;\n    this.dataProps = createSizedArray(data.length);\n    this.renderer = renderer;\n    this.k = false;\n    this.dashStr = '';\n    this.dashArray = createTypedArray('float32', data.length ? data.length - 1 : 0);\n    this.dashoffset = createTypedArray('float32', 1);\n    this.initDynamicPropertyContainer(container);\n    var i;\n    var len = data.length || 0;\n    var prop;\n\n    for (i = 0; i < len; i += 1) {\n      prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this);\n      this.k = prop.k || this.k;\n      this.dataProps[i] = {\n        n: data[i].n,\n        p: prop\n      };\n    }\n\n    if (!this.k) {\n      this.getValue(true);\n    }\n\n    this._isAnimated = this.k;\n  }\n\n  DashProperty.prototype.getValue = function (forceRender) {\n    if (this.elem.globalData.frameId === this.frameId && !forceRender) {\n      return;\n    }\n\n    this.frameId = this.elem.globalData.frameId;\n    this.iterateDynamicProperties();\n    this._mdf = this._mdf || forceRender;\n\n    if (this._mdf) {\n      var i = 0;\n      var len = this.dataProps.length;\n\n      if (this.renderer === 'svg') {\n        this.dashStr = '';\n      }\n\n      for (i = 0; i < len; i += 1) {\n        if (this.dataProps[i].n !== 'o') {\n          if (this.renderer === 'svg') {\n            this.dashStr += ' ' + this.dataProps[i].p.v;\n          } else {\n            this.dashArray[i] = this.dataProps[i].p.v;\n          }\n        } else {\n          this.dashoffset[0] = this.dataProps[i].p.v;\n        }\n      }\n    }\n  };\n\n  extendPrototype([DynamicPropertyContainer], DashProperty);\n\n  function SVGStrokeStyleData(elem, data, styleOb) {\n    this.initDynamicPropertyContainer(elem);\n    this.getValue = this.iterateDynamicProperties;\n    this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);\n    this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);\n    this.d = new DashProperty(elem, data.d || {}, 'svg', this);\n    this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);\n    this.style = styleOb;\n    this._isAnimated = !!this._isAnimated;\n  }\n\n  extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);\n\n  function SVGFillStyleData(elem, data, styleOb) {\n    this.initDynamicPropertyContainer(elem);\n    this.getValue = this.iterateDynamicProperties;\n    this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);\n    this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);\n    this.style = styleOb;\n  }\n\n  extendPrototype([DynamicPropertyContainer], SVGFillStyleData);\n\n  function SVGNoStyleData(elem, data, styleOb) {\n    this.initDynamicPropertyContainer(elem);\n    this.getValue = this.iterateDynamicProperties;\n    this.style = styleOb;\n  }\n\n  extendPrototype([DynamicPropertyContainer], SVGNoStyleData);\n\n  function GradientProperty(elem, data, container) {\n    this.data = data;\n    this.c = createTypedArray('uint8c', data.p * 4);\n    var cLength = data.k.k[0].s ? data.k.k[0].s.length - data.p * 4 : data.k.k.length - data.p * 4;\n    this.o = createTypedArray('float32', cLength);\n    this._cmdf = false;\n    this._omdf = false;\n    this._collapsable = this.checkCollapsable();\n    this._hasOpacity = cLength;\n    this.initDynamicPropertyContainer(container);\n    this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);\n    this.k = this.prop.k;\n    this.getValue(true);\n  }\n\n  GradientProperty.prototype.comparePoints = function (values, points) {\n    var i = 0;\n    var len = this.o.length / 2;\n    var diff;\n\n    while (i < len) {\n      diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);\n\n      if (diff > 0.01) {\n        return false;\n      }\n\n      i += 1;\n    }\n\n    return true;\n  };\n\n  GradientProperty.prototype.checkCollapsable = function () {\n    if (this.o.length / 2 !== this.c.length / 4) {\n      return false;\n    }\n\n    if (this.data.k.k[0].s) {\n      var i = 0;\n      var len = this.data.k.k.length;\n\n      while (i < len) {\n        if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {\n          return false;\n        }\n\n        i += 1;\n      }\n    } else if (!this.comparePoints(this.data.k.k, this.data.p)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  GradientProperty.prototype.getValue = function (forceRender) {\n    this.prop.getValue();\n    this._mdf = false;\n    this._cmdf = false;\n    this._omdf = false;\n\n    if (this.prop._mdf || forceRender) {\n      var i;\n      var len = this.data.p * 4;\n      var mult;\n      var val;\n\n      for (i = 0; i < len; i += 1) {\n        mult = i % 4 === 0 ? 100 : 255;\n        val = Math.round(this.prop.v[i] * mult);\n\n        if (this.c[i] !== val) {\n          this.c[i] = val;\n          this._cmdf = !forceRender;\n        }\n      }\n\n      if (this.o.length) {\n        len = this.prop.v.length;\n\n        for (i = this.data.p * 4; i < len; i += 1) {\n          mult = i % 2 === 0 ? 100 : 1;\n          val = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i];\n\n          if (this.o[i - this.data.p * 4] !== val) {\n            this.o[i - this.data.p * 4] = val;\n            this._omdf = !forceRender;\n          }\n        }\n      }\n\n      this._mdf = !forceRender;\n    }\n  };\n\n  extendPrototype([DynamicPropertyContainer], GradientProperty);\n\n  function SVGGradientFillStyleData(elem, data, styleOb) {\n    this.initDynamicPropertyContainer(elem);\n    this.getValue = this.iterateDynamicProperties;\n    this.initGradientData(elem, data, styleOb);\n  }\n\n  SVGGradientFillStyleData.prototype.initGradientData = function (elem, data, styleOb) {\n    this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);\n    this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);\n    this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);\n    this.h = PropertyFactory.getProp(elem, data.h || {\n      k: 0\n    }, 0, 0.01, this);\n    this.a = PropertyFactory.getProp(elem, data.a || {\n      k: 0\n    }, 0, degToRads, this);\n    this.g = new GradientProperty(elem, data.g, this);\n    this.style = styleOb;\n    this.stops = [];\n    this.setGradientData(styleOb.pElem, data);\n    this.setGradientOpacity(data, styleOb);\n    this._isAnimated = !!this._isAnimated;\n  };\n\n  SVGGradientFillStyleData.prototype.setGradientData = function (pathElement, data) {\n    var gradientId = createElementID();\n    var gfill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');\n    gfill.setAttribute('id', gradientId);\n    gfill.setAttribute('spreadMethod', 'pad');\n    gfill.setAttribute('gradientUnits', 'userSpaceOnUse');\n    var stops = [];\n    var stop;\n    var j;\n    var jLen;\n    jLen = data.g.p * 4;\n\n    for (j = 0; j < jLen; j += 4) {\n      stop = createNS('stop');\n      gfill.appendChild(stop);\n      stops.push(stop);\n    }\n\n    pathElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + getLocationHref() + '#' + gradientId + ')');\n    this.gf = gfill;\n    this.cst = stops;\n  };\n\n  SVGGradientFillStyleData.prototype.setGradientOpacity = function (data, styleOb) {\n    if (this.g._hasOpacity && !this.g._collapsable) {\n      var stop;\n      var j;\n      var jLen;\n      var mask = createNS('mask');\n      var maskElement = createNS('path');\n      mask.appendChild(maskElement);\n      var opacityId = createElementID();\n      var maskId = createElementID();\n      mask.setAttribute('id', maskId);\n      var opFill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');\n      opFill.setAttribute('id', opacityId);\n      opFill.setAttribute('spreadMethod', 'pad');\n      opFill.setAttribute('gradientUnits', 'userSpaceOnUse');\n      jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;\n      var stops = this.stops;\n\n      for (j = data.g.p * 4; j < jLen; j += 2) {\n        stop = createNS('stop');\n        stop.setAttribute('stop-color', 'rgb(255,255,255)');\n        opFill.appendChild(stop);\n        stops.push(stop);\n      }\n\n      maskElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + getLocationHref() + '#' + opacityId + ')');\n\n      if (data.ty === 'gs') {\n        maskElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);\n        maskElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);\n\n        if (data.lj === 1) {\n          maskElement.setAttribute('stroke-miterlimit', data.ml);\n        }\n      }\n\n      this.of = opFill;\n      this.ms = mask;\n      this.ost = stops;\n      this.maskId = maskId;\n      styleOb.msElem = maskElement;\n    }\n  };\n\n  extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);\n\n  function SVGGradientStrokeStyleData(elem, data, styleOb) {\n    this.initDynamicPropertyContainer(elem);\n    this.getValue = this.iterateDynamicProperties;\n    this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);\n    this.d = new DashProperty(elem, data.d || {}, 'svg', this);\n    this.initGradientData(elem, data, styleOb);\n    this._isAnimated = !!this._isAnimated;\n  }\n\n  extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);\n\n  function ShapeGroupData() {\n    this.it = [];\n    this.prevViewData = [];\n    this.gr = createNS('g');\n  }\n\n  function SVGTransformData(mProps, op, container) {\n    this.transform = {\n      mProps: mProps,\n      op: op,\n      container: container\n    };\n    this.elements = [];\n    this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;\n  }\n\n  var buildShapeString = function buildShapeString(pathNodes, length, closed, mat) {\n    if (length === 0) {\n      return '';\n    }\n\n    var _o = pathNodes.o;\n    var _i = pathNodes.i;\n    var _v = pathNodes.v;\n    var i;\n    var shapeString = ' M' + mat.applyToPointStringified(_v[0][0], _v[0][1]);\n\n    for (i = 1; i < length; i += 1) {\n      shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[i][0], _i[i][1]) + ' ' + mat.applyToPointStringified(_v[i][0], _v[i][1]);\n    }\n\n    if (closed && length) {\n      shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[0][0], _i[0][1]) + ' ' + mat.applyToPointStringified(_v[0][0], _v[0][1]);\n      shapeString += 'z';\n    }\n\n    return shapeString;\n  };\n\n  var SVGElementsRenderer = function () {\n    var _identityMatrix = new Matrix();\n\n    var _matrixHelper = new Matrix();\n\n    var ob = {\n      createRenderFunction: createRenderFunction\n    };\n\n    function createRenderFunction(data) {\n      switch (data.ty) {\n        case 'fl':\n          return renderFill;\n\n        case 'gf':\n          return renderGradient;\n\n        case 'gs':\n          return renderGradientStroke;\n\n        case 'st':\n          return renderStroke;\n\n        case 'sh':\n        case 'el':\n        case 'rc':\n        case 'sr':\n          return renderPath;\n\n        case 'tr':\n          return renderContentTransform;\n\n        case 'no':\n          return renderNoop;\n\n        default:\n          return null;\n      }\n    }\n\n    function renderContentTransform(styleData, itemData, isFirstFrame) {\n      if (isFirstFrame || itemData.transform.op._mdf) {\n        itemData.transform.container.setAttribute('opacity', itemData.transform.op.v);\n      }\n\n      if (isFirstFrame || itemData.transform.mProps._mdf) {\n        itemData.transform.container.setAttribute('transform', itemData.transform.mProps.v.to2dCSS());\n      }\n    }\n\n    function renderNoop() {}\n\n    function renderPath(styleData, itemData, isFirstFrame) {\n      var j;\n      var jLen;\n      var pathStringTransformed;\n      var redraw;\n      var pathNodes;\n      var l;\n      var lLen = itemData.styles.length;\n      var lvl = itemData.lvl;\n      var paths;\n      var mat;\n      var iterations;\n      var k;\n\n      for (l = 0; l < lLen; l += 1) {\n        redraw = itemData.sh._mdf || isFirstFrame;\n\n        if (itemData.styles[l].lvl < lvl) {\n          mat = _matrixHelper.reset();\n          iterations = lvl - itemData.styles[l].lvl;\n          k = itemData.transformers.length - 1;\n\n          while (!redraw && iterations > 0) {\n            redraw = itemData.transformers[k].mProps._mdf || redraw;\n            iterations -= 1;\n            k -= 1;\n          }\n\n          if (redraw) {\n            iterations = lvl - itemData.styles[l].lvl;\n            k = itemData.transformers.length - 1;\n\n            while (iterations > 0) {\n              mat.multiply(itemData.transformers[k].mProps.v);\n              iterations -= 1;\n              k -= 1;\n            }\n          }\n        } else {\n          mat = _identityMatrix;\n        }\n\n        paths = itemData.sh.paths;\n        jLen = paths._length;\n\n        if (redraw) {\n          pathStringTransformed = '';\n\n          for (j = 0; j < jLen; j += 1) {\n            pathNodes = paths.shapes[j];\n\n            if (pathNodes && pathNodes._length) {\n              pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);\n            }\n          }\n\n          itemData.caches[l] = pathStringTransformed;\n        } else {\n          pathStringTransformed = itemData.caches[l];\n        }\n\n        itemData.styles[l].d += styleData.hd === true ? '' : pathStringTransformed;\n        itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;\n      }\n    }\n\n    function renderFill(styleData, itemData, isFirstFrame) {\n      var styleElem = itemData.style;\n\n      if (itemData.c._mdf || isFirstFrame) {\n        styleElem.pElem.setAttribute('fill', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');\n      }\n\n      if (itemData.o._mdf || isFirstFrame) {\n        styleElem.pElem.setAttribute('fill-opacity', itemData.o.v);\n      }\n    }\n\n    function renderGradientStroke(styleData, itemData, isFirstFrame) {\n      renderGradient(styleData, itemData, isFirstFrame);\n      renderStroke(styleData, itemData, isFirstFrame);\n    }\n\n    function renderGradient(styleData, itemData, isFirstFrame) {\n      var gfill = itemData.gf;\n      var hasOpacity = itemData.g._hasOpacity;\n      var pt1 = itemData.s.v;\n      var pt2 = itemData.e.v;\n\n      if (itemData.o._mdf || isFirstFrame) {\n        var attr = styleData.ty === 'gf' ? 'fill-opacity' : 'stroke-opacity';\n        itemData.style.pElem.setAttribute(attr, itemData.o.v);\n      }\n\n      if (itemData.s._mdf || isFirstFrame) {\n        var attr1 = styleData.t === 1 ? 'x1' : 'cx';\n        var attr2 = attr1 === 'x1' ? 'y1' : 'cy';\n        gfill.setAttribute(attr1, pt1[0]);\n        gfill.setAttribute(attr2, pt1[1]);\n\n        if (hasOpacity && !itemData.g._collapsable) {\n          itemData.of.setAttribute(attr1, pt1[0]);\n          itemData.of.setAttribute(attr2, pt1[1]);\n        }\n      }\n\n      var stops;\n      var i;\n      var len;\n      var stop;\n\n      if (itemData.g._cmdf || isFirstFrame) {\n        stops = itemData.cst;\n        var cValues = itemData.g.c;\n        len = stops.length;\n\n        for (i = 0; i < len; i += 1) {\n          stop = stops[i];\n          stop.setAttribute('offset', cValues[i * 4] + '%');\n          stop.setAttribute('stop-color', 'rgb(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ')');\n        }\n      }\n\n      if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {\n        var oValues = itemData.g.o;\n\n        if (itemData.g._collapsable) {\n          stops = itemData.cst;\n        } else {\n          stops = itemData.ost;\n        }\n\n        len = stops.length;\n\n        for (i = 0; i < len; i += 1) {\n          stop = stops[i];\n\n          if (!itemData.g._collapsable) {\n            stop.setAttribute('offset', oValues[i * 2] + '%');\n          }\n\n          stop.setAttribute('stop-opacity', oValues[i * 2 + 1]);\n        }\n      }\n\n      if (styleData.t === 1) {\n        if (itemData.e._mdf || isFirstFrame) {\n          gfill.setAttribute('x2', pt2[0]);\n          gfill.setAttribute('y2', pt2[1]);\n\n          if (hasOpacity && !itemData.g._collapsable) {\n            itemData.of.setAttribute('x2', pt2[0]);\n            itemData.of.setAttribute('y2', pt2[1]);\n          }\n        }\n      } else {\n        var rad;\n\n        if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {\n          rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));\n          gfill.setAttribute('r', rad);\n\n          if (hasOpacity && !itemData.g._collapsable) {\n            itemData.of.setAttribute('r', rad);\n          }\n        }\n\n        if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {\n          if (!rad) {\n            rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));\n          }\n\n          var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);\n          var percent = itemData.h.v;\n\n          if (percent >= 1) {\n            percent = 0.99;\n          } else if (percent <= -1) {\n            percent = -0.99;\n          }\n\n          var dist = rad * percent;\n          var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];\n          var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];\n          gfill.setAttribute('fx', x);\n          gfill.setAttribute('fy', y);\n\n          if (hasOpacity && !itemData.g._collapsable) {\n            itemData.of.setAttribute('fx', x);\n            itemData.of.setAttribute('fy', y);\n          }\n        } // gfill.setAttribute('fy','200');\n\n      }\n    }\n\n    function renderStroke(styleData, itemData, isFirstFrame) {\n      var styleElem = itemData.style;\n      var d = itemData.d;\n\n      if (d && (d._mdf || isFirstFrame) && d.dashStr) {\n        styleElem.pElem.setAttribute('stroke-dasharray', d.dashStr);\n        styleElem.pElem.setAttribute('stroke-dashoffset', d.dashoffset[0]);\n      }\n\n      if (itemData.c && (itemData.c._mdf || isFirstFrame)) {\n        styleElem.pElem.setAttribute('stroke', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');\n      }\n\n      if (itemData.o._mdf || isFirstFrame) {\n        styleElem.pElem.setAttribute('stroke-opacity', itemData.o.v);\n      }\n\n      if (itemData.w._mdf || isFirstFrame) {\n        styleElem.pElem.setAttribute('stroke-width', itemData.w.v);\n\n        if (styleElem.msElem) {\n          styleElem.msElem.setAttribute('stroke-width', itemData.w.v);\n        }\n      }\n    }\n\n    return ob;\n  }();\n\n  function SVGShapeElement(data, globalData, comp) {\n    // List of drawable elements\n    this.shapes = []; // Full shape data\n\n    this.shapesData = data.shapes; // List of styles that will be applied to shapes\n\n    this.stylesList = []; // List of modifiers that will be applied to shapes\n\n    this.shapeModifiers = []; // List of items in shape tree\n\n    this.itemsData = []; // List of items in previous shape tree\n\n    this.processedElements = []; // List of animated components\n\n    this.animatedContents = [];\n    this.initElement(data, globalData, comp); // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\n    // List of elements that have been created\n\n    this.prevViewData = []; // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\n  }\n\n  extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);\n\n  SVGShapeElement.prototype.initSecondaryElement = function () {};\n\n  SVGShapeElement.prototype.identityMatrix = new Matrix();\n\n  SVGShapeElement.prototype.buildExpressionInterface = function () {};\n\n  SVGShapeElement.prototype.createContent = function () {\n    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);\n    this.filterUniqueShapes();\n  };\n  /*\r\n  This method searches for multiple shapes that affect a single element and one of them is animated\r\n  */\n\n\n  SVGShapeElement.prototype.filterUniqueShapes = function () {\n    var i;\n    var len = this.shapes.length;\n    var shape;\n    var j;\n    var jLen = this.stylesList.length;\n    var style;\n    var tempShapes = [];\n    var areAnimated = false;\n\n    for (j = 0; j < jLen; j += 1) {\n      style = this.stylesList[j];\n      areAnimated = false;\n      tempShapes.length = 0;\n\n      for (i = 0; i < len; i += 1) {\n        shape = this.shapes[i];\n\n        if (shape.styles.indexOf(style) !== -1) {\n          tempShapes.push(shape);\n          areAnimated = shape._isAnimated || areAnimated;\n        }\n      }\n\n      if (tempShapes.length > 1 && areAnimated) {\n        this.setShapesAsAnimated(tempShapes);\n      }\n    }\n  };\n\n  SVGShapeElement.prototype.setShapesAsAnimated = function (shapes) {\n    var i;\n    var len = shapes.length;\n\n    for (i = 0; i < len; i += 1) {\n      shapes[i].setAsAnimated();\n    }\n  };\n\n  SVGShapeElement.prototype.createStyleElement = function (data, level) {\n    // TODO: prevent drawing of hidden styles\n    var elementData;\n    var styleOb = new SVGStyleData(data, level);\n    var pathElement = styleOb.pElem;\n\n    if (data.ty === 'st') {\n      elementData = new SVGStrokeStyleData(this, data, styleOb);\n    } else if (data.ty === 'fl') {\n      elementData = new SVGFillStyleData(this, data, styleOb);\n    } else if (data.ty === 'gf' || data.ty === 'gs') {\n      var GradientConstructor = data.ty === 'gf' ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;\n      elementData = new GradientConstructor(this, data, styleOb);\n      this.globalData.defs.appendChild(elementData.gf);\n\n      if (elementData.maskId) {\n        this.globalData.defs.appendChild(elementData.ms);\n        this.globalData.defs.appendChild(elementData.of);\n        pathElement.setAttribute('mask', 'url(' + getLocationHref() + '#' + elementData.maskId + ')');\n      }\n    } else if (data.ty === 'no') {\n      elementData = new SVGNoStyleData(this, data, styleOb);\n    }\n\n    if (data.ty === 'st' || data.ty === 'gs') {\n      pathElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);\n      pathElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);\n      pathElement.setAttribute('fill-opacity', '0');\n\n      if (data.lj === 1) {\n        pathElement.setAttribute('stroke-miterlimit', data.ml);\n      }\n    }\n\n    if (data.r === 2) {\n      pathElement.setAttribute('fill-rule', 'evenodd');\n    }\n\n    if (data.ln) {\n      pathElement.setAttribute('id', data.ln);\n    }\n\n    if (data.cl) {\n      pathElement.setAttribute('class', data.cl);\n    }\n\n    if (data.bm) {\n      pathElement.style['mix-blend-mode'] = getBlendMode(data.bm);\n    }\n\n    this.stylesList.push(styleOb);\n    this.addToAnimatedContents(data, elementData);\n    return elementData;\n  };\n\n  SVGShapeElement.prototype.createGroupElement = function (data) {\n    var elementData = new ShapeGroupData();\n\n    if (data.ln) {\n      elementData.gr.setAttribute('id', data.ln);\n    }\n\n    if (data.cl) {\n      elementData.gr.setAttribute('class', data.cl);\n    }\n\n    if (data.bm) {\n      elementData.gr.style['mix-blend-mode'] = getBlendMode(data.bm);\n    }\n\n    return elementData;\n  };\n\n  SVGShapeElement.prototype.createTransformElement = function (data, container) {\n    var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this);\n    var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);\n    this.addToAnimatedContents(data, elementData);\n    return elementData;\n  };\n\n  SVGShapeElement.prototype.createShapeElement = function (data, ownTransformers, level) {\n    var ty = 4;\n\n    if (data.ty === 'rc') {\n      ty = 5;\n    } else if (data.ty === 'el') {\n      ty = 6;\n    } else if (data.ty === 'sr') {\n      ty = 7;\n    }\n\n    var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this);\n    var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);\n    this.shapes.push(elementData);\n    this.addShapeToModifiers(elementData);\n    this.addToAnimatedContents(data, elementData);\n    return elementData;\n  };\n\n  SVGShapeElement.prototype.addToAnimatedContents = function (data, element) {\n    var i = 0;\n    var len = this.animatedContents.length;\n\n    while (i < len) {\n      if (this.animatedContents[i].element === element) {\n        return;\n      }\n\n      i += 1;\n    }\n\n    this.animatedContents.push({\n      fn: SVGElementsRenderer.createRenderFunction(data),\n      element: element,\n      data: data\n    });\n  };\n\n  SVGShapeElement.prototype.setElementStyles = function (elementData) {\n    var arr = elementData.styles;\n    var j;\n    var jLen = this.stylesList.length;\n\n    for (j = 0; j < jLen; j += 1) {\n      if (!this.stylesList[j].closed) {\n        arr.push(this.stylesList[j]);\n      }\n    }\n  };\n\n  SVGShapeElement.prototype.reloadShapes = function () {\n    this._isFirstFrame = true;\n    var i;\n    var len = this.itemsData.length;\n\n    for (i = 0; i < len; i += 1) {\n      this.prevViewData[i] = this.itemsData[i];\n    }\n\n    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);\n    this.filterUniqueShapes();\n    len = this.dynamicProperties.length;\n\n    for (i = 0; i < len; i += 1) {\n      this.dynamicProperties[i].getValue();\n    }\n\n    this.renderModifiers();\n  };\n\n  SVGShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, container, level, transformers, render) {\n    var ownTransformers = [].concat(transformers);\n    var i;\n    var len = arr.length - 1;\n    var j;\n    var jLen;\n    var ownStyles = [];\n    var ownModifiers = [];\n    var currentTransform;\n    var modifier;\n    var processedPos;\n\n    for (i = len; i >= 0; i -= 1) {\n      processedPos = this.searchProcessedElement(arr[i]);\n\n      if (!processedPos) {\n        arr[i]._render = render;\n      } else {\n        itemsData[i] = prevViewData[processedPos - 1];\n      }\n\n      if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs' || arr[i].ty === 'no') {\n        if (!processedPos) {\n          itemsData[i] = this.createStyleElement(arr[i], level);\n        } else {\n          itemsData[i].style.closed = false;\n        }\n\n        if (arr[i]._render) {\n          if (itemsData[i].style.pElem.parentNode !== container) {\n            container.appendChild(itemsData[i].style.pElem);\n          }\n        }\n\n        ownStyles.push(itemsData[i].style);\n      } else if (arr[i].ty === 'gr') {\n        if (!processedPos) {\n          itemsData[i] = this.createGroupElement(arr[i]);\n        } else {\n          jLen = itemsData[i].it.length;\n\n          for (j = 0; j < jLen; j += 1) {\n            itemsData[i].prevViewData[j] = itemsData[i].it[j];\n          }\n        }\n\n        this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render);\n\n        if (arr[i]._render) {\n          if (itemsData[i].gr.parentNode !== container) {\n            container.appendChild(itemsData[i].gr);\n          }\n        }\n      } else if (arr[i].ty === 'tr') {\n        if (!processedPos) {\n          itemsData[i] = this.createTransformElement(arr[i], container);\n        }\n\n        currentTransform = itemsData[i].transform;\n        ownTransformers.push(currentTransform);\n      } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {\n        if (!processedPos) {\n          itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);\n        }\n\n        this.setElementStyles(itemsData[i]);\n      } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'ms' || arr[i].ty === 'pb' || arr[i].ty === 'zz' || arr[i].ty === 'op') {\n        if (!processedPos) {\n          modifier = ShapeModifiers.getModifier(arr[i].ty);\n          modifier.init(this, arr[i]);\n          itemsData[i] = modifier;\n          this.shapeModifiers.push(modifier);\n        } else {\n          modifier = itemsData[i];\n          modifier.closed = false;\n        }\n\n        ownModifiers.push(modifier);\n      } else if (arr[i].ty === 'rp') {\n        if (!processedPos) {\n          modifier = ShapeModifiers.getModifier(arr[i].ty);\n          itemsData[i] = modifier;\n          modifier.init(this, arr, i, itemsData);\n          this.shapeModifiers.push(modifier);\n          render = false;\n        } else {\n          modifier = itemsData[i];\n          modifier.closed = true;\n        }\n\n        ownModifiers.push(modifier);\n      }\n\n      this.addProcessedElement(arr[i], i + 1);\n    }\n\n    len = ownStyles.length;\n\n    for (i = 0; i < len; i += 1) {\n      ownStyles[i].closed = true;\n    }\n\n    len = ownModifiers.length;\n\n    for (i = 0; i < len; i += 1) {\n      ownModifiers[i].closed = true;\n    }\n  };\n\n  SVGShapeElement.prototype.renderInnerContent = function () {\n    this.renderModifiers();\n    var i;\n    var len = this.stylesList.length;\n\n    for (i = 0; i < len; i += 1) {\n      this.stylesList[i].reset();\n    }\n\n    this.renderShape();\n\n    for (i = 0; i < len; i += 1) {\n      if (this.stylesList[i]._mdf || this._isFirstFrame) {\n        if (this.stylesList[i].msElem) {\n          this.stylesList[i].msElem.setAttribute('d', this.stylesList[i].d); // Adding M0 0 fixes same mask bug on all browsers\n\n          this.stylesList[i].d = 'M0 0' + this.stylesList[i].d;\n        }\n\n        this.stylesList[i].pElem.setAttribute('d', this.stylesList[i].d || 'M0 0');\n      }\n    }\n  };\n\n  SVGShapeElement.prototype.renderShape = function () {\n    var i;\n    var len = this.animatedContents.length;\n    var animatedContent;\n\n    for (i = 0; i < len; i += 1) {\n      animatedContent = this.animatedContents[i];\n\n      if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {\n        animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);\n      }\n    }\n  };\n\n  SVGShapeElement.prototype.destroy = function () {\n    this.destroyBaseElement();\n    this.shapesData = null;\n    this.itemsData = null;\n  };\n\n  function LetterProps(o, sw, sc, fc, m, p) {\n    this.o = o;\n    this.sw = sw;\n    this.sc = sc;\n    this.fc = fc;\n    this.m = m;\n    this.p = p;\n    this._mdf = {\n      o: true,\n      sw: !!sw,\n      sc: !!sc,\n      fc: !!fc,\n      m: true,\n      p: true\n    };\n  }\n\n  LetterProps.prototype.update = function (o, sw, sc, fc, m, p) {\n    this._mdf.o = false;\n    this._mdf.sw = false;\n    this._mdf.sc = false;\n    this._mdf.fc = false;\n    this._mdf.m = false;\n    this._mdf.p = false;\n    var updated = false;\n\n    if (this.o !== o) {\n      this.o = o;\n      this._mdf.o = true;\n      updated = true;\n    }\n\n    if (this.sw !== sw) {\n      this.sw = sw;\n      this._mdf.sw = true;\n      updated = true;\n    }\n\n    if (this.sc !== sc) {\n      this.sc = sc;\n      this._mdf.sc = true;\n      updated = true;\n    }\n\n    if (this.fc !== fc) {\n      this.fc = fc;\n      this._mdf.fc = true;\n      updated = true;\n    }\n\n    if (this.m !== m) {\n      this.m = m;\n      this._mdf.m = true;\n      updated = true;\n    }\n\n    if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {\n      this.p = p;\n      this._mdf.p = true;\n      updated = true;\n    }\n\n    return updated;\n  };\n\n  function TextProperty(elem, data) {\n    this._frameId = initialDefaultFrame;\n    this.pv = '';\n    this.v = '';\n    this.kf = false;\n    this._isFirstFrame = true;\n    this._mdf = false;\n\n    if (data.d && data.d.sid) {\n      data.d = elem.globalData.slotManager.getProp(data.d);\n    }\n\n    this.data = data;\n    this.elem = elem;\n    this.comp = this.elem.comp;\n    this.keysIndex = 0;\n    this.canResize = false;\n    this.minimumFontSize = 1;\n    this.effectsSequence = [];\n    this.currentData = {\n      ascent: 0,\n      boxWidth: this.defaultBoxWidth,\n      f: '',\n      fStyle: '',\n      fWeight: '',\n      fc: '',\n      j: '',\n      justifyOffset: '',\n      l: [],\n      lh: 0,\n      lineWidths: [],\n      ls: '',\n      of: '',\n      s: '',\n      sc: '',\n      sw: 0,\n      t: 0,\n      tr: 0,\n      sz: 0,\n      ps: null,\n      fillColorAnim: false,\n      strokeColorAnim: false,\n      strokeWidthAnim: false,\n      yOffset: 0,\n      finalSize: 0,\n      finalText: [],\n      finalLineHeight: 0,\n      __complete: false\n    };\n    this.copyData(this.currentData, this.data.d.k[0].s);\n\n    if (!this.searchProperty()) {\n      this.completeTextData(this.currentData);\n    }\n  }\n\n  TextProperty.prototype.defaultBoxWidth = [0, 0];\n\n  TextProperty.prototype.copyData = function (obj, data) {\n    for (var s in data) {\n      if (Object.prototype.hasOwnProperty.call(data, s)) {\n        obj[s] = data[s];\n      }\n    }\n\n    return obj;\n  };\n\n  TextProperty.prototype.setCurrentData = function (data) {\n    if (!data.__complete) {\n      this.completeTextData(data);\n    }\n\n    this.currentData = data;\n    this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;\n    this._mdf = true;\n  };\n\n  TextProperty.prototype.searchProperty = function () {\n    return this.searchKeyframes();\n  };\n\n  TextProperty.prototype.searchKeyframes = function () {\n    this.kf = this.data.d.k.length > 1;\n\n    if (this.kf) {\n      this.addEffect(this.getKeyframeValue.bind(this));\n    }\n\n    return this.kf;\n  };\n\n  TextProperty.prototype.addEffect = function (effectFunction) {\n    this.effectsSequence.push(effectFunction);\n    this.elem.addDynamicProperty(this);\n  };\n\n  TextProperty.prototype.getValue = function (_finalValue) {\n    if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {\n      return;\n    }\n\n    this.currentData.t = this.data.d.k[this.keysIndex].s.t;\n    var currentValue = this.currentData;\n    var currentIndex = this.keysIndex;\n\n    if (this.lock) {\n      this.setCurrentData(this.currentData);\n      return;\n    }\n\n    this.lock = true;\n    this._mdf = false;\n    var i;\n    var len = this.effectsSequence.length;\n    var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;\n\n    for (i = 0; i < len; i += 1) {\n      // Checking if index changed to prevent creating a new object every time the expression updates.\n      if (currentIndex !== this.keysIndex) {\n        finalValue = this.effectsSequence[i](finalValue, finalValue.t);\n      } else {\n        finalValue = this.effectsSequence[i](this.currentData, finalValue.t);\n      }\n    }\n\n    if (currentValue !== finalValue) {\n      this.setCurrentData(finalValue);\n    }\n\n    this.v = this.currentData;\n    this.pv = this.v;\n    this.lock = false;\n    this.frameId = this.elem.globalData.frameId;\n  };\n\n  TextProperty.prototype.getKeyframeValue = function () {\n    var textKeys = this.data.d.k;\n    var frameNum = this.elem.comp.renderedFrame;\n    var i = 0;\n    var len = textKeys.length;\n\n    while (i <= len - 1) {\n      if (i === len - 1 || textKeys[i + 1].t > frameNum) {\n        break;\n      }\n\n      i += 1;\n    }\n\n    if (this.keysIndex !== i) {\n      this.keysIndex = i;\n    }\n\n    return this.data.d.k[this.keysIndex].s;\n  };\n\n  TextProperty.prototype.buildFinalText = function (text) {\n    var charactersArray = [];\n    var i = 0;\n    var len = text.length;\n    var charCode;\n    var secondCharCode;\n    var shouldCombine = false;\n    var shouldCombineNext = false;\n    var currentChars = '';\n\n    while (i < len) {\n      shouldCombine = shouldCombineNext;\n      shouldCombineNext = false;\n      charCode = text.charCodeAt(i);\n      currentChars = text.charAt(i);\n\n      if (FontManager.isCombinedCharacter(charCode)) {\n        shouldCombine = true; // It's a potential surrogate pair (this is the High surrogate)\n      } else if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n        if (FontManager.isRegionalFlag(text, i)) {\n          currentChars = text.substr(i, 14);\n        } else {\n          secondCharCode = text.charCodeAt(i + 1); // It's a surrogate pair (this is the Low surrogate)\n\n          if (secondCharCode >= 0xDC00 && secondCharCode <= 0xDFFF) {\n            if (FontManager.isModifier(charCode, secondCharCode)) {\n              currentChars = text.substr(i, 2);\n              shouldCombine = true;\n            } else if (FontManager.isFlagEmoji(text.substr(i, 4))) {\n              currentChars = text.substr(i, 4);\n            } else {\n              currentChars = text.substr(i, 2);\n            }\n          }\n        }\n      } else if (charCode > 0xDBFF) {\n        secondCharCode = text.charCodeAt(i + 1);\n\n        if (FontManager.isVariationSelector(charCode)) {\n          shouldCombine = true;\n        }\n      } else if (FontManager.isZeroWidthJoiner(charCode)) {\n        shouldCombine = true;\n        shouldCombineNext = true;\n      }\n\n      if (shouldCombine) {\n        charactersArray[charactersArray.length - 1] += currentChars;\n        shouldCombine = false;\n      } else {\n        charactersArray.push(currentChars);\n      }\n\n      i += currentChars.length;\n    }\n\n    return charactersArray;\n  };\n\n  TextProperty.prototype.completeTextData = function (documentData) {\n    documentData.__complete = true;\n    var fontManager = this.elem.globalData.fontManager;\n    var data = this.data;\n    var letters = [];\n    var i;\n    var len;\n    var newLineFlag;\n    var index = 0;\n    var val;\n    var anchorGrouping = data.m.g;\n    var currentSize = 0;\n    var currentPos = 0;\n    var currentLine = 0;\n    var lineWidths = [];\n    var lineWidth = 0;\n    var maxLineWidth = 0;\n    var j;\n    var jLen;\n    var fontData = fontManager.getFontByName(documentData.f);\n    var charData;\n    var cLength = 0;\n    var fontProps = getFontProperties(fontData);\n    documentData.fWeight = fontProps.weight;\n    documentData.fStyle = fontProps.style;\n    documentData.finalSize = documentData.s;\n    documentData.finalText = this.buildFinalText(documentData.t);\n    len = documentData.finalText.length;\n    documentData.finalLineHeight = documentData.lh;\n    var trackingOffset = documentData.tr / 1000 * documentData.finalSize;\n    var charCode;\n\n    if (documentData.sz) {\n      var flag = true;\n      var boxWidth = documentData.sz[0];\n      var boxHeight = documentData.sz[1];\n      var currentHeight;\n      var finalText;\n\n      while (flag) {\n        finalText = this.buildFinalText(documentData.t);\n        currentHeight = 0;\n        lineWidth = 0;\n        len = finalText.length;\n        trackingOffset = documentData.tr / 1000 * documentData.finalSize;\n        var lastSpaceIndex = -1;\n\n        for (i = 0; i < len; i += 1) {\n          charCode = finalText[i].charCodeAt(0);\n          newLineFlag = false;\n\n          if (finalText[i] === ' ') {\n            lastSpaceIndex = i;\n          } else if (charCode === 13 || charCode === 3) {\n            lineWidth = 0;\n            newLineFlag = true;\n            currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;\n          }\n\n          if (fontManager.chars) {\n            charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);\n            cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;\n          } else {\n            // tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;\n            cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);\n          }\n\n          if (lineWidth + cLength > boxWidth && finalText[i] !== ' ') {\n            if (lastSpaceIndex === -1) {\n              len += 1;\n            } else {\n              i = lastSpaceIndex;\n            }\n\n            currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;\n            finalText.splice(i, lastSpaceIndex === i ? 1 : 0, '\\r'); // finalText = finalText.substr(0,i) + \"\\r\" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);\n\n            lastSpaceIndex = -1;\n            lineWidth = 0;\n          } else {\n            lineWidth += cLength;\n            lineWidth += trackingOffset;\n          }\n        }\n\n        currentHeight += fontData.ascent * documentData.finalSize / 100;\n\n        if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {\n          documentData.finalSize -= 1;\n          documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;\n        } else {\n          documentData.finalText = finalText;\n          len = documentData.finalText.length;\n          flag = false;\n        }\n      }\n    }\n\n    lineWidth = -trackingOffset;\n    cLength = 0;\n    var uncollapsedSpaces = 0;\n    var currentChar;\n\n    for (i = 0; i < len; i += 1) {\n      newLineFlag = false;\n      currentChar = documentData.finalText[i];\n      charCode = currentChar.charCodeAt(0);\n\n      if (charCode === 13 || charCode === 3) {\n        uncollapsedSpaces = 0;\n        lineWidths.push(lineWidth);\n        maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;\n        lineWidth = -2 * trackingOffset;\n        val = '';\n        newLineFlag = true;\n        currentLine += 1;\n      } else {\n        val = currentChar;\n      }\n\n      if (fontManager.chars) {\n        charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);\n        cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;\n      } else {\n        // var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);\n        // tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;\n        cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);\n      } //\n\n\n      if (currentChar === ' ') {\n        uncollapsedSpaces += cLength + trackingOffset;\n      } else {\n        lineWidth += cLength + trackingOffset + uncollapsedSpaces;\n        uncollapsedSpaces = 0;\n      }\n\n      letters.push({\n        l: cLength,\n        an: cLength,\n        add: currentSize,\n        n: newLineFlag,\n        anIndexes: [],\n        val: val,\n        line: currentLine,\n        animatorJustifyOffset: 0\n      });\n\n      if (anchorGrouping == 2) {\n        // eslint-disable-line eqeqeq\n        currentSize += cLength;\n\n        if (val === '' || val === ' ' || i === len - 1) {\n          if (val === '' || val === ' ') {\n            currentSize -= cLength;\n          }\n\n          while (currentPos <= i) {\n            letters[currentPos].an = currentSize;\n            letters[currentPos].ind = index;\n            letters[currentPos].extra = cLength;\n            currentPos += 1;\n          }\n\n          index += 1;\n          currentSize = 0;\n        }\n      } else if (anchorGrouping == 3) {\n        // eslint-disable-line eqeqeq\n        currentSize += cLength;\n\n        if (val === '' || i === len - 1) {\n          if (val === '') {\n            currentSize -= cLength;\n          }\n\n          while (currentPos <= i) {\n            letters[currentPos].an = currentSize;\n            letters[currentPos].ind = index;\n            letters[currentPos].extra = cLength;\n            currentPos += 1;\n          }\n\n          currentSize = 0;\n          index += 1;\n        }\n      } else {\n        letters[index].ind = index;\n        letters[index].extra = 0;\n        index += 1;\n      }\n    }\n\n    documentData.l = letters;\n    maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;\n    lineWidths.push(lineWidth);\n\n    if (documentData.sz) {\n      documentData.boxWidth = documentData.sz[0];\n      documentData.justifyOffset = 0;\n    } else {\n      documentData.boxWidth = maxLineWidth;\n\n      switch (documentData.j) {\n        case 1:\n          documentData.justifyOffset = -documentData.boxWidth;\n          break;\n\n        case 2:\n          documentData.justifyOffset = -documentData.boxWidth / 2;\n          break;\n\n        default:\n          documentData.justifyOffset = 0;\n      }\n    }\n\n    documentData.lineWidths = lineWidths;\n    var animators = data.a;\n    var animatorData;\n    var letterData;\n    jLen = animators.length;\n    var based;\n    var ind;\n    var indexes = [];\n\n    for (j = 0; j < jLen; j += 1) {\n      animatorData = animators[j];\n\n      if (animatorData.a.sc) {\n        documentData.strokeColorAnim = true;\n      }\n\n      if (animatorData.a.sw) {\n        documentData.strokeWidthAnim = true;\n      }\n\n      if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {\n        documentData.fillColorAnim = true;\n      }\n\n      ind = 0;\n      based = animatorData.s.b;\n\n      for (i = 0; i < len; i += 1) {\n        letterData = letters[i];\n        letterData.anIndexes[j] = ind;\n\n        if (based == 1 && letterData.val !== '' || based == 2 && letterData.val !== '' && letterData.val !== ' ' || based == 3 && (letterData.n || letterData.val == ' ' || i == len - 1) || based == 4 && (letterData.n || i == len - 1)) {\n          // eslint-disable-line eqeqeq\n          if (animatorData.s.rn === 1) {\n            indexes.push(ind);\n          }\n\n          ind += 1;\n        }\n      }\n\n      data.a[j].s.totalChars = ind;\n      var currentInd = -1;\n      var newInd;\n\n      if (animatorData.s.rn === 1) {\n        for (i = 0; i < len; i += 1) {\n          letterData = letters[i];\n\n          if (currentInd != letterData.anIndexes[j]) {\n            // eslint-disable-line eqeqeq\n            currentInd = letterData.anIndexes[j];\n            newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];\n          }\n\n          letterData.anIndexes[j] = newInd;\n        }\n      }\n    }\n\n    documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;\n    documentData.ls = documentData.ls || 0;\n    documentData.ascent = fontData.ascent * documentData.finalSize / 100;\n  };\n\n  TextProperty.prototype.updateDocumentData = function (newData, index) {\n    index = index === undefined ? this.keysIndex : index;\n    var dData = this.copyData({}, this.data.d.k[index].s);\n    dData = this.copyData(dData, newData);\n    this.data.d.k[index].s = dData;\n    this.recalculate(index);\n    this.setCurrentData(dData);\n    this.elem.addDynamicProperty(this);\n  };\n\n  TextProperty.prototype.recalculate = function (index) {\n    var dData = this.data.d.k[index].s;\n    dData.__complete = false;\n    this.keysIndex = 0;\n    this._isFirstFrame = true;\n    this.getValue(dData);\n  };\n\n  TextProperty.prototype.canResizeFont = function (_canResize) {\n    this.canResize = _canResize;\n    this.recalculate(this.keysIndex);\n    this.elem.addDynamicProperty(this);\n  };\n\n  TextProperty.prototype.setMinimumFontSize = function (_fontValue) {\n    this.minimumFontSize = Math.floor(_fontValue) || 1;\n    this.recalculate(this.keysIndex);\n    this.elem.addDynamicProperty(this);\n  };\n\n  var TextSelectorProp = function () {\n    var max = Math.max;\n    var min = Math.min;\n    var floor = Math.floor;\n\n    function TextSelectorPropFactory(elem, data) {\n      this._currentTextLength = -1;\n      this.k = false;\n      this.data = data;\n      this.elem = elem;\n      this.comp = elem.comp;\n      this.finalS = 0;\n      this.finalE = 0;\n      this.initDynamicPropertyContainer(elem);\n      this.s = PropertyFactory.getProp(elem, data.s || {\n        k: 0\n      }, 0, 0, this);\n\n      if ('e' in data) {\n        this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this);\n      } else {\n        this.e = {\n          v: 100\n        };\n      }\n\n      this.o = PropertyFactory.getProp(elem, data.o || {\n        k: 0\n      }, 0, 0, this);\n      this.xe = PropertyFactory.getProp(elem, data.xe || {\n        k: 0\n      }, 0, 0, this);\n      this.ne = PropertyFactory.getProp(elem, data.ne || {\n        k: 0\n      }, 0, 0, this);\n      this.sm = PropertyFactory.getProp(elem, data.sm || {\n        k: 100\n      }, 0, 0, this);\n      this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this);\n\n      if (!this.dynamicProperties.length) {\n        this.getValue();\n      }\n    }\n\n    TextSelectorPropFactory.prototype = {\n      getMult: function getMult(ind) {\n        if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {\n          this.getValue();\n        }\n\n        var x1 = 0;\n        var y1 = 0;\n        var x2 = 1;\n        var y2 = 1;\n\n        if (this.ne.v > 0) {\n          x1 = this.ne.v / 100.0;\n        } else {\n          y1 = -this.ne.v / 100.0;\n        }\n\n        if (this.xe.v > 0) {\n          x2 = 1.0 - this.xe.v / 100.0;\n        } else {\n          y2 = 1.0 + this.xe.v / 100.0;\n        }\n\n        var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;\n        var mult = 0;\n        var s = this.finalS;\n        var e = this.finalE;\n        var type = this.data.sh;\n\n        if (type === 2) {\n          if (e === s) {\n            mult = ind >= e ? 1 : 0;\n          } else {\n            mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));\n          }\n\n          mult = easer(mult);\n        } else if (type === 3) {\n          if (e === s) {\n            mult = ind >= e ? 0 : 1;\n          } else {\n            mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));\n          }\n\n          mult = easer(mult);\n        } else if (type === 4) {\n          if (e === s) {\n            mult = 0;\n          } else {\n            mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));\n\n            if (mult < 0.5) {\n              mult *= 2;\n            } else {\n              mult = 1 - 2 * (mult - 0.5);\n            }\n          }\n\n          mult = easer(mult);\n        } else if (type === 5) {\n          if (e === s) {\n            mult = 0;\n          } else {\n            var tot = e - s;\n            /* ind += 0.5;\r\n                      mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind; */\n\n            ind = min(max(0, ind + 0.5 - s), e - s);\n            var x = -tot / 2 + ind;\n            var a = tot / 2;\n            mult = Math.sqrt(1 - x * x / (a * a));\n          }\n\n          mult = easer(mult);\n        } else if (type === 6) {\n          if (e === s) {\n            mult = 0;\n          } else {\n            ind = min(max(0, ind + 0.5 - s), e - s);\n            mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e - s))) / 2; // eslint-disable-line\n          }\n\n          mult = easer(mult);\n        } else {\n          if (ind >= floor(s)) {\n            if (ind - s < 0) {\n              mult = max(0, min(min(e, 1) - (s - ind), 1));\n            } else {\n              mult = max(0, min(e - ind, 1));\n            }\n          }\n\n          mult = easer(mult);\n        } // Smoothness implementation.\n        // The smoothness represents a reduced range of the original [0; 1] range.\n        // if smoothness is 25%, the new range will be [0.375; 0.625]\n        // Steps are:\n        // - find the lower value of the new range (threshold)\n        // - if multiplier is smaller than that value, floor it to 0\n        // - if it is larger,\n        //     - subtract the threshold\n        //     - divide it by the smoothness (this will return the range to [0; 1])\n        // Note: If it doesn't work on some scenarios, consider applying it before the easer.\n\n\n        if (this.sm.v !== 100) {\n          var smoothness = this.sm.v * 0.01;\n\n          if (smoothness === 0) {\n            smoothness = 0.00000001;\n          }\n\n          var threshold = 0.5 - smoothness * 0.5;\n\n          if (mult < threshold) {\n            mult = 0;\n          } else {\n            mult = (mult - threshold) / smoothness;\n\n            if (mult > 1) {\n              mult = 1;\n            }\n          }\n        }\n\n        return mult * this.a.v;\n      },\n      getValue: function getValue(newCharsFlag) {\n        this.iterateDynamicProperties();\n        this._mdf = newCharsFlag || this._mdf;\n        this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;\n\n        if (newCharsFlag && this.data.r === 2) {\n          this.e.v = this._currentTextLength;\n        }\n\n        var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;\n        var o = this.o.v / divisor;\n        var s = this.s.v / divisor + o;\n        var e = this.e.v / divisor + o;\n\n        if (s > e) {\n          var _s = s;\n          s = e;\n          e = _s;\n        }\n\n        this.finalS = s;\n        this.finalE = e;\n      }\n    };\n    extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);\n\n    function getTextSelectorProp(elem, data, arr) {\n      return new TextSelectorPropFactory(elem, data, arr);\n    }\n\n    return {\n      getTextSelectorProp: getTextSelectorProp\n    };\n  }();\n\n  function TextAnimatorDataProperty(elem, animatorProps, container) {\n    var defaultData = {\n      propType: false\n    };\n    var getProp = PropertyFactory.getProp;\n    var textAnimatorAnimatables = animatorProps.a;\n    this.a = {\n      r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,\n      rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,\n      ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,\n      sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,\n      sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,\n      s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,\n      a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,\n      o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,\n      p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,\n      sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,\n      sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,\n      fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,\n      fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,\n      fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,\n      fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,\n      t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData\n    };\n    this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container);\n    this.s.t = animatorProps.s.t;\n  }\n\n  function TextAnimatorProperty(textData, renderType, elem) {\n    this._isFirstFrame = true;\n    this._hasMaskedPath = false;\n    this._frameId = -1;\n    this._textData = textData;\n    this._renderType = renderType;\n    this._elem = elem;\n    this._animatorsData = createSizedArray(this._textData.a.length);\n    this._pathData = {};\n    this._moreOptions = {\n      alignment: {}\n    };\n    this.renderedLetters = [];\n    this.lettersChangedFlag = false;\n    this.initDynamicPropertyContainer(elem);\n  }\n\n  TextAnimatorProperty.prototype.searchProperties = function () {\n    var i;\n    var len = this._textData.a.length;\n    var animatorProps;\n    var getProp = PropertyFactory.getProp;\n\n    for (i = 0; i < len; i += 1) {\n      animatorProps = this._textData.a[i];\n      this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);\n    }\n\n    if (this._textData.p && 'm' in this._textData.p) {\n      this._pathData = {\n        a: getProp(this._elem, this._textData.p.a, 0, 0, this),\n        f: getProp(this._elem, this._textData.p.f, 0, 0, this),\n        l: getProp(this._elem, this._textData.p.l, 0, 0, this),\n        r: getProp(this._elem, this._textData.p.r, 0, 0, this),\n        p: getProp(this._elem, this._textData.p.p, 0, 0, this),\n        m: this._elem.maskManager.getMaskProperty(this._textData.p.m)\n      };\n      this._hasMaskedPath = true;\n    } else {\n      this._hasMaskedPath = false;\n    }\n\n    this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);\n  };\n\n  TextAnimatorProperty.prototype.getMeasures = function (documentData, lettersChangedFlag) {\n    this.lettersChangedFlag = lettersChangedFlag;\n\n    if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {\n      return;\n    }\n\n    this._isFirstFrame = false;\n    var alignment = this._moreOptions.alignment.v;\n    var animators = this._animatorsData;\n    var textData = this._textData;\n    var matrixHelper = this.mHelper;\n    var renderType = this._renderType;\n    var renderedLettersCount = this.renderedLetters.length;\n    var xPos;\n    var yPos;\n    var i;\n    var len;\n    var letters = documentData.l;\n    var pathInfo;\n    var currentLength;\n    var currentPoint;\n    var segmentLength;\n    var flag;\n    var pointInd;\n    var segmentInd;\n    var prevPoint;\n    var points;\n    var segments;\n    var partialLength;\n    var totalLength;\n    var perc;\n    var tanAngle;\n    var mask;\n\n    if (this._hasMaskedPath) {\n      mask = this._pathData.m;\n\n      if (!this._pathData.n || this._pathData._mdf) {\n        var paths = mask.v;\n\n        if (this._pathData.r.v) {\n          paths = paths.reverse();\n        } // TODO: release bezier data cached from previous pathInfo: this._pathData.pi\n\n\n        pathInfo = {\n          tLength: 0,\n          segments: []\n        };\n        len = paths._length - 1;\n        var bezierData;\n        totalLength = 0;\n\n        for (i = 0; i < len; i += 1) {\n          bezierData = bez.buildBezierData(paths.v[i], paths.v[i + 1], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]);\n          pathInfo.tLength += bezierData.segmentLength;\n          pathInfo.segments.push(bezierData);\n          totalLength += bezierData.segmentLength;\n        }\n\n        i = len;\n\n        if (mask.v.c) {\n          bezierData = bez.buildBezierData(paths.v[i], paths.v[0], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);\n          pathInfo.tLength += bezierData.segmentLength;\n          pathInfo.segments.push(bezierData);\n          totalLength += bezierData.segmentLength;\n        }\n\n        this._pathData.pi = pathInfo;\n      }\n\n      pathInfo = this._pathData.pi;\n      currentLength = this._pathData.f.v;\n      segmentInd = 0;\n      pointInd = 1;\n      segmentLength = 0;\n      flag = true;\n      segments = pathInfo.segments;\n\n      if (currentLength < 0 && mask.v.c) {\n        if (pathInfo.tLength < Math.abs(currentLength)) {\n          currentLength = -Math.abs(currentLength) % pathInfo.tLength;\n        }\n\n        segmentInd = segments.length - 1;\n        points = segments[segmentInd].points;\n        pointInd = points.length - 1;\n\n        while (currentLength < 0) {\n          currentLength += points[pointInd].partialLength;\n          pointInd -= 1;\n\n          if (pointInd < 0) {\n            segmentInd -= 1;\n            points = segments[segmentInd].points;\n            pointInd = points.length - 1;\n          }\n        }\n      }\n\n      points = segments[segmentInd].points;\n      prevPoint = points[pointInd - 1];\n      currentPoint = points[pointInd];\n      partialLength = currentPoint.partialLength;\n    }\n\n    len = letters.length;\n    xPos = 0;\n    yPos = 0;\n    var yOff = documentData.finalSize * 1.2 * 0.714;\n    var firstLine = true;\n    var animatorProps;\n    var animatorSelector;\n    var j;\n    var jLen;\n    var letterValue;\n    jLen = animators.length;\n    var mult;\n    var ind = -1;\n    var offf;\n    var xPathPos;\n    var yPathPos;\n    var initPathPos = currentLength;\n    var initSegmentInd = segmentInd;\n    var initPointInd = pointInd;\n    var currentLine = -1;\n    var elemOpacity;\n    var sc;\n    var sw;\n    var fc;\n    var k;\n    var letterSw;\n    var letterSc;\n    var letterFc;\n    var letterM = '';\n    var letterP = this.defaultPropsArray;\n    var letterO; //\n\n    if (documentData.j === 2 || documentData.j === 1) {\n      var animatorJustifyOffset = 0;\n      var animatorFirstCharOffset = 0;\n      var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;\n      var lastIndex = 0;\n      var isNewLine = true;\n\n      for (i = 0; i < len; i += 1) {\n        if (letters[i].n) {\n          if (animatorJustifyOffset) {\n            animatorJustifyOffset += animatorFirstCharOffset;\n          }\n\n          while (lastIndex < i) {\n            letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;\n            lastIndex += 1;\n          }\n\n          animatorJustifyOffset = 0;\n          isNewLine = true;\n        } else {\n          for (j = 0; j < jLen; j += 1) {\n            animatorProps = animators[j].a;\n\n            if (animatorProps.t.propType) {\n              if (isNewLine && documentData.j === 2) {\n                animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;\n              }\n\n              animatorSelector = animators[j].s;\n              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n\n              if (mult.length) {\n                animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;\n              } else {\n                animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;\n              }\n            }\n          }\n\n          isNewLine = false;\n        }\n      }\n\n      if (animatorJustifyOffset) {\n        animatorJustifyOffset += animatorFirstCharOffset;\n      }\n\n      while (lastIndex < i) {\n        letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;\n        lastIndex += 1;\n      }\n    } //\n\n\n    for (i = 0; i < len; i += 1) {\n      matrixHelper.reset();\n      elemOpacity = 1;\n\n      if (letters[i].n) {\n        xPos = 0;\n        yPos += documentData.yOffset;\n        yPos += firstLine ? 1 : 0;\n        currentLength = initPathPos;\n        firstLine = false;\n\n        if (this._hasMaskedPath) {\n          segmentInd = initSegmentInd;\n          pointInd = initPointInd;\n          points = segments[segmentInd].points;\n          prevPoint = points[pointInd - 1];\n          currentPoint = points[pointInd];\n          partialLength = currentPoint.partialLength;\n          segmentLength = 0;\n        }\n\n        letterM = '';\n        letterFc = '';\n        letterSw = '';\n        letterO = '';\n        letterP = this.defaultPropsArray;\n      } else {\n        if (this._hasMaskedPath) {\n          if (currentLine !== letters[i].line) {\n            switch (documentData.j) {\n              case 1:\n                currentLength += totalLength - documentData.lineWidths[letters[i].line];\n                break;\n\n              case 2:\n                currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2;\n                break;\n\n              default:\n                break;\n            }\n\n            currentLine = letters[i].line;\n          }\n\n          if (ind !== letters[i].ind) {\n            if (letters[ind]) {\n              currentLength += letters[ind].extra;\n            }\n\n            currentLength += letters[i].an / 2;\n            ind = letters[i].ind;\n          }\n\n          currentLength += alignment[0] * letters[i].an * 0.005;\n          var animatorOffset = 0;\n\n          for (j = 0; j < jLen; j += 1) {\n            animatorProps = animators[j].a;\n\n            if (animatorProps.p.propType) {\n              animatorSelector = animators[j].s;\n              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n\n              if (mult.length) {\n                animatorOffset += animatorProps.p.v[0] * mult[0];\n              } else {\n                animatorOffset += animatorProps.p.v[0] * mult;\n              }\n            }\n\n            if (animatorProps.a.propType) {\n              animatorSelector = animators[j].s;\n              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n\n              if (mult.length) {\n                animatorOffset += animatorProps.a.v[0] * mult[0];\n              } else {\n                animatorOffset += animatorProps.a.v[0] * mult;\n              }\n            }\n          }\n\n          flag = true; // Force alignment only works with a single line for now\n\n          if (this._pathData.a.v) {\n            currentLength = letters[0].an * 0.5 + (totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);\n            currentLength += this._pathData.f.v;\n          }\n\n          while (flag) {\n            if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {\n              perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;\n              xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;\n              yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;\n              matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -(alignment[1] * yOff) * 0.01);\n              flag = false;\n            } else if (points) {\n              segmentLength += currentPoint.partialLength;\n              pointInd += 1;\n\n              if (pointInd >= points.length) {\n                pointInd = 0;\n                segmentInd += 1;\n\n                if (!segments[segmentInd]) {\n                  if (mask.v.c) {\n                    pointInd = 0;\n                    segmentInd = 0;\n                    points = segments[segmentInd].points;\n                  } else {\n                    segmentLength -= currentPoint.partialLength;\n                    points = null;\n                  }\n                } else {\n                  points = segments[segmentInd].points;\n                }\n              }\n\n              if (points) {\n                prevPoint = currentPoint;\n                currentPoint = points[pointInd];\n                partialLength = currentPoint.partialLength;\n              }\n            }\n          }\n\n          offf = letters[i].an / 2 - letters[i].add;\n          matrixHelper.translate(-offf, 0, 0);\n        } else {\n          offf = letters[i].an / 2 - letters[i].add;\n          matrixHelper.translate(-offf, 0, 0); // Grouping alignment\n\n          matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -alignment[1] * yOff * 0.01, 0);\n        }\n\n        for (j = 0; j < jLen; j += 1) {\n          animatorProps = animators[j].a;\n\n          if (animatorProps.t.propType) {\n            animatorSelector = animators[j].s;\n            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars); // This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean \"isNewLine\"\n\n            if (xPos !== 0 || documentData.j !== 0) {\n              if (this._hasMaskedPath) {\n                if (mult.length) {\n                  currentLength += animatorProps.t.v * mult[0];\n                } else {\n                  currentLength += animatorProps.t.v * mult;\n                }\n              } else if (mult.length) {\n                xPos += animatorProps.t.v * mult[0];\n              } else {\n                xPos += animatorProps.t.v * mult;\n              }\n            }\n          }\n        }\n\n        if (documentData.strokeWidthAnim) {\n          sw = documentData.sw || 0;\n        }\n\n        if (documentData.strokeColorAnim) {\n          if (documentData.sc) {\n            sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];\n          } else {\n            sc = [0, 0, 0];\n          }\n        }\n\n        if (documentData.fillColorAnim && documentData.fc) {\n          fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];\n        }\n\n        for (j = 0; j < jLen; j += 1) {\n          animatorProps = animators[j].a;\n\n          if (animatorProps.a.propType) {\n            animatorSelector = animators[j].s;\n            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n\n            if (mult.length) {\n              matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);\n            } else {\n              matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);\n            }\n          }\n        }\n\n        for (j = 0; j < jLen; j += 1) {\n          animatorProps = animators[j].a;\n\n          if (animatorProps.s.propType) {\n            animatorSelector = animators[j].s;\n            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n\n            if (mult.length) {\n              matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);\n            } else {\n              matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);\n            }\n          }\n        }\n\n        for (j = 0; j < jLen; j += 1) {\n          animatorProps = animators[j].a;\n          animatorSelector = animators[j].s;\n          mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n\n          if (animatorProps.sk.propType) {\n            if (mult.length) {\n              matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);\n            } else {\n              matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);\n            }\n          }\n\n          if (animatorProps.r.propType) {\n            if (mult.length) {\n              matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);\n            } else {\n              matrixHelper.rotateZ(-animatorProps.r.v * mult);\n            }\n          }\n\n          if (animatorProps.ry.propType) {\n            if (mult.length) {\n              matrixHelper.rotateY(animatorProps.ry.v * mult[1]);\n            } else {\n              matrixHelper.rotateY(animatorProps.ry.v * mult);\n            }\n          }\n\n          if (animatorProps.rx.propType) {\n            if (mult.length) {\n              matrixHelper.rotateX(animatorProps.rx.v * mult[0]);\n            } else {\n              matrixHelper.rotateX(animatorProps.rx.v * mult);\n            }\n          }\n\n          if (animatorProps.o.propType) {\n            if (mult.length) {\n              elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];\n            } else {\n              elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;\n            }\n          }\n\n          if (documentData.strokeWidthAnim && animatorProps.sw.propType) {\n            if (mult.length) {\n              sw += animatorProps.sw.v * mult[0];\n            } else {\n              sw += animatorProps.sw.v * mult;\n            }\n          }\n\n          if (documentData.strokeColorAnim && animatorProps.sc.propType) {\n            for (k = 0; k < 3; k += 1) {\n              if (mult.length) {\n                sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];\n              } else {\n                sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;\n              }\n            }\n          }\n\n          if (documentData.fillColorAnim && documentData.fc) {\n            if (animatorProps.fc.propType) {\n              for (k = 0; k < 3; k += 1) {\n                if (mult.length) {\n                  fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];\n                } else {\n                  fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;\n                }\n              }\n            }\n\n            if (animatorProps.fh.propType) {\n              if (mult.length) {\n                fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);\n              } else {\n                fc = addHueToRGB(fc, animatorProps.fh.v * mult);\n              }\n            }\n\n            if (animatorProps.fs.propType) {\n              if (mult.length) {\n                fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);\n              } else {\n                fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);\n              }\n            }\n\n            if (animatorProps.fb.propType) {\n              if (mult.length) {\n                fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);\n              } else {\n                fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);\n              }\n            }\n          }\n        }\n\n        for (j = 0; j < jLen; j += 1) {\n          animatorProps = animators[j].a;\n\n          if (animatorProps.p.propType) {\n            animatorSelector = animators[j].s;\n            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n\n            if (this._hasMaskedPath) {\n              if (mult.length) {\n                matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);\n              } else {\n                matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);\n              }\n            } else if (mult.length) {\n              matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);\n            } else {\n              matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);\n            }\n          }\n        }\n\n        if (documentData.strokeWidthAnim) {\n          letterSw = sw < 0 ? 0 : sw;\n        }\n\n        if (documentData.strokeColorAnim) {\n          letterSc = 'rgb(' + Math.round(sc[0] * 255) + ',' + Math.round(sc[1] * 255) + ',' + Math.round(sc[2] * 255) + ')';\n        }\n\n        if (documentData.fillColorAnim && documentData.fc) {\n          letterFc = 'rgb(' + Math.round(fc[0] * 255) + ',' + Math.round(fc[1] * 255) + ',' + Math.round(fc[2] * 255) + ')';\n        }\n\n        if (this._hasMaskedPath) {\n          matrixHelper.translate(0, -documentData.ls);\n          matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);\n\n          if (this._pathData.p.v) {\n            tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);\n            var rot = Math.atan(tanAngle) * 180 / Math.PI;\n\n            if (currentPoint.point[0] < prevPoint.point[0]) {\n              rot += 180;\n            }\n\n            matrixHelper.rotate(-rot * Math.PI / 180);\n          }\n\n          matrixHelper.translate(xPathPos, yPathPos, 0);\n          currentLength -= alignment[0] * letters[i].an * 0.005;\n\n          if (letters[i + 1] && ind !== letters[i + 1].ind) {\n            currentLength += letters[i].an / 2;\n            currentLength += documentData.tr * 0.001 * documentData.finalSize;\n          }\n        } else {\n          matrixHelper.translate(xPos, yPos, 0);\n\n          if (documentData.ps) {\n            // matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);\n            matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);\n          }\n\n          switch (documentData.j) {\n            case 1:\n              matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);\n              break;\n\n            case 2:\n              matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0);\n              break;\n\n            default:\n              break;\n          }\n\n          matrixHelper.translate(0, -documentData.ls);\n          matrixHelper.translate(offf, 0, 0);\n          matrixHelper.translate(alignment[0] * letters[i].an * 0.005, alignment[1] * yOff * 0.01, 0);\n          xPos += letters[i].l + documentData.tr * 0.001 * documentData.finalSize;\n        }\n\n        if (renderType === 'html') {\n          letterM = matrixHelper.toCSS();\n        } else if (renderType === 'svg') {\n          letterM = matrixHelper.to2dCSS();\n        } else {\n          letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];\n        }\n\n        letterO = elemOpacity;\n      }\n\n      if (renderedLettersCount <= i) {\n        letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);\n        this.renderedLetters.push(letterValue);\n        renderedLettersCount += 1;\n        this.lettersChangedFlag = true;\n      } else {\n        letterValue = this.renderedLetters[i];\n        this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;\n      }\n    }\n  };\n\n  TextAnimatorProperty.prototype.getValue = function () {\n    if (this._elem.globalData.frameId === this._frameId) {\n      return;\n    }\n\n    this._frameId = this._elem.globalData.frameId;\n    this.iterateDynamicProperties();\n  };\n\n  TextAnimatorProperty.prototype.mHelper = new Matrix();\n  TextAnimatorProperty.prototype.defaultPropsArray = [];\n  extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);\n\n  function ITextElement() {}\n\n  ITextElement.prototype.initElement = function (data, globalData, comp) {\n    this.lettersChangedFlag = true;\n    this.initFrame();\n    this.initBaseData(data, globalData, comp);\n    this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);\n    this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);\n    this.initTransform(data, globalData, comp);\n    this.initHierarchy();\n    this.initRenderable();\n    this.initRendererElement();\n    this.createContainerElements();\n    this.createRenderableComponents();\n    this.createContent();\n    this.hide();\n    this.textAnimator.searchProperties(this.dynamicProperties);\n  };\n\n  ITextElement.prototype.prepareFrame = function (num) {\n    this._mdf = false;\n    this.prepareRenderableFrame(num);\n    this.prepareProperties(num, this.isInRange);\n  };\n\n  ITextElement.prototype.createPathShape = function (matrixHelper, shapes) {\n    var j;\n    var jLen = shapes.length;\n    var pathNodes;\n    var shapeStr = '';\n\n    for (j = 0; j < jLen; j += 1) {\n      if (shapes[j].ty === 'sh') {\n        pathNodes = shapes[j].ks.k;\n        shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);\n      }\n    }\n\n    return shapeStr;\n  };\n\n  ITextElement.prototype.updateDocumentData = function (newData, index) {\n    this.textProperty.updateDocumentData(newData, index);\n  };\n\n  ITextElement.prototype.canResizeFont = function (_canResize) {\n    this.textProperty.canResizeFont(_canResize);\n  };\n\n  ITextElement.prototype.setMinimumFontSize = function (_fontSize) {\n    this.textProperty.setMinimumFontSize(_fontSize);\n  };\n\n  ITextElement.prototype.applyTextPropertiesToMatrix = function (documentData, matrixHelper, lineNumber, xPos, yPos) {\n    if (documentData.ps) {\n      matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);\n    }\n\n    matrixHelper.translate(0, -documentData.ls, 0);\n\n    switch (documentData.j) {\n      case 1:\n        matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);\n        break;\n\n      case 2:\n        matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);\n        break;\n\n      default:\n        break;\n    }\n\n    matrixHelper.translate(xPos, yPos, 0);\n  };\n\n  ITextElement.prototype.buildColor = function (colorData) {\n    return 'rgb(' + Math.round(colorData[0] * 255) + ',' + Math.round(colorData[1] * 255) + ',' + Math.round(colorData[2] * 255) + ')';\n  };\n\n  ITextElement.prototype.emptyProp = new LetterProps();\n\n  ITextElement.prototype.destroy = function () {};\n\n  ITextElement.prototype.validateText = function () {\n    if (this.textProperty._mdf || this.textProperty._isFirstFrame) {\n      this.buildNewText();\n      this.textProperty._isFirstFrame = false;\n      this.textProperty._mdf = false;\n    }\n  };\n\n  var emptyShapeData = {\n    shapes: []\n  };\n\n  function SVGTextLottieElement(data, globalData, comp) {\n    this.textSpans = [];\n    this.renderType = 'svg';\n    this.initElement(data, globalData, comp);\n  }\n\n  extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);\n\n  SVGTextLottieElement.prototype.createContent = function () {\n    if (this.data.singleShape && !this.globalData.fontManager.chars) {\n      this.textContainer = createNS('text');\n    }\n  };\n\n  SVGTextLottieElement.prototype.buildTextContents = function (textArray) {\n    var i = 0;\n    var len = textArray.length;\n    var textContents = [];\n    var currentTextContent = '';\n\n    while (i < len) {\n      if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {\n        textContents.push(currentTextContent);\n        currentTextContent = '';\n      } else {\n        currentTextContent += textArray[i];\n      }\n\n      i += 1;\n    }\n\n    textContents.push(currentTextContent);\n    return textContents;\n  };\n\n  SVGTextLottieElement.prototype.buildShapeData = function (data, scale) {\n    // data should probably be cloned to apply scale separately to each instance of a text on different layers\n    // but since text internal content gets only rendered once and then it's never rerendered,\n    // it's probably safe not to clone data and reuse always the same instance even if the object is mutated.\n    // Avoiding cloning is preferred since cloning each character shape data is expensive\n    if (data.shapes && data.shapes.length) {\n      var shape = data.shapes[0];\n\n      if (shape.it) {\n        var shapeItem = shape.it[shape.it.length - 1];\n\n        if (shapeItem.s) {\n          shapeItem.s.k[0] = scale;\n          shapeItem.s.k[1] = scale;\n        }\n      }\n    }\n\n    return data;\n  };\n\n  SVGTextLottieElement.prototype.buildNewText = function () {\n    this.addDynamicProperty(this);\n    var i;\n    var len;\n    var documentData = this.textProperty.currentData;\n    this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);\n\n    if (documentData.fc) {\n      this.layerElement.setAttribute('fill', this.buildColor(documentData.fc));\n    } else {\n      this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)');\n    }\n\n    if (documentData.sc) {\n      this.layerElement.setAttribute('stroke', this.buildColor(documentData.sc));\n      this.layerElement.setAttribute('stroke-width', documentData.sw);\n    }\n\n    this.layerElement.setAttribute('font-size', documentData.finalSize);\n    var fontData = this.globalData.fontManager.getFontByName(documentData.f);\n\n    if (fontData.fClass) {\n      this.layerElement.setAttribute('class', fontData.fClass);\n    } else {\n      this.layerElement.setAttribute('font-family', fontData.fFamily);\n      var fWeight = documentData.fWeight;\n      var fStyle = documentData.fStyle;\n      this.layerElement.setAttribute('font-style', fStyle);\n      this.layerElement.setAttribute('font-weight', fWeight);\n    }\n\n    this.layerElement.setAttribute('aria-label', documentData.t);\n    var letters = documentData.l || [];\n    var usesGlyphs = !!this.globalData.fontManager.chars;\n    len = letters.length;\n    var tSpan;\n    var matrixHelper = this.mHelper;\n    var shapeStr = '';\n    var singleShape = this.data.singleShape;\n    var xPos = 0;\n    var yPos = 0;\n    var firstLine = true;\n    var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;\n\n    if (singleShape && !usesGlyphs && !documentData.sz) {\n      var tElement = this.textContainer;\n      var justify = 'start';\n\n      switch (documentData.j) {\n        case 1:\n          justify = 'end';\n          break;\n\n        case 2:\n          justify = 'middle';\n          break;\n\n        default:\n          justify = 'start';\n          break;\n      }\n\n      tElement.setAttribute('text-anchor', justify);\n      tElement.setAttribute('letter-spacing', trackingOffset);\n      var textContent = this.buildTextContents(documentData.finalText);\n      len = textContent.length;\n      yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;\n\n      for (i = 0; i < len; i += 1) {\n        tSpan = this.textSpans[i].span || createNS('tspan');\n        tSpan.textContent = textContent[i];\n        tSpan.setAttribute('x', 0);\n        tSpan.setAttribute('y', yPos);\n        tSpan.style.display = 'inherit';\n        tElement.appendChild(tSpan);\n\n        if (!this.textSpans[i]) {\n          this.textSpans[i] = {\n            span: null,\n            glyph: null\n          };\n        }\n\n        this.textSpans[i].span = tSpan;\n        yPos += documentData.finalLineHeight;\n      }\n\n      this.layerElement.appendChild(tElement);\n    } else {\n      var cachedSpansLength = this.textSpans.length;\n      var charData;\n\n      for (i = 0; i < len; i += 1) {\n        if (!this.textSpans[i]) {\n          this.textSpans[i] = {\n            span: null,\n            childSpan: null,\n            glyph: null\n          };\n        }\n\n        if (!usesGlyphs || !singleShape || i === 0) {\n          tSpan = cachedSpansLength > i ? this.textSpans[i].span : createNS(usesGlyphs ? 'g' : 'text');\n\n          if (cachedSpansLength <= i) {\n            tSpan.setAttribute('stroke-linecap', 'butt');\n            tSpan.setAttribute('stroke-linejoin', 'round');\n            tSpan.setAttribute('stroke-miterlimit', '4');\n            this.textSpans[i].span = tSpan;\n\n            if (usesGlyphs) {\n              var childSpan = createNS('g');\n              tSpan.appendChild(childSpan);\n              this.textSpans[i].childSpan = childSpan;\n            }\n\n            this.textSpans[i].span = tSpan;\n            this.layerElement.appendChild(tSpan);\n          }\n\n          tSpan.style.display = 'inherit';\n        }\n\n        matrixHelper.reset();\n\n        if (singleShape) {\n          if (letters[i].n) {\n            xPos = -trackingOffset;\n            yPos += documentData.yOffset;\n            yPos += firstLine ? 1 : 0;\n            firstLine = false;\n          }\n\n          this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);\n          xPos += letters[i].l || 0; // xPos += letters[i].val === ' ' ? 0 : trackingOffset;\n\n          xPos += trackingOffset;\n        }\n\n        if (usesGlyphs) {\n          charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);\n          var glyphElement; // t === 1 means the character has been replaced with an animated shaped\n\n          if (charData.t === 1) {\n            glyphElement = new SVGCompElement(charData.data, this.globalData, this);\n          } else {\n            var data = emptyShapeData;\n\n            if (charData.data && charData.data.shapes) {\n              data = this.buildShapeData(charData.data, documentData.finalSize);\n            }\n\n            glyphElement = new SVGShapeElement(data, this.globalData, this);\n          }\n\n          if (this.textSpans[i].glyph) {\n            var glyph = this.textSpans[i].glyph;\n            this.textSpans[i].childSpan.removeChild(glyph.layerElement);\n            glyph.destroy();\n          }\n\n          this.textSpans[i].glyph = glyphElement;\n          glyphElement._debug = true;\n          glyphElement.prepareFrame(0);\n          glyphElement.renderFrame();\n          this.textSpans[i].childSpan.appendChild(glyphElement.layerElement); // when using animated shapes, the layer will be scaled instead of replacing the internal scale\n          // this might have issues with strokes and might need a different solution\n\n          if (charData.t === 1) {\n            this.textSpans[i].childSpan.setAttribute('transform', 'scale(' + documentData.finalSize / 100 + ',' + documentData.finalSize / 100 + ')');\n          }\n        } else {\n          if (singleShape) {\n            tSpan.setAttribute('transform', 'translate(' + matrixHelper.props[12] + ',' + matrixHelper.props[13] + ')');\n          }\n\n          tSpan.textContent = letters[i].val;\n          tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');\n        } //\n\n      }\n\n      if (singleShape && tSpan) {\n        tSpan.setAttribute('d', shapeStr);\n      }\n    }\n\n    while (i < this.textSpans.length) {\n      this.textSpans[i].span.style.display = 'none';\n      i += 1;\n    }\n\n    this._sizeChanged = true;\n  };\n\n  SVGTextLottieElement.prototype.sourceRectAtTime = function () {\n    this.prepareFrame(this.comp.renderedFrame - this.data.st);\n    this.renderInnerContent();\n\n    if (this._sizeChanged) {\n      this._sizeChanged = false;\n      var textBox = this.layerElement.getBBox();\n      this.bbox = {\n        top: textBox.y,\n        left: textBox.x,\n        width: textBox.width,\n        height: textBox.height\n      };\n    }\n\n    return this.bbox;\n  };\n\n  SVGTextLottieElement.prototype.getValue = function () {\n    var i;\n    var len = this.textSpans.length;\n    var glyphElement;\n    this.renderedFrame = this.comp.renderedFrame;\n\n    for (i = 0; i < len; i += 1) {\n      glyphElement = this.textSpans[i].glyph;\n\n      if (glyphElement) {\n        glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st);\n\n        if (glyphElement._mdf) {\n          this._mdf = true;\n        }\n      }\n    }\n  };\n\n  SVGTextLottieElement.prototype.renderInnerContent = function () {\n    this.validateText();\n\n    if (!this.data.singleShape || this._mdf) {\n      this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);\n\n      if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {\n        this._sizeChanged = true;\n        var i;\n        var len;\n        var renderedLetters = this.textAnimator.renderedLetters;\n        var letters = this.textProperty.currentData.l;\n        len = letters.length;\n        var renderedLetter;\n        var textSpan;\n        var glyphElement;\n\n        for (i = 0; i < len; i += 1) {\n          if (!letters[i].n) {\n            renderedLetter = renderedLetters[i];\n            textSpan = this.textSpans[i].span;\n            glyphElement = this.textSpans[i].glyph;\n\n            if (glyphElement) {\n              glyphElement.renderFrame();\n            }\n\n            if (renderedLetter._mdf.m) {\n              textSpan.setAttribute('transform', renderedLetter.m);\n            }\n\n            if (renderedLetter._mdf.o) {\n              textSpan.setAttribute('opacity', renderedLetter.o);\n            }\n\n            if (renderedLetter._mdf.sw) {\n              textSpan.setAttribute('stroke-width', renderedLetter.sw);\n            }\n\n            if (renderedLetter._mdf.sc) {\n              textSpan.setAttribute('stroke', renderedLetter.sc);\n            }\n\n            if (renderedLetter._mdf.fc) {\n              textSpan.setAttribute('fill', renderedLetter.fc);\n            }\n          }\n        }\n      }\n    }\n  };\n\n  function ISolidElement(data, globalData, comp) {\n    this.initElement(data, globalData, comp);\n  }\n\n  extendPrototype([IImageElement], ISolidElement);\n\n  ISolidElement.prototype.createContent = function () {\n    var rect = createNS('rect'); /// /rect.style.width = this.data.sw;\n    /// /rect.style.height = this.data.sh;\n    /// /rect.style.fill = this.data.sc;\n\n    rect.setAttribute('width', this.data.sw);\n    rect.setAttribute('height', this.data.sh);\n    rect.setAttribute('fill', this.data.sc);\n    this.layerElement.appendChild(rect);\n  };\n\n  function NullElement(data, globalData, comp) {\n    this.initFrame();\n    this.initBaseData(data, globalData, comp);\n    this.initFrame();\n    this.initTransform(data, globalData, comp);\n    this.initHierarchy();\n  }\n\n  NullElement.prototype.prepareFrame = function (num) {\n    this.prepareProperties(num, true);\n  };\n\n  NullElement.prototype.renderFrame = function () {};\n\n  NullElement.prototype.getBaseElement = function () {\n    return null;\n  };\n\n  NullElement.prototype.destroy = function () {};\n\n  NullElement.prototype.sourceRectAtTime = function () {};\n\n  NullElement.prototype.hide = function () {};\n\n  extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);\n\n  function SVGRendererBase() {}\n\n  extendPrototype([BaseRenderer], SVGRendererBase);\n\n  SVGRendererBase.prototype.createNull = function (data) {\n    return new NullElement(data, this.globalData, this);\n  };\n\n  SVGRendererBase.prototype.createShape = function (data) {\n    return new SVGShapeElement(data, this.globalData, this);\n  };\n\n  SVGRendererBase.prototype.createText = function (data) {\n    return new SVGTextLottieElement(data, this.globalData, this);\n  };\n\n  SVGRendererBase.prototype.createImage = function (data) {\n    return new IImageElement(data, this.globalData, this);\n  };\n\n  SVGRendererBase.prototype.createSolid = function (data) {\n    return new ISolidElement(data, this.globalData, this);\n  };\n\n  SVGRendererBase.prototype.configAnimation = function (animData) {\n    this.svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    this.svgElement.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n\n    if (this.renderConfig.viewBoxSize) {\n      this.svgElement.setAttribute('viewBox', this.renderConfig.viewBoxSize);\n    } else {\n      this.svgElement.setAttribute('viewBox', '0 0 ' + animData.w + ' ' + animData.h);\n    }\n\n    if (!this.renderConfig.viewBoxOnly) {\n      this.svgElement.setAttribute('width', animData.w);\n      this.svgElement.setAttribute('height', animData.h);\n      this.svgElement.style.width = '100%';\n      this.svgElement.style.height = '100%';\n      this.svgElement.style.transform = 'translate3d(0,0,0)';\n      this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;\n    }\n\n    if (this.renderConfig.width) {\n      this.svgElement.setAttribute('width', this.renderConfig.width);\n    }\n\n    if (this.renderConfig.height) {\n      this.svgElement.setAttribute('height', this.renderConfig.height);\n    }\n\n    if (this.renderConfig.className) {\n      this.svgElement.setAttribute('class', this.renderConfig.className);\n    }\n\n    if (this.renderConfig.id) {\n      this.svgElement.setAttribute('id', this.renderConfig.id);\n    }\n\n    if (this.renderConfig.focusable !== undefined) {\n      this.svgElement.setAttribute('focusable', this.renderConfig.focusable);\n    }\n\n    this.svgElement.setAttribute('preserveAspectRatio', this.renderConfig.preserveAspectRatio); // this.layerElement.style.transform = 'translate3d(0,0,0)';\n    // this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = \"0px 0px 0px\";\n\n    this.animationItem.wrapper.appendChild(this.svgElement); // Mask animation\n\n    var defs = this.globalData.defs;\n    this.setupGlobalData(animData, defs);\n    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;\n    this.data = animData;\n    var maskElement = createNS('clipPath');\n    var rect = createNS('rect');\n    rect.setAttribute('width', animData.w);\n    rect.setAttribute('height', animData.h);\n    rect.setAttribute('x', 0);\n    rect.setAttribute('y', 0);\n    var maskId = createElementID();\n    maskElement.setAttribute('id', maskId);\n    maskElement.appendChild(rect);\n    this.layerElement.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + maskId + ')');\n    defs.appendChild(maskElement);\n    this.layers = animData.layers;\n    this.elements = createSizedArray(animData.layers.length);\n  };\n\n  SVGRendererBase.prototype.destroy = function () {\n    if (this.animationItem.wrapper) {\n      this.animationItem.wrapper.innerText = '';\n    }\n\n    this.layerElement = null;\n    this.globalData.defs = null;\n    var i;\n    var len = this.layers ? this.layers.length : 0;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.elements[i] && this.elements[i].destroy) {\n        this.elements[i].destroy();\n      }\n    }\n\n    this.elements.length = 0;\n    this.destroyed = true;\n    this.animationItem = null;\n  };\n\n  SVGRendererBase.prototype.updateContainerSize = function () {};\n\n  SVGRendererBase.prototype.findIndexByInd = function (ind) {\n    var i = 0;\n    var len = this.layers.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.layers[i].ind === ind) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  SVGRendererBase.prototype.buildItem = function (pos) {\n    var elements = this.elements;\n\n    if (elements[pos] || this.layers[pos].ty === 99) {\n      return;\n    }\n\n    elements[pos] = true;\n    var element = this.createItem(this.layers[pos]);\n    elements[pos] = element;\n\n    if (getExpressionsPlugin()) {\n      if (this.layers[pos].ty === 0) {\n        this.globalData.projectInterface.registerComposition(element);\n      }\n\n      element.initExpressions();\n    }\n\n    this.appendElementInPos(element, pos);\n\n    if (this.layers[pos].tt) {\n      var elementIndex = 'tp' in this.layers[pos] ? this.findIndexByInd(this.layers[pos].tp) : pos - 1;\n\n      if (elementIndex === -1) {\n        return;\n      }\n\n      if (!this.elements[elementIndex] || this.elements[elementIndex] === true) {\n        this.buildItem(elementIndex);\n        this.addPendingElement(element);\n      } else {\n        var matteElement = elements[elementIndex];\n        var matteMask = matteElement.getMatte(this.layers[pos].tt);\n        element.setMatte(matteMask);\n      }\n    }\n  };\n\n  SVGRendererBase.prototype.checkPendingElements = function () {\n    while (this.pendingElements.length) {\n      var element = this.pendingElements.pop();\n      element.checkParenting();\n\n      if (element.data.tt) {\n        var i = 0;\n        var len = this.elements.length;\n\n        while (i < len) {\n          if (this.elements[i] === element) {\n            var elementIndex = 'tp' in element.data ? this.findIndexByInd(element.data.tp) : i - 1;\n            var matteElement = this.elements[elementIndex];\n            var matteMask = matteElement.getMatte(this.layers[i].tt);\n            element.setMatte(matteMask);\n            break;\n          }\n\n          i += 1;\n        }\n      }\n    }\n  };\n\n  SVGRendererBase.prototype.renderFrame = function (num) {\n    if (this.renderedFrame === num || this.destroyed) {\n      return;\n    }\n\n    if (num === null) {\n      num = this.renderedFrame;\n    } else {\n      this.renderedFrame = num;\n    } // console.log('-------');\n    // console.log('FRAME ',num);\n\n\n    this.globalData.frameNum = num;\n    this.globalData.frameId += 1;\n    this.globalData.projectInterface.currentFrame = num;\n    this.globalData._mdf = false;\n    var i;\n    var len = this.layers.length;\n\n    if (!this.completeLayers) {\n      this.checkLayers(num);\n    }\n\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (this.completeLayers || this.elements[i]) {\n        this.elements[i].prepareFrame(num - this.layers[i].st);\n      }\n    }\n\n    if (this.globalData._mdf) {\n      for (i = 0; i < len; i += 1) {\n        if (this.completeLayers || this.elements[i]) {\n          this.elements[i].renderFrame();\n        }\n      }\n    }\n  };\n\n  SVGRendererBase.prototype.appendElementInPos = function (element, pos) {\n    var newElement = element.getBaseElement();\n\n    if (!newElement) {\n      return;\n    }\n\n    var i = 0;\n    var nextElement;\n\n    while (i < pos) {\n      if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) {\n        nextElement = this.elements[i].getBaseElement();\n      }\n\n      i += 1;\n    }\n\n    if (nextElement) {\n      this.layerElement.insertBefore(newElement, nextElement);\n    } else {\n      this.layerElement.appendChild(newElement);\n    }\n  };\n\n  SVGRendererBase.prototype.hide = function () {\n    this.layerElement.style.display = 'none';\n  };\n\n  SVGRendererBase.prototype.show = function () {\n    this.layerElement.style.display = 'block';\n  };\n\n  function ICompElement() {}\n\n  extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);\n\n  ICompElement.prototype.initElement = function (data, globalData, comp) {\n    this.initFrame();\n    this.initBaseData(data, globalData, comp);\n    this.initTransform(data, globalData, comp);\n    this.initRenderable();\n    this.initHierarchy();\n    this.initRendererElement();\n    this.createContainerElements();\n    this.createRenderableComponents();\n\n    if (this.data.xt || !globalData.progressiveLoad) {\n      this.buildAllItems();\n    }\n\n    this.hide();\n  };\n  /* ICompElement.prototype.hide = function(){\r\n      if(!this.hidden){\r\n          this.hideElement();\r\n          var i,len = this.elements.length;\r\n          for( i = 0; i < len; i+=1 ){\r\n              if(this.elements[i]){\r\n                  this.elements[i].hide();\r\n              }\r\n          }\r\n      }\r\n  }; */\n\n\n  ICompElement.prototype.prepareFrame = function (num) {\n    this._mdf = false;\n    this.prepareRenderableFrame(num);\n    this.prepareProperties(num, this.isInRange);\n\n    if (!this.isInRange && !this.data.xt) {\n      return;\n    }\n\n    if (!this.tm._placeholder) {\n      var timeRemapped = this.tm.v;\n\n      if (timeRemapped === this.data.op) {\n        timeRemapped = this.data.op - 1;\n      }\n\n      this.renderedFrame = timeRemapped;\n    } else {\n      this.renderedFrame = num / this.data.sr;\n    }\n\n    var i;\n    var len = this.elements.length;\n\n    if (!this.completeLayers) {\n      this.checkLayers(this.renderedFrame);\n    } // This iteration needs to be backwards because of how expressions connect between each other\n\n\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (this.completeLayers || this.elements[i]) {\n        this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);\n\n        if (this.elements[i]._mdf) {\n          this._mdf = true;\n        }\n      }\n    }\n  };\n\n  ICompElement.prototype.renderInnerContent = function () {\n    var i;\n    var len = this.layers.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.completeLayers || this.elements[i]) {\n        this.elements[i].renderFrame();\n      }\n    }\n  };\n\n  ICompElement.prototype.setElements = function (elems) {\n    this.elements = elems;\n  };\n\n  ICompElement.prototype.getElements = function () {\n    return this.elements;\n  };\n\n  ICompElement.prototype.destroyElements = function () {\n    var i;\n    var len = this.layers.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.elements[i]) {\n        this.elements[i].destroy();\n      }\n    }\n  };\n\n  ICompElement.prototype.destroy = function () {\n    this.destroyElements();\n    this.destroyBaseElement();\n  };\n\n  function SVGCompElement(data, globalData, comp) {\n    this.layers = data.layers;\n    this.supports3d = true;\n    this.completeLayers = false;\n    this.pendingElements = [];\n    this.elements = this.layers ? createSizedArray(this.layers.length) : [];\n    this.initElement(data, globalData, comp);\n    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n      _placeholder: true\n    };\n  }\n\n  extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement);\n\n  SVGCompElement.prototype.createComp = function (data) {\n    return new SVGCompElement(data, this.globalData, this);\n  };\n\n  function SVGRenderer(animationItem, config) {\n    this.animationItem = animationItem;\n    this.layers = null;\n    this.renderedFrame = -1;\n    this.svgElement = createNS('svg');\n    var ariaLabel = '';\n\n    if (config && config.title) {\n      var titleElement = createNS('title');\n      var titleId = createElementID();\n      titleElement.setAttribute('id', titleId);\n      titleElement.textContent = config.title;\n      this.svgElement.appendChild(titleElement);\n      ariaLabel += titleId;\n    }\n\n    if (config && config.description) {\n      var descElement = createNS('desc');\n      var descId = createElementID();\n      descElement.setAttribute('id', descId);\n      descElement.textContent = config.description;\n      this.svgElement.appendChild(descElement);\n      ariaLabel += ' ' + descId;\n    }\n\n    if (ariaLabel) {\n      this.svgElement.setAttribute('aria-labelledby', ariaLabel);\n    }\n\n    var defs = createNS('defs');\n    this.svgElement.appendChild(defs);\n    var maskElement = createNS('g');\n    this.svgElement.appendChild(maskElement);\n    this.layerElement = maskElement;\n    this.renderConfig = {\n      preserveAspectRatio: config && config.preserveAspectRatio || 'xMidYMid meet',\n      imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',\n      contentVisibility: config && config.contentVisibility || 'visible',\n      progressiveLoad: config && config.progressiveLoad || false,\n      hideOnTransparent: !(config && config.hideOnTransparent === false),\n      viewBoxOnly: config && config.viewBoxOnly || false,\n      viewBoxSize: config && config.viewBoxSize || false,\n      className: config && config.className || '',\n      id: config && config.id || '',\n      focusable: config && config.focusable,\n      filterSize: {\n        width: config && config.filterSize && config.filterSize.width || '100%',\n        height: config && config.filterSize && config.filterSize.height || '100%',\n        x: config && config.filterSize && config.filterSize.x || '0%',\n        y: config && config.filterSize && config.filterSize.y || '0%'\n      },\n      width: config && config.width,\n      height: config && config.height,\n      runExpressions: !config || config.runExpressions === undefined || config.runExpressions\n    };\n    this.globalData = {\n      _mdf: false,\n      frameNum: -1,\n      defs: defs,\n      renderConfig: this.renderConfig\n    };\n    this.elements = [];\n    this.pendingElements = [];\n    this.destroyed = false;\n    this.rendererType = 'svg';\n  }\n\n  extendPrototype([SVGRendererBase], SVGRenderer);\n\n  SVGRenderer.prototype.createComp = function (data) {\n    return new SVGCompElement(data, this.globalData, this);\n  };\n\n  function ShapeTransformManager() {\n    this.sequences = {};\n    this.sequenceList = [];\n    this.transform_key_count = 0;\n  }\n\n  ShapeTransformManager.prototype = {\n    addTransformSequence: function addTransformSequence(transforms) {\n      var i;\n      var len = transforms.length;\n      var key = '_';\n\n      for (i = 0; i < len; i += 1) {\n        key += transforms[i].transform.key + '_';\n      }\n\n      var sequence = this.sequences[key];\n\n      if (!sequence) {\n        sequence = {\n          transforms: [].concat(transforms),\n          finalTransform: new Matrix(),\n          _mdf: false\n        };\n        this.sequences[key] = sequence;\n        this.sequenceList.push(sequence);\n      }\n\n      return sequence;\n    },\n    processSequence: function processSequence(sequence, isFirstFrame) {\n      var i = 0;\n      var len = sequence.transforms.length;\n      var _mdf = isFirstFrame;\n\n      while (i < len && !isFirstFrame) {\n        if (sequence.transforms[i].transform.mProps._mdf) {\n          _mdf = true;\n          break;\n        }\n\n        i += 1;\n      }\n\n      if (_mdf) {\n        sequence.finalTransform.reset();\n\n        for (i = len - 1; i >= 0; i -= 1) {\n          sequence.finalTransform.multiply(sequence.transforms[i].transform.mProps.v);\n        }\n      }\n\n      sequence._mdf = _mdf;\n    },\n    processSequences: function processSequences(isFirstFrame) {\n      var i;\n      var len = this.sequenceList.length;\n\n      for (i = 0; i < len; i += 1) {\n        this.processSequence(this.sequenceList[i], isFirstFrame);\n      }\n    },\n    getNewKey: function getNewKey() {\n      this.transform_key_count += 1;\n      return '_' + this.transform_key_count;\n    }\n  };\n\n  var lumaLoader = function lumaLoader() {\n    var id = '__lottie_element_luma_buffer';\n    var lumaBuffer = null;\n    var lumaBufferCtx = null;\n    var svg = null; // This alternate solution has a slight delay before the filter is applied, resulting in a flicker on the first frame.\n    // Keeping this here for reference, and in the future, if offscreen canvas supports url filters, this can be used.\n    // For now, neither of them work for offscreen canvas, so canvas workers can't support the luma track matte mask.\n    // Naming it solution 2 to mark the extra comment lines.\n\n    /*\r\n    var svgString = [\r\n      '<svg xmlns=\"http://www.w3.org/2000/svg\">',\r\n      '<filter id=\"' + id + '\">',\r\n      '<feColorMatrix type=\"matrix\" color-interpolation-filters=\"sRGB\" values=\"',\r\n      '0.3, 0.3, 0.3, 0, 0, ',\r\n      '0.3, 0.3, 0.3, 0, 0, ',\r\n      '0.3, 0.3, 0.3, 0, 0, ',\r\n      '0.3, 0.3, 0.3, 0, 0',\r\n      '\"/>',\r\n      '</filter>',\r\n      '</svg>',\r\n    ].join('');\r\n    var blob = new Blob([svgString], { type: 'image/svg+xml' });\r\n    var url = URL.createObjectURL(blob);\r\n    */\n\n    function createLumaSvgFilter() {\n      var _svg = createNS('svg');\n\n      var fil = createNS('filter');\n      var matrix = createNS('feColorMatrix');\n      fil.setAttribute('id', id);\n      matrix.setAttribute('type', 'matrix');\n      matrix.setAttribute('color-interpolation-filters', 'sRGB');\n      matrix.setAttribute('values', '0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0');\n      fil.appendChild(matrix);\n\n      _svg.appendChild(fil);\n\n      _svg.setAttribute('id', id + '_svg');\n\n      if (featureSupport.svgLumaHidden) {\n        _svg.style.display = 'none';\n      }\n\n      return _svg;\n    }\n\n    function loadLuma() {\n      if (!lumaBuffer) {\n        svg = createLumaSvgFilter();\n        document.body.appendChild(svg);\n        lumaBuffer = createTag('canvas');\n        lumaBufferCtx = lumaBuffer.getContext('2d'); // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2\n\n        lumaBufferCtx.filter = 'url(#' + id + ')';\n        lumaBufferCtx.fillStyle = 'rgba(0,0,0,0)';\n        lumaBufferCtx.fillRect(0, 0, 1, 1);\n      }\n    }\n\n    function getLuma(canvas) {\n      if (!lumaBuffer) {\n        loadLuma();\n      }\n\n      lumaBuffer.width = canvas.width;\n      lumaBuffer.height = canvas.height; // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2\n\n      lumaBufferCtx.filter = 'url(#' + id + ')';\n      return lumaBuffer;\n    }\n\n    return {\n      load: loadLuma,\n      get: getLuma\n    };\n  };\n\n  function createCanvas(width, height) {\n    if (featureSupport.offscreenCanvas) {\n      return new OffscreenCanvas(width, height);\n    }\n\n    var canvas = createTag('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  }\n\n  var assetLoader = function () {\n    return {\n      loadLumaCanvas: lumaLoader.load,\n      getLumaCanvas: lumaLoader.get,\n      createCanvas: createCanvas\n    };\n  }();\n\n  var registeredEffects = {};\n\n  function CVEffects(elem) {\n    var i;\n    var len = elem.data.ef ? elem.data.ef.length : 0;\n    this.filters = [];\n    var filterManager;\n\n    for (i = 0; i < len; i += 1) {\n      filterManager = null;\n      var type = elem.data.ef[i].ty;\n\n      if (registeredEffects[type]) {\n        var Effect = registeredEffects[type].effect;\n        filterManager = new Effect(elem.effectsManager.effectElements[i], elem);\n      }\n\n      if (filterManager) {\n        this.filters.push(filterManager);\n      }\n    }\n\n    if (this.filters.length) {\n      elem.addRenderableComponent(this);\n    }\n  }\n\n  CVEffects.prototype.renderFrame = function (_isFirstFrame) {\n    var i;\n    var len = this.filters.length;\n\n    for (i = 0; i < len; i += 1) {\n      this.filters[i].renderFrame(_isFirstFrame);\n    }\n  };\n\n  CVEffects.prototype.getEffects = function (type) {\n    var i;\n    var len = this.filters.length;\n    var effects = [];\n\n    for (i = 0; i < len; i += 1) {\n      if (this.filters[i].type === type) {\n        effects.push(this.filters[i]);\n      }\n    }\n\n    return effects;\n  };\n\n  function registerEffect(id, effect) {\n    registeredEffects[id] = {\n      effect: effect\n    };\n  }\n\n  function CVMaskElement(data, element) {\n    this.data = data;\n    this.element = element;\n    this.masksProperties = this.data.masksProperties || [];\n    this.viewData = createSizedArray(this.masksProperties.length);\n    var i;\n    var len = this.masksProperties.length;\n    var hasMasks = false;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.masksProperties[i].mode !== 'n') {\n        hasMasks = true;\n      }\n\n      this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);\n    }\n\n    this.hasMasks = hasMasks;\n\n    if (hasMasks) {\n      this.element.addRenderableComponent(this);\n    }\n  }\n\n  CVMaskElement.prototype.renderFrame = function () {\n    if (!this.hasMasks) {\n      return;\n    }\n\n    var transform = this.element.finalTransform.mat;\n    var ctx = this.element.canvasContext;\n    var i;\n    var len = this.masksProperties.length;\n    var pt;\n    var pts;\n    var data;\n    ctx.beginPath();\n\n    for (i = 0; i < len; i += 1) {\n      if (this.masksProperties[i].mode !== 'n') {\n        if (this.masksProperties[i].inv) {\n          ctx.moveTo(0, 0);\n          ctx.lineTo(this.element.globalData.compSize.w, 0);\n          ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);\n          ctx.lineTo(0, this.element.globalData.compSize.h);\n          ctx.lineTo(0, 0);\n        }\n\n        data = this.viewData[i].v;\n        pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0);\n        ctx.moveTo(pt[0], pt[1]);\n        var j;\n        var jLen = data._length;\n\n        for (j = 1; j < jLen; j += 1) {\n          pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);\n          ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);\n        }\n\n        pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);\n        ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);\n      }\n    }\n\n    this.element.globalData.renderer.save(true);\n    ctx.clip();\n  };\n\n  CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;\n\n  CVMaskElement.prototype.destroy = function () {\n    this.element = null;\n  };\n\n  function CVBaseElement() {}\n\n  var operationsMap = {\n    1: 'source-in',\n    2: 'source-out',\n    3: 'source-in',\n    4: 'source-out'\n  };\n  CVBaseElement.prototype = {\n    createElements: function createElements() {},\n    initRendererElement: function initRendererElement() {},\n    createContainerElements: function createContainerElements() {\n      // If the layer is masked we will use two buffers to store each different states of the drawing\n      // This solution is not ideal for several reason. But unfortunately, because of the recursive\n      // nature of the render tree, it's the only simple way to make sure one inner mask doesn't override an outer mask.\n      // TODO: try to reduce the size of these buffers to the size of the composition contaning the layer\n      // It might be challenging because the layer most likely is transformed in some way\n      if (this.data.tt >= 1) {\n        this.buffers = [];\n        var canvasContext = this.globalData.canvasContext;\n        var bufferCanvas = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);\n        this.buffers.push(bufferCanvas);\n        var bufferCanvas2 = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);\n        this.buffers.push(bufferCanvas2);\n\n        if (this.data.tt >= 3 && !document._isProxy) {\n          assetLoader.loadLumaCanvas();\n        }\n      }\n\n      this.canvasContext = this.globalData.canvasContext;\n      this.transformCanvas = this.globalData.transformCanvas;\n      this.renderableEffectsManager = new CVEffects(this);\n      this.searchEffectTransforms();\n    },\n    createContent: function createContent() {},\n    setBlendMode: function setBlendMode() {\n      var globalData = this.globalData;\n\n      if (globalData.blendMode !== this.data.bm) {\n        globalData.blendMode = this.data.bm;\n        var blendModeValue = getBlendMode(this.data.bm);\n        globalData.canvasContext.globalCompositeOperation = blendModeValue;\n      }\n    },\n    createRenderableComponents: function createRenderableComponents() {\n      this.maskManager = new CVMaskElement(this.data, this);\n      this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);\n    },\n    hideElement: function hideElement() {\n      if (!this.hidden && (!this.isInRange || this.isTransparent)) {\n        this.hidden = true;\n      }\n    },\n    showElement: function showElement() {\n      if (this.isInRange && !this.isTransparent) {\n        this.hidden = false;\n        this._isFirstFrame = true;\n        this.maskManager._isFirstFrame = true;\n      }\n    },\n    clearCanvas: function clearCanvas(canvasContext) {\n      canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);\n    },\n    prepareLayer: function prepareLayer() {\n      if (this.data.tt >= 1) {\n        var buffer = this.buffers[0];\n        var bufferCtx = buffer.getContext('2d');\n        this.clearCanvas(bufferCtx); // on the first buffer we store the current state of the global drawing\n\n        bufferCtx.drawImage(this.canvasContext.canvas, 0, 0); // The next four lines are to clear the canvas\n        // TODO: Check if there is a way to clear the canvas without resetting the transform\n\n        this.currentTransform = this.canvasContext.getTransform();\n        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);\n        this.clearCanvas(this.canvasContext);\n        this.canvasContext.setTransform(this.currentTransform);\n      }\n    },\n    exitLayer: function exitLayer() {\n      if (this.data.tt >= 1) {\n        var buffer = this.buffers[1]; // On the second buffer we store the current state of the global drawing\n        // that only contains the content of this layer\n        // (if it is a composition, it also includes the nested layers)\n\n        var bufferCtx = buffer.getContext('2d');\n        this.clearCanvas(bufferCtx);\n        bufferCtx.drawImage(this.canvasContext.canvas, 0, 0); // We clear the canvas again\n\n        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);\n        this.clearCanvas(this.canvasContext);\n        this.canvasContext.setTransform(this.currentTransform); // We draw the mask\n\n        var mask = this.comp.getElementById('tp' in this.data ? this.data.tp : this.data.ind - 1);\n        mask.renderFrame(true); // We draw the second buffer (that contains the content of this layer)\n\n        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0); // If the mask is a Luma matte, we need to do two extra painting operations\n        // the _isProxy check is to avoid drawing a fake canvas in workers that will throw an error\n\n        if (this.data.tt >= 3 && !document._isProxy) {\n          // We copy the painted mask to a buffer that has a color matrix filter applied to it\n          // that applies the rgb values to the alpha channel\n          var lumaBuffer = assetLoader.getLumaCanvas(this.canvasContext.canvas);\n          var lumaBufferCtx = lumaBuffer.getContext('2d');\n          lumaBufferCtx.drawImage(this.canvasContext.canvas, 0, 0);\n          this.clearCanvas(this.canvasContext); // we repaint the context with the mask applied to it\n\n          this.canvasContext.drawImage(lumaBuffer, 0, 0);\n        }\n\n        this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt];\n        this.canvasContext.drawImage(buffer, 0, 0); // We finally draw the first buffer (that contains the content of the global drawing)\n        // We use destination-over to draw the global drawing below the current layer\n\n        this.canvasContext.globalCompositeOperation = 'destination-over';\n        this.canvasContext.drawImage(this.buffers[0], 0, 0);\n        this.canvasContext.setTransform(this.currentTransform); // We reset the globalCompositeOperation to source-over, the standard type of operation\n\n        this.canvasContext.globalCompositeOperation = 'source-over';\n      }\n    },\n    renderFrame: function renderFrame(forceRender) {\n      if (this.hidden || this.data.hd) {\n        return;\n      }\n\n      if (this.data.td === 1 && !forceRender) {\n        return;\n      }\n\n      this.renderTransform();\n      this.renderRenderable();\n      this.renderLocalTransform();\n      this.setBlendMode();\n      var forceRealStack = this.data.ty === 0;\n      this.prepareLayer();\n      this.globalData.renderer.save(forceRealStack);\n      this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props);\n      this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity);\n      this.renderInnerContent();\n      this.globalData.renderer.restore(forceRealStack);\n      this.exitLayer();\n\n      if (this.maskManager.hasMasks) {\n        this.globalData.renderer.restore(true);\n      }\n\n      if (this._isFirstFrame) {\n        this._isFirstFrame = false;\n      }\n    },\n    destroy: function destroy() {\n      this.canvasContext = null;\n      this.data = null;\n      this.globalData = null;\n      this.maskManager.destroy();\n    },\n    mHelper: new Matrix()\n  };\n  CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;\n  CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;\n\n  function CVShapeData(element, data, styles, transformsManager) {\n    this.styledShapes = [];\n    this.tr = [0, 0, 0, 0, 0, 0];\n    var ty = 4;\n\n    if (data.ty === 'rc') {\n      ty = 5;\n    } else if (data.ty === 'el') {\n      ty = 6;\n    } else if (data.ty === 'sr') {\n      ty = 7;\n    }\n\n    this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element);\n    var i;\n    var len = styles.length;\n    var styledShape;\n\n    for (i = 0; i < len; i += 1) {\n      if (!styles[i].closed) {\n        styledShape = {\n          transforms: transformsManager.addTransformSequence(styles[i].transforms),\n          trNodes: []\n        };\n        this.styledShapes.push(styledShape);\n        styles[i].elements.push(styledShape);\n      }\n    }\n  }\n\n  CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;\n\n  function CVShapeElement(data, globalData, comp) {\n    this.shapes = [];\n    this.shapesData = data.shapes;\n    this.stylesList = [];\n    this.itemsData = [];\n    this.prevViewData = [];\n    this.shapeModifiers = [];\n    this.processedElements = [];\n    this.transformsManager = new ShapeTransformManager();\n    this.initElement(data, globalData, comp);\n  }\n\n  extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement);\n  CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;\n  CVShapeElement.prototype.transformHelper = {\n    opacity: 1,\n    _opMdf: false\n  };\n  CVShapeElement.prototype.dashResetter = [];\n\n  CVShapeElement.prototype.createContent = function () {\n    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);\n  };\n\n  CVShapeElement.prototype.createStyleElement = function (data, transforms) {\n    var styleElem = {\n      data: data,\n      type: data.ty,\n      preTransforms: this.transformsManager.addTransformSequence(transforms),\n      transforms: [],\n      elements: [],\n      closed: data.hd === true\n    };\n    var elementData = {};\n\n    if (data.ty === 'fl' || data.ty === 'st') {\n      elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this);\n\n      if (!elementData.c.k) {\n        styleElem.co = 'rgb(' + bmFloor(elementData.c.v[0]) + ',' + bmFloor(elementData.c.v[1]) + ',' + bmFloor(elementData.c.v[2]) + ')';\n      }\n    } else if (data.ty === 'gf' || data.ty === 'gs') {\n      elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this);\n      elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this);\n      elementData.h = PropertyFactory.getProp(this, data.h || {\n        k: 0\n      }, 0, 0.01, this);\n      elementData.a = PropertyFactory.getProp(this, data.a || {\n        k: 0\n      }, 0, degToRads, this);\n      elementData.g = new GradientProperty(this, data.g, this);\n    }\n\n    elementData.o = PropertyFactory.getProp(this, data.o, 0, 0.01, this);\n\n    if (data.ty === 'st' || data.ty === 'gs') {\n      styleElem.lc = lineCapEnum[data.lc || 2];\n      styleElem.lj = lineJoinEnum[data.lj || 2];\n\n      if (data.lj == 1) {\n        // eslint-disable-line eqeqeq\n        styleElem.ml = data.ml;\n      }\n\n      elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this);\n\n      if (!elementData.w.k) {\n        styleElem.wi = elementData.w.v;\n      }\n\n      if (data.d) {\n        var d = new DashProperty(this, data.d, 'canvas', this);\n        elementData.d = d;\n\n        if (!elementData.d.k) {\n          styleElem.da = elementData.d.dashArray;\n          styleElem[\"do\"] = elementData.d.dashoffset[0];\n        }\n      }\n    } else {\n      styleElem.r = data.r === 2 ? 'evenodd' : 'nonzero';\n    }\n\n    this.stylesList.push(styleElem);\n    elementData.style = styleElem;\n    return elementData;\n  };\n\n  CVShapeElement.prototype.createGroupElement = function () {\n    var elementData = {\n      it: [],\n      prevViewData: []\n    };\n    return elementData;\n  };\n\n  CVShapeElement.prototype.createTransformElement = function (data) {\n    var elementData = {\n      transform: {\n        opacity: 1,\n        _opMdf: false,\n        key: this.transformsManager.getNewKey(),\n        op: PropertyFactory.getProp(this, data.o, 0, 0.01, this),\n        mProps: TransformPropertyFactory.getTransformProperty(this, data, this)\n      }\n    };\n    return elementData;\n  };\n\n  CVShapeElement.prototype.createShapeElement = function (data) {\n    var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);\n    this.shapes.push(elementData);\n    this.addShapeToModifiers(elementData);\n    return elementData;\n  };\n\n  CVShapeElement.prototype.reloadShapes = function () {\n    this._isFirstFrame = true;\n    var i;\n    var len = this.itemsData.length;\n\n    for (i = 0; i < len; i += 1) {\n      this.prevViewData[i] = this.itemsData[i];\n    }\n\n    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);\n    len = this.dynamicProperties.length;\n\n    for (i = 0; i < len; i += 1) {\n      this.dynamicProperties[i].getValue();\n    }\n\n    this.renderModifiers();\n    this.transformsManager.processSequences(this._isFirstFrame);\n  };\n\n  CVShapeElement.prototype.addTransformToStyleList = function (transform) {\n    var i;\n    var len = this.stylesList.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (!this.stylesList[i].closed) {\n        this.stylesList[i].transforms.push(transform);\n      }\n    }\n  };\n\n  CVShapeElement.prototype.removeTransformFromStyleList = function () {\n    var i;\n    var len = this.stylesList.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (!this.stylesList[i].closed) {\n        this.stylesList[i].transforms.pop();\n      }\n    }\n  };\n\n  CVShapeElement.prototype.closeStyles = function (styles) {\n    var i;\n    var len = styles.length;\n\n    for (i = 0; i < len; i += 1) {\n      styles[i].closed = true;\n    }\n  };\n\n  CVShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, shouldRender, transforms) {\n    var i;\n    var len = arr.length - 1;\n    var j;\n    var jLen;\n    var ownStyles = [];\n    var ownModifiers = [];\n    var processedPos;\n    var modifier;\n    var currentTransform;\n    var ownTransforms = [].concat(transforms);\n\n    for (i = len; i >= 0; i -= 1) {\n      processedPos = this.searchProcessedElement(arr[i]);\n\n      if (!processedPos) {\n        arr[i]._shouldRender = shouldRender;\n      } else {\n        itemsData[i] = prevViewData[processedPos - 1];\n      }\n\n      if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs') {\n        if (!processedPos) {\n          itemsData[i] = this.createStyleElement(arr[i], ownTransforms);\n        } else {\n          itemsData[i].style.closed = false;\n        }\n\n        ownStyles.push(itemsData[i].style);\n      } else if (arr[i].ty === 'gr') {\n        if (!processedPos) {\n          itemsData[i] = this.createGroupElement(arr[i]);\n        } else {\n          jLen = itemsData[i].it.length;\n\n          for (j = 0; j < jLen; j += 1) {\n            itemsData[i].prevViewData[j] = itemsData[i].it[j];\n          }\n        }\n\n        this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms);\n      } else if (arr[i].ty === 'tr') {\n        if (!processedPos) {\n          currentTransform = this.createTransformElement(arr[i]);\n          itemsData[i] = currentTransform;\n        }\n\n        ownTransforms.push(itemsData[i]);\n        this.addTransformToStyleList(itemsData[i]);\n      } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {\n        if (!processedPos) {\n          itemsData[i] = this.createShapeElement(arr[i]);\n        }\n      } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'pb' || arr[i].ty === 'zz' || arr[i].ty === 'op') {\n        if (!processedPos) {\n          modifier = ShapeModifiers.getModifier(arr[i].ty);\n          modifier.init(this, arr[i]);\n          itemsData[i] = modifier;\n          this.shapeModifiers.push(modifier);\n        } else {\n          modifier = itemsData[i];\n          modifier.closed = false;\n        }\n\n        ownModifiers.push(modifier);\n      } else if (arr[i].ty === 'rp') {\n        if (!processedPos) {\n          modifier = ShapeModifiers.getModifier(arr[i].ty);\n          itemsData[i] = modifier;\n          modifier.init(this, arr, i, itemsData);\n          this.shapeModifiers.push(modifier);\n          shouldRender = false;\n        } else {\n          modifier = itemsData[i];\n          modifier.closed = true;\n        }\n\n        ownModifiers.push(modifier);\n      }\n\n      this.addProcessedElement(arr[i], i + 1);\n    }\n\n    this.removeTransformFromStyleList();\n    this.closeStyles(ownStyles);\n    len = ownModifiers.length;\n\n    for (i = 0; i < len; i += 1) {\n      ownModifiers[i].closed = true;\n    }\n  };\n\n  CVShapeElement.prototype.renderInnerContent = function () {\n    this.transformHelper.opacity = 1;\n    this.transformHelper._opMdf = false;\n    this.renderModifiers();\n    this.transformsManager.processSequences(this._isFirstFrame);\n    this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);\n  };\n\n  CVShapeElement.prototype.renderShapeTransform = function (parentTransform, groupTransform) {\n    if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {\n      groupTransform.opacity = parentTransform.opacity;\n      groupTransform.opacity *= groupTransform.op.v;\n      groupTransform._opMdf = true;\n    }\n  };\n\n  CVShapeElement.prototype.drawLayer = function () {\n    var i;\n    var len = this.stylesList.length;\n    var j;\n    var jLen;\n    var k;\n    var kLen;\n    var elems;\n    var nodes;\n    var renderer = this.globalData.renderer;\n    var ctx = this.globalData.canvasContext;\n    var type;\n    var currentStyle;\n\n    for (i = 0; i < len; i += 1) {\n      currentStyle = this.stylesList[i];\n      type = currentStyle.type; // Skipping style when\n      // Stroke width equals 0\n      // style should not be rendered (extra unused repeaters)\n      // current opacity equals 0\n      // global opacity equals 0\n\n      if (!((type === 'st' || type === 'gs') && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {\n        renderer.save();\n        elems = currentStyle.elements;\n\n        if (type === 'st' || type === 'gs') {\n          renderer.ctxStrokeStyle(type === 'st' ? currentStyle.co : currentStyle.grd); // ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;\n\n          renderer.ctxLineWidth(currentStyle.wi); // ctx.lineWidth = currentStyle.wi;\n\n          renderer.ctxLineCap(currentStyle.lc); // ctx.lineCap = currentStyle.lc;\n\n          renderer.ctxLineJoin(currentStyle.lj); // ctx.lineJoin = currentStyle.lj;\n\n          renderer.ctxMiterLimit(currentStyle.ml || 0); // ctx.miterLimit = currentStyle.ml || 0;\n        } else {\n          renderer.ctxFillStyle(type === 'fl' ? currentStyle.co : currentStyle.grd); // ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;\n        }\n\n        renderer.ctxOpacity(currentStyle.coOp);\n\n        if (type !== 'st' && type !== 'gs') {\n          ctx.beginPath();\n        }\n\n        renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);\n        jLen = elems.length;\n\n        for (j = 0; j < jLen; j += 1) {\n          if (type === 'st' || type === 'gs') {\n            ctx.beginPath();\n\n            if (currentStyle.da) {\n              ctx.setLineDash(currentStyle.da);\n              ctx.lineDashOffset = currentStyle[\"do\"];\n            }\n          }\n\n          nodes = elems[j].trNodes;\n          kLen = nodes.length;\n\n          for (k = 0; k < kLen; k += 1) {\n            if (nodes[k].t === 'm') {\n              ctx.moveTo(nodes[k].p[0], nodes[k].p[1]);\n            } else if (nodes[k].t === 'c') {\n              ctx.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]);\n            } else {\n              ctx.closePath();\n            }\n          }\n\n          if (type === 'st' || type === 'gs') {\n            // ctx.stroke();\n            renderer.ctxStroke();\n\n            if (currentStyle.da) {\n              ctx.setLineDash(this.dashResetter);\n            }\n          }\n        }\n\n        if (type !== 'st' && type !== 'gs') {\n          // ctx.fill(currentStyle.r);\n          this.globalData.renderer.ctxFill(currentStyle.r);\n        }\n\n        renderer.restore();\n      }\n    }\n  };\n\n  CVShapeElement.prototype.renderShape = function (parentTransform, items, data, isMain) {\n    var i;\n    var len = items.length - 1;\n    var groupTransform;\n    groupTransform = parentTransform;\n\n    for (i = len; i >= 0; i -= 1) {\n      if (items[i].ty === 'tr') {\n        groupTransform = data[i].transform;\n        this.renderShapeTransform(parentTransform, groupTransform);\n      } else if (items[i].ty === 'sh' || items[i].ty === 'el' || items[i].ty === 'rc' || items[i].ty === 'sr') {\n        this.renderPath(items[i], data[i]);\n      } else if (items[i].ty === 'fl') {\n        this.renderFill(items[i], data[i], groupTransform);\n      } else if (items[i].ty === 'st') {\n        this.renderStroke(items[i], data[i], groupTransform);\n      } else if (items[i].ty === 'gf' || items[i].ty === 'gs') {\n        this.renderGradientFill(items[i], data[i], groupTransform);\n      } else if (items[i].ty === 'gr') {\n        this.renderShape(groupTransform, items[i].it, data[i].it);\n      } else if (items[i].ty === 'tm') {//\n      }\n    }\n\n    if (isMain) {\n      this.drawLayer();\n    }\n  };\n\n  CVShapeElement.prototype.renderStyledShape = function (styledShape, shape) {\n    if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {\n      var shapeNodes = styledShape.trNodes;\n      var paths = shape.paths;\n      var i;\n      var len;\n      var j;\n      var jLen = paths._length;\n      shapeNodes.length = 0;\n      var groupTransformMat = styledShape.transforms.finalTransform;\n\n      for (j = 0; j < jLen; j += 1) {\n        var pathNodes = paths.shapes[j];\n\n        if (pathNodes && pathNodes.v) {\n          len = pathNodes._length;\n\n          for (i = 1; i < len; i += 1) {\n            if (i === 1) {\n              shapeNodes.push({\n                t: 'm',\n                p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)\n              });\n            }\n\n            shapeNodes.push({\n              t: 'c',\n              pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i])\n            });\n          }\n\n          if (len === 1) {\n            shapeNodes.push({\n              t: 'm',\n              p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)\n            });\n          }\n\n          if (pathNodes.c && len) {\n            shapeNodes.push({\n              t: 'c',\n              pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0])\n            });\n            shapeNodes.push({\n              t: 'z'\n            });\n          }\n        }\n      }\n\n      styledShape.trNodes = shapeNodes;\n    }\n  };\n\n  CVShapeElement.prototype.renderPath = function (pathData, itemData) {\n    if (pathData.hd !== true && pathData._shouldRender) {\n      var i;\n      var len = itemData.styledShapes.length;\n\n      for (i = 0; i < len; i += 1) {\n        this.renderStyledShape(itemData.styledShapes[i], itemData.sh);\n      }\n    }\n  };\n\n  CVShapeElement.prototype.renderFill = function (styleData, itemData, groupTransform) {\n    var styleElem = itemData.style;\n\n    if (itemData.c._mdf || this._isFirstFrame) {\n      styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';\n    }\n\n    if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {\n      styleElem.coOp = itemData.o.v * groupTransform.opacity;\n    }\n  };\n\n  CVShapeElement.prototype.renderGradientFill = function (styleData, itemData, groupTransform) {\n    var styleElem = itemData.style;\n    var grd;\n\n    if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {\n      var ctx = this.globalData.canvasContext;\n      var pt1 = itemData.s.v;\n      var pt2 = itemData.e.v;\n\n      if (styleData.t === 1) {\n        grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);\n      } else {\n        var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));\n        var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);\n        var percent = itemData.h.v;\n\n        if (percent >= 1) {\n          percent = 0.99;\n        } else if (percent <= -1) {\n          percent = -0.99;\n        }\n\n        var dist = rad * percent;\n        var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];\n        var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];\n        grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);\n      }\n\n      var i;\n      var len = styleData.g.p;\n      var cValues = itemData.g.c;\n      var opacity = 1;\n\n      for (i = 0; i < len; i += 1) {\n        if (itemData.g._hasOpacity && itemData.g._collapsable) {\n          opacity = itemData.g.o[i * 2 + 1];\n        }\n\n        grd.addColorStop(cValues[i * 4] / 100, 'rgba(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ',' + opacity + ')');\n      }\n\n      styleElem.grd = grd;\n    }\n\n    styleElem.coOp = itemData.o.v * groupTransform.opacity;\n  };\n\n  CVShapeElement.prototype.renderStroke = function (styleData, itemData, groupTransform) {\n    var styleElem = itemData.style;\n    var d = itemData.d;\n\n    if (d && (d._mdf || this._isFirstFrame)) {\n      styleElem.da = d.dashArray;\n      styleElem[\"do\"] = d.dashoffset[0];\n    }\n\n    if (itemData.c._mdf || this._isFirstFrame) {\n      styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';\n    }\n\n    if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {\n      styleElem.coOp = itemData.o.v * groupTransform.opacity;\n    }\n\n    if (itemData.w._mdf || this._isFirstFrame) {\n      styleElem.wi = itemData.w.v;\n    }\n  };\n\n  CVShapeElement.prototype.destroy = function () {\n    this.shapesData = null;\n    this.globalData = null;\n    this.canvasContext = null;\n    this.stylesList.length = 0;\n    this.itemsData.length = 0;\n  };\n\n  function CVTextElement(data, globalData, comp) {\n    this.textSpans = [];\n    this.yOffset = 0;\n    this.fillColorAnim = false;\n    this.strokeColorAnim = false;\n    this.strokeWidthAnim = false;\n    this.stroke = false;\n    this.fill = false;\n    this.justifyOffset = 0;\n    this.currentRender = null;\n    this.renderType = 'canvas';\n    this.values = {\n      fill: 'rgba(0,0,0,0)',\n      stroke: 'rgba(0,0,0,0)',\n      sWidth: 0,\n      fValue: ''\n    };\n    this.initElement(data, globalData, comp);\n  }\n\n  extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement);\n  CVTextElement.prototype.tHelper = createTag('canvas').getContext('2d');\n\n  CVTextElement.prototype.buildNewText = function () {\n    var documentData = this.textProperty.currentData;\n    this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);\n    var hasFill = false;\n\n    if (documentData.fc) {\n      hasFill = true;\n      this.values.fill = this.buildColor(documentData.fc);\n    } else {\n      this.values.fill = 'rgba(0,0,0,0)';\n    }\n\n    this.fill = hasFill;\n    var hasStroke = false;\n\n    if (documentData.sc) {\n      hasStroke = true;\n      this.values.stroke = this.buildColor(documentData.sc);\n      this.values.sWidth = documentData.sw;\n    }\n\n    var fontData = this.globalData.fontManager.getFontByName(documentData.f);\n    var i;\n    var len;\n    var letters = documentData.l;\n    var matrixHelper = this.mHelper;\n    this.stroke = hasStroke;\n    this.values.fValue = documentData.finalSize + 'px ' + this.globalData.fontManager.getFontByName(documentData.f).fFamily;\n    len = documentData.finalText.length; // this.tHelper.font = this.values.fValue;\n\n    var charData;\n    var shapeData;\n    var k;\n    var kLen;\n    var shapes;\n    var j;\n    var jLen;\n    var pathNodes;\n    var commands;\n    var pathArr;\n    var singleShape = this.data.singleShape;\n    var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;\n    var xPos = 0;\n    var yPos = 0;\n    var firstLine = true;\n    var cnt = 0;\n\n    for (i = 0; i < len; i += 1) {\n      charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);\n      shapeData = charData && charData.data || {};\n      matrixHelper.reset();\n\n      if (singleShape && letters[i].n) {\n        xPos = -trackingOffset;\n        yPos += documentData.yOffset;\n        yPos += firstLine ? 1 : 0;\n        firstLine = false;\n      }\n\n      shapes = shapeData.shapes ? shapeData.shapes[0].it : [];\n      jLen = shapes.length;\n      matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);\n\n      if (singleShape) {\n        this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);\n      }\n\n      commands = createSizedArray(jLen - 1);\n      var commandsCounter = 0;\n\n      for (j = 0; j < jLen; j += 1) {\n        if (shapes[j].ty === 'sh') {\n          kLen = shapes[j].ks.k.i.length;\n          pathNodes = shapes[j].ks.k;\n          pathArr = [];\n\n          for (k = 1; k < kLen; k += 1) {\n            if (k === 1) {\n              pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));\n            }\n\n            pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));\n          }\n\n          pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));\n          commands[commandsCounter] = pathArr;\n          commandsCounter += 1;\n        }\n      }\n\n      if (singleShape) {\n        xPos += letters[i].l;\n        xPos += trackingOffset;\n      }\n\n      if (this.textSpans[cnt]) {\n        this.textSpans[cnt].elem = commands;\n      } else {\n        this.textSpans[cnt] = {\n          elem: commands\n        };\n      }\n\n      cnt += 1;\n    }\n  };\n\n  CVTextElement.prototype.renderInnerContent = function () {\n    this.validateText();\n    var ctx = this.canvasContext;\n    ctx.font = this.values.fValue;\n    this.globalData.renderer.ctxLineCap('butt'); // ctx.lineCap = 'butt';\n\n    this.globalData.renderer.ctxLineJoin('miter'); // ctx.lineJoin = 'miter';\n\n    this.globalData.renderer.ctxMiterLimit(4); // ctx.miterLimit = 4;\n\n    if (!this.data.singleShape) {\n      this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);\n    }\n\n    var i;\n    var len;\n    var j;\n    var jLen;\n    var k;\n    var kLen;\n    var renderedLetters = this.textAnimator.renderedLetters;\n    var letters = this.textProperty.currentData.l;\n    len = letters.length;\n    var renderedLetter;\n    var lastFill = null;\n    var lastStroke = null;\n    var lastStrokeW = null;\n    var commands;\n    var pathArr;\n    var renderer = this.globalData.renderer;\n\n    for (i = 0; i < len; i += 1) {\n      if (!letters[i].n) {\n        renderedLetter = renderedLetters[i];\n\n        if (renderedLetter) {\n          renderer.save();\n          renderer.ctxTransform(renderedLetter.p);\n          renderer.ctxOpacity(renderedLetter.o);\n        }\n\n        if (this.fill) {\n          if (renderedLetter && renderedLetter.fc) {\n            if (lastFill !== renderedLetter.fc) {\n              renderer.ctxFillStyle(renderedLetter.fc);\n              lastFill = renderedLetter.fc; // ctx.fillStyle = renderedLetter.fc;\n            }\n          } else if (lastFill !== this.values.fill) {\n            lastFill = this.values.fill;\n            renderer.ctxFillStyle(this.values.fill); // ctx.fillStyle = this.values.fill;\n          }\n\n          commands = this.textSpans[i].elem;\n          jLen = commands.length;\n          this.globalData.canvasContext.beginPath();\n\n          for (j = 0; j < jLen; j += 1) {\n            pathArr = commands[j];\n            kLen = pathArr.length;\n            this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);\n\n            for (k = 2; k < kLen; k += 6) {\n              this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);\n            }\n          }\n\n          this.globalData.canvasContext.closePath();\n          renderer.ctxFill(); // this.globalData.canvasContext.fill();\n          /// ctx.fillText(this.textSpans[i].val,0,0);\n        }\n\n        if (this.stroke) {\n          if (renderedLetter && renderedLetter.sw) {\n            if (lastStrokeW !== renderedLetter.sw) {\n              lastStrokeW = renderedLetter.sw;\n              renderer.ctxLineWidth(renderedLetter.sw); // ctx.lineWidth = renderedLetter.sw;\n            }\n          } else if (lastStrokeW !== this.values.sWidth) {\n            lastStrokeW = this.values.sWidth;\n            renderer.ctxLineWidth(this.values.sWidth); // ctx.lineWidth = this.values.sWidth;\n          }\n\n          if (renderedLetter && renderedLetter.sc) {\n            if (lastStroke !== renderedLetter.sc) {\n              lastStroke = renderedLetter.sc;\n              renderer.ctxStrokeStyle(renderedLetter.sc); // ctx.strokeStyle = renderedLetter.sc;\n            }\n          } else if (lastStroke !== this.values.stroke) {\n            lastStroke = this.values.stroke;\n            renderer.ctxStrokeStyle(this.values.stroke); // ctx.strokeStyle = this.values.stroke;\n          }\n\n          commands = this.textSpans[i].elem;\n          jLen = commands.length;\n          this.globalData.canvasContext.beginPath();\n\n          for (j = 0; j < jLen; j += 1) {\n            pathArr = commands[j];\n            kLen = pathArr.length;\n            this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);\n\n            for (k = 2; k < kLen; k += 6) {\n              this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);\n            }\n          }\n\n          this.globalData.canvasContext.closePath();\n          renderer.ctxStroke(); // this.globalData.canvasContext.stroke();\n          /// ctx.strokeText(letters[i].val,0,0);\n        }\n\n        if (renderedLetter) {\n          this.globalData.renderer.restore();\n        }\n      }\n    }\n  };\n\n  function CVImageElement(data, globalData, comp) {\n    this.assetData = globalData.getAssetData(data.refId);\n    this.img = globalData.imageLoader.getAsset(this.assetData);\n    this.initElement(data, globalData, comp);\n  }\n\n  extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);\n  CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;\n  CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;\n\n  CVImageElement.prototype.createContent = function () {\n    if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {\n      var canvas = createTag('canvas');\n      canvas.width = this.assetData.w;\n      canvas.height = this.assetData.h;\n      var ctx = canvas.getContext('2d');\n      var imgW = this.img.width;\n      var imgH = this.img.height;\n      var imgRel = imgW / imgH;\n      var canvasRel = this.assetData.w / this.assetData.h;\n      var widthCrop;\n      var heightCrop;\n      var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;\n\n      if (imgRel > canvasRel && par === 'xMidYMid slice' || imgRel < canvasRel && par !== 'xMidYMid slice') {\n        heightCrop = imgH;\n        widthCrop = heightCrop * canvasRel;\n      } else {\n        widthCrop = imgW;\n        heightCrop = widthCrop / canvasRel;\n      }\n\n      ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);\n      this.img = canvas;\n    }\n  };\n\n  CVImageElement.prototype.renderInnerContent = function () {\n    this.canvasContext.drawImage(this.img, 0, 0);\n  };\n\n  CVImageElement.prototype.destroy = function () {\n    this.img = null;\n  };\n\n  function CVSolidElement(data, globalData, comp) {\n    this.initElement(data, globalData, comp);\n  }\n\n  extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);\n  CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;\n  CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;\n\n  CVSolidElement.prototype.renderInnerContent = function () {\n    // var ctx = this.canvasContext;\n    this.globalData.renderer.ctxFillStyle(this.data.sc); // ctx.fillStyle = this.data.sc;\n\n    this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh); // ctx.fillRect(0, 0, this.data.sw, this.data.sh);\n    //\n  };\n\n  function CanvasRendererBase() {}\n\n  extendPrototype([BaseRenderer], CanvasRendererBase);\n\n  CanvasRendererBase.prototype.createShape = function (data) {\n    return new CVShapeElement(data, this.globalData, this);\n  };\n\n  CanvasRendererBase.prototype.createText = function (data) {\n    return new CVTextElement(data, this.globalData, this);\n  };\n\n  CanvasRendererBase.prototype.createImage = function (data) {\n    return new CVImageElement(data, this.globalData, this);\n  };\n\n  CanvasRendererBase.prototype.createSolid = function (data) {\n    return new CVSolidElement(data, this.globalData, this);\n  };\n\n  CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;\n\n  CanvasRendererBase.prototype.ctxTransform = function (props) {\n    if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {\n      return;\n    }\n\n    this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);\n  };\n\n  CanvasRendererBase.prototype.ctxOpacity = function (op) {\n    this.canvasContext.globalAlpha *= op < 0 ? 0 : op;\n  };\n\n  CanvasRendererBase.prototype.ctxFillStyle = function (value) {\n    this.canvasContext.fillStyle = value;\n  };\n\n  CanvasRendererBase.prototype.ctxStrokeStyle = function (value) {\n    this.canvasContext.strokeStyle = value;\n  };\n\n  CanvasRendererBase.prototype.ctxLineWidth = function (value) {\n    this.canvasContext.lineWidth = value;\n  };\n\n  CanvasRendererBase.prototype.ctxLineCap = function (value) {\n    this.canvasContext.lineCap = value;\n  };\n\n  CanvasRendererBase.prototype.ctxLineJoin = function (value) {\n    this.canvasContext.lineJoin = value;\n  };\n\n  CanvasRendererBase.prototype.ctxMiterLimit = function (value) {\n    this.canvasContext.miterLimit = value;\n  };\n\n  CanvasRendererBase.prototype.ctxFill = function (rule) {\n    this.canvasContext.fill(rule);\n  };\n\n  CanvasRendererBase.prototype.ctxFillRect = function (x, y, w, h) {\n    this.canvasContext.fillRect(x, y, w, h);\n  };\n\n  CanvasRendererBase.prototype.ctxStroke = function () {\n    this.canvasContext.stroke();\n  };\n\n  CanvasRendererBase.prototype.reset = function () {\n    if (!this.renderConfig.clearCanvas) {\n      this.canvasContext.restore();\n      return;\n    }\n\n    this.contextData.reset();\n  };\n\n  CanvasRendererBase.prototype.save = function () {\n    this.canvasContext.save();\n  };\n\n  CanvasRendererBase.prototype.restore = function (actionFlag) {\n    if (!this.renderConfig.clearCanvas) {\n      this.canvasContext.restore();\n      return;\n    }\n\n    if (actionFlag) {\n      this.globalData.blendMode = 'source-over';\n    }\n\n    this.contextData.restore(actionFlag);\n  };\n\n  CanvasRendererBase.prototype.configAnimation = function (animData) {\n    if (this.animationItem.wrapper) {\n      this.animationItem.container = createTag('canvas');\n      var containerStyle = this.animationItem.container.style;\n      containerStyle.width = '100%';\n      containerStyle.height = '100%';\n      var origin = '0px 0px 0px';\n      containerStyle.transformOrigin = origin;\n      containerStyle.mozTransformOrigin = origin;\n      containerStyle.webkitTransformOrigin = origin;\n      containerStyle['-webkit-transform'] = origin;\n      containerStyle.contentVisibility = this.renderConfig.contentVisibility;\n      this.animationItem.wrapper.appendChild(this.animationItem.container);\n      this.canvasContext = this.animationItem.container.getContext('2d');\n\n      if (this.renderConfig.className) {\n        this.animationItem.container.setAttribute('class', this.renderConfig.className);\n      }\n\n      if (this.renderConfig.id) {\n        this.animationItem.container.setAttribute('id', this.renderConfig.id);\n      }\n    } else {\n      this.canvasContext = this.renderConfig.context;\n    }\n\n    this.contextData.setContext(this.canvasContext);\n    this.data = animData;\n    this.layers = animData.layers;\n    this.transformCanvas = {\n      w: animData.w,\n      h: animData.h,\n      sx: 0,\n      sy: 0,\n      tx: 0,\n      ty: 0\n    };\n    this.setupGlobalData(animData, document.body);\n    this.globalData.canvasContext = this.canvasContext;\n    this.globalData.renderer = this;\n    this.globalData.isDashed = false;\n    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;\n    this.globalData.transformCanvas = this.transformCanvas;\n    this.elements = createSizedArray(animData.layers.length);\n    this.updateContainerSize();\n  };\n\n  CanvasRendererBase.prototype.updateContainerSize = function (width, height) {\n    this.reset();\n    var elementWidth;\n    var elementHeight;\n\n    if (width) {\n      elementWidth = width;\n      elementHeight = height;\n      this.canvasContext.canvas.width = elementWidth;\n      this.canvasContext.canvas.height = elementHeight;\n    } else {\n      if (this.animationItem.wrapper && this.animationItem.container) {\n        elementWidth = this.animationItem.wrapper.offsetWidth;\n        elementHeight = this.animationItem.wrapper.offsetHeight;\n      } else {\n        elementWidth = this.canvasContext.canvas.width;\n        elementHeight = this.canvasContext.canvas.height;\n      }\n\n      this.canvasContext.canvas.width = elementWidth * this.renderConfig.dpr;\n      this.canvasContext.canvas.height = elementHeight * this.renderConfig.dpr;\n    }\n\n    var elementRel;\n    var animationRel;\n\n    if (this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 || this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1) {\n      var par = this.renderConfig.preserveAspectRatio.split(' ');\n      var fillType = par[1] || 'meet';\n      var pos = par[0] || 'xMidYMid';\n      var xPos = pos.substr(0, 4);\n      var yPos = pos.substr(4);\n      elementRel = elementWidth / elementHeight;\n      animationRel = this.transformCanvas.w / this.transformCanvas.h;\n\n      if (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice') {\n        this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);\n        this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);\n      } else {\n        this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);\n        this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);\n      }\n\n      if (xPos === 'xMid' && (animationRel < elementRel && fillType === 'meet' || animationRel > elementRel && fillType === 'slice')) {\n        this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr;\n      } else if (xPos === 'xMax' && (animationRel < elementRel && fillType === 'meet' || animationRel > elementRel && fillType === 'slice')) {\n        this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;\n      } else {\n        this.transformCanvas.tx = 0;\n      }\n\n      if (yPos === 'YMid' && (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice')) {\n        this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr;\n      } else if (yPos === 'YMax' && (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice')) {\n        this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr;\n      } else {\n        this.transformCanvas.ty = 0;\n      }\n    } else if (this.renderConfig.preserveAspectRatio === 'none') {\n      this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);\n      this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);\n      this.transformCanvas.tx = 0;\n      this.transformCanvas.ty = 0;\n    } else {\n      this.transformCanvas.sx = this.renderConfig.dpr;\n      this.transformCanvas.sy = this.renderConfig.dpr;\n      this.transformCanvas.tx = 0;\n      this.transformCanvas.ty = 0;\n    }\n\n    this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1];\n    /* var i, len = this.elements.length;\r\n      for(i=0;i<len;i+=1){\r\n          if(this.elements[i] && this.elements[i].data.ty === 0){\r\n              this.elements[i].resize(this.globalData.transformCanvas);\r\n          }\r\n      } */\n\n    this.ctxTransform(this.transformCanvas.props);\n    this.canvasContext.beginPath();\n    this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);\n    this.canvasContext.closePath();\n    this.canvasContext.clip();\n    this.renderFrame(this.renderedFrame, true);\n  };\n\n  CanvasRendererBase.prototype.destroy = function () {\n    if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {\n      this.animationItem.wrapper.innerText = '';\n    }\n\n    var i;\n    var len = this.layers ? this.layers.length : 0;\n\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (this.elements[i] && this.elements[i].destroy) {\n        this.elements[i].destroy();\n      }\n    }\n\n    this.elements.length = 0;\n    this.globalData.canvasContext = null;\n    this.animationItem.container = null;\n    this.destroyed = true;\n  };\n\n  CanvasRendererBase.prototype.renderFrame = function (num, forceRender) {\n    if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) {\n      return;\n    }\n\n    this.renderedFrame = num;\n    this.globalData.frameNum = num - this.animationItem._isFirstFrame;\n    this.globalData.frameId += 1;\n    this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;\n    this.globalData.projectInterface.currentFrame = num; // console.log('--------');\n    // console.log('NEW: ',num);\n\n    var i;\n    var len = this.layers.length;\n\n    if (!this.completeLayers) {\n      this.checkLayers(num);\n    }\n\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (this.completeLayers || this.elements[i]) {\n        this.elements[i].prepareFrame(num - this.layers[i].st);\n      }\n    }\n\n    if (this.globalData._mdf) {\n      if (this.renderConfig.clearCanvas === true) {\n        this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);\n      } else {\n        this.save();\n      }\n\n      for (i = len - 1; i >= 0; i -= 1) {\n        if (this.completeLayers || this.elements[i]) {\n          this.elements[i].renderFrame();\n        }\n      }\n\n      if (this.renderConfig.clearCanvas !== true) {\n        this.restore();\n      }\n    }\n  };\n\n  CanvasRendererBase.prototype.buildItem = function (pos) {\n    var elements = this.elements;\n\n    if (elements[pos] || this.layers[pos].ty === 99) {\n      return;\n    }\n\n    var element = this.createItem(this.layers[pos], this, this.globalData);\n    elements[pos] = element;\n    element.initExpressions();\n    /* if(this.layers[pos].ty === 0){\r\n          element.resize(this.globalData.transformCanvas);\r\n      } */\n  };\n\n  CanvasRendererBase.prototype.checkPendingElements = function () {\n    while (this.pendingElements.length) {\n      var element = this.pendingElements.pop();\n      element.checkParenting();\n    }\n  };\n\n  CanvasRendererBase.prototype.hide = function () {\n    this.animationItem.container.style.display = 'none';\n  };\n\n  CanvasRendererBase.prototype.show = function () {\n    this.animationItem.container.style.display = 'block';\n  };\n\n  function CanvasContext() {\n    this.opacity = -1;\n    this.transform = createTypedArray('float32', 16);\n    this.fillStyle = '';\n    this.strokeStyle = '';\n    this.lineWidth = '';\n    this.lineCap = '';\n    this.lineJoin = '';\n    this.miterLimit = '';\n    this.id = Math.random();\n  }\n\n  function CVContextData() {\n    this.stack = [];\n    this.cArrPos = 0;\n    this.cTr = new Matrix();\n    var i;\n    var len = 15;\n\n    for (i = 0; i < len; i += 1) {\n      var canvasContext = new CanvasContext();\n      this.stack[i] = canvasContext;\n    }\n\n    this._length = len;\n    this.nativeContext = null;\n    this.transformMat = new Matrix();\n    this.currentOpacity = 1; //\n\n    this.currentFillStyle = '';\n    this.appliedFillStyle = ''; //\n\n    this.currentStrokeStyle = '';\n    this.appliedStrokeStyle = ''; //\n\n    this.currentLineWidth = '';\n    this.appliedLineWidth = ''; //\n\n    this.currentLineCap = '';\n    this.appliedLineCap = ''; //\n\n    this.currentLineJoin = '';\n    this.appliedLineJoin = ''; //\n\n    this.appliedMiterLimit = '';\n    this.currentMiterLimit = '';\n  }\n\n  CVContextData.prototype.duplicate = function () {\n    var newLength = this._length * 2;\n    var i = 0;\n\n    for (i = this._length; i < newLength; i += 1) {\n      this.stack[i] = new CanvasContext();\n    }\n\n    this._length = newLength;\n  };\n\n  CVContextData.prototype.reset = function () {\n    this.cArrPos = 0;\n    this.cTr.reset();\n    this.stack[this.cArrPos].opacity = 1;\n  };\n\n  CVContextData.prototype.restore = function (forceRestore) {\n    this.cArrPos -= 1;\n    var currentContext = this.stack[this.cArrPos];\n    var transform = currentContext.transform;\n    var i;\n    var arr = this.cTr.props;\n\n    for (i = 0; i < 16; i += 1) {\n      arr[i] = transform[i];\n    }\n\n    if (forceRestore) {\n      this.nativeContext.restore();\n      var prevStack = this.stack[this.cArrPos + 1];\n      this.appliedFillStyle = prevStack.fillStyle;\n      this.appliedStrokeStyle = prevStack.strokeStyle;\n      this.appliedLineWidth = prevStack.lineWidth;\n      this.appliedLineCap = prevStack.lineCap;\n      this.appliedLineJoin = prevStack.lineJoin;\n      this.appliedMiterLimit = prevStack.miterLimit;\n    }\n\n    this.nativeContext.setTransform(transform[0], transform[1], transform[4], transform[5], transform[12], transform[13]);\n\n    if (forceRestore || currentContext.opacity !== -1 && this.currentOpacity !== currentContext.opacity) {\n      this.nativeContext.globalAlpha = currentContext.opacity;\n      this.currentOpacity = currentContext.opacity;\n    }\n\n    this.currentFillStyle = currentContext.fillStyle;\n    this.currentStrokeStyle = currentContext.strokeStyle;\n    this.currentLineWidth = currentContext.lineWidth;\n    this.currentLineCap = currentContext.lineCap;\n    this.currentLineJoin = currentContext.lineJoin;\n    this.currentMiterLimit = currentContext.miterLimit;\n  };\n\n  CVContextData.prototype.save = function (saveOnNativeFlag) {\n    if (saveOnNativeFlag) {\n      this.nativeContext.save();\n    }\n\n    var props = this.cTr.props;\n\n    if (this._length <= this.cArrPos) {\n      this.duplicate();\n    }\n\n    var currentStack = this.stack[this.cArrPos];\n    var i;\n\n    for (i = 0; i < 16; i += 1) {\n      currentStack.transform[i] = props[i];\n    }\n\n    this.cArrPos += 1;\n    var newStack = this.stack[this.cArrPos];\n    newStack.opacity = currentStack.opacity;\n    newStack.fillStyle = currentStack.fillStyle;\n    newStack.strokeStyle = currentStack.strokeStyle;\n    newStack.lineWidth = currentStack.lineWidth;\n    newStack.lineCap = currentStack.lineCap;\n    newStack.lineJoin = currentStack.lineJoin;\n    newStack.miterLimit = currentStack.miterLimit;\n  };\n\n  CVContextData.prototype.setOpacity = function (value) {\n    this.stack[this.cArrPos].opacity = value;\n  };\n\n  CVContextData.prototype.setContext = function (value) {\n    this.nativeContext = value;\n  };\n\n  CVContextData.prototype.fillStyle = function (value) {\n    if (this.stack[this.cArrPos].fillStyle !== value) {\n      this.currentFillStyle = value;\n      this.stack[this.cArrPos].fillStyle = value;\n    }\n  };\n\n  CVContextData.prototype.strokeStyle = function (value) {\n    if (this.stack[this.cArrPos].strokeStyle !== value) {\n      this.currentStrokeStyle = value;\n      this.stack[this.cArrPos].strokeStyle = value;\n    }\n  };\n\n  CVContextData.prototype.lineWidth = function (value) {\n    if (this.stack[this.cArrPos].lineWidth !== value) {\n      this.currentLineWidth = value;\n      this.stack[this.cArrPos].lineWidth = value;\n    }\n  };\n\n  CVContextData.prototype.lineCap = function (value) {\n    if (this.stack[this.cArrPos].lineCap !== value) {\n      this.currentLineCap = value;\n      this.stack[this.cArrPos].lineCap = value;\n    }\n  };\n\n  CVContextData.prototype.lineJoin = function (value) {\n    if (this.stack[this.cArrPos].lineJoin !== value) {\n      this.currentLineJoin = value;\n      this.stack[this.cArrPos].lineJoin = value;\n    }\n  };\n\n  CVContextData.prototype.miterLimit = function (value) {\n    if (this.stack[this.cArrPos].miterLimit !== value) {\n      this.currentMiterLimit = value;\n      this.stack[this.cArrPos].miterLimit = value;\n    }\n  };\n\n  CVContextData.prototype.transform = function (props) {\n    this.transformMat.cloneFromProps(props); // Taking the last transform value from the stored stack of transforms\n\n    var currentTransform = this.cTr; // Applying the last transform value after the new transform to respect the order of transformations\n\n    this.transformMat.multiply(currentTransform); // Storing the new transformed value in the stored transform\n\n    currentTransform.cloneFromProps(this.transformMat.props);\n    var trProps = currentTransform.props; // Applying the new transform to the canvas\n\n    this.nativeContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);\n  };\n\n  CVContextData.prototype.opacity = function (op) {\n    var currentOpacity = this.stack[this.cArrPos].opacity;\n    currentOpacity *= op < 0 ? 0 : op;\n\n    if (this.stack[this.cArrPos].opacity !== currentOpacity) {\n      if (this.currentOpacity !== op) {\n        this.nativeContext.globalAlpha = op;\n        this.currentOpacity = op;\n      }\n\n      this.stack[this.cArrPos].opacity = currentOpacity;\n    }\n  };\n\n  CVContextData.prototype.fill = function (rule) {\n    if (this.appliedFillStyle !== this.currentFillStyle) {\n      this.appliedFillStyle = this.currentFillStyle;\n      this.nativeContext.fillStyle = this.appliedFillStyle;\n    }\n\n    this.nativeContext.fill(rule);\n  };\n\n  CVContextData.prototype.fillRect = function (x, y, w, h) {\n    if (this.appliedFillStyle !== this.currentFillStyle) {\n      this.appliedFillStyle = this.currentFillStyle;\n      this.nativeContext.fillStyle = this.appliedFillStyle;\n    }\n\n    this.nativeContext.fillRect(x, y, w, h);\n  };\n\n  CVContextData.prototype.stroke = function () {\n    if (this.appliedStrokeStyle !== this.currentStrokeStyle) {\n      this.appliedStrokeStyle = this.currentStrokeStyle;\n      this.nativeContext.strokeStyle = this.appliedStrokeStyle;\n    }\n\n    if (this.appliedLineWidth !== this.currentLineWidth) {\n      this.appliedLineWidth = this.currentLineWidth;\n      this.nativeContext.lineWidth = this.appliedLineWidth;\n    }\n\n    if (this.appliedLineCap !== this.currentLineCap) {\n      this.appliedLineCap = this.currentLineCap;\n      this.nativeContext.lineCap = this.appliedLineCap;\n    }\n\n    if (this.appliedLineJoin !== this.currentLineJoin) {\n      this.appliedLineJoin = this.currentLineJoin;\n      this.nativeContext.lineJoin = this.appliedLineJoin;\n    }\n\n    if (this.appliedMiterLimit !== this.currentMiterLimit) {\n      this.appliedMiterLimit = this.currentMiterLimit;\n      this.nativeContext.miterLimit = this.appliedMiterLimit;\n    }\n\n    this.nativeContext.stroke();\n  };\n\n  function CVCompElement(data, globalData, comp) {\n    this.completeLayers = false;\n    this.layers = data.layers;\n    this.pendingElements = [];\n    this.elements = createSizedArray(this.layers.length);\n    this.initElement(data, globalData, comp);\n    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n      _placeholder: true\n    };\n  }\n\n  extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement);\n\n  CVCompElement.prototype.renderInnerContent = function () {\n    var ctx = this.canvasContext;\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(this.data.w, 0);\n    ctx.lineTo(this.data.w, this.data.h);\n    ctx.lineTo(0, this.data.h);\n    ctx.lineTo(0, 0);\n    ctx.clip();\n    var i;\n    var len = this.layers.length;\n\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (this.completeLayers || this.elements[i]) {\n        this.elements[i].renderFrame();\n      }\n    }\n  };\n\n  CVCompElement.prototype.destroy = function () {\n    var i;\n    var len = this.layers.length;\n\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (this.elements[i]) {\n        this.elements[i].destroy();\n      }\n    }\n\n    this.layers = null;\n    this.elements = null;\n  };\n\n  CVCompElement.prototype.createComp = function (data) {\n    return new CVCompElement(data, this.globalData, this);\n  };\n\n  function CanvasRenderer(animationItem, config) {\n    this.animationItem = animationItem;\n    this.renderConfig = {\n      clearCanvas: config && config.clearCanvas !== undefined ? config.clearCanvas : true,\n      context: config && config.context || null,\n      progressiveLoad: config && config.progressiveLoad || false,\n      preserveAspectRatio: config && config.preserveAspectRatio || 'xMidYMid meet',\n      imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',\n      contentVisibility: config && config.contentVisibility || 'visible',\n      className: config && config.className || '',\n      id: config && config.id || '',\n      runExpressions: !config || config.runExpressions === undefined || config.runExpressions\n    };\n    this.renderConfig.dpr = config && config.dpr || 1;\n\n    if (this.animationItem.wrapper) {\n      this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;\n    }\n\n    this.renderedFrame = -1;\n    this.globalData = {\n      frameNum: -1,\n      _mdf: false,\n      renderConfig: this.renderConfig,\n      currentGlobalAlpha: -1\n    };\n    this.contextData = new CVContextData();\n    this.elements = [];\n    this.pendingElements = [];\n    this.transformMat = new Matrix();\n    this.completeLayers = false;\n    this.rendererType = 'canvas';\n\n    if (this.renderConfig.clearCanvas) {\n      this.ctxTransform = this.contextData.transform.bind(this.contextData);\n      this.ctxOpacity = this.contextData.opacity.bind(this.contextData);\n      this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData);\n      this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData);\n      this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData);\n      this.ctxLineCap = this.contextData.lineCap.bind(this.contextData);\n      this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData);\n      this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData);\n      this.ctxFill = this.contextData.fill.bind(this.contextData);\n      this.ctxFillRect = this.contextData.fillRect.bind(this.contextData);\n      this.ctxStroke = this.contextData.stroke.bind(this.contextData);\n      this.save = this.contextData.save.bind(this.contextData);\n    }\n  }\n\n  extendPrototype([CanvasRendererBase], CanvasRenderer);\n\n  CanvasRenderer.prototype.createComp = function (data) {\n    return new CVCompElement(data, this.globalData, this);\n  };\n\n  function HBaseElement() {}\n\n  HBaseElement.prototype = {\n    checkBlendMode: function checkBlendMode() {},\n    initRendererElement: function initRendererElement() {\n      this.baseElement = createTag(this.data.tg || 'div');\n\n      if (this.data.hasMask) {\n        this.svgElement = createNS('svg');\n        this.layerElement = createNS('g');\n        this.maskedElement = this.layerElement;\n        this.svgElement.appendChild(this.layerElement);\n        this.baseElement.appendChild(this.svgElement);\n      } else {\n        this.layerElement = this.baseElement;\n      }\n\n      styleDiv(this.baseElement);\n    },\n    createContainerElements: function createContainerElements() {\n      this.renderableEffectsManager = new CVEffects(this);\n      this.transformedElement = this.baseElement;\n      this.maskedElement = this.layerElement;\n\n      if (this.data.ln) {\n        this.layerElement.setAttribute('id', this.data.ln);\n      }\n\n      if (this.data.cl) {\n        this.layerElement.setAttribute('class', this.data.cl);\n      }\n\n      if (this.data.bm !== 0) {\n        this.setBlendMode();\n      }\n    },\n    renderElement: function renderElement() {\n      var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};\n\n      if (this.finalTransform._matMdf) {\n        var matrixValue = this.finalTransform.mat.toCSS();\n        transformedElementStyle.transform = matrixValue;\n        transformedElementStyle.webkitTransform = matrixValue;\n      }\n\n      if (this.finalTransform._opMdf) {\n        transformedElementStyle.opacity = this.finalTransform.mProp.o.v;\n      }\n    },\n    renderFrame: function renderFrame() {\n      // If it is exported as hidden (data.hd === true) no need to render\n      // If it is not visible no need to render\n      if (this.data.hd || this.hidden) {\n        return;\n      }\n\n      this.renderTransform();\n      this.renderRenderable();\n      this.renderElement();\n      this.renderInnerContent();\n\n      if (this._isFirstFrame) {\n        this._isFirstFrame = false;\n      }\n    },\n    destroy: function destroy() {\n      this.layerElement = null;\n      this.transformedElement = null;\n\n      if (this.matteElement) {\n        this.matteElement = null;\n      }\n\n      if (this.maskManager) {\n        this.maskManager.destroy();\n        this.maskManager = null;\n      }\n    },\n    createRenderableComponents: function createRenderableComponents() {\n      this.maskManager = new MaskElement(this.data, this, this.globalData);\n    },\n    addEffects: function addEffects() {},\n    setMatte: function setMatte() {}\n  };\n  HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;\n  HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;\n  HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;\n\n  function HSolidElement(data, globalData, comp) {\n    this.initElement(data, globalData, comp);\n  }\n\n  extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement);\n\n  HSolidElement.prototype.createContent = function () {\n    var rect;\n\n    if (this.data.hasMask) {\n      rect = createNS('rect');\n      rect.setAttribute('width', this.data.sw);\n      rect.setAttribute('height', this.data.sh);\n      rect.setAttribute('fill', this.data.sc);\n      this.svgElement.setAttribute('width', this.data.sw);\n      this.svgElement.setAttribute('height', this.data.sh);\n    } else {\n      rect = createTag('div');\n      rect.style.width = this.data.sw + 'px';\n      rect.style.height = this.data.sh + 'px';\n      rect.style.backgroundColor = this.data.sc;\n    }\n\n    this.layerElement.appendChild(rect);\n  };\n\n  function HShapeElement(data, globalData, comp) {\n    // List of drawable elements\n    this.shapes = []; // Full shape data\n\n    this.shapesData = data.shapes; // List of styles that will be applied to shapes\n\n    this.stylesList = []; // List of modifiers that will be applied to shapes\n\n    this.shapeModifiers = []; // List of items in shape tree\n\n    this.itemsData = []; // List of items in previous shape tree\n\n    this.processedElements = []; // List of animated components\n\n    this.animatedContents = [];\n    this.shapesContainer = createNS('g');\n    this.initElement(data, globalData, comp); // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\n    // List of elements that have been created\n\n    this.prevViewData = [];\n    this.currentBBox = {\n      x: 999999,\n      y: -999999,\n      h: 0,\n      w: 0\n    };\n  }\n\n  extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement);\n  HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;\n\n  HShapeElement.prototype.createContent = function () {\n    var cont;\n    this.baseElement.style.fontSize = 0;\n\n    if (this.data.hasMask) {\n      this.layerElement.appendChild(this.shapesContainer);\n      cont = this.svgElement;\n    } else {\n      cont = createNS('svg');\n      var size = this.comp.data ? this.comp.data : this.globalData.compSize;\n      cont.setAttribute('width', size.w);\n      cont.setAttribute('height', size.h);\n      cont.appendChild(this.shapesContainer);\n      this.layerElement.appendChild(cont);\n    }\n\n    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);\n    this.filterUniqueShapes();\n    this.shapeCont = cont;\n  };\n\n  HShapeElement.prototype.getTransformedPoint = function (transformers, point) {\n    var i;\n    var len = transformers.length;\n\n    for (i = 0; i < len; i += 1) {\n      point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);\n    }\n\n    return point;\n  };\n\n  HShapeElement.prototype.calculateShapeBoundingBox = function (item, boundingBox) {\n    var shape = item.sh.v;\n    var transformers = item.transformers;\n    var i;\n    var len = shape._length;\n    var vPoint;\n    var oPoint;\n    var nextIPoint;\n    var nextVPoint;\n\n    if (len <= 1) {\n      return;\n    }\n\n    for (i = 0; i < len - 1; i += 1) {\n      vPoint = this.getTransformedPoint(transformers, shape.v[i]);\n      oPoint = this.getTransformedPoint(transformers, shape.o[i]);\n      nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);\n      nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);\n      this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);\n    }\n\n    if (shape.c) {\n      vPoint = this.getTransformedPoint(transformers, shape.v[i]);\n      oPoint = this.getTransformedPoint(transformers, shape.o[i]);\n      nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);\n      nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);\n      this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);\n    }\n  };\n\n  HShapeElement.prototype.checkBounds = function (vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {\n    this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);\n    var bounds = this.shapeBoundingBox;\n    boundingBox.x = bmMin(bounds.left, boundingBox.x);\n    boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);\n    boundingBox.y = bmMin(bounds.top, boundingBox.y);\n    boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);\n  };\n\n  HShapeElement.prototype.shapeBoundingBox = {\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0\n  };\n  HShapeElement.prototype.tempBoundingBox = {\n    x: 0,\n    xMax: 0,\n    y: 0,\n    yMax: 0,\n    width: 0,\n    height: 0\n  };\n\n  HShapeElement.prototype.getBoundsOfCurve = function (p0, p1, p2, p3) {\n    var bounds = [[p0[0], p3[0]], [p0[1], p3[1]]];\n\n    for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) {\n      // eslint-disable-line no-plusplus\n      b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\n      a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\n      c = 3 * p1[i] - 3 * p0[i];\n      b |= 0; // eslint-disable-line no-bitwise\n\n      a |= 0; // eslint-disable-line no-bitwise\n\n      c |= 0; // eslint-disable-line no-bitwise\n\n      if (a === 0 && b === 0) {//\n      } else if (a === 0) {\n        t = -c / b;\n\n        if (t > 0 && t < 1) {\n          bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));\n        }\n      } else {\n        b2ac = b * b - 4 * c * a;\n\n        if (b2ac >= 0) {\n          t1 = (-b + bmSqrt(b2ac)) / (2 * a);\n          if (t1 > 0 && t1 < 1) bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));\n          t2 = (-b - bmSqrt(b2ac)) / (2 * a);\n          if (t2 > 0 && t2 < 1) bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));\n        }\n      }\n    }\n\n    this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);\n    this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);\n    this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);\n    this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);\n  };\n\n  HShapeElement.prototype.calculateF = function (t, p0, p1, p2, p3, i) {\n    return bmPow(1 - t, 3) * p0[i] + 3 * bmPow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * bmPow(t, 2) * p2[i] + bmPow(t, 3) * p3[i];\n  };\n\n  HShapeElement.prototype.calculateBoundingBox = function (itemsData, boundingBox) {\n    var i;\n    var len = itemsData.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (itemsData[i] && itemsData[i].sh) {\n        this.calculateShapeBoundingBox(itemsData[i], boundingBox);\n      } else if (itemsData[i] && itemsData[i].it) {\n        this.calculateBoundingBox(itemsData[i].it, boundingBox);\n      } else if (itemsData[i] && itemsData[i].style && itemsData[i].w) {\n        this.expandStrokeBoundingBox(itemsData[i].w, boundingBox);\n      }\n    }\n  };\n\n  HShapeElement.prototype.expandStrokeBoundingBox = function (widthProperty, boundingBox) {\n    var width = 0;\n\n    if (widthProperty.keyframes) {\n      for (var i = 0; i < widthProperty.keyframes.length; i += 1) {\n        var kfw = widthProperty.keyframes[i].s;\n\n        if (kfw > width) {\n          width = kfw;\n        }\n      }\n\n      width *= widthProperty.mult;\n    } else {\n      width = widthProperty.v * widthProperty.mult;\n    }\n\n    boundingBox.x -= width;\n    boundingBox.xMax += width;\n    boundingBox.y -= width;\n    boundingBox.yMax += width;\n  };\n\n  HShapeElement.prototype.currentBoxContains = function (box) {\n    return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;\n  };\n\n  HShapeElement.prototype.renderInnerContent = function () {\n    this._renderShapeFrame();\n\n    if (!this.hidden && (this._isFirstFrame || this._mdf)) {\n      var tempBoundingBox = this.tempBoundingBox;\n      var max = 999999;\n      tempBoundingBox.x = max;\n      tempBoundingBox.xMax = -max;\n      tempBoundingBox.y = max;\n      tempBoundingBox.yMax = -max;\n      this.calculateBoundingBox(this.itemsData, tempBoundingBox);\n      tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;\n      tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y; // var tempBoundingBox = this.shapeCont.getBBox();\n\n      if (this.currentBoxContains(tempBoundingBox)) {\n        return;\n      }\n\n      var changed = false;\n\n      if (this.currentBBox.w !== tempBoundingBox.width) {\n        this.currentBBox.w = tempBoundingBox.width;\n        this.shapeCont.setAttribute('width', tempBoundingBox.width);\n        changed = true;\n      }\n\n      if (this.currentBBox.h !== tempBoundingBox.height) {\n        this.currentBBox.h = tempBoundingBox.height;\n        this.shapeCont.setAttribute('height', tempBoundingBox.height);\n        changed = true;\n      }\n\n      if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {\n        this.currentBBox.w = tempBoundingBox.width;\n        this.currentBBox.h = tempBoundingBox.height;\n        this.currentBBox.x = tempBoundingBox.x;\n        this.currentBBox.y = tempBoundingBox.y;\n        this.shapeCont.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);\n        var shapeStyle = this.shapeCont.style;\n        var shapeTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';\n        shapeStyle.transform = shapeTransform;\n        shapeStyle.webkitTransform = shapeTransform;\n      }\n    }\n  };\n\n  function HTextElement(data, globalData, comp) {\n    this.textSpans = [];\n    this.textPaths = [];\n    this.currentBBox = {\n      x: 999999,\n      y: -999999,\n      h: 0,\n      w: 0\n    };\n    this.renderType = 'svg';\n    this.isMasked = false;\n    this.initElement(data, globalData, comp);\n  }\n\n  extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement);\n\n  HTextElement.prototype.createContent = function () {\n    this.isMasked = this.checkMasks();\n\n    if (this.isMasked) {\n      this.renderType = 'svg';\n      this.compW = this.comp.data.w;\n      this.compH = this.comp.data.h;\n      this.svgElement.setAttribute('width', this.compW);\n      this.svgElement.setAttribute('height', this.compH);\n      var g = createNS('g');\n      this.maskedElement.appendChild(g);\n      this.innerElem = g;\n    } else {\n      this.renderType = 'html';\n      this.innerElem = this.layerElement;\n    }\n\n    this.checkParenting();\n  };\n\n  HTextElement.prototype.buildNewText = function () {\n    var documentData = this.textProperty.currentData;\n    this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);\n    var innerElemStyle = this.innerElem.style;\n    var textColor = documentData.fc ? this.buildColor(documentData.fc) : 'rgba(0,0,0,0)';\n    innerElemStyle.fill = textColor;\n    innerElemStyle.color = textColor;\n\n    if (documentData.sc) {\n      innerElemStyle.stroke = this.buildColor(documentData.sc);\n      innerElemStyle.strokeWidth = documentData.sw + 'px';\n    }\n\n    var fontData = this.globalData.fontManager.getFontByName(documentData.f);\n\n    if (!this.globalData.fontManager.chars) {\n      innerElemStyle.fontSize = documentData.finalSize + 'px';\n      innerElemStyle.lineHeight = documentData.finalSize + 'px';\n\n      if (fontData.fClass) {\n        this.innerElem.className = fontData.fClass;\n      } else {\n        innerElemStyle.fontFamily = fontData.fFamily;\n        var fWeight = documentData.fWeight;\n        var fStyle = documentData.fStyle;\n        innerElemStyle.fontStyle = fStyle;\n        innerElemStyle.fontWeight = fWeight;\n      }\n    }\n\n    var i;\n    var len;\n    var letters = documentData.l;\n    len = letters.length;\n    var tSpan;\n    var tParent;\n    var tCont;\n    var matrixHelper = this.mHelper;\n    var shapes;\n    var shapeStr = '';\n    var cnt = 0;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.globalData.fontManager.chars) {\n        if (!this.textPaths[cnt]) {\n          tSpan = createNS('path');\n          tSpan.setAttribute('stroke-linecap', lineCapEnum[1]);\n          tSpan.setAttribute('stroke-linejoin', lineJoinEnum[2]);\n          tSpan.setAttribute('stroke-miterlimit', '4');\n        } else {\n          tSpan = this.textPaths[cnt];\n        }\n\n        if (!this.isMasked) {\n          if (this.textSpans[cnt]) {\n            tParent = this.textSpans[cnt];\n            tCont = tParent.children[0];\n          } else {\n            tParent = createTag('div');\n            tParent.style.lineHeight = 0;\n            tCont = createNS('svg');\n            tCont.appendChild(tSpan);\n            styleDiv(tParent);\n          }\n        }\n      } else if (!this.isMasked) {\n        if (this.textSpans[cnt]) {\n          tParent = this.textSpans[cnt];\n          tSpan = this.textPaths[cnt];\n        } else {\n          tParent = createTag('span');\n          styleDiv(tParent);\n          tSpan = createTag('span');\n          styleDiv(tSpan);\n          tParent.appendChild(tSpan);\n        }\n      } else {\n        tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS('text');\n      } // tSpan.setAttribute('visibility', 'hidden');\n\n\n      if (this.globalData.fontManager.chars) {\n        var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);\n        var shapeData;\n\n        if (charData) {\n          shapeData = charData.data;\n        } else {\n          shapeData = null;\n        }\n\n        matrixHelper.reset();\n\n        if (shapeData && shapeData.shapes && shapeData.shapes.length) {\n          shapes = shapeData.shapes[0].it;\n          matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);\n          shapeStr = this.createPathShape(matrixHelper, shapes);\n          tSpan.setAttribute('d', shapeStr);\n        }\n\n        if (!this.isMasked) {\n          this.innerElem.appendChild(tParent);\n\n          if (shapeData && shapeData.shapes) {\n            // document.body.appendChild is needed to get exact measure of shape\n            document.body.appendChild(tCont);\n            var boundingBox = tCont.getBBox();\n            tCont.setAttribute('width', boundingBox.width + 2);\n            tCont.setAttribute('height', boundingBox.height + 2);\n            tCont.setAttribute('viewBox', boundingBox.x - 1 + ' ' + (boundingBox.y - 1) + ' ' + (boundingBox.width + 2) + ' ' + (boundingBox.height + 2));\n            var tContStyle = tCont.style;\n            var tContTranslation = 'translate(' + (boundingBox.x - 1) + 'px,' + (boundingBox.y - 1) + 'px)';\n            tContStyle.transform = tContTranslation;\n            tContStyle.webkitTransform = tContTranslation;\n            letters[i].yOffset = boundingBox.y - 1;\n          } else {\n            tCont.setAttribute('width', 1);\n            tCont.setAttribute('height', 1);\n          }\n\n          tParent.appendChild(tCont);\n        } else {\n          this.innerElem.appendChild(tSpan);\n        }\n      } else {\n        tSpan.textContent = letters[i].val;\n        tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');\n\n        if (!this.isMasked) {\n          this.innerElem.appendChild(tParent); //\n\n          var tStyle = tSpan.style;\n          var tSpanTranslation = 'translate3d(0,' + -documentData.finalSize / 1.2 + 'px,0)';\n          tStyle.transform = tSpanTranslation;\n          tStyle.webkitTransform = tSpanTranslation;\n        } else {\n          this.innerElem.appendChild(tSpan);\n        }\n      } //\n\n\n      if (!this.isMasked) {\n        this.textSpans[cnt] = tParent;\n      } else {\n        this.textSpans[cnt] = tSpan;\n      }\n\n      this.textSpans[cnt].style.display = 'block';\n      this.textPaths[cnt] = tSpan;\n      cnt += 1;\n    }\n\n    while (cnt < this.textSpans.length) {\n      this.textSpans[cnt].style.display = 'none';\n      cnt += 1;\n    }\n  };\n\n  HTextElement.prototype.renderInnerContent = function () {\n    this.validateText();\n    var svgStyle;\n\n    if (this.data.singleShape) {\n      if (!this._isFirstFrame && !this.lettersChangedFlag) {\n        return;\n      }\n\n      if (this.isMasked && this.finalTransform._matMdf) {\n        // Todo Benchmark if using this is better than getBBox\n        this.svgElement.setAttribute('viewBox', -this.finalTransform.mProp.p.v[0] + ' ' + -this.finalTransform.mProp.p.v[1] + ' ' + this.compW + ' ' + this.compH);\n        svgStyle = this.svgElement.style;\n        var translation = 'translate(' + -this.finalTransform.mProp.p.v[0] + 'px,' + -this.finalTransform.mProp.p.v[1] + 'px)';\n        svgStyle.transform = translation;\n        svgStyle.webkitTransform = translation;\n      }\n    }\n\n    this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);\n\n    if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {\n      return;\n    }\n\n    var i;\n    var len;\n    var count = 0;\n    var renderedLetters = this.textAnimator.renderedLetters;\n    var letters = this.textProperty.currentData.l;\n    len = letters.length;\n    var renderedLetter;\n    var textSpan;\n    var textPath;\n\n    for (i = 0; i < len; i += 1) {\n      if (letters[i].n) {\n        count += 1;\n      } else {\n        textSpan = this.textSpans[i];\n        textPath = this.textPaths[i];\n        renderedLetter = renderedLetters[count];\n        count += 1;\n\n        if (renderedLetter._mdf.m) {\n          if (!this.isMasked) {\n            textSpan.style.webkitTransform = renderedLetter.m;\n            textSpan.style.transform = renderedLetter.m;\n          } else {\n            textSpan.setAttribute('transform', renderedLetter.m);\n          }\n        } /// /textSpan.setAttribute('opacity',renderedLetter.o);\n\n\n        textSpan.style.opacity = renderedLetter.o;\n\n        if (renderedLetter.sw && renderedLetter._mdf.sw) {\n          textPath.setAttribute('stroke-width', renderedLetter.sw);\n        }\n\n        if (renderedLetter.sc && renderedLetter._mdf.sc) {\n          textPath.setAttribute('stroke', renderedLetter.sc);\n        }\n\n        if (renderedLetter.fc && renderedLetter._mdf.fc) {\n          textPath.setAttribute('fill', renderedLetter.fc);\n          textPath.style.color = renderedLetter.fc;\n        }\n      }\n    }\n\n    if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {\n      var boundingBox = this.innerElem.getBBox();\n\n      if (this.currentBBox.w !== boundingBox.width) {\n        this.currentBBox.w = boundingBox.width;\n        this.svgElement.setAttribute('width', boundingBox.width);\n      }\n\n      if (this.currentBBox.h !== boundingBox.height) {\n        this.currentBBox.h = boundingBox.height;\n        this.svgElement.setAttribute('height', boundingBox.height);\n      }\n\n      var margin = 1;\n\n      if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {\n        this.currentBBox.w = boundingBox.width + margin * 2;\n        this.currentBBox.h = boundingBox.height + margin * 2;\n        this.currentBBox.x = boundingBox.x - margin;\n        this.currentBBox.y = boundingBox.y - margin;\n        this.svgElement.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);\n        svgStyle = this.svgElement.style;\n        var svgTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';\n        svgStyle.transform = svgTransform;\n        svgStyle.webkitTransform = svgTransform;\n      }\n    }\n  };\n\n  function HCameraElement(data, globalData, comp) {\n    this.initFrame();\n    this.initBaseData(data, globalData, comp);\n    this.initHierarchy();\n    var getProp = PropertyFactory.getProp;\n    this.pe = getProp(this, data.pe, 0, 0, this);\n\n    if (data.ks.p.s) {\n      this.px = getProp(this, data.ks.p.x, 1, 0, this);\n      this.py = getProp(this, data.ks.p.y, 1, 0, this);\n      this.pz = getProp(this, data.ks.p.z, 1, 0, this);\n    } else {\n      this.p = getProp(this, data.ks.p, 1, 0, this);\n    }\n\n    if (data.ks.a) {\n      this.a = getProp(this, data.ks.a, 1, 0, this);\n    }\n\n    if (data.ks.or.k.length && data.ks.or.k[0].to) {\n      var i;\n      var len = data.ks.or.k.length;\n\n      for (i = 0; i < len; i += 1) {\n        data.ks.or.k[i].to = null;\n        data.ks.or.k[i].ti = null;\n      }\n    }\n\n    this.or = getProp(this, data.ks.or, 1, degToRads, this);\n    this.or.sh = true;\n    this.rx = getProp(this, data.ks.rx, 0, degToRads, this);\n    this.ry = getProp(this, data.ks.ry, 0, degToRads, this);\n    this.rz = getProp(this, data.ks.rz, 0, degToRads, this);\n    this.mat = new Matrix();\n    this._prevMat = new Matrix();\n    this._isFirstFrame = true; // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.\n\n    this.finalTransform = {\n      mProp: this\n    };\n  }\n\n  extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);\n\n  HCameraElement.prototype.setup = function () {\n    var i;\n    var len = this.comp.threeDElements.length;\n    var comp;\n    var perspectiveStyle;\n    var containerStyle;\n\n    for (i = 0; i < len; i += 1) {\n      // [perspectiveElem,container]\n      comp = this.comp.threeDElements[i];\n\n      if (comp.type === '3d') {\n        perspectiveStyle = comp.perspectiveElem.style;\n        containerStyle = comp.container.style;\n        var perspective = this.pe.v + 'px';\n        var origin = '0px 0px 0px';\n        var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';\n        perspectiveStyle.perspective = perspective;\n        perspectiveStyle.webkitPerspective = perspective;\n        containerStyle.transformOrigin = origin;\n        containerStyle.mozTransformOrigin = origin;\n        containerStyle.webkitTransformOrigin = origin;\n        perspectiveStyle.transform = matrix;\n        perspectiveStyle.webkitTransform = matrix;\n      }\n    }\n  };\n\n  HCameraElement.prototype.createElements = function () {};\n\n  HCameraElement.prototype.hide = function () {};\n\n  HCameraElement.prototype.renderFrame = function () {\n    var _mdf = this._isFirstFrame;\n    var i;\n    var len;\n\n    if (this.hierarchy) {\n      len = this.hierarchy.length;\n\n      for (i = 0; i < len; i += 1) {\n        _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;\n      }\n    }\n\n    if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {\n      this.mat.reset();\n\n      if (this.hierarchy) {\n        len = this.hierarchy.length - 1;\n\n        for (i = len; i >= 0; i -= 1) {\n          var mTransf = this.hierarchy[i].finalTransform.mProp;\n          this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);\n          this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);\n          this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);\n          this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);\n          this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);\n        }\n      }\n\n      if (this.p) {\n        this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);\n      } else {\n        this.mat.translate(-this.px.v, -this.py.v, this.pz.v);\n      }\n\n      if (this.a) {\n        var diffVector;\n\n        if (this.p) {\n          diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];\n        } else {\n          diffVector = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];\n        }\n\n        var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2)); // var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));\n\n        var lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag];\n        var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);\n        var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);\n        var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);\n        this.mat.rotateY(mRotationY).rotateX(-mRotationX);\n      }\n\n      this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);\n      this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);\n      this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);\n      this.mat.translate(0, 0, this.pe.v);\n      var hasMatrixChanged = !this._prevMat.equals(this.mat);\n\n      if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {\n        len = this.comp.threeDElements.length;\n        var comp;\n        var perspectiveStyle;\n        var containerStyle;\n\n        for (i = 0; i < len; i += 1) {\n          comp = this.comp.threeDElements[i];\n\n          if (comp.type === '3d') {\n            if (hasMatrixChanged) {\n              var matValue = this.mat.toCSS();\n              containerStyle = comp.container.style;\n              containerStyle.transform = matValue;\n              containerStyle.webkitTransform = matValue;\n            }\n\n            if (this.pe._mdf) {\n              perspectiveStyle = comp.perspectiveElem.style;\n              perspectiveStyle.perspective = this.pe.v + 'px';\n              perspectiveStyle.webkitPerspective = this.pe.v + 'px';\n            }\n          }\n        }\n\n        this.mat.clone(this._prevMat);\n      }\n    }\n\n    this._isFirstFrame = false;\n  };\n\n  HCameraElement.prototype.prepareFrame = function (num) {\n    this.prepareProperties(num, true);\n  };\n\n  HCameraElement.prototype.destroy = function () {};\n\n  HCameraElement.prototype.getBaseElement = function () {\n    return null;\n  };\n\n  function HImageElement(data, globalData, comp) {\n    this.assetData = globalData.getAssetData(data.refId);\n    this.initElement(data, globalData, comp);\n  }\n\n  extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement);\n\n  HImageElement.prototype.createContent = function () {\n    var assetPath = this.globalData.getAssetsPath(this.assetData);\n    var img = new Image();\n\n    if (this.data.hasMask) {\n      this.imageElem = createNS('image');\n      this.imageElem.setAttribute('width', this.assetData.w + 'px');\n      this.imageElem.setAttribute('height', this.assetData.h + 'px');\n      this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);\n      this.layerElement.appendChild(this.imageElem);\n      this.baseElement.setAttribute('width', this.assetData.w);\n      this.baseElement.setAttribute('height', this.assetData.h);\n    } else {\n      this.layerElement.appendChild(img);\n    }\n\n    img.crossOrigin = 'anonymous';\n    img.src = assetPath;\n\n    if (this.data.ln) {\n      this.baseElement.setAttribute('id', this.data.ln);\n    }\n  };\n\n  function HybridRendererBase(animationItem, config) {\n    this.animationItem = animationItem;\n    this.layers = null;\n    this.renderedFrame = -1;\n    this.renderConfig = {\n      className: config && config.className || '',\n      imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',\n      hideOnTransparent: !(config && config.hideOnTransparent === false),\n      filterSize: {\n        width: config && config.filterSize && config.filterSize.width || '400%',\n        height: config && config.filterSize && config.filterSize.height || '400%',\n        x: config && config.filterSize && config.filterSize.x || '-100%',\n        y: config && config.filterSize && config.filterSize.y || '-100%'\n      }\n    };\n    this.globalData = {\n      _mdf: false,\n      frameNum: -1,\n      renderConfig: this.renderConfig\n    };\n    this.pendingElements = [];\n    this.elements = [];\n    this.threeDElements = [];\n    this.destroyed = false;\n    this.camera = null;\n    this.supports3d = true;\n    this.rendererType = 'html';\n  }\n\n  extendPrototype([BaseRenderer], HybridRendererBase);\n  HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem;\n\n  HybridRendererBase.prototype.checkPendingElements = function () {\n    while (this.pendingElements.length) {\n      var element = this.pendingElements.pop();\n      element.checkParenting();\n    }\n  };\n\n  HybridRendererBase.prototype.appendElementInPos = function (element, pos) {\n    var newDOMElement = element.getBaseElement();\n\n    if (!newDOMElement) {\n      return;\n    }\n\n    var layer = this.layers[pos];\n\n    if (!layer.ddd || !this.supports3d) {\n      if (this.threeDElements) {\n        this.addTo3dContainer(newDOMElement, pos);\n      } else {\n        var i = 0;\n        var nextDOMElement;\n        var nextLayer;\n        var tmpDOMElement;\n\n        while (i < pos) {\n          if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement) {\n            nextLayer = this.elements[i];\n            tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();\n            nextDOMElement = tmpDOMElement || nextDOMElement;\n          }\n\n          i += 1;\n        }\n\n        if (nextDOMElement) {\n          if (!layer.ddd || !this.supports3d) {\n            this.layerElement.insertBefore(newDOMElement, nextDOMElement);\n          }\n        } else if (!layer.ddd || !this.supports3d) {\n          this.layerElement.appendChild(newDOMElement);\n        }\n      }\n    } else {\n      this.addTo3dContainer(newDOMElement, pos);\n    }\n  };\n\n  HybridRendererBase.prototype.createShape = function (data) {\n    if (!this.supports3d) {\n      return new SVGShapeElement(data, this.globalData, this);\n    }\n\n    return new HShapeElement(data, this.globalData, this);\n  };\n\n  HybridRendererBase.prototype.createText = function (data) {\n    if (!this.supports3d) {\n      return new SVGTextLottieElement(data, this.globalData, this);\n    }\n\n    return new HTextElement(data, this.globalData, this);\n  };\n\n  HybridRendererBase.prototype.createCamera = function (data) {\n    this.camera = new HCameraElement(data, this.globalData, this);\n    return this.camera;\n  };\n\n  HybridRendererBase.prototype.createImage = function (data) {\n    if (!this.supports3d) {\n      return new IImageElement(data, this.globalData, this);\n    }\n\n    return new HImageElement(data, this.globalData, this);\n  };\n\n  HybridRendererBase.prototype.createSolid = function (data) {\n    if (!this.supports3d) {\n      return new ISolidElement(data, this.globalData, this);\n    }\n\n    return new HSolidElement(data, this.globalData, this);\n  };\n\n  HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;\n\n  HybridRendererBase.prototype.getThreeDContainerByPos = function (pos) {\n    var i = 0;\n    var len = this.threeDElements.length;\n\n    while (i < len) {\n      if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {\n        return this.threeDElements[i].perspectiveElem;\n      }\n\n      i += 1;\n    }\n\n    return null;\n  };\n\n  HybridRendererBase.prototype.createThreeDContainer = function (pos, type) {\n    var perspectiveElem = createTag('div');\n    var style;\n    var containerStyle;\n    styleDiv(perspectiveElem);\n    var container = createTag('div');\n    styleDiv(container);\n\n    if (type === '3d') {\n      style = perspectiveElem.style;\n      style.width = this.globalData.compSize.w + 'px';\n      style.height = this.globalData.compSize.h + 'px';\n      var center = '50% 50%';\n      style.webkitTransformOrigin = center;\n      style.mozTransformOrigin = center;\n      style.transformOrigin = center;\n      containerStyle = container.style;\n      var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';\n      containerStyle.transform = matrix;\n      containerStyle.webkitTransform = matrix;\n    }\n\n    perspectiveElem.appendChild(container); // this.resizerElem.appendChild(perspectiveElem);\n\n    var threeDContainerData = {\n      container: container,\n      perspectiveElem: perspectiveElem,\n      startPos: pos,\n      endPos: pos,\n      type: type\n    };\n    this.threeDElements.push(threeDContainerData);\n    return threeDContainerData;\n  };\n\n  HybridRendererBase.prototype.build3dContainers = function () {\n    var i;\n    var len = this.layers.length;\n    var lastThreeDContainerData;\n    var currentContainer = '';\n\n    for (i = 0; i < len; i += 1) {\n      if (this.layers[i].ddd && this.layers[i].ty !== 3) {\n        if (currentContainer !== '3d') {\n          currentContainer = '3d';\n          lastThreeDContainerData = this.createThreeDContainer(i, '3d');\n        }\n\n        lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);\n      } else {\n        if (currentContainer !== '2d') {\n          currentContainer = '2d';\n          lastThreeDContainerData = this.createThreeDContainer(i, '2d');\n        }\n\n        lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);\n      }\n    }\n\n    len = this.threeDElements.length;\n\n    for (i = len - 1; i >= 0; i -= 1) {\n      this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);\n    }\n  };\n\n  HybridRendererBase.prototype.addTo3dContainer = function (elem, pos) {\n    var i = 0;\n    var len = this.threeDElements.length;\n\n    while (i < len) {\n      if (pos <= this.threeDElements[i].endPos) {\n        var j = this.threeDElements[i].startPos;\n        var nextElement;\n\n        while (j < pos) {\n          if (this.elements[j] && this.elements[j].getBaseElement) {\n            nextElement = this.elements[j].getBaseElement();\n          }\n\n          j += 1;\n        }\n\n        if (nextElement) {\n          this.threeDElements[i].container.insertBefore(elem, nextElement);\n        } else {\n          this.threeDElements[i].container.appendChild(elem);\n        }\n\n        break;\n      }\n\n      i += 1;\n    }\n  };\n\n  HybridRendererBase.prototype.configAnimation = function (animData) {\n    var resizerElem = createTag('div');\n    var wrapper = this.animationItem.wrapper;\n    var style = resizerElem.style;\n    style.width = animData.w + 'px';\n    style.height = animData.h + 'px';\n    this.resizerElem = resizerElem;\n    styleDiv(resizerElem);\n    style.transformStyle = 'flat';\n    style.mozTransformStyle = 'flat';\n    style.webkitTransformStyle = 'flat';\n\n    if (this.renderConfig.className) {\n      resizerElem.setAttribute('class', this.renderConfig.className);\n    }\n\n    wrapper.appendChild(resizerElem);\n    style.overflow = 'hidden';\n    var svg = createNS('svg');\n    svg.setAttribute('width', '1');\n    svg.setAttribute('height', '1');\n    styleDiv(svg);\n    this.resizerElem.appendChild(svg);\n    var defs = createNS('defs');\n    svg.appendChild(defs);\n    this.data = animData; // Mask animation\n\n    this.setupGlobalData(animData, svg);\n    this.globalData.defs = defs;\n    this.layers = animData.layers;\n    this.layerElement = this.resizerElem;\n    this.build3dContainers();\n    this.updateContainerSize();\n  };\n\n  HybridRendererBase.prototype.destroy = function () {\n    if (this.animationItem.wrapper) {\n      this.animationItem.wrapper.innerText = '';\n    }\n\n    this.animationItem.container = null;\n    this.globalData.defs = null;\n    var i;\n    var len = this.layers ? this.layers.length : 0;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.elements[i] && this.elements[i].destroy) {\n        this.elements[i].destroy();\n      }\n    }\n\n    this.elements.length = 0;\n    this.destroyed = true;\n    this.animationItem = null;\n  };\n\n  HybridRendererBase.prototype.updateContainerSize = function () {\n    var elementWidth = this.animationItem.wrapper.offsetWidth;\n    var elementHeight = this.animationItem.wrapper.offsetHeight;\n    var elementRel = elementWidth / elementHeight;\n    var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;\n    var sx;\n    var sy;\n    var tx;\n    var ty;\n\n    if (animationRel > elementRel) {\n      sx = elementWidth / this.globalData.compSize.w;\n      sy = elementWidth / this.globalData.compSize.w;\n      tx = 0;\n      ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;\n    } else {\n      sx = elementHeight / this.globalData.compSize.h;\n      sy = elementHeight / this.globalData.compSize.h;\n      tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;\n      ty = 0;\n    }\n\n    var style = this.resizerElem.style;\n    style.webkitTransform = 'matrix3d(' + sx + ',0,0,0,0,' + sy + ',0,0,0,0,1,0,' + tx + ',' + ty + ',0,1)';\n    style.transform = style.webkitTransform;\n  };\n\n  HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame;\n\n  HybridRendererBase.prototype.hide = function () {\n    this.resizerElem.style.display = 'none';\n  };\n\n  HybridRendererBase.prototype.show = function () {\n    this.resizerElem.style.display = 'block';\n  };\n\n  HybridRendererBase.prototype.initItems = function () {\n    this.buildAllItems();\n\n    if (this.camera) {\n      this.camera.setup();\n    } else {\n      var cWidth = this.globalData.compSize.w;\n      var cHeight = this.globalData.compSize.h;\n      var i;\n      var len = this.threeDElements.length;\n\n      for (i = 0; i < len; i += 1) {\n        var style = this.threeDElements[i].perspectiveElem.style;\n        style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + 'px';\n        style.perspective = style.webkitPerspective;\n      }\n    }\n  };\n\n  HybridRendererBase.prototype.searchExtraCompositions = function (assets) {\n    var i;\n    var len = assets.length;\n    var floatingContainer = createTag('div');\n\n    for (i = 0; i < len; i += 1) {\n      if (assets[i].xt) {\n        var comp = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);\n        comp.initExpressions();\n        this.globalData.projectInterface.registerComposition(comp);\n      }\n    }\n  };\n\n  function HCompElement(data, globalData, comp) {\n    this.layers = data.layers;\n    this.supports3d = !data.hasMask;\n    this.completeLayers = false;\n    this.pendingElements = [];\n    this.elements = this.layers ? createSizedArray(this.layers.length) : [];\n    this.initElement(data, globalData, comp);\n    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n      _placeholder: true\n    };\n  }\n\n  extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement);\n  HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;\n\n  HCompElement.prototype.createContainerElements = function () {\n    this._createBaseContainerElements(); // divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';\n\n\n    if (this.data.hasMask) {\n      this.svgElement.setAttribute('width', this.data.w);\n      this.svgElement.setAttribute('height', this.data.h);\n      this.transformedElement = this.baseElement;\n    } else {\n      this.transformedElement = this.layerElement;\n    }\n  };\n\n  HCompElement.prototype.addTo3dContainer = function (elem, pos) {\n    var j = 0;\n    var nextElement;\n\n    while (j < pos) {\n      if (this.elements[j] && this.elements[j].getBaseElement) {\n        nextElement = this.elements[j].getBaseElement();\n      }\n\n      j += 1;\n    }\n\n    if (nextElement) {\n      this.layerElement.insertBefore(elem, nextElement);\n    } else {\n      this.layerElement.appendChild(elem);\n    }\n  };\n\n  HCompElement.prototype.createComp = function (data) {\n    if (!this.supports3d) {\n      return new SVGCompElement(data, this.globalData, this);\n    }\n\n    return new HCompElement(data, this.globalData, this);\n  };\n\n  function HybridRenderer(animationItem, config) {\n    this.animationItem = animationItem;\n    this.layers = null;\n    this.renderedFrame = -1;\n    this.renderConfig = {\n      className: config && config.className || '',\n      imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',\n      hideOnTransparent: !(config && config.hideOnTransparent === false),\n      filterSize: {\n        width: config && config.filterSize && config.filterSize.width || '400%',\n        height: config && config.filterSize && config.filterSize.height || '400%',\n        x: config && config.filterSize && config.filterSize.x || '-100%',\n        y: config && config.filterSize && config.filterSize.y || '-100%'\n      },\n      runExpressions: !config || config.runExpressions === undefined || config.runExpressions\n    };\n    this.globalData = {\n      _mdf: false,\n      frameNum: -1,\n      renderConfig: this.renderConfig\n    };\n    this.pendingElements = [];\n    this.elements = [];\n    this.threeDElements = [];\n    this.destroyed = false;\n    this.camera = null;\n    this.supports3d = true;\n    this.rendererType = 'html';\n  }\n\n  extendPrototype([HybridRendererBase], HybridRenderer);\n\n  HybridRenderer.prototype.createComp = function (data) {\n    if (!this.supports3d) {\n      return new SVGCompElement(data, this.globalData, this);\n    }\n\n    return new HCompElement(data, this.globalData, this);\n  };\n\n  var CompExpressionInterface = function () {\n    return function (comp) {\n      function _thisLayerFunction(name) {\n        var i = 0;\n        var len = comp.layers.length;\n\n        while (i < len) {\n          if (comp.layers[i].nm === name || comp.layers[i].ind === name) {\n            return comp.elements[i].layerInterface;\n          }\n\n          i += 1;\n        }\n\n        return null; // return {active:false};\n      }\n\n      Object.defineProperty(_thisLayerFunction, '_name', {\n        value: comp.data.nm\n      });\n      _thisLayerFunction.layer = _thisLayerFunction;\n      _thisLayerFunction.pixelAspect = 1;\n      _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;\n      _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;\n      _thisLayerFunction.pixelAspect = 1;\n      _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;\n      _thisLayerFunction.displayStartTime = 0;\n      _thisLayerFunction.numLayers = comp.layers.length;\n      return _thisLayerFunction;\n    };\n  }();\n\n  function _typeof$2(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof$2 = function _typeof(obj) { return typeof obj; }; } else { _typeof$2 = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof$2(obj); }\n\n  /* eslint-disable */\n\n  /*\r\n   Copyright 2014 David Bau.\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining\r\n   a copy of this software and associated documentation files (the\r\n   \"Software\"), to deal in the Software without restriction, including\r\n   without limitation the rights to use, copy, modify, merge, publish,\r\n   distribute, sublicense, and/or sell copies of the Software, and to\r\n   permit persons to whom the Software is furnished to do so, subject to\r\n   the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be\r\n   included in all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   */\n  function seedRandom(pool, math) {\n    //\n    // The following constants are related to IEEE 754 limits.\n    //\n    var global = this,\n        width = 256,\n        // each RC4 output is 0 <= x < 256\n    chunks = 6,\n        // at least six RC4 outputs for each double\n    digits = 52,\n        // there are 52 significant digits in a double\n    rngname = 'random',\n        // rngname: name for Math.random and Math.seedrandom\n    startdenom = math.pow(width, chunks),\n        significance = math.pow(2, digits),\n        overflow = significance * 2,\n        mask = width - 1,\n        nodecrypto; // node.js crypto module, initialized at the bottom.\n    //\n    // seedrandom()\n    // This is the seedrandom function described above.\n    //\n\n    function seedrandom(seed, options, callback) {\n      var key = [];\n      options = options === true ? {\n        entropy: true\n      } : options || {}; // Flatten the seed string or build one from local entropy if needed.\n\n      var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : seed === null ? autoseed() : seed, 3), key); // Use the seed to initialize an ARC4 generator.\n\n      var arc4 = new ARC4(key); // This function returns a random double in [0, 1) that contains\n      // randomness in every bit of the mantissa of the IEEE 754 value.\n\n      var prng = function prng() {\n        var n = arc4.g(chunks),\n            // Start with a numerator n < 2 ^ 48\n        d = startdenom,\n            //   and denominator d = 2 ^ 48.\n        x = 0; //   and no 'extra last byte'.\n\n        while (n < significance) {\n          // Fill up all significant digits by\n          n = (n + x) * width; //   shifting numerator and\n\n          d *= width; //   denominator and generating a\n\n          x = arc4.g(1); //   new least-significant-byte.\n        }\n\n        while (n >= overflow) {\n          // To avoid rounding up, before adding\n          n /= 2; //   last byte, shift everything\n\n          d /= 2; //   right using integer math until\n\n          x >>>= 1; //   we have exactly the desired bits.\n        }\n\n        return (n + x) / d; // Form the number within [0, 1).\n      };\n\n      prng.int32 = function () {\n        return arc4.g(4) | 0;\n      };\n\n      prng.quick = function () {\n        return arc4.g(4) / 0x100000000;\n      };\n\n      prng[\"double\"] = prng; // Mix the randomness into accumulated entropy.\n\n      mixkey(tostring(arc4.S), pool); // Calling convention: what to return as a function of prng, seed, is_math.\n\n      return (options.pass || callback || function (prng, seed, is_math_call, state) {\n        if (state) {\n          // Load the arc4 state from the given state if it has an S array.\n          if (state.S) {\n            copy(state, arc4);\n          } // Only provide the .state method if requested via options.state.\n\n\n          prng.state = function () {\n            return copy(arc4, {});\n          };\n        } // If called as a method of Math (Math.seedrandom()), mutate\n        // Math.random because that is how seedrandom.js has worked since v1.0.\n\n\n        if (is_math_call) {\n          math[rngname] = prng;\n          return seed;\n        } // Otherwise, it is a newer calling convention, so return the\n        // prng directly.\n        else return prng;\n      })(prng, shortseed, 'global' in options ? options.global : this == math, options.state);\n    }\n\n    math['seed' + rngname] = seedrandom; //\n    // ARC4\n    //\n    // An ARC4 implementation.  The constructor takes a key in the form of\n    // an array of at most (width) integers that should be 0 <= x < (width).\n    //\n    // The g(count) method returns a pseudorandom integer that concatenates\n    // the next (count) outputs from ARC4.  Its return value is a number x\n    // that is in the range 0 <= x < (width ^ count).\n    //\n\n    function ARC4(key) {\n      var t,\n          keylen = key.length,\n          me = this,\n          i = 0,\n          j = me.i = me.j = 0,\n          s = me.S = []; // The empty key [] is treated as [0].\n\n      if (!keylen) {\n        key = [keylen++];\n      } // Set up S using the standard key scheduling algorithm.\n\n\n      while (i < width) {\n        s[i] = i++;\n      }\n\n      for (i = 0; i < width; i++) {\n        s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];\n        s[j] = t;\n      } // The \"g\" method returns the next (count) outputs as one number.\n\n\n      me.g = function (count) {\n        // Using instance members instead of closure state nearly doubles speed.\n        var t,\n            r = 0,\n            i = me.i,\n            j = me.j,\n            s = me.S;\n\n        while (count--) {\n          t = s[i = mask & i + 1];\n          r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];\n        }\n\n        me.i = i;\n        me.j = j;\n        return r; // For robust unpredictability, the function call below automatically\n        // discards an initial batch of values.  This is called RC4-drop[256].\n        // See http://google.com/search?q=rsa+fluhrer+response&btnI\n      };\n    } //\n    // copy()\n    // Copies internal state of ARC4 to or from a plain object.\n    //\n\n\n    function copy(f, t) {\n      t.i = f.i;\n      t.j = f.j;\n      t.S = f.S.slice();\n      return t;\n    } //\n    // flatten()\n    // Converts an object tree to nested arrays of strings.\n    //\n\n\n    function flatten(obj, depth) {\n      var result = [],\n          typ = _typeof$2(obj),\n          prop;\n\n      if (depth && typ == 'object') {\n        for (prop in obj) {\n          try {\n            result.push(flatten(obj[prop], depth - 1));\n          } catch (e) {}\n        }\n      }\n\n      return result.length ? result : typ == 'string' ? obj : obj + '\\0';\n    } //\n    // mixkey()\n    // Mixes a string seed into a key that is an array of integers, and\n    // returns a shortened string seed that is equivalent to the result key.\n    //\n\n\n    function mixkey(seed, key) {\n      var stringseed = seed + '',\n          smear,\n          j = 0;\n\n      while (j < stringseed.length) {\n        key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);\n      }\n\n      return tostring(key);\n    } //\n    // autoseed()\n    // Returns an object for autoseeding, using window.crypto and Node crypto\n    // module if available.\n    //\n\n\n    function autoseed() {\n      try {\n        if (nodecrypto) {\n          return tostring(nodecrypto.randomBytes(width));\n        }\n\n        var out = new Uint8Array(width);\n        (global.crypto || global.msCrypto).getRandomValues(out);\n        return tostring(out);\n      } catch (e) {\n        var browser = global.navigator,\n            plugins = browser && browser.plugins;\n        return [+new Date(), global, plugins, global.screen, tostring(pool)];\n      }\n    } //\n    // tostring()\n    // Converts an array of charcodes to a string\n    //\n\n\n    function tostring(a) {\n      return String.fromCharCode.apply(0, a);\n    } //\n    // When seedrandom.js is loaded, we immediately mix a few bits\n    // from the built-in RNG into the entropy pool.  Because we do\n    // not want to interfere with deterministic PRNG state later,\n    // seedrandom will not call math.random on its own again after\n    // initialization.\n    //\n\n\n    mixkey(math.random(), pool); //\n    // Nodejs and AMD support: export the implementation as a module using\n    // either convention.\n    //\n    // End anonymous scope, and pass initial values.\n  }\n\n  ;\n\n  function initialize$2(BMMath) {\n    seedRandom([], BMMath);\n  }\n\n  var propTypes = {\n    SHAPE: 'shape'\n  };\n\n  function _typeof$1(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof$1(obj); }\n\n  var ExpressionManager = function () {\n    'use strict';\n\n    var ob = {};\n    var Math = BMMath;\n    var window = null;\n    var document = null;\n    var XMLHttpRequest = null;\n    var fetch = null;\n    var frames = null;\n    var _lottieGlobal = {};\n    initialize$2(BMMath);\n\n    function resetFrame() {\n      _lottieGlobal = {};\n    }\n\n    function $bm_isInstanceOfArray(arr) {\n      return arr.constructor === Array || arr.constructor === Float32Array;\n    }\n\n    function isNumerable(tOfV, v) {\n      return tOfV === 'number' || v instanceof Number || tOfV === 'boolean' || tOfV === 'string';\n    }\n\n    function $bm_neg(a) {\n      var tOfA = _typeof$1(a);\n\n      if (tOfA === 'number' || a instanceof Number || tOfA === 'boolean') {\n        return -a;\n      }\n\n      if ($bm_isInstanceOfArray(a)) {\n        var i;\n        var lenA = a.length;\n        var retArr = [];\n\n        for (i = 0; i < lenA; i += 1) {\n          retArr[i] = -a[i];\n        }\n\n        return retArr;\n      }\n\n      if (a.propType) {\n        return a.v;\n      }\n\n      return -a;\n    }\n\n    var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, 'easeIn').get;\n    var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, 'easeOut').get;\n    var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, 'easeInOut').get;\n\n    function sum(a, b) {\n      var tOfA = _typeof$1(a);\n\n      var tOfB = _typeof$1(b);\n\n      if (isNumerable(tOfA, a) && isNumerable(tOfB, b) || tOfA === 'string' || tOfB === 'string') {\n        return a + b;\n      }\n\n      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n        a = a.slice(0);\n        a[0] += b;\n        return a;\n      }\n\n      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n        b = b.slice(0);\n        b[0] = a + b[0];\n        return b;\n      }\n\n      if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {\n        var i = 0;\n        var lenA = a.length;\n        var lenB = b.length;\n        var retArr = [];\n\n        while (i < lenA || i < lenB) {\n          if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {\n            retArr[i] = a[i] + b[i];\n          } else {\n            retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];\n          }\n\n          i += 1;\n        }\n\n        return retArr;\n      }\n\n      return 0;\n    }\n\n    var add = sum;\n\n    function sub(a, b) {\n      var tOfA = _typeof$1(a);\n\n      var tOfB = _typeof$1(b);\n\n      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n        if (tOfA === 'string') {\n          a = parseInt(a, 10);\n        }\n\n        if (tOfB === 'string') {\n          b = parseInt(b, 10);\n        }\n\n        return a - b;\n      }\n\n      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n        a = a.slice(0);\n        a[0] -= b;\n        return a;\n      }\n\n      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n        b = b.slice(0);\n        b[0] = a - b[0];\n        return b;\n      }\n\n      if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {\n        var i = 0;\n        var lenA = a.length;\n        var lenB = b.length;\n        var retArr = [];\n\n        while (i < lenA || i < lenB) {\n          if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {\n            retArr[i] = a[i] - b[i];\n          } else {\n            retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];\n          }\n\n          i += 1;\n        }\n\n        return retArr;\n      }\n\n      return 0;\n    }\n\n    function mul(a, b) {\n      var tOfA = _typeof$1(a);\n\n      var tOfB = _typeof$1(b);\n\n      var arr;\n\n      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n        return a * b;\n      }\n\n      var i;\n      var len;\n\n      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n        len = a.length;\n        arr = createTypedArray('float32', len);\n\n        for (i = 0; i < len; i += 1) {\n          arr[i] = a[i] * b;\n        }\n\n        return arr;\n      }\n\n      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n        len = b.length;\n        arr = createTypedArray('float32', len);\n\n        for (i = 0; i < len; i += 1) {\n          arr[i] = a * b[i];\n        }\n\n        return arr;\n      }\n\n      return 0;\n    }\n\n    function div(a, b) {\n      var tOfA = _typeof$1(a);\n\n      var tOfB = _typeof$1(b);\n\n      var arr;\n\n      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n        return a / b;\n      }\n\n      var i;\n      var len;\n\n      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n        len = a.length;\n        arr = createTypedArray('float32', len);\n\n        for (i = 0; i < len; i += 1) {\n          arr[i] = a[i] / b;\n        }\n\n        return arr;\n      }\n\n      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n        len = b.length;\n        arr = createTypedArray('float32', len);\n\n        for (i = 0; i < len; i += 1) {\n          arr[i] = a / b[i];\n        }\n\n        return arr;\n      }\n\n      return 0;\n    }\n\n    function mod(a, b) {\n      if (typeof a === 'string') {\n        a = parseInt(a, 10);\n      }\n\n      if (typeof b === 'string') {\n        b = parseInt(b, 10);\n      }\n\n      return a % b;\n    }\n\n    var $bm_sum = sum;\n    var $bm_sub = sub;\n    var $bm_mul = mul;\n    var $bm_div = div;\n    var $bm_mod = mod;\n\n    function clamp(num, min, max) {\n      if (min > max) {\n        var mm = max;\n        max = min;\n        min = mm;\n      }\n\n      return Math.min(Math.max(num, min), max);\n    }\n\n    function radiansToDegrees(val) {\n      return val / degToRads;\n    }\n\n    var radians_to_degrees = radiansToDegrees;\n\n    function degreesToRadians(val) {\n      return val * degToRads;\n    }\n\n    var degrees_to_radians = radiansToDegrees;\n    var helperLengthArray = [0, 0, 0, 0, 0, 0];\n\n    function length(arr1, arr2) {\n      if (typeof arr1 === 'number' || arr1 instanceof Number) {\n        arr2 = arr2 || 0;\n        return Math.abs(arr1 - arr2);\n      }\n\n      if (!arr2) {\n        arr2 = helperLengthArray;\n      }\n\n      var i;\n      var len = Math.min(arr1.length, arr2.length);\n      var addedLength = 0;\n\n      for (i = 0; i < len; i += 1) {\n        addedLength += Math.pow(arr2[i] - arr1[i], 2);\n      }\n\n      return Math.sqrt(addedLength);\n    }\n\n    function normalize(vec) {\n      return div(vec, length(vec));\n    }\n\n    function rgbToHsl(val) {\n      var r = val[0];\n      var g = val[1];\n      var b = val[2];\n      var max = Math.max(r, g, b);\n      var min = Math.min(r, g, b);\n      var h;\n      var s;\n      var l = (max + min) / 2;\n\n      if (max === min) {\n        h = 0; // achromatic\n\n        s = 0; // achromatic\n      } else {\n        var d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n        switch (max) {\n          case r:\n            h = (g - b) / d + (g < b ? 6 : 0);\n            break;\n\n          case g:\n            h = (b - r) / d + 2;\n            break;\n\n          case b:\n            h = (r - g) / d + 4;\n            break;\n\n          default:\n            break;\n        }\n\n        h /= 6;\n      }\n\n      return [h, s, l, val[3]];\n    }\n\n    function hue2rgb(p, q, t) {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p + (q - p) * 6 * t;\n      if (t < 1 / 2) return q;\n      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    }\n\n    function hslToRgb(val) {\n      var h = val[0];\n      var s = val[1];\n      var l = val[2];\n      var r;\n      var g;\n      var b;\n\n      if (s === 0) {\n        r = l; // achromatic\n\n        b = l; // achromatic\n\n        g = l; // achromatic\n      } else {\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        var p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n      }\n\n      return [r, g, b, val[3]];\n    }\n\n    function linear(t, tMin, tMax, value1, value2) {\n      if (value1 === undefined || value2 === undefined) {\n        value1 = tMin;\n        value2 = tMax;\n        tMin = 0;\n        tMax = 1;\n      }\n\n      if (tMax < tMin) {\n        var _tMin = tMax;\n        tMax = tMin;\n        tMin = _tMin;\n      }\n\n      if (t <= tMin) {\n        return value1;\n      }\n\n      if (t >= tMax) {\n        return value2;\n      }\n\n      var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);\n\n      if (!value1.length) {\n        return value1 + (value2 - value1) * perc;\n      }\n\n      var i;\n      var len = value1.length;\n      var arr = createTypedArray('float32', len);\n\n      for (i = 0; i < len; i += 1) {\n        arr[i] = value1[i] + (value2[i] - value1[i]) * perc;\n      }\n\n      return arr;\n    }\n\n    function random(min, max) {\n      if (max === undefined) {\n        if (min === undefined) {\n          min = 0;\n          max = 1;\n        } else {\n          max = min;\n          min = undefined;\n        }\n      }\n\n      if (max.length) {\n        var i;\n        var len = max.length;\n\n        if (!min) {\n          min = createTypedArray('float32', len);\n        }\n\n        var arr = createTypedArray('float32', len);\n        var rnd = BMMath.random();\n\n        for (i = 0; i < len; i += 1) {\n          arr[i] = min[i] + rnd * (max[i] - min[i]);\n        }\n\n        return arr;\n      }\n\n      if (min === undefined) {\n        min = 0;\n      }\n\n      var rndm = BMMath.random();\n      return min + rndm * (max - min);\n    }\n\n    function createPath(points, inTangents, outTangents, closed) {\n      var i;\n      var len = points.length;\n      var path = shapePool.newElement();\n      path.setPathData(!!closed, len);\n      var arrPlaceholder = [0, 0];\n      var inVertexPoint;\n      var outVertexPoint;\n\n      for (i = 0; i < len; i += 1) {\n        inVertexPoint = inTangents && inTangents[i] ? inTangents[i] : arrPlaceholder;\n        outVertexPoint = outTangents && outTangents[i] ? outTangents[i] : arrPlaceholder;\n        path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, true);\n      }\n\n      return path;\n    }\n\n    function initiateExpression(elem, data, property) {\n      // Bail out if we don't want expressions\n      function noOp(_value) {\n        return _value;\n      }\n\n      if (!elem.globalData.renderConfig.runExpressions) {\n        return noOp;\n      }\n\n      var val = data.x;\n      var needsVelocity = /velocity(?![\\w\\d])/.test(val);\n\n      var _needsRandom = val.indexOf('random') !== -1;\n\n      var elemType = elem.data.ty;\n      var transform;\n      var $bm_transform;\n      var content;\n      var effect;\n      var thisProperty = property;\n      thisProperty.valueAtTime = thisProperty.getValueAtTime;\n      Object.defineProperty(thisProperty, 'value', {\n        get: function get() {\n          return thisProperty.v;\n        }\n      });\n      elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;\n      elem.comp.displayStartTime = 0;\n      var inPoint = elem.data.ip / elem.comp.globalData.frameRate;\n      var outPoint = elem.data.op / elem.comp.globalData.frameRate;\n      var width = elem.data.sw ? elem.data.sw : 0;\n      var height = elem.data.sh ? elem.data.sh : 0;\n      var name = elem.data.nm;\n      var loopIn;\n      var loop_in;\n      var loopOut;\n      var loop_out;\n      var smooth;\n      var toWorld;\n      var fromWorld;\n      var fromComp;\n      var toComp;\n      var fromCompToSurface;\n      var position;\n      var rotation;\n      var anchorPoint;\n      var scale;\n      var thisLayer;\n      var thisComp;\n      var mask;\n      var valueAtTime;\n      var velocityAtTime;\n      var scoped_bm_rt; // val = val.replace(/(\\\\?\"|')((http)(s)?(:\\/))?\\/.*?(\\\\?\"|')/g, \"\\\"\\\"\"); // deter potential network calls\n\n      var expression_function = eval('[function _expression_function(){' + val + ';scoped_bm_rt=$bm_rt}]')[0]; // eslint-disable-line no-eval\n\n      var numKeys = property.kf ? data.k.length : 0;\n      var active = !this.data || this.data.hd !== true;\n\n      var wiggle = function wiggle(freq, amp) {\n        var iWiggle;\n        var j;\n        var lenWiggle = this.pv.length ? this.pv.length : 1;\n        var addedAmps = createTypedArray('float32', lenWiggle);\n        freq = 5;\n        var iterations = Math.floor(time * freq);\n        iWiggle = 0;\n        j = 0;\n\n        while (iWiggle < iterations) {\n          // var rnd = BMMath.random();\n          for (j = 0; j < lenWiggle; j += 1) {\n            addedAmps[j] += -amp + amp * 2 * BMMath.random(); // addedAmps[j] += -amp + amp*2*rnd;\n          }\n\n          iWiggle += 1;\n        } // var rnd2 = BMMath.random();\n\n\n        var periods = time * freq;\n        var perc = periods - Math.floor(periods);\n        var arr = createTypedArray('float32', lenWiggle);\n\n        if (lenWiggle > 1) {\n          for (j = 0; j < lenWiggle; j += 1) {\n            arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc; // arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;\n            // arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);\n          }\n\n          return arr;\n        }\n\n        return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;\n      }.bind(this);\n\n      if (thisProperty.loopIn) {\n        loopIn = thisProperty.loopIn.bind(thisProperty);\n        loop_in = loopIn;\n      }\n\n      if (thisProperty.loopOut) {\n        loopOut = thisProperty.loopOut.bind(thisProperty);\n        loop_out = loopOut;\n      }\n\n      if (thisProperty.smooth) {\n        smooth = thisProperty.smooth.bind(thisProperty);\n      }\n\n      function loopInDuration(type, duration) {\n        return loopIn(type, duration, true);\n      }\n\n      function loopOutDuration(type, duration) {\n        return loopOut(type, duration, true);\n      }\n\n      if (this.getValueAtTime) {\n        valueAtTime = this.getValueAtTime.bind(this);\n      }\n\n      if (this.getVelocityAtTime) {\n        velocityAtTime = this.getVelocityAtTime.bind(this);\n      }\n\n      var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);\n\n      function lookAt(elem1, elem2) {\n        var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]];\n        var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;\n        var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;\n        return [yaw, pitch, 0];\n      }\n\n      function easeOut(t, tMin, tMax, val1, val2) {\n        return applyEase(easeOutBez, t, tMin, tMax, val1, val2);\n      }\n\n      function easeIn(t, tMin, tMax, val1, val2) {\n        return applyEase(easeInBez, t, tMin, tMax, val1, val2);\n      }\n\n      function ease(t, tMin, tMax, val1, val2) {\n        return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);\n      }\n\n      function applyEase(fn, t, tMin, tMax, val1, val2) {\n        if (val1 === undefined) {\n          val1 = tMin;\n          val2 = tMax;\n        } else {\n          t = (t - tMin) / (tMax - tMin);\n        }\n\n        if (t > 1) {\n          t = 1;\n        } else if (t < 0) {\n          t = 0;\n        }\n\n        var mult = fn(t);\n\n        if ($bm_isInstanceOfArray(val1)) {\n          var iKey;\n          var lenKey = val1.length;\n          var arr = createTypedArray('float32', lenKey);\n\n          for (iKey = 0; iKey < lenKey; iKey += 1) {\n            arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];\n          }\n\n          return arr;\n        }\n\n        return (val2 - val1) * mult + val1;\n      }\n\n      function nearestKey(time) {\n        var iKey;\n        var lenKey = data.k.length;\n        var index;\n        var keyTime;\n\n        if (!data.k.length || typeof data.k[0] === 'number') {\n          index = 0;\n          keyTime = 0;\n        } else {\n          index = -1;\n          time *= elem.comp.globalData.frameRate;\n\n          if (time < data.k[0].t) {\n            index = 1;\n            keyTime = data.k[0].t;\n          } else {\n            for (iKey = 0; iKey < lenKey - 1; iKey += 1) {\n              if (time === data.k[iKey].t) {\n                index = iKey + 1;\n                keyTime = data.k[iKey].t;\n                break;\n              } else if (time > data.k[iKey].t && time < data.k[iKey + 1].t) {\n                if (time - data.k[iKey].t > data.k[iKey + 1].t - time) {\n                  index = iKey + 2;\n                  keyTime = data.k[iKey + 1].t;\n                } else {\n                  index = iKey + 1;\n                  keyTime = data.k[iKey].t;\n                }\n\n                break;\n              }\n            }\n\n            if (index === -1) {\n              index = iKey + 1;\n              keyTime = data.k[iKey].t;\n            }\n          }\n        }\n\n        var obKey = {};\n        obKey.index = index;\n        obKey.time = keyTime / elem.comp.globalData.frameRate;\n        return obKey;\n      }\n\n      function key(ind) {\n        var obKey;\n        var iKey;\n        var lenKey;\n\n        if (!data.k.length || typeof data.k[0] === 'number') {\n          throw new Error('The property has no keyframe at index ' + ind);\n        }\n\n        ind -= 1;\n        obKey = {\n          time: data.k[ind].t / elem.comp.globalData.frameRate,\n          value: []\n        };\n        var arr = Object.prototype.hasOwnProperty.call(data.k[ind], 's') ? data.k[ind].s : data.k[ind - 1].e;\n        lenKey = arr.length;\n\n        for (iKey = 0; iKey < lenKey; iKey += 1) {\n          obKey[iKey] = arr[iKey];\n          obKey.value[iKey] = arr[iKey];\n        }\n\n        return obKey;\n      }\n\n      function framesToTime(fr, fps) {\n        if (!fps) {\n          fps = elem.comp.globalData.frameRate;\n        }\n\n        return fr / fps;\n      }\n\n      function timeToFrames(t, fps) {\n        if (!t && t !== 0) {\n          t = time;\n        }\n\n        if (!fps) {\n          fps = elem.comp.globalData.frameRate;\n        }\n\n        return t * fps;\n      }\n\n      function seedRandom(seed) {\n        BMMath.seedrandom(randSeed + seed);\n      }\n\n      function sourceRectAtTime() {\n        return elem.sourceRectAtTime();\n      }\n\n      function substring(init, end) {\n        if (typeof value === 'string') {\n          if (end === undefined) {\n            return value.substring(init);\n          }\n\n          return value.substring(init, end);\n        }\n\n        return '';\n      }\n\n      function substr(init, end) {\n        if (typeof value === 'string') {\n          if (end === undefined) {\n            return value.substr(init);\n          }\n\n          return value.substr(init, end);\n        }\n\n        return '';\n      }\n\n      function posterizeTime(framesPerSecond) {\n        time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;\n        value = valueAtTime(time);\n      }\n\n      var time;\n      var velocity;\n      var value;\n      var text;\n      var textIndex;\n      var textTotal;\n      var selectorValue;\n      var index = elem.data.ind;\n      var hasParent = !!(elem.hierarchy && elem.hierarchy.length);\n      var parent;\n      var randSeed = Math.floor(Math.random() * 1000000);\n      var globalData = elem.globalData;\n\n      function executeExpression(_value) {\n        // globalData.pushExpression();\n        value = _value;\n\n        if (this.frameExpressionId === elem.globalData.frameId && this.propType !== 'textSelector') {\n          return value;\n        }\n\n        if (this.propType === 'textSelector') {\n          textIndex = this.textIndex;\n          textTotal = this.textTotal;\n          selectorValue = this.selectorValue;\n        }\n\n        if (!thisLayer) {\n          text = elem.layerInterface.text;\n          thisLayer = elem.layerInterface;\n          thisComp = elem.comp.compInterface;\n          toWorld = thisLayer.toWorld.bind(thisLayer);\n          fromWorld = thisLayer.fromWorld.bind(thisLayer);\n          fromComp = thisLayer.fromComp.bind(thisLayer);\n          toComp = thisLayer.toComp.bind(thisLayer);\n          mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;\n          fromCompToSurface = fromComp;\n        }\n\n        if (!transform) {\n          transform = elem.layerInterface('ADBE Transform Group');\n          $bm_transform = transform;\n\n          if (transform) {\n            anchorPoint = transform.anchorPoint;\n            /* position = transform.position;\r\n                      rotation = transform.rotation;\r\n                      scale = transform.scale; */\n          }\n        }\n\n        if (elemType === 4 && !content) {\n          content = thisLayer('ADBE Root Vectors Group');\n        }\n\n        if (!effect) {\n          effect = thisLayer(4);\n        }\n\n        hasParent = !!(elem.hierarchy && elem.hierarchy.length);\n\n        if (hasParent && !parent) {\n          parent = elem.hierarchy[0].layerInterface;\n        }\n\n        time = this.comp.renderedFrame / this.comp.globalData.frameRate;\n\n        if (_needsRandom) {\n          seedRandom(randSeed + time);\n        }\n\n        if (needsVelocity) {\n          velocity = velocityAtTime(time);\n        }\n\n        expression_function();\n        this.frameExpressionId = elem.globalData.frameId; // TODO: Check if it's possible to return on ShapeInterface the .v value\n        // Changed this to a ternary operation because Rollup failed compiling it correctly\n\n        scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt;\n        return scoped_bm_rt;\n      } // Bundlers will see these as dead code and unless we reference them\n\n\n      executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData];\n      return executeExpression;\n    }\n\n    ob.initiateExpression = initiateExpression;\n    ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal];\n    ob.resetFrame = resetFrame;\n    return ob;\n  }();\n\n  var Expressions = function () {\n    var ob = {};\n    ob.initExpressions = initExpressions;\n    ob.resetFrame = ExpressionManager.resetFrame;\n\n    function initExpressions(animation) {\n      var stackCount = 0;\n      var registers = [];\n\n      function pushExpression() {\n        stackCount += 1;\n      }\n\n      function popExpression() {\n        stackCount -= 1;\n\n        if (stackCount === 0) {\n          releaseInstances();\n        }\n      }\n\n      function registerExpressionProperty(expression) {\n        if (registers.indexOf(expression) === -1) {\n          registers.push(expression);\n        }\n      }\n\n      function releaseInstances() {\n        var i;\n        var len = registers.length;\n\n        for (i = 0; i < len; i += 1) {\n          registers[i].release();\n        }\n\n        registers.length = 0;\n      }\n\n      animation.renderer.compInterface = CompExpressionInterface(animation.renderer);\n      animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);\n      animation.renderer.globalData.pushExpression = pushExpression;\n      animation.renderer.globalData.popExpression = popExpression;\n      animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;\n    }\n\n    return ob;\n  }();\n\n  var MaskManagerInterface = function () {\n    function MaskInterface(mask, data) {\n      this._mask = mask;\n      this._data = data;\n    }\n\n    Object.defineProperty(MaskInterface.prototype, 'maskPath', {\n      get: function get() {\n        if (this._mask.prop.k) {\n          this._mask.prop.getValue();\n        }\n\n        return this._mask.prop;\n      }\n    });\n    Object.defineProperty(MaskInterface.prototype, 'maskOpacity', {\n      get: function get() {\n        if (this._mask.op.k) {\n          this._mask.op.getValue();\n        }\n\n        return this._mask.op.v * 100;\n      }\n    });\n\n    var MaskManager = function MaskManager(maskManager) {\n      var _masksInterfaces = createSizedArray(maskManager.viewData.length);\n\n      var i;\n      var len = maskManager.viewData.length;\n\n      for (i = 0; i < len; i += 1) {\n        _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);\n      }\n\n      var maskFunction = function maskFunction(name) {\n        i = 0;\n\n        while (i < len) {\n          if (maskManager.masksProperties[i].nm === name) {\n            return _masksInterfaces[i];\n          }\n\n          i += 1;\n        }\n\n        return null;\n      };\n\n      return maskFunction;\n    };\n\n    return MaskManager;\n  }();\n\n  var ExpressionPropertyInterface = function () {\n    var defaultUnidimensionalValue = {\n      pv: 0,\n      v: 0,\n      mult: 1\n    };\n    var defaultMultidimensionalValue = {\n      pv: [0, 0, 0],\n      v: [0, 0, 0],\n      mult: 1\n    };\n\n    function completeProperty(expressionValue, property, type) {\n      Object.defineProperty(expressionValue, 'velocity', {\n        get: function get() {\n          return property.getVelocityAtTime(property.comp.currentFrame);\n        }\n      });\n      expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;\n\n      expressionValue.key = function (pos) {\n        if (!expressionValue.numKeys) {\n          return 0;\n        }\n\n        var value = '';\n\n        if ('s' in property.keyframes[pos - 1]) {\n          value = property.keyframes[pos - 1].s;\n        } else if ('e' in property.keyframes[pos - 2]) {\n          value = property.keyframes[pos - 2].e;\n        } else {\n          value = property.keyframes[pos - 2].s;\n        }\n\n        var valueProp = type === 'unidimensional' ? new Number(value) : Object.assign({}, value); // eslint-disable-line no-new-wrappers\n\n        valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate;\n        valueProp.value = type === 'unidimensional' ? value[0] : value;\n        return valueProp;\n      };\n\n      expressionValue.valueAtTime = property.getValueAtTime;\n      expressionValue.speedAtTime = property.getSpeedAtTime;\n      expressionValue.velocityAtTime = property.getVelocityAtTime;\n      expressionValue.propertyGroup = property.propertyGroup;\n    }\n\n    function UnidimensionalPropertyInterface(property) {\n      if (!property || !('pv' in property)) {\n        property = defaultUnidimensionalValue;\n      }\n\n      var mult = 1 / property.mult;\n      var val = property.pv * mult;\n      var expressionValue = new Number(val); // eslint-disable-line no-new-wrappers\n\n      expressionValue.value = val;\n      completeProperty(expressionValue, property, 'unidimensional');\n      return function () {\n        if (property.k) {\n          property.getValue();\n        }\n\n        val = property.v * mult;\n\n        if (expressionValue.value !== val) {\n          expressionValue = new Number(val); // eslint-disable-line no-new-wrappers\n\n          expressionValue.value = val;\n          completeProperty(expressionValue, property, 'unidimensional');\n        }\n\n        return expressionValue;\n      };\n    }\n\n    function MultidimensionalPropertyInterface(property) {\n      if (!property || !('pv' in property)) {\n        property = defaultMultidimensionalValue;\n      }\n\n      var mult = 1 / property.mult;\n      var len = property.data && property.data.l || property.pv.length;\n      var expressionValue = createTypedArray('float32', len);\n      var arrValue = createTypedArray('float32', len);\n      expressionValue.value = arrValue;\n      completeProperty(expressionValue, property, 'multidimensional');\n      return function () {\n        if (property.k) {\n          property.getValue();\n        }\n\n        for (var i = 0; i < len; i += 1) {\n          arrValue[i] = property.v[i] * mult;\n          expressionValue[i] = arrValue[i];\n        }\n\n        return expressionValue;\n      };\n    } // TODO: try to avoid using this getter\n\n\n    function defaultGetter() {\n      return defaultUnidimensionalValue;\n    }\n\n    return function (property) {\n      if (!property) {\n        return defaultGetter;\n      }\n\n      if (property.propType === 'unidimensional') {\n        return UnidimensionalPropertyInterface(property);\n      }\n\n      return MultidimensionalPropertyInterface(property);\n    };\n  }();\n\n  var TransformExpressionInterface = function () {\n    return function (transform) {\n      function _thisFunction(name) {\n        switch (name) {\n          case 'scale':\n          case 'Scale':\n          case 'ADBE Scale':\n          case 6:\n            return _thisFunction.scale;\n\n          case 'rotation':\n          case 'Rotation':\n          case 'ADBE Rotation':\n          case 'ADBE Rotate Z':\n          case 10:\n            return _thisFunction.rotation;\n\n          case 'ADBE Rotate X':\n            return _thisFunction.xRotation;\n\n          case 'ADBE Rotate Y':\n            return _thisFunction.yRotation;\n\n          case 'position':\n          case 'Position':\n          case 'ADBE Position':\n          case 2:\n            return _thisFunction.position;\n\n          case 'ADBE Position_0':\n            return _thisFunction.xPosition;\n\n          case 'ADBE Position_1':\n            return _thisFunction.yPosition;\n\n          case 'ADBE Position_2':\n            return _thisFunction.zPosition;\n\n          case 'anchorPoint':\n          case 'AnchorPoint':\n          case 'Anchor Point':\n          case 'ADBE AnchorPoint':\n          case 1:\n            return _thisFunction.anchorPoint;\n\n          case 'opacity':\n          case 'Opacity':\n          case 11:\n            return _thisFunction.opacity;\n\n          default:\n            return null;\n        }\n      }\n\n      Object.defineProperty(_thisFunction, 'rotation', {\n        get: ExpressionPropertyInterface(transform.r || transform.rz)\n      });\n      Object.defineProperty(_thisFunction, 'zRotation', {\n        get: ExpressionPropertyInterface(transform.rz || transform.r)\n      });\n      Object.defineProperty(_thisFunction, 'xRotation', {\n        get: ExpressionPropertyInterface(transform.rx)\n      });\n      Object.defineProperty(_thisFunction, 'yRotation', {\n        get: ExpressionPropertyInterface(transform.ry)\n      });\n      Object.defineProperty(_thisFunction, 'scale', {\n        get: ExpressionPropertyInterface(transform.s)\n      });\n\n      var _px;\n\n      var _py;\n\n      var _pz;\n\n      var _transformFactory;\n\n      if (transform.p) {\n        _transformFactory = ExpressionPropertyInterface(transform.p);\n      } else {\n        _px = ExpressionPropertyInterface(transform.px);\n        _py = ExpressionPropertyInterface(transform.py);\n\n        if (transform.pz) {\n          _pz = ExpressionPropertyInterface(transform.pz);\n        }\n      }\n\n      Object.defineProperty(_thisFunction, 'position', {\n        get: function get() {\n          if (transform.p) {\n            return _transformFactory();\n          }\n\n          return [_px(), _py(), _pz ? _pz() : 0];\n        }\n      });\n      Object.defineProperty(_thisFunction, 'xPosition', {\n        get: ExpressionPropertyInterface(transform.px)\n      });\n      Object.defineProperty(_thisFunction, 'yPosition', {\n        get: ExpressionPropertyInterface(transform.py)\n      });\n      Object.defineProperty(_thisFunction, 'zPosition', {\n        get: ExpressionPropertyInterface(transform.pz)\n      });\n      Object.defineProperty(_thisFunction, 'anchorPoint', {\n        get: ExpressionPropertyInterface(transform.a)\n      });\n      Object.defineProperty(_thisFunction, 'opacity', {\n        get: ExpressionPropertyInterface(transform.o)\n      });\n      Object.defineProperty(_thisFunction, 'skew', {\n        get: ExpressionPropertyInterface(transform.sk)\n      });\n      Object.defineProperty(_thisFunction, 'skewAxis', {\n        get: ExpressionPropertyInterface(transform.sa)\n      });\n      Object.defineProperty(_thisFunction, 'orientation', {\n        get: ExpressionPropertyInterface(transform.or)\n      });\n      return _thisFunction;\n    };\n  }();\n\n  var LayerExpressionInterface = function () {\n    function getMatrix(time) {\n      var toWorldMat = new Matrix();\n\n      if (time !== undefined) {\n        var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time);\n\n        propMatrix.clone(toWorldMat);\n      } else {\n        var transformMat = this._elem.finalTransform.mProp;\n        transformMat.applyToMatrix(toWorldMat);\n      }\n\n      return toWorldMat;\n    }\n\n    function toWorldVec(arr, time) {\n      var toWorldMat = this.getMatrix(time);\n      toWorldMat.props[12] = 0;\n      toWorldMat.props[13] = 0;\n      toWorldMat.props[14] = 0;\n      return this.applyPoint(toWorldMat, arr);\n    }\n\n    function toWorld(arr, time) {\n      var toWorldMat = this.getMatrix(time);\n      return this.applyPoint(toWorldMat, arr);\n    }\n\n    function fromWorldVec(arr, time) {\n      var toWorldMat = this.getMatrix(time);\n      toWorldMat.props[12] = 0;\n      toWorldMat.props[13] = 0;\n      toWorldMat.props[14] = 0;\n      return this.invertPoint(toWorldMat, arr);\n    }\n\n    function fromWorld(arr, time) {\n      var toWorldMat = this.getMatrix(time);\n      return this.invertPoint(toWorldMat, arr);\n    }\n\n    function applyPoint(matrix, arr) {\n      if (this._elem.hierarchy && this._elem.hierarchy.length) {\n        var i;\n        var len = this._elem.hierarchy.length;\n\n        for (i = 0; i < len; i += 1) {\n          this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);\n        }\n      }\n\n      return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);\n    }\n\n    function invertPoint(matrix, arr) {\n      if (this._elem.hierarchy && this._elem.hierarchy.length) {\n        var i;\n        var len = this._elem.hierarchy.length;\n\n        for (i = 0; i < len; i += 1) {\n          this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);\n        }\n      }\n\n      return matrix.inversePoint(arr);\n    }\n\n    function fromComp(arr) {\n      var toWorldMat = new Matrix();\n      toWorldMat.reset();\n\n      this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);\n\n      if (this._elem.hierarchy && this._elem.hierarchy.length) {\n        var i;\n        var len = this._elem.hierarchy.length;\n\n        for (i = 0; i < len; i += 1) {\n          this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);\n        }\n\n        return toWorldMat.inversePoint(arr);\n      }\n\n      return toWorldMat.inversePoint(arr);\n    }\n\n    function sampleImage() {\n      return [1, 1, 1, 1];\n    }\n\n    return function (elem) {\n      var transformInterface;\n\n      function _registerMaskInterface(maskManager) {\n        _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);\n      }\n\n      function _registerEffectsInterface(effects) {\n        _thisLayerFunction.effect = effects;\n      }\n\n      function _thisLayerFunction(name) {\n        switch (name) {\n          case 'ADBE Root Vectors Group':\n          case 'Contents':\n          case 2:\n            return _thisLayerFunction.shapeInterface;\n\n          case 1:\n          case 6:\n          case 'Transform':\n          case 'transform':\n          case 'ADBE Transform Group':\n            return transformInterface;\n\n          case 4:\n          case 'ADBE Effect Parade':\n          case 'effects':\n          case 'Effects':\n            return _thisLayerFunction.effect;\n\n          case 'ADBE Text Properties':\n            return _thisLayerFunction.textInterface;\n\n          default:\n            return null;\n        }\n      }\n\n      _thisLayerFunction.getMatrix = getMatrix;\n      _thisLayerFunction.invertPoint = invertPoint;\n      _thisLayerFunction.applyPoint = applyPoint;\n      _thisLayerFunction.toWorld = toWorld;\n      _thisLayerFunction.toWorldVec = toWorldVec;\n      _thisLayerFunction.fromWorld = fromWorld;\n      _thisLayerFunction.fromWorldVec = fromWorldVec;\n      _thisLayerFunction.toComp = toWorld;\n      _thisLayerFunction.fromComp = fromComp;\n      _thisLayerFunction.sampleImage = sampleImage;\n      _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);\n      _thisLayerFunction._elem = elem;\n      transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);\n      var anchorPointDescriptor = getDescriptor(transformInterface, 'anchorPoint');\n      Object.defineProperties(_thisLayerFunction, {\n        hasParent: {\n          get: function get() {\n            return elem.hierarchy.length;\n          }\n        },\n        parent: {\n          get: function get() {\n            return elem.hierarchy[0].layerInterface;\n          }\n        },\n        rotation: getDescriptor(transformInterface, 'rotation'),\n        scale: getDescriptor(transformInterface, 'scale'),\n        position: getDescriptor(transformInterface, 'position'),\n        opacity: getDescriptor(transformInterface, 'opacity'),\n        anchorPoint: anchorPointDescriptor,\n        anchor_point: anchorPointDescriptor,\n        transform: {\n          get: function get() {\n            return transformInterface;\n          }\n        },\n        active: {\n          get: function get() {\n            return elem.isInRange;\n          }\n        }\n      });\n      _thisLayerFunction.startTime = elem.data.st;\n      _thisLayerFunction.index = elem.data.ind;\n      _thisLayerFunction.source = elem.data.refId;\n      _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;\n      _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;\n      _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate;\n      _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate;\n      _thisLayerFunction._name = elem.data.nm;\n      _thisLayerFunction.registerMaskInterface = _registerMaskInterface;\n      _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;\n      return _thisLayerFunction;\n    };\n  }();\n\n  var propertyGroupFactory = function () {\n    return function (interfaceFunction, parentPropertyGroup) {\n      return function (val) {\n        val = val === undefined ? 1 : val;\n\n        if (val <= 0) {\n          return interfaceFunction;\n        }\n\n        return parentPropertyGroup(val - 1);\n      };\n    };\n  }();\n\n  var PropertyInterface = function () {\n    return function (propertyName, propertyGroup) {\n      var interfaceFunction = {\n        _name: propertyName\n      };\n\n      function _propertyGroup(val) {\n        val = val === undefined ? 1 : val;\n\n        if (val <= 0) {\n          return interfaceFunction;\n        }\n\n        return propertyGroup(val - 1);\n      }\n\n      return _propertyGroup;\n    };\n  }();\n\n  var EffectsExpressionInterface = function () {\n    var ob = {\n      createEffectsInterface: createEffectsInterface\n    };\n\n    function createEffectsInterface(elem, propertyGroup) {\n      if (elem.effectsManager) {\n        var effectElements = [];\n        var effectsData = elem.data.ef;\n        var i;\n        var len = elem.effectsManager.effectElements.length;\n\n        for (i = 0; i < len; i += 1) {\n          effectElements.push(createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem));\n        }\n\n        var effects = elem.data.ef || [];\n\n        var groupInterface = function groupInterface(name) {\n          i = 0;\n          len = effects.length;\n\n          while (i < len) {\n            if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {\n              return effectElements[i];\n            }\n\n            i += 1;\n          }\n\n          return null;\n        };\n\n        Object.defineProperty(groupInterface, 'numProperties', {\n          get: function get() {\n            return effects.length;\n          }\n        });\n        return groupInterface;\n      }\n\n      return null;\n    }\n\n    function createGroupInterface(data, elements, propertyGroup, elem) {\n      function groupInterface(name) {\n        var effects = data.ef;\n        var i = 0;\n        var len = effects.length;\n\n        while (i < len) {\n          if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {\n            if (effects[i].ty === 5) {\n              return effectElements[i];\n            }\n\n            return effectElements[i]();\n          }\n\n          i += 1;\n        }\n\n        throw new Error();\n      }\n\n      var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);\n\n      var effectElements = [];\n      var i;\n      var len = data.ef.length;\n\n      for (i = 0; i < len; i += 1) {\n        if (data.ef[i].ty === 5) {\n          effectElements.push(createGroupInterface(data.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem));\n        } else {\n          effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup));\n        }\n      }\n\n      if (data.mn === 'ADBE Color Control') {\n        Object.defineProperty(groupInterface, 'color', {\n          get: function get() {\n            return effectElements[0]();\n          }\n        });\n      }\n\n      Object.defineProperties(groupInterface, {\n        numProperties: {\n          get: function get() {\n            return data.np;\n          }\n        },\n        _name: {\n          value: data.nm\n        },\n        propertyGroup: {\n          value: _propertyGroup\n        }\n      });\n      groupInterface.enabled = data.en !== 0;\n      groupInterface.active = groupInterface.enabled;\n      return groupInterface;\n    }\n\n    function createValueInterface(element, type, elem, propertyGroup) {\n      var expressionProperty = ExpressionPropertyInterface(element.p);\n\n      function interfaceFunction() {\n        if (type === 10) {\n          return elem.comp.compInterface(element.p.v);\n        }\n\n        return expressionProperty();\n      }\n\n      if (element.p.setGroupProperty) {\n        element.p.setGroupProperty(PropertyInterface('', propertyGroup));\n      }\n\n      return interfaceFunction;\n    }\n\n    return ob;\n  }();\n\n  var ShapePathInterface = function () {\n    return function pathInterfaceFactory(shape, view, propertyGroup) {\n      var prop = view.sh;\n\n      function interfaceFunction(val) {\n        if (val === 'Shape' || val === 'shape' || val === 'Path' || val === 'path' || val === 'ADBE Vector Shape' || val === 2) {\n          return interfaceFunction.path;\n        }\n\n        return null;\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n\n      prop.setGroupProperty(PropertyInterface('Path', _propertyGroup));\n      Object.defineProperties(interfaceFunction, {\n        path: {\n          get: function get() {\n            if (prop.k) {\n              prop.getValue();\n            }\n\n            return prop;\n          }\n        },\n        shape: {\n          get: function get() {\n            if (prop.k) {\n              prop.getValue();\n            }\n\n            return prop;\n          }\n        },\n        _name: {\n          value: shape.nm\n        },\n        ix: {\n          value: shape.ix\n        },\n        propertyIndex: {\n          value: shape.ix\n        },\n        mn: {\n          value: shape.mn\n        },\n        propertyGroup: {\n          value: propertyGroup\n        }\n      });\n      return interfaceFunction;\n    };\n  }();\n\n  var ShapeExpressionInterface = function () {\n    function iterateElements(shapes, view, propertyGroup) {\n      var arr = [];\n      var i;\n      var len = shapes ? shapes.length : 0;\n\n      for (i = 0; i < len; i += 1) {\n        if (shapes[i].ty === 'gr') {\n          arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'fl') {\n          arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'st') {\n          arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'tm') {\n          arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'tr') {// arr.push(transformInterfaceFactory(shapes[i],view[i],propertyGroup));\n        } else if (shapes[i].ty === 'el') {\n          arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'sr') {\n          arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'sh') {\n          arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'rc') {\n          arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'rd') {\n          arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'rp') {\n          arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'gf') {\n          arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else {\n          arr.push(defaultInterfaceFactory(shapes[i], view[i], propertyGroup));\n        }\n      }\n\n      return arr;\n    }\n\n    function contentsInterfaceFactory(shape, view, propertyGroup) {\n      var interfaces;\n\n      var interfaceFunction = function _interfaceFunction(value) {\n        var i = 0;\n        var len = interfaces.length;\n\n        while (i < len) {\n          if (interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value) {\n            return interfaces[i];\n          }\n\n          i += 1;\n        }\n\n        if (typeof value === 'number') {\n          return interfaces[value - 1];\n        }\n\n        return null;\n      };\n\n      interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n      interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);\n      interfaceFunction.numProperties = interfaces.length;\n      var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);\n      interfaceFunction.transform = transformInterface;\n      interfaceFunction.propertyIndex = shape.cix;\n      interfaceFunction._name = shape.nm;\n      return interfaceFunction;\n    }\n\n    function groupInterfaceFactory(shape, view, propertyGroup) {\n      var interfaceFunction = function _interfaceFunction(value) {\n        switch (value) {\n          case 'ADBE Vectors Group':\n          case 'Contents':\n          case 2:\n            return interfaceFunction.content;\n          // Not necessary for now. Keeping them here in case a new case appears\n          // case 'ADBE Vector Transform Group':\n          // case 3:\n\n          default:\n            return interfaceFunction.transform;\n        }\n      };\n\n      interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n      var content = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);\n      var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);\n      interfaceFunction.content = content;\n      interfaceFunction.transform = transformInterface;\n      Object.defineProperty(interfaceFunction, '_name', {\n        get: function get() {\n          return shape.nm;\n        }\n      }); // interfaceFunction.content = interfaceFunction;\n\n      interfaceFunction.numProperties = shape.np;\n      interfaceFunction.propertyIndex = shape.ix;\n      interfaceFunction.nm = shape.nm;\n      interfaceFunction.mn = shape.mn;\n      return interfaceFunction;\n    }\n\n    function fillInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(val) {\n        if (val === 'Color' || val === 'color') {\n          return interfaceFunction.color;\n        }\n\n        if (val === 'Opacity' || val === 'opacity') {\n          return interfaceFunction.opacity;\n        }\n\n        return null;\n      }\n\n      Object.defineProperties(interfaceFunction, {\n        color: {\n          get: ExpressionPropertyInterface(view.c)\n        },\n        opacity: {\n          get: ExpressionPropertyInterface(view.o)\n        },\n        _name: {\n          value: shape.nm\n        },\n        mn: {\n          value: shape.mn\n        }\n      });\n      view.c.setGroupProperty(PropertyInterface('Color', propertyGroup));\n      view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));\n      return interfaceFunction;\n    }\n\n    function gradientFillInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(val) {\n        if (val === 'Start Point' || val === 'start point') {\n          return interfaceFunction.startPoint;\n        }\n\n        if (val === 'End Point' || val === 'end point') {\n          return interfaceFunction.endPoint;\n        }\n\n        if (val === 'Opacity' || val === 'opacity') {\n          return interfaceFunction.opacity;\n        }\n\n        return null;\n      }\n\n      Object.defineProperties(interfaceFunction, {\n        startPoint: {\n          get: ExpressionPropertyInterface(view.s)\n        },\n        endPoint: {\n          get: ExpressionPropertyInterface(view.e)\n        },\n        opacity: {\n          get: ExpressionPropertyInterface(view.o)\n        },\n        type: {\n          get: function get() {\n            return 'a';\n          }\n        },\n        _name: {\n          value: shape.nm\n        },\n        mn: {\n          value: shape.mn\n        }\n      });\n      view.s.setGroupProperty(PropertyInterface('Start Point', propertyGroup));\n      view.e.setGroupProperty(PropertyInterface('End Point', propertyGroup));\n      view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));\n      return interfaceFunction;\n    }\n\n    function defaultInterfaceFactory() {\n      function interfaceFunction() {\n        return null;\n      }\n\n      return interfaceFunction;\n    }\n\n    function strokeInterfaceFactory(shape, view, propertyGroup) {\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n\n      var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);\n\n      function addPropertyToDashOb(i) {\n        Object.defineProperty(dashOb, shape.d[i].nm, {\n          get: ExpressionPropertyInterface(view.d.dataProps[i].p)\n        });\n      }\n\n      var i;\n      var len = shape.d ? shape.d.length : 0;\n      var dashOb = {};\n\n      for (i = 0; i < len; i += 1) {\n        addPropertyToDashOb(i);\n        view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);\n      }\n\n      function interfaceFunction(val) {\n        if (val === 'Color' || val === 'color') {\n          return interfaceFunction.color;\n        }\n\n        if (val === 'Opacity' || val === 'opacity') {\n          return interfaceFunction.opacity;\n        }\n\n        if (val === 'Stroke Width' || val === 'stroke width') {\n          return interfaceFunction.strokeWidth;\n        }\n\n        return null;\n      }\n\n      Object.defineProperties(interfaceFunction, {\n        color: {\n          get: ExpressionPropertyInterface(view.c)\n        },\n        opacity: {\n          get: ExpressionPropertyInterface(view.o)\n        },\n        strokeWidth: {\n          get: ExpressionPropertyInterface(view.w)\n        },\n        dash: {\n          get: function get() {\n            return dashOb;\n          }\n        },\n        _name: {\n          value: shape.nm\n        },\n        mn: {\n          value: shape.mn\n        }\n      });\n      view.c.setGroupProperty(PropertyInterface('Color', _propertyGroup));\n      view.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));\n      view.w.setGroupProperty(PropertyInterface('Stroke Width', _propertyGroup));\n      return interfaceFunction;\n    }\n\n    function trimInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(val) {\n        if (val === shape.e.ix || val === 'End' || val === 'end') {\n          return interfaceFunction.end;\n        }\n\n        if (val === shape.s.ix) {\n          return interfaceFunction.start;\n        }\n\n        if (val === shape.o.ix) {\n          return interfaceFunction.offset;\n        }\n\n        return null;\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n\n      interfaceFunction.propertyIndex = shape.ix;\n      view.s.setGroupProperty(PropertyInterface('Start', _propertyGroup));\n      view.e.setGroupProperty(PropertyInterface('End', _propertyGroup));\n      view.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));\n      interfaceFunction.propertyIndex = shape.ix;\n      interfaceFunction.propertyGroup = propertyGroup;\n      Object.defineProperties(interfaceFunction, {\n        start: {\n          get: ExpressionPropertyInterface(view.s)\n        },\n        end: {\n          get: ExpressionPropertyInterface(view.e)\n        },\n        offset: {\n          get: ExpressionPropertyInterface(view.o)\n        },\n        _name: {\n          value: shape.nm\n        }\n      });\n      interfaceFunction.mn = shape.mn;\n      return interfaceFunction;\n    }\n\n    function transformInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(value) {\n        if (shape.a.ix === value || value === 'Anchor Point') {\n          return interfaceFunction.anchorPoint;\n        }\n\n        if (shape.o.ix === value || value === 'Opacity') {\n          return interfaceFunction.opacity;\n        }\n\n        if (shape.p.ix === value || value === 'Position') {\n          return interfaceFunction.position;\n        }\n\n        if (shape.r.ix === value || value === 'Rotation' || value === 'ADBE Vector Rotation') {\n          return interfaceFunction.rotation;\n        }\n\n        if (shape.s.ix === value || value === 'Scale') {\n          return interfaceFunction.scale;\n        }\n\n        if (shape.sk && shape.sk.ix === value || value === 'Skew') {\n          return interfaceFunction.skew;\n        }\n\n        if (shape.sa && shape.sa.ix === value || value === 'Skew Axis') {\n          return interfaceFunction.skewAxis;\n        }\n\n        return null;\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n\n      view.transform.mProps.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));\n      view.transform.mProps.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));\n      view.transform.mProps.a.setGroupProperty(PropertyInterface('Anchor Point', _propertyGroup));\n      view.transform.mProps.s.setGroupProperty(PropertyInterface('Scale', _propertyGroup));\n      view.transform.mProps.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));\n\n      if (view.transform.mProps.sk) {\n        view.transform.mProps.sk.setGroupProperty(PropertyInterface('Skew', _propertyGroup));\n        view.transform.mProps.sa.setGroupProperty(PropertyInterface('Skew Angle', _propertyGroup));\n      }\n\n      view.transform.op.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));\n      Object.defineProperties(interfaceFunction, {\n        opacity: {\n          get: ExpressionPropertyInterface(view.transform.mProps.o)\n        },\n        position: {\n          get: ExpressionPropertyInterface(view.transform.mProps.p)\n        },\n        anchorPoint: {\n          get: ExpressionPropertyInterface(view.transform.mProps.a)\n        },\n        scale: {\n          get: ExpressionPropertyInterface(view.transform.mProps.s)\n        },\n        rotation: {\n          get: ExpressionPropertyInterface(view.transform.mProps.r)\n        },\n        skew: {\n          get: ExpressionPropertyInterface(view.transform.mProps.sk)\n        },\n        skewAxis: {\n          get: ExpressionPropertyInterface(view.transform.mProps.sa)\n        },\n        _name: {\n          value: shape.nm\n        }\n      });\n      interfaceFunction.ty = 'tr';\n      interfaceFunction.mn = shape.mn;\n      interfaceFunction.propertyGroup = propertyGroup;\n      return interfaceFunction;\n    }\n\n    function ellipseInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(value) {\n        if (shape.p.ix === value) {\n          return interfaceFunction.position;\n        }\n\n        if (shape.s.ix === value) {\n          return interfaceFunction.size;\n        }\n\n        return null;\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n\n      interfaceFunction.propertyIndex = shape.ix;\n      var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;\n      prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));\n      prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));\n      Object.defineProperties(interfaceFunction, {\n        size: {\n          get: ExpressionPropertyInterface(prop.s)\n        },\n        position: {\n          get: ExpressionPropertyInterface(prop.p)\n        },\n        _name: {\n          value: shape.nm\n        }\n      });\n      interfaceFunction.mn = shape.mn;\n      return interfaceFunction;\n    }\n\n    function starInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(value) {\n        if (shape.p.ix === value) {\n          return interfaceFunction.position;\n        }\n\n        if (shape.r.ix === value) {\n          return interfaceFunction.rotation;\n        }\n\n        if (shape.pt.ix === value) {\n          return interfaceFunction.points;\n        }\n\n        if (shape.or.ix === value || value === 'ADBE Vector Star Outer Radius') {\n          return interfaceFunction.outerRadius;\n        }\n\n        if (shape.os.ix === value) {\n          return interfaceFunction.outerRoundness;\n        }\n\n        if (shape.ir && (shape.ir.ix === value || value === 'ADBE Vector Star Inner Radius')) {\n          return interfaceFunction.innerRadius;\n        }\n\n        if (shape.is && shape.is.ix === value) {\n          return interfaceFunction.innerRoundness;\n        }\n\n        return null;\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n\n      var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;\n      interfaceFunction.propertyIndex = shape.ix;\n      prop.or.setGroupProperty(PropertyInterface('Outer Radius', _propertyGroup));\n      prop.os.setGroupProperty(PropertyInterface('Outer Roundness', _propertyGroup));\n      prop.pt.setGroupProperty(PropertyInterface('Points', _propertyGroup));\n      prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));\n      prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));\n\n      if (shape.ir) {\n        prop.ir.setGroupProperty(PropertyInterface('Inner Radius', _propertyGroup));\n        prop.is.setGroupProperty(PropertyInterface('Inner Roundness', _propertyGroup));\n      }\n\n      Object.defineProperties(interfaceFunction, {\n        position: {\n          get: ExpressionPropertyInterface(prop.p)\n        },\n        rotation: {\n          get: ExpressionPropertyInterface(prop.r)\n        },\n        points: {\n          get: ExpressionPropertyInterface(prop.pt)\n        },\n        outerRadius: {\n          get: ExpressionPropertyInterface(prop.or)\n        },\n        outerRoundness: {\n          get: ExpressionPropertyInterface(prop.os)\n        },\n        innerRadius: {\n          get: ExpressionPropertyInterface(prop.ir)\n        },\n        innerRoundness: {\n          get: ExpressionPropertyInterface(prop.is)\n        },\n        _name: {\n          value: shape.nm\n        }\n      });\n      interfaceFunction.mn = shape.mn;\n      return interfaceFunction;\n    }\n\n    function rectInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(value) {\n        if (shape.p.ix === value) {\n          return interfaceFunction.position;\n        }\n\n        if (shape.r.ix === value) {\n          return interfaceFunction.roundness;\n        }\n\n        if (shape.s.ix === value || value === 'Size' || value === 'ADBE Vector Rect Size') {\n          return interfaceFunction.size;\n        }\n\n        return null;\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n\n      var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;\n      interfaceFunction.propertyIndex = shape.ix;\n      prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));\n      prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));\n      prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));\n      Object.defineProperties(interfaceFunction, {\n        position: {\n          get: ExpressionPropertyInterface(prop.p)\n        },\n        roundness: {\n          get: ExpressionPropertyInterface(prop.r)\n        },\n        size: {\n          get: ExpressionPropertyInterface(prop.s)\n        },\n        _name: {\n          value: shape.nm\n        }\n      });\n      interfaceFunction.mn = shape.mn;\n      return interfaceFunction;\n    }\n\n    function roundedInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(value) {\n        if (shape.r.ix === value || value === 'Round Corners 1') {\n          return interfaceFunction.radius;\n        }\n\n        return null;\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n\n      var prop = view;\n      interfaceFunction.propertyIndex = shape.ix;\n      prop.rd.setGroupProperty(PropertyInterface('Radius', _propertyGroup));\n      Object.defineProperties(interfaceFunction, {\n        radius: {\n          get: ExpressionPropertyInterface(prop.rd)\n        },\n        _name: {\n          value: shape.nm\n        }\n      });\n      interfaceFunction.mn = shape.mn;\n      return interfaceFunction;\n    }\n\n    function repeaterInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(value) {\n        if (shape.c.ix === value || value === 'Copies') {\n          return interfaceFunction.copies;\n        }\n\n        if (shape.o.ix === value || value === 'Offset') {\n          return interfaceFunction.offset;\n        }\n\n        return null;\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n\n      var prop = view;\n      interfaceFunction.propertyIndex = shape.ix;\n      prop.c.setGroupProperty(PropertyInterface('Copies', _propertyGroup));\n      prop.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));\n      Object.defineProperties(interfaceFunction, {\n        copies: {\n          get: ExpressionPropertyInterface(prop.c)\n        },\n        offset: {\n          get: ExpressionPropertyInterface(prop.o)\n        },\n        _name: {\n          value: shape.nm\n        }\n      });\n      interfaceFunction.mn = shape.mn;\n      return interfaceFunction;\n    }\n\n    return function (shapes, view, propertyGroup) {\n      var interfaces;\n\n      function _interfaceFunction(value) {\n        if (typeof value === 'number') {\n          value = value === undefined ? 1 : value;\n\n          if (value === 0) {\n            return propertyGroup;\n          }\n\n          return interfaces[value - 1];\n        }\n\n        var i = 0;\n        var len = interfaces.length;\n\n        while (i < len) {\n          if (interfaces[i]._name === value) {\n            return interfaces[i];\n          }\n\n          i += 1;\n        }\n\n        return null;\n      }\n\n      function parentGroupWrapper() {\n        return propertyGroup;\n      }\n\n      _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);\n      interfaces = iterateElements(shapes, view, _interfaceFunction.propertyGroup);\n      _interfaceFunction.numProperties = interfaces.length;\n      _interfaceFunction._name = 'Contents';\n      return _interfaceFunction;\n    };\n  }();\n\n  var TextExpressionInterface = function () {\n    return function (elem) {\n      var _sourceText;\n\n      function _thisLayerFunction(name) {\n        switch (name) {\n          case 'ADBE Text Document':\n            return _thisLayerFunction.sourceText;\n\n          default:\n            return null;\n        }\n      }\n\n      Object.defineProperty(_thisLayerFunction, 'sourceText', {\n        get: function get() {\n          elem.textProperty.getValue();\n          var stringValue = elem.textProperty.currentData.t;\n\n          if (!_sourceText || stringValue !== _sourceText.value) {\n            _sourceText = new String(stringValue); // eslint-disable-line no-new-wrappers\n            // If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive\n\n            _sourceText.value = stringValue || new String(stringValue); // eslint-disable-line no-new-wrappers\n\n            Object.defineProperty(_sourceText, 'style', {\n              get: function get() {\n                return {\n                  fillColor: elem.textProperty.currentData.fc\n                };\n              }\n            });\n          }\n\n          return _sourceText;\n        }\n      });\n      return _thisLayerFunction;\n    };\n  }();\n\n  function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n  var FootageInterface = function () {\n    var outlineInterfaceFactory = function outlineInterfaceFactory(elem) {\n      var currentPropertyName = '';\n      var currentProperty = elem.getFootageData();\n\n      function init() {\n        currentPropertyName = '';\n        currentProperty = elem.getFootageData();\n        return searchProperty;\n      }\n\n      function searchProperty(value) {\n        if (currentProperty[value]) {\n          currentPropertyName = value;\n          currentProperty = currentProperty[value];\n\n          if (_typeof(currentProperty) === 'object') {\n            return searchProperty;\n          }\n\n          return currentProperty;\n        }\n\n        var propertyNameIndex = value.indexOf(currentPropertyName);\n\n        if (propertyNameIndex !== -1) {\n          var index = parseInt(value.substr(propertyNameIndex + currentPropertyName.length), 10);\n          currentProperty = currentProperty[index];\n\n          if (_typeof(currentProperty) === 'object') {\n            return searchProperty;\n          }\n\n          return currentProperty;\n        }\n\n        return '';\n      }\n\n      return init;\n    };\n\n    var dataInterfaceFactory = function dataInterfaceFactory(elem) {\n      function interfaceFunction(value) {\n        if (value === 'Outline') {\n          return interfaceFunction.outlineInterface();\n        }\n\n        return null;\n      }\n\n      interfaceFunction._name = 'Outline';\n      interfaceFunction.outlineInterface = outlineInterfaceFactory(elem);\n      return interfaceFunction;\n    };\n\n    return function (elem) {\n      function _interfaceFunction(value) {\n        if (value === 'Data') {\n          return _interfaceFunction.dataInterface;\n        }\n\n        return null;\n      }\n\n      _interfaceFunction._name = 'Data';\n      _interfaceFunction.dataInterface = dataInterfaceFactory(elem);\n      return _interfaceFunction;\n    };\n  }();\n\n  var interfaces = {\n    layer: LayerExpressionInterface,\n    effects: EffectsExpressionInterface,\n    comp: CompExpressionInterface,\n    shape: ShapeExpressionInterface,\n    text: TextExpressionInterface,\n    footage: FootageInterface\n  };\n\n  function getInterface(type) {\n    return interfaces[type] || null;\n  }\n\n  var expressionHelpers = function () {\n    function searchExpressions(elem, data, prop) {\n      if (data.x) {\n        prop.k = true;\n        prop.x = true;\n        prop.initiateExpression = ExpressionManager.initiateExpression;\n        prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop));\n      }\n    }\n\n    function getValueAtTime(frameNum) {\n      frameNum *= this.elem.globalData.frameRate;\n      frameNum -= this.offsetTime;\n\n      if (frameNum !== this._cachingAtTime.lastFrame) {\n        this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;\n        this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);\n        this._cachingAtTime.lastFrame = frameNum;\n      }\n\n      return this._cachingAtTime.value;\n    }\n\n    function getSpeedAtTime(frameNum) {\n      var delta = -0.01;\n      var v1 = this.getValueAtTime(frameNum);\n      var v2 = this.getValueAtTime(frameNum + delta);\n      var speed = 0;\n\n      if (v1.length) {\n        var i;\n\n        for (i = 0; i < v1.length; i += 1) {\n          speed += Math.pow(v2[i] - v1[i], 2);\n        }\n\n        speed = Math.sqrt(speed) * 100;\n      } else {\n        speed = 0;\n      }\n\n      return speed;\n    }\n\n    function getVelocityAtTime(frameNum) {\n      if (this.vel !== undefined) {\n        return this.vel;\n      }\n\n      var delta = -0.001; // frameNum += this.elem.data.st;\n\n      var v1 = this.getValueAtTime(frameNum);\n      var v2 = this.getValueAtTime(frameNum + delta);\n      var velocity;\n\n      if (v1.length) {\n        velocity = createTypedArray('float32', v1.length);\n        var i;\n\n        for (i = 0; i < v1.length; i += 1) {\n          // removing frameRate\n          // if needed, don't add it here\n          // velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);\n          velocity[i] = (v2[i] - v1[i]) / delta;\n        }\n      } else {\n        velocity = (v2 - v1) / delta;\n      }\n\n      return velocity;\n    }\n\n    function getStaticValueAtTime() {\n      return this.pv;\n    }\n\n    function setGroupProperty(propertyGroup) {\n      this.propertyGroup = propertyGroup;\n    }\n\n    return {\n      searchExpressions: searchExpressions,\n      getSpeedAtTime: getSpeedAtTime,\n      getVelocityAtTime: getVelocityAtTime,\n      getValueAtTime: getValueAtTime,\n      getStaticValueAtTime: getStaticValueAtTime,\n      setGroupProperty: setGroupProperty\n    };\n  }();\n\n  function addPropertyDecorator() {\n    function loopOut(type, duration, durationFlag) {\n      if (!this.k || !this.keyframes) {\n        return this.pv;\n      }\n\n      type = type ? type.toLowerCase() : '';\n      var currentFrame = this.comp.renderedFrame;\n      var keyframes = this.keyframes;\n      var lastKeyFrame = keyframes[keyframes.length - 1].t;\n\n      if (currentFrame <= lastKeyFrame) {\n        return this.pv;\n      }\n\n      var cycleDuration;\n      var firstKeyFrame;\n\n      if (!durationFlag) {\n        if (!duration || duration > keyframes.length - 1) {\n          duration = keyframes.length - 1;\n        }\n\n        firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;\n        cycleDuration = lastKeyFrame - firstKeyFrame;\n      } else {\n        if (!duration) {\n          cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);\n        } else {\n          cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);\n        }\n\n        firstKeyFrame = lastKeyFrame - cycleDuration;\n      }\n\n      var i;\n      var len;\n      var ret;\n\n      if (type === 'pingpong') {\n        var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);\n\n        if (iterations % 2 !== 0) {\n          return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n        }\n      } else if (type === 'offset') {\n        var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);\n        var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);\n        var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n\n        var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);\n\n        if (this.pv.length) {\n          ret = new Array(initV.length);\n          len = ret.length;\n\n          for (i = 0; i < len; i += 1) {\n            ret[i] = (endV[i] - initV[i]) * repeats + current[i];\n          }\n\n          return ret;\n        }\n\n        return (endV - initV) * repeats + current;\n      } else if (type === 'continue') {\n        var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);\n        var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);\n\n        if (this.pv.length) {\n          ret = new Array(lastValue.length);\n          len = ret.length;\n\n          for (i = 0; i < len; i += 1) {\n            ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 0.0005; // eslint-disable-line\n          }\n\n          return ret;\n        }\n\n        return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / 0.001);\n      }\n\n      return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n    }\n\n    function loopIn(type, duration, durationFlag) {\n      if (!this.k) {\n        return this.pv;\n      }\n\n      type = type ? type.toLowerCase() : '';\n      var currentFrame = this.comp.renderedFrame;\n      var keyframes = this.keyframes;\n      var firstKeyFrame = keyframes[0].t;\n\n      if (currentFrame >= firstKeyFrame) {\n        return this.pv;\n      }\n\n      var cycleDuration;\n      var lastKeyFrame;\n\n      if (!durationFlag) {\n        if (!duration || duration > keyframes.length - 1) {\n          duration = keyframes.length - 1;\n        }\n\n        lastKeyFrame = keyframes[duration].t;\n        cycleDuration = lastKeyFrame - firstKeyFrame;\n      } else {\n        if (!duration) {\n          cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);\n        } else {\n          cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);\n        }\n\n        lastKeyFrame = firstKeyFrame + cycleDuration;\n      }\n\n      var i;\n      var len;\n      var ret;\n\n      if (type === 'pingpong') {\n        var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);\n\n        if (iterations % 2 === 0) {\n          return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n        }\n      } else if (type === 'offset') {\n        var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);\n        var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);\n        var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);\n        var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;\n\n        if (this.pv.length) {\n          ret = new Array(initV.length);\n          len = ret.length;\n\n          for (i = 0; i < len; i += 1) {\n            ret[i] = current[i] - (endV[i] - initV[i]) * repeats;\n          }\n\n          return ret;\n        }\n\n        return current - (endV - initV) * repeats;\n      } else if (type === 'continue') {\n        var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);\n        var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);\n\n        if (this.pv.length) {\n          ret = new Array(firstValue.length);\n          len = ret.length;\n\n          for (i = 0; i < len; i += 1) {\n            ret[i] = firstValue[i] + (firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame) / 0.001;\n          }\n\n          return ret;\n        }\n\n        return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / 0.001;\n      }\n\n      return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n    }\n\n    function smooth(width, samples) {\n      if (!this.k) {\n        return this.pv;\n      }\n\n      width = (width || 0.4) * 0.5;\n      samples = Math.floor(samples || 5);\n\n      if (samples <= 1) {\n        return this.pv;\n      }\n\n      var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;\n      var initFrame = currentTime - width;\n      var endFrame = currentTime + width;\n      var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;\n      var i = 0;\n      var j = 0;\n      var value;\n\n      if (this.pv.length) {\n        value = createTypedArray('float32', this.pv.length);\n      } else {\n        value = 0;\n      }\n\n      var sampleValue;\n\n      while (i < samples) {\n        sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);\n\n        if (this.pv.length) {\n          for (j = 0; j < this.pv.length; j += 1) {\n            value[j] += sampleValue[j];\n          }\n        } else {\n          value += sampleValue;\n        }\n\n        i += 1;\n      }\n\n      if (this.pv.length) {\n        for (j = 0; j < this.pv.length; j += 1) {\n          value[j] /= samples;\n        }\n      } else {\n        value /= samples;\n      }\n\n      return value;\n    }\n\n    function getTransformValueAtTime(time) {\n      if (!this._transformCachingAtTime) {\n        this._transformCachingAtTime = {\n          v: new Matrix()\n        };\n      } /// /\n\n\n      var matrix = this._transformCachingAtTime.v;\n      matrix.cloneFromProps(this.pre.props);\n\n      if (this.appliedTransformations < 1) {\n        var anchor = this.a.getValueAtTime(time);\n        matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult);\n      }\n\n      if (this.appliedTransformations < 2) {\n        var scale = this.s.getValueAtTime(time);\n        matrix.scale(scale[0] * this.s.mult, scale[1] * this.s.mult, scale[2] * this.s.mult);\n      }\n\n      if (this.sk && this.appliedTransformations < 3) {\n        var skew = this.sk.getValueAtTime(time);\n        var skewAxis = this.sa.getValueAtTime(time);\n        matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);\n      }\n\n      if (this.r && this.appliedTransformations < 4) {\n        var rotation = this.r.getValueAtTime(time);\n        matrix.rotate(-rotation * this.r.mult);\n      } else if (!this.r && this.appliedTransformations < 4) {\n        var rotationZ = this.rz.getValueAtTime(time);\n        var rotationY = this.ry.getValueAtTime(time);\n        var rotationX = this.rx.getValueAtTime(time);\n        var orientation = this.or.getValueAtTime(time);\n        matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult);\n      }\n\n      if (this.data.p && this.data.p.s) {\n        var positionX = this.px.getValueAtTime(time);\n        var positionY = this.py.getValueAtTime(time);\n\n        if (this.data.p.z) {\n          var positionZ = this.pz.getValueAtTime(time);\n          matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult);\n        } else {\n          matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);\n        }\n      } else {\n        var position = this.p.getValueAtTime(time);\n        matrix.translate(position[0] * this.p.mult, position[1] * this.p.mult, -position[2] * this.p.mult);\n      }\n\n      return matrix; /// /\n    }\n\n    function getTransformStaticValueAtTime() {\n      return this.v.clone(new Matrix());\n    }\n\n    var getTransformProperty = TransformPropertyFactory.getTransformProperty;\n\n    TransformPropertyFactory.getTransformProperty = function (elem, data, container) {\n      var prop = getTransformProperty(elem, data, container);\n\n      if (prop.dynamicProperties.length) {\n        prop.getValueAtTime = getTransformValueAtTime.bind(prop);\n      } else {\n        prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);\n      }\n\n      prop.setGroupProperty = expressionHelpers.setGroupProperty;\n      return prop;\n    };\n\n    var propertyGetProp = PropertyFactory.getProp;\n\n    PropertyFactory.getProp = function (elem, data, type, mult, container) {\n      var prop = propertyGetProp(elem, data, type, mult, container); // prop.getVelocityAtTime = getVelocityAtTime;\n      // prop.loopOut = loopOut;\n      // prop.loopIn = loopIn;\n\n      if (prop.kf) {\n        prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);\n      } else {\n        prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);\n      }\n\n      prop.setGroupProperty = expressionHelpers.setGroupProperty;\n      prop.loopOut = loopOut;\n      prop.loopIn = loopIn;\n      prop.smooth = smooth;\n      prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);\n      prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);\n      prop.numKeys = data.a === 1 ? data.k.length : 0;\n      prop.propertyIndex = data.ix;\n      var value = 0;\n\n      if (type !== 0) {\n        value = createTypedArray('float32', data.a === 1 ? data.k[0].s.length : data.k.length);\n      }\n\n      prop._cachingAtTime = {\n        lastFrame: initialDefaultFrame,\n        lastIndex: 0,\n        value: value\n      };\n      expressionHelpers.searchExpressions(elem, data, prop);\n\n      if (prop.k) {\n        container.addDynamicProperty(prop);\n      }\n\n      return prop;\n    };\n\n    function getShapeValueAtTime(frameNum) {\n      // For now this caching object is created only when needed instead of creating it when the shape is initialized.\n      if (!this._cachingAtTime) {\n        this._cachingAtTime = {\n          shapeValue: shapePool.clone(this.pv),\n          lastIndex: 0,\n          lastTime: initialDefaultFrame\n        };\n      }\n\n      frameNum *= this.elem.globalData.frameRate;\n      frameNum -= this.offsetTime;\n\n      if (frameNum !== this._cachingAtTime.lastTime) {\n        this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;\n        this._cachingAtTime.lastTime = frameNum;\n        this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);\n      }\n\n      return this._cachingAtTime.shapeValue;\n    }\n\n    var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();\n    var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();\n\n    function ShapeExpressions() {}\n\n    ShapeExpressions.prototype = {\n      vertices: function vertices(prop, time) {\n        if (this.k) {\n          this.getValue();\n        }\n\n        var shapePath = this.v;\n\n        if (time !== undefined) {\n          shapePath = this.getValueAtTime(time, 0);\n        }\n\n        var i;\n        var len = shapePath._length;\n        var vertices = shapePath[prop];\n        var points = shapePath.v;\n        var arr = createSizedArray(len);\n\n        for (i = 0; i < len; i += 1) {\n          if (prop === 'i' || prop === 'o') {\n            arr[i] = [vertices[i][0] - points[i][0], vertices[i][1] - points[i][1]];\n          } else {\n            arr[i] = [vertices[i][0], vertices[i][1]];\n          }\n        }\n\n        return arr;\n      },\n      points: function points(time) {\n        return this.vertices('v', time);\n      },\n      inTangents: function inTangents(time) {\n        return this.vertices('i', time);\n      },\n      outTangents: function outTangents(time) {\n        return this.vertices('o', time);\n      },\n      isClosed: function isClosed() {\n        return this.v.c;\n      },\n      pointOnPath: function pointOnPath(perc, time) {\n        var shapePath = this.v;\n\n        if (time !== undefined) {\n          shapePath = this.getValueAtTime(time, 0);\n        }\n\n        if (!this._segmentsLength) {\n          this._segmentsLength = bez.getSegmentsLength(shapePath);\n        }\n\n        var segmentsLength = this._segmentsLength;\n        var lengths = segmentsLength.lengths;\n        var lengthPos = segmentsLength.totalLength * perc;\n        var i = 0;\n        var len = lengths.length;\n        var accumulatedLength = 0;\n        var pt;\n\n        while (i < len) {\n          if (accumulatedLength + lengths[i].addedLength > lengthPos) {\n            var initIndex = i;\n            var endIndex = shapePath.c && i === len - 1 ? 0 : i + 1;\n            var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;\n            pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);\n            break;\n          } else {\n            accumulatedLength += lengths[i].addedLength;\n          }\n\n          i += 1;\n        }\n\n        if (!pt) {\n          pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];\n        }\n\n        return pt;\n      },\n      vectorOnPath: function vectorOnPath(perc, time, vectorType) {\n        // perc doesn't use triple equality because it can be a Number object as well as a primitive.\n        if (perc == 1) {\n          // eslint-disable-line eqeqeq\n          perc = this.v.c;\n        } else if (perc == 0) {\n          // eslint-disable-line eqeqeq\n          perc = 0.999;\n        }\n\n        var pt1 = this.pointOnPath(perc, time);\n        var pt2 = this.pointOnPath(perc + 0.001, time);\n        var xLength = pt2[0] - pt1[0];\n        var yLength = pt2[1] - pt1[1];\n        var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));\n\n        if (magnitude === 0) {\n          return [0, 0];\n        }\n\n        var unitVector = vectorType === 'tangent' ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];\n        return unitVector;\n      },\n      tangentOnPath: function tangentOnPath(perc, time) {\n        return this.vectorOnPath(perc, time, 'tangent');\n      },\n      normalOnPath: function normalOnPath(perc, time) {\n        return this.vectorOnPath(perc, time, 'normal');\n      },\n      setGroupProperty: expressionHelpers.setGroupProperty,\n      getValueAtTime: expressionHelpers.getStaticValueAtTime\n    };\n    extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);\n    extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);\n    KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;\n    KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;\n    var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;\n\n    ShapePropertyFactory.getShapeProp = function (elem, data, type, arr, trims) {\n      var prop = propertyGetShapeProp(elem, data, type, arr, trims);\n      prop.propertyIndex = data.ix;\n      prop.lock = false;\n\n      if (type === 3) {\n        expressionHelpers.searchExpressions(elem, data.pt, prop);\n      } else if (type === 4) {\n        expressionHelpers.searchExpressions(elem, data.ks, prop);\n      }\n\n      if (prop.k) {\n        elem.addDynamicProperty(prop);\n      }\n\n      return prop;\n    };\n  }\n\n  function initialize$1() {\n    addPropertyDecorator();\n  }\n\n  function addDecorator() {\n    function searchExpressions() {\n      if (this.data.d.x) {\n        this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);\n        this.addEffect(this.getExpressionValue.bind(this));\n        return true;\n      }\n\n      return null;\n    }\n\n    TextProperty.prototype.getExpressionValue = function (currentValue, text) {\n      var newValue = this.calculateExpression(text);\n\n      if (currentValue.t !== newValue) {\n        var newData = {};\n        this.copyData(newData, currentValue);\n        newData.t = newValue.toString();\n        newData.__complete = false;\n        return newData;\n      }\n\n      return currentValue;\n    };\n\n    TextProperty.prototype.searchProperty = function () {\n      var isKeyframed = this.searchKeyframes();\n      var hasExpressions = this.searchExpressions();\n      this.kf = isKeyframed || hasExpressions;\n      return this.kf;\n    };\n\n    TextProperty.prototype.searchExpressions = searchExpressions;\n  }\n\n  function initialize() {\n    addDecorator();\n  }\n\n  function SVGComposableEffect() {}\n\n  SVGComposableEffect.prototype = {\n    createMergeNode: function createMergeNode(resultId, ins) {\n      var feMerge = createNS('feMerge');\n      feMerge.setAttribute('result', resultId);\n      var feMergeNode;\n      var i;\n\n      for (i = 0; i < ins.length; i += 1) {\n        feMergeNode = createNS('feMergeNode');\n        feMergeNode.setAttribute('in', ins[i]);\n        feMerge.appendChild(feMergeNode);\n        feMerge.appendChild(feMergeNode);\n      }\n\n      return feMerge;\n    }\n  };\n\n  var linearFilterValue = '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0';\n\n  function SVGTintFilter(filter, filterManager, elem, id, source) {\n    this.filterManager = filterManager;\n    var feColorMatrix = createNS('feColorMatrix');\n    feColorMatrix.setAttribute('type', 'matrix');\n    feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');\n    feColorMatrix.setAttribute('values', linearFilterValue + ' 1 0');\n    this.linearFilter = feColorMatrix;\n    feColorMatrix.setAttribute('result', id + '_tint_1');\n    filter.appendChild(feColorMatrix);\n    feColorMatrix = createNS('feColorMatrix');\n    feColorMatrix.setAttribute('type', 'matrix');\n    feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');\n    feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');\n    feColorMatrix.setAttribute('result', id + '_tint_2');\n    filter.appendChild(feColorMatrix);\n    this.matrixFilter = feColorMatrix;\n    var feMerge = this.createMergeNode(id, [source, id + '_tint_1', id + '_tint_2']);\n    filter.appendChild(feMerge);\n  }\n\n  extendPrototype([SVGComposableEffect], SVGTintFilter);\n\n  SVGTintFilter.prototype.renderFrame = function (forceRender) {\n    if (forceRender || this.filterManager._mdf) {\n      var colorBlack = this.filterManager.effectElements[0].p.v;\n      var colorWhite = this.filterManager.effectElements[1].p.v;\n      var opacity = this.filterManager.effectElements[2].p.v / 100;\n      this.linearFilter.setAttribute('values', linearFilterValue + ' ' + opacity + ' 0');\n      this.matrixFilter.setAttribute('values', colorWhite[0] - colorBlack[0] + ' 0 0 0 ' + colorBlack[0] + ' ' + (colorWhite[1] - colorBlack[1]) + ' 0 0 0 ' + colorBlack[1] + ' ' + (colorWhite[2] - colorBlack[2]) + ' 0 0 0 ' + colorBlack[2] + ' 0 0 0 1 0');\n    }\n  };\n\n  function SVGFillFilter(filter, filterManager, elem, id) {\n    this.filterManager = filterManager;\n    var feColorMatrix = createNS('feColorMatrix');\n    feColorMatrix.setAttribute('type', 'matrix');\n    feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');\n    feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');\n    feColorMatrix.setAttribute('result', id);\n    filter.appendChild(feColorMatrix);\n    this.matrixFilter = feColorMatrix;\n  }\n\n  SVGFillFilter.prototype.renderFrame = function (forceRender) {\n    if (forceRender || this.filterManager._mdf) {\n      var color = this.filterManager.effectElements[2].p.v;\n      var opacity = this.filterManager.effectElements[6].p.v;\n      this.matrixFilter.setAttribute('values', '0 0 0 0 ' + color[0] + ' 0 0 0 0 ' + color[1] + ' 0 0 0 0 ' + color[2] + ' 0 0 0 ' + opacity + ' 0');\n    }\n  };\n\n  function SVGStrokeEffect(fil, filterManager, elem) {\n    this.initialized = false;\n    this.filterManager = filterManager;\n    this.elem = elem;\n    this.paths = [];\n  }\n\n  SVGStrokeEffect.prototype.initialize = function () {\n    var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;\n    var path;\n    var groupPath;\n    var i;\n    var len;\n\n    if (this.filterManager.effectElements[1].p.v === 1) {\n      len = this.elem.maskManager.masksProperties.length;\n      i = 0;\n    } else {\n      i = this.filterManager.effectElements[0].p.v - 1;\n      len = i + 1;\n    }\n\n    groupPath = createNS('g');\n    groupPath.setAttribute('fill', 'none');\n    groupPath.setAttribute('stroke-linecap', 'round');\n    groupPath.setAttribute('stroke-dashoffset', 1);\n\n    for (i; i < len; i += 1) {\n      path = createNS('path');\n      groupPath.appendChild(path);\n      this.paths.push({\n        p: path,\n        m: i\n      });\n    }\n\n    if (this.filterManager.effectElements[10].p.v === 3) {\n      var mask = createNS('mask');\n      var id = createElementID();\n      mask.setAttribute('id', id);\n      mask.setAttribute('mask-type', 'alpha');\n      mask.appendChild(groupPath);\n      this.elem.globalData.defs.appendChild(mask);\n      var g = createNS('g');\n      g.setAttribute('mask', 'url(' + getLocationHref() + '#' + id + ')');\n\n      while (elemChildren[0]) {\n        g.appendChild(elemChildren[0]);\n      }\n\n      this.elem.layerElement.appendChild(g);\n      this.masker = mask;\n      groupPath.setAttribute('stroke', '#fff');\n    } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {\n      if (this.filterManager.effectElements[10].p.v === 2) {\n        elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;\n\n        while (elemChildren.length) {\n          this.elem.layerElement.removeChild(elemChildren[0]);\n        }\n      }\n\n      this.elem.layerElement.appendChild(groupPath);\n      this.elem.layerElement.removeAttribute('mask');\n      groupPath.setAttribute('stroke', '#fff');\n    }\n\n    this.initialized = true;\n    this.pathMasker = groupPath;\n  };\n\n  SVGStrokeEffect.prototype.renderFrame = function (forceRender) {\n    if (!this.initialized) {\n      this.initialize();\n    }\n\n    var i;\n    var len = this.paths.length;\n    var mask;\n    var path;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.paths[i].m !== -1) {\n        mask = this.elem.maskManager.viewData[this.paths[i].m];\n        path = this.paths[i].p;\n\n        if (forceRender || this.filterManager._mdf || mask.prop._mdf) {\n          path.setAttribute('d', mask.lastPath);\n        }\n\n        if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {\n          var dasharrayValue;\n\n          if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {\n            var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;\n            var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;\n            var l = path.getTotalLength();\n            dasharrayValue = '0 0 0 ' + l * s + ' ';\n            var lineLength = l * (e - s);\n            var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;\n            var units = Math.floor(lineLength / segment);\n            var j;\n\n            for (j = 0; j < units; j += 1) {\n              dasharrayValue += '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + ' ';\n            }\n\n            dasharrayValue += '0 ' + l * 10 + ' 0 0';\n          } else {\n            dasharrayValue = '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;\n          }\n\n          path.setAttribute('stroke-dasharray', dasharrayValue);\n        }\n      }\n    }\n\n    if (forceRender || this.filterManager.effectElements[4].p._mdf) {\n      this.pathMasker.setAttribute('stroke-width', this.filterManager.effectElements[4].p.v * 2);\n    }\n\n    if (forceRender || this.filterManager.effectElements[6].p._mdf) {\n      this.pathMasker.setAttribute('opacity', this.filterManager.effectElements[6].p.v);\n    }\n\n    if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {\n      if (forceRender || this.filterManager.effectElements[3].p._mdf) {\n        var color = this.filterManager.effectElements[3].p.v;\n        this.pathMasker.setAttribute('stroke', 'rgb(' + bmFloor(color[0] * 255) + ',' + bmFloor(color[1] * 255) + ',' + bmFloor(color[2] * 255) + ')');\n      }\n    }\n  };\n\n  function SVGTritoneFilter(filter, filterManager, elem, id) {\n    this.filterManager = filterManager;\n    var feColorMatrix = createNS('feColorMatrix');\n    feColorMatrix.setAttribute('type', 'matrix');\n    feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');\n    feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');\n    filter.appendChild(feColorMatrix);\n    var feComponentTransfer = createNS('feComponentTransfer');\n    feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');\n    feComponentTransfer.setAttribute('result', id);\n    this.matrixFilter = feComponentTransfer;\n    var feFuncR = createNS('feFuncR');\n    feFuncR.setAttribute('type', 'table');\n    feComponentTransfer.appendChild(feFuncR);\n    this.feFuncR = feFuncR;\n    var feFuncG = createNS('feFuncG');\n    feFuncG.setAttribute('type', 'table');\n    feComponentTransfer.appendChild(feFuncG);\n    this.feFuncG = feFuncG;\n    var feFuncB = createNS('feFuncB');\n    feFuncB.setAttribute('type', 'table');\n    feComponentTransfer.appendChild(feFuncB);\n    this.feFuncB = feFuncB;\n    filter.appendChild(feComponentTransfer);\n  }\n\n  SVGTritoneFilter.prototype.renderFrame = function (forceRender) {\n    if (forceRender || this.filterManager._mdf) {\n      var color1 = this.filterManager.effectElements[0].p.v;\n      var color2 = this.filterManager.effectElements[1].p.v;\n      var color3 = this.filterManager.effectElements[2].p.v;\n      var tableR = color3[0] + ' ' + color2[0] + ' ' + color1[0];\n      var tableG = color3[1] + ' ' + color2[1] + ' ' + color1[1];\n      var tableB = color3[2] + ' ' + color2[2] + ' ' + color1[2];\n      this.feFuncR.setAttribute('tableValues', tableR);\n      this.feFuncG.setAttribute('tableValues', tableG);\n      this.feFuncB.setAttribute('tableValues', tableB);\n    }\n  };\n\n  function SVGProLevelsFilter(filter, filterManager, elem, id) {\n    this.filterManager = filterManager;\n    var effectElements = this.filterManager.effectElements;\n    var feComponentTransfer = createNS('feComponentTransfer'); // Red\n\n    if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {\n      this.feFuncR = this.createFeFunc('feFuncR', feComponentTransfer);\n    } // Green\n\n\n    if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {\n      this.feFuncG = this.createFeFunc('feFuncG', feComponentTransfer);\n    } // Blue\n\n\n    if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {\n      this.feFuncB = this.createFeFunc('feFuncB', feComponentTransfer);\n    } // Alpha\n\n\n    if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {\n      this.feFuncA = this.createFeFunc('feFuncA', feComponentTransfer);\n    } // RGB\n\n\n    if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {\n      feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');\n      filter.appendChild(feComponentTransfer);\n    }\n\n    if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {\n      feComponentTransfer = createNS('feComponentTransfer');\n      feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');\n      feComponentTransfer.setAttribute('result', id);\n      filter.appendChild(feComponentTransfer);\n      this.feFuncRComposed = this.createFeFunc('feFuncR', feComponentTransfer);\n      this.feFuncGComposed = this.createFeFunc('feFuncG', feComponentTransfer);\n      this.feFuncBComposed = this.createFeFunc('feFuncB', feComponentTransfer);\n    }\n  }\n\n  SVGProLevelsFilter.prototype.createFeFunc = function (type, feComponentTransfer) {\n    var feFunc = createNS(type);\n    feFunc.setAttribute('type', 'table');\n    feComponentTransfer.appendChild(feFunc);\n    return feFunc;\n  };\n\n  SVGProLevelsFilter.prototype.getTableValue = function (inputBlack, inputWhite, gamma, outputBlack, outputWhite) {\n    var cnt = 0;\n    var segments = 256;\n    var perc;\n    var min = Math.min(inputBlack, inputWhite);\n    var max = Math.max(inputBlack, inputWhite);\n    var table = Array.call(null, {\n      length: segments\n    });\n    var colorValue;\n    var pos = 0;\n    var outputDelta = outputWhite - outputBlack;\n    var inputDelta = inputWhite - inputBlack;\n\n    while (cnt <= 256) {\n      perc = cnt / 256;\n\n      if (perc <= min) {\n        colorValue = inputDelta < 0 ? outputWhite : outputBlack;\n      } else if (perc >= max) {\n        colorValue = inputDelta < 0 ? outputBlack : outputWhite;\n      } else {\n        colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);\n      }\n\n      table[pos] = colorValue;\n      pos += 1;\n      cnt += 256 / (segments - 1);\n    }\n\n    return table.join(' ');\n  };\n\n  SVGProLevelsFilter.prototype.renderFrame = function (forceRender) {\n    if (forceRender || this.filterManager._mdf) {\n      var val;\n      var effectElements = this.filterManager.effectElements;\n\n      if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {\n        val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);\n        this.feFuncRComposed.setAttribute('tableValues', val);\n        this.feFuncGComposed.setAttribute('tableValues', val);\n        this.feFuncBComposed.setAttribute('tableValues', val);\n      }\n\n      if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {\n        val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);\n        this.feFuncR.setAttribute('tableValues', val);\n      }\n\n      if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {\n        val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);\n        this.feFuncG.setAttribute('tableValues', val);\n      }\n\n      if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {\n        val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);\n        this.feFuncB.setAttribute('tableValues', val);\n      }\n\n      if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {\n        val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);\n        this.feFuncA.setAttribute('tableValues', val);\n      }\n    }\n  };\n\n  function SVGDropShadowEffect(filter, filterManager, elem, id, source) {\n    var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize;\n    var filterSize = filterManager.data.fs || globalFilterSize;\n    filter.setAttribute('x', filterSize.x || globalFilterSize.x);\n    filter.setAttribute('y', filterSize.y || globalFilterSize.y);\n    filter.setAttribute('width', filterSize.width || globalFilterSize.width);\n    filter.setAttribute('height', filterSize.height || globalFilterSize.height);\n    this.filterManager = filterManager;\n    var feGaussianBlur = createNS('feGaussianBlur');\n    feGaussianBlur.setAttribute('in', 'SourceAlpha');\n    feGaussianBlur.setAttribute('result', id + '_drop_shadow_1');\n    feGaussianBlur.setAttribute('stdDeviation', '0');\n    this.feGaussianBlur = feGaussianBlur;\n    filter.appendChild(feGaussianBlur);\n    var feOffset = createNS('feOffset');\n    feOffset.setAttribute('dx', '25');\n    feOffset.setAttribute('dy', '0');\n    feOffset.setAttribute('in', id + '_drop_shadow_1');\n    feOffset.setAttribute('result', id + '_drop_shadow_2');\n    this.feOffset = feOffset;\n    filter.appendChild(feOffset);\n    var feFlood = createNS('feFlood');\n    feFlood.setAttribute('flood-color', '#00ff00');\n    feFlood.setAttribute('flood-opacity', '1');\n    feFlood.setAttribute('result', id + '_drop_shadow_3');\n    this.feFlood = feFlood;\n    filter.appendChild(feFlood);\n    var feComposite = createNS('feComposite');\n    feComposite.setAttribute('in', id + '_drop_shadow_3');\n    feComposite.setAttribute('in2', id + '_drop_shadow_2');\n    feComposite.setAttribute('operator', 'in');\n    feComposite.setAttribute('result', id + '_drop_shadow_4');\n    filter.appendChild(feComposite);\n    var feMerge = this.createMergeNode(id, [id + '_drop_shadow_4', source]);\n    filter.appendChild(feMerge); //\n  }\n\n  extendPrototype([SVGComposableEffect], SVGDropShadowEffect);\n\n  SVGDropShadowEffect.prototype.renderFrame = function (forceRender) {\n    if (forceRender || this.filterManager._mdf) {\n      if (forceRender || this.filterManager.effectElements[4].p._mdf) {\n        this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4);\n      }\n\n      if (forceRender || this.filterManager.effectElements[0].p._mdf) {\n        var col = this.filterManager.effectElements[0].p.v;\n        this.feFlood.setAttribute('flood-color', rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));\n      }\n\n      if (forceRender || this.filterManager.effectElements[1].p._mdf) {\n        this.feFlood.setAttribute('flood-opacity', this.filterManager.effectElements[1].p.v / 255);\n      }\n\n      if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {\n        var distance = this.filterManager.effectElements[3].p.v;\n        var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;\n        var x = distance * Math.cos(angle);\n        var y = distance * Math.sin(angle);\n        this.feOffset.setAttribute('dx', x);\n        this.feOffset.setAttribute('dy', y);\n      }\n    }\n  };\n\n  var _svgMatteSymbols = [];\n\n  function SVGMatte3Effect(filterElem, filterManager, elem) {\n    this.initialized = false;\n    this.filterManager = filterManager;\n    this.filterElem = filterElem;\n    this.elem = elem;\n    elem.matteElement = createNS('g');\n    elem.matteElement.appendChild(elem.layerElement);\n    elem.matteElement.appendChild(elem.transformedElement);\n    elem.baseElement = elem.matteElement;\n  }\n\n  SVGMatte3Effect.prototype.findSymbol = function (mask) {\n    var i = 0;\n    var len = _svgMatteSymbols.length;\n\n    while (i < len) {\n      if (_svgMatteSymbols[i] === mask) {\n        return _svgMatteSymbols[i];\n      }\n\n      i += 1;\n    }\n\n    return null;\n  };\n\n  SVGMatte3Effect.prototype.replaceInParent = function (mask, symbolId) {\n    var parentNode = mask.layerElement.parentNode;\n\n    if (!parentNode) {\n      return;\n    }\n\n    var children = parentNode.children;\n    var i = 0;\n    var len = children.length;\n\n    while (i < len) {\n      if (children[i] === mask.layerElement) {\n        break;\n      }\n\n      i += 1;\n    }\n\n    var nextChild;\n\n    if (i <= len - 2) {\n      nextChild = children[i + 1];\n    }\n\n    var useElem = createNS('use');\n    useElem.setAttribute('href', '#' + symbolId);\n\n    if (nextChild) {\n      parentNode.insertBefore(useElem, nextChild);\n    } else {\n      parentNode.appendChild(useElem);\n    }\n  };\n\n  SVGMatte3Effect.prototype.setElementAsMask = function (elem, mask) {\n    if (!this.findSymbol(mask)) {\n      var symbolId = createElementID();\n      var masker = createNS('mask');\n      masker.setAttribute('id', mask.layerId);\n      masker.setAttribute('mask-type', 'alpha');\n\n      _svgMatteSymbols.push(mask);\n\n      var defs = elem.globalData.defs;\n      defs.appendChild(masker);\n      var symbol = createNS('symbol');\n      symbol.setAttribute('id', symbolId);\n      this.replaceInParent(mask, symbolId);\n      symbol.appendChild(mask.layerElement);\n      defs.appendChild(symbol);\n      var useElem = createNS('use');\n      useElem.setAttribute('href', '#' + symbolId);\n      masker.appendChild(useElem);\n      mask.data.hd = false;\n      mask.show();\n    }\n\n    elem.setMatte(mask.layerId);\n  };\n\n  SVGMatte3Effect.prototype.initialize = function () {\n    var ind = this.filterManager.effectElements[0].p.v;\n    var elements = this.elem.comp.elements;\n    var i = 0;\n    var len = elements.length;\n\n    while (i < len) {\n      if (elements[i] && elements[i].data.ind === ind) {\n        this.setElementAsMask(this.elem, elements[i]);\n      }\n\n      i += 1;\n    }\n\n    this.initialized = true;\n  };\n\n  SVGMatte3Effect.prototype.renderFrame = function () {\n    if (!this.initialized) {\n      this.initialize();\n    }\n  };\n\n  function SVGGaussianBlurEffect(filter, filterManager, elem, id) {\n    // Outset the filter region by 100% on all sides to accommodate blur expansion.\n    filter.setAttribute('x', '-100%');\n    filter.setAttribute('y', '-100%');\n    filter.setAttribute('width', '300%');\n    filter.setAttribute('height', '300%');\n    this.filterManager = filterManager;\n    var feGaussianBlur = createNS('feGaussianBlur');\n    feGaussianBlur.setAttribute('result', id);\n    filter.appendChild(feGaussianBlur);\n    this.feGaussianBlur = feGaussianBlur;\n  }\n\n  SVGGaussianBlurEffect.prototype.renderFrame = function (forceRender) {\n    if (forceRender || this.filterManager._mdf) {\n      // Empirical value, matching AE's blur appearance.\n      var kBlurrinessToSigma = 0.3;\n      var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma; // Dimensions mapping:\n      //\n      //   1 -> horizontal & vertical\n      //   2 -> horizontal only\n      //   3 -> vertical only\n      //\n\n      var dimensions = this.filterManager.effectElements[1].p.v;\n      var sigmaX = dimensions == 3 ? 0 : sigma; // eslint-disable-line eqeqeq\n\n      var sigmaY = dimensions == 2 ? 0 : sigma; // eslint-disable-line eqeqeq\n\n      this.feGaussianBlur.setAttribute('stdDeviation', sigmaX + ' ' + sigmaY); // Repeat edges mapping:\n      //\n      //   0 -> off -> duplicate\n      //   1 -> on  -> wrap\n\n      var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? 'wrap' : 'duplicate'; // eslint-disable-line eqeqeq\n\n      this.feGaussianBlur.setAttribute('edgeMode', edgeMode);\n    }\n  };\n\n  function TransformEffect() {}\n\n  TransformEffect.prototype.init = function (effectsManager) {\n    this.effectsManager = effectsManager;\n    this.type = effectTypes.TRANSFORM_EFFECT;\n    this.matrix = new Matrix();\n    this.opacity = -1;\n    this._mdf = false;\n    this._opMdf = false;\n  };\n\n  TransformEffect.prototype.renderFrame = function (forceFrame) {\n    this._opMdf = false;\n    this._mdf = false;\n\n    if (forceFrame || this.effectsManager._mdf) {\n      var effectElements = this.effectsManager.effectElements;\n      var anchor = effectElements[0].p.v;\n      var position = effectElements[1].p.v;\n      var isUniformScale = effectElements[2].p.v === 1;\n      var scaleHeight = effectElements[3].p.v;\n      var scaleWidth = isUniformScale ? scaleHeight : effectElements[4].p.v;\n      var skew = effectElements[5].p.v;\n      var skewAxis = effectElements[6].p.v;\n      var rotation = effectElements[7].p.v;\n      this.matrix.reset();\n      this.matrix.translate(-anchor[0], -anchor[1], anchor[2]);\n      this.matrix.scale(scaleWidth * 0.01, scaleHeight * 0.01, 1);\n      this.matrix.rotate(-rotation * degToRads);\n      this.matrix.skewFromAxis(-skew * degToRads, (skewAxis + 90) * degToRads);\n      this.matrix.translate(position[0], position[1], 0);\n      this._mdf = true;\n\n      if (this.opacity !== effectElements[8].p.v) {\n        this.opacity = effectElements[8].p.v;\n        this._opMdf = true;\n      }\n    }\n  };\n\n  function SVGTransformEffect(_, filterManager) {\n    this.init(filterManager);\n  }\n\n  extendPrototype([TransformEffect], SVGTransformEffect);\n\n  function CVTransformEffect(effectsManager) {\n    this.init(effectsManager);\n  }\n\n  extendPrototype([TransformEffect], CVTransformEffect);\n\n  registerRenderer('canvas', CanvasRenderer);\n  registerRenderer('html', HybridRenderer);\n  registerRenderer('svg', SVGRenderer); // Registering shape modifiers\n\n  ShapeModifiers.registerModifier('tm', TrimModifier);\n  ShapeModifiers.registerModifier('pb', PuckerAndBloatModifier);\n  ShapeModifiers.registerModifier('rp', RepeaterModifier);\n  ShapeModifiers.registerModifier('rd', RoundCornersModifier);\n  ShapeModifiers.registerModifier('zz', ZigZagModifier);\n  ShapeModifiers.registerModifier('op', OffsetPathModifier); // Registering expression plugin\n\n  setExpressionsPlugin(Expressions);\n  setExpressionInterfaces(getInterface);\n  initialize$1();\n  initialize(); // Registering svg effects\n\n  registerEffect$1(20, SVGTintFilter, true);\n  registerEffect$1(21, SVGFillFilter, true);\n  registerEffect$1(22, SVGStrokeEffect, false);\n  registerEffect$1(23, SVGTritoneFilter, true);\n  registerEffect$1(24, SVGProLevelsFilter, true);\n  registerEffect$1(25, SVGDropShadowEffect, true);\n  registerEffect$1(28, SVGMatte3Effect, false);\n  registerEffect$1(29, SVGGaussianBlurEffect, true);\n  registerEffect$1(35, SVGTransformEffect, false);\n  registerEffect(35, CVTransformEffect);\n\n  return lottie;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3R0aWUtd2ViL2J1aWxkL3BsYXllci9sb3R0aWUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsQ0FDcUc7QUFDdkcsQ0FBQyx1QkFBdUI7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsd0JBQXdCLDBCQUEwQjtBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYLHdDQUF3QztBQUN4QyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSw0QkFBNEIsMkJBQTJCLDJFQUEyRSxvQ0FBb0Msd0JBQXdCLE9BQU8sb0NBQW9DLG1JQUFtSTtBQUM1VztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsd0JBQXdCLDBCQUEwQjtBQUNqRTtBQUNBOztBQUVBLDRCQUE0QiwyQkFBMkIsMkVBQTJFLG9DQUFvQyx3QkFBd0IsT0FBTyxvQ0FBb0MsbUlBQW1JOztBQUU1VztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxTQUFTLEdBQUcsK0RBQStELHlCQUF5Qjs7QUFFcEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLFNBQVM7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQSxvQ0FBb0MsVUFBVTtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9CQUFvQjtBQUNsRCw4QkFBOEIsOEJBQThCO0FBQzVELDhCQUE4QixZQUFZO0FBQzFDLDhCQUE4QixxQkFBcUI7QUFDbkQsOEJBQThCLGNBQWM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUEsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLFNBQVM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQSxrQ0FBa0MsVUFBVTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBLGtDQUFrQyxVQUFVO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLFNBQVM7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUEsb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7OztBQUdqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYixZQUFZO0FBQ1o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGtCQUFrQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QiwyQkFBMkIsMkVBQTJFLG9DQUFvQyx3QkFBd0IsT0FBTyxvQ0FBb0MsbUlBQW1JOztBQUU1VztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFVBQVU7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdHQUFnRzs7QUFFaEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLHlCQUF5QjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxlQUFlO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFVBQVU7QUFDNUIsb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw2TUFBNk07QUFDN007O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCw0QkFBNEIsMkJBQTJCLDJFQUEyRSxvQ0FBb0Msd0JBQXdCLE9BQU8sb0NBQW9DLG1JQUFtSTtBQUM1VztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixXQUFXO0FBQy9COztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCLDJCQUEyQjs7QUFFM0Isa0NBQWtDOztBQUVsQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EseUVBQXlFOztBQUV6RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQyxtQ0FBbUM7O0FBRW5DO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1IsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCLDhEQUE4RDs7QUFFOUQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsUUFBUTtBQUNoQyx1RkFBdUY7QUFDdkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFVBQVU7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixVQUFVO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QixtQ0FBbUM7O0FBRW5DLDBCQUEwQjs7QUFFMUIsOEJBQThCOztBQUU5Qix5QkFBeUI7O0FBRXpCLGlDQUFpQzs7QUFFakM7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUEsNEJBQTRCO0FBQzVCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0EsNkVBQTZFOztBQUU3RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUIsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBOztBQUVBLG9CQUFvQixVQUFVO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0dBQWdHO0FBQ2hHOztBQUVBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUI7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0NBQWtDLElBQUksa0NBQWtDOztBQUU3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLGtDQUFrQyxJQUFJLGtDQUFrQzs7QUFFakg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckMsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0EsZ0NBQWdDOztBQUVoQywyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBOztBQUVBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdC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QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFD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Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCLG1DQUFtQzs7QUFFbkMsMEJBQTBCOztBQUUxQiw4QkFBOEI7O0FBRTlCLHlCQUF5Qjs7QUFFekIsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQsY0FBYzs7QUFFZCxjQUFjOztBQUVkLCtCQUErQjtBQUMvQixRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixvQ0FBb0M7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SDs7QUFFeEg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7OztBQUdWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLG1IQUFtSDs7QUFFbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlOztBQUVmLGVBQWU7O0FBRWYsZUFBZTtBQUNmLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBFQUEwRTs7QUFFbEcsdUVBQXVFLFlBQVksb0JBQW9CLFFBQVE7O0FBRS9HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQyw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQyw0RkFBNEY7QUFDNUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSx3RkFBd0YsVUFBVTs7QUFFbEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVLGlDQUFpQztBQUMzQyxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxHQUFHOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDtBQUNuRDs7QUFFQSx3RUFBd0U7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVILDBCQUEwQiwyQkFBMkIsMkVBQTJFLGtDQUFrQyx3QkFBd0IsT0FBTyxrQ0FBa0MsbUlBQW1JOztBQUV0VztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRKQUE0SjtBQUM1SjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsaUpBQWlKOztBQUVqSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CLG1KQUFtSjtBQUNuSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0lBQXdJO0FBQ3hJOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0SUFBNEk7QUFDNUk7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwSkFBMEo7QUFDMUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7O0FBRS9EO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEOztBQUVoRCxnREFBZ0Q7O0FBRWhELCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7O0FBRUEsMkZBQTJGOztBQUUzRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvdHRpZS13ZWIvYnVpbGQvcGxheWVyL2xvdHRpZS5qcz8xMjNkIl0sInNvdXJjZXNDb250ZW50IjpbIih0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiKSAmJiAoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5sb3R0aWUgPSBmYWN0b3J5KCkpO1xufSkodGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBzdmdOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gIHZhciBsb2NhdGlvbkhyZWYgPSAnJztcbiAgdmFyIF91c2VXZWJXb3JrZXIgPSBmYWxzZTtcbiAgdmFyIGluaXRpYWxEZWZhdWx0RnJhbWUgPSAtOTk5OTk5O1xuXG4gIHZhciBzZXRXZWJXb3JrZXIgPSBmdW5jdGlvbiBzZXRXZWJXb3JrZXIoZmxhZykge1xuICAgIF91c2VXZWJXb3JrZXIgPSAhIWZsYWc7XG4gIH07XG5cbiAgdmFyIGdldFdlYldvcmtlciA9IGZ1bmN0aW9uIGdldFdlYldvcmtlcigpIHtcbiAgICByZXR1cm4gX3VzZVdlYldvcmtlcjtcbiAgfTtcblxuICB2YXIgc2V0TG9jYXRpb25IcmVmID0gZnVuY3Rpb24gc2V0TG9jYXRpb25IcmVmKHZhbHVlKSB7XG4gICAgbG9jYXRpb25IcmVmID0gdmFsdWU7XG4gIH07XG5cbiAgdmFyIGdldExvY2F0aW9uSHJlZiA9IGZ1bmN0aW9uIGdldExvY2F0aW9uSHJlZigpIHtcbiAgICByZXR1cm4gbG9jYXRpb25IcmVmO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVRhZyh0eXBlKSB7XG4gICAgLy8gcmV0dXJuIHthcHBlbmRDaGlsZDpmdW5jdGlvbigpe30sc2V0QXR0cmlidXRlOmZ1bmN0aW9uKCl7fSxzdHlsZTp7fX1cbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZFByb3RvdHlwZShzb3VyY2VzLCBkZXN0aW5hdGlvbikge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBzb3VyY2VzLmxlbmd0aDtcbiAgICB2YXIgc291cmNlUHJvdG90eXBlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBzb3VyY2VQcm90b3R5cGUgPSBzb3VyY2VzW2ldLnByb3RvdHlwZTtcblxuICAgICAgZm9yICh2YXIgYXR0ciBpbiBzb3VyY2VQcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2VQcm90b3R5cGUsIGF0dHIpKSBkZXN0aW5hdGlvbi5wcm90b3R5cGVbYXR0cl0gPSBzb3VyY2VQcm90b3R5cGVbYXR0cl07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGVzY3JpcHRvcihvYmplY3QsIHByb3ApIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3ApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJveHlGdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBmdW5jdGlvbiBQcm94eUZ1bmN0aW9uKCkge31cblxuICAgIFByb3h5RnVuY3Rpb24ucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHJldHVybiBQcm94eUZ1bmN0aW9uO1xuICB9XG5cbiAgLy8gaW1wb3J0IEhvd2wgZnJvbSAnLi4vLi4vM3JkX3BhcnR5L2hvd2xlcic7XG4gIHZhciBhdWRpb0NvbnRyb2xsZXJGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF1ZGlvQ29udHJvbGxlcihhdWRpb0ZhY3RvcnkpIHtcbiAgICAgIHRoaXMuYXVkaW9zID0gW107XG4gICAgICB0aGlzLmF1ZGlvRmFjdG9yeSA9IGF1ZGlvRmFjdG9yeTtcbiAgICAgIHRoaXMuX3ZvbHVtZSA9IDE7XG4gICAgICB0aGlzLl9pc011dGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgQXVkaW9Db250cm9sbGVyLnByb3RvdHlwZSA9IHtcbiAgICAgIGFkZEF1ZGlvOiBmdW5jdGlvbiBhZGRBdWRpbyhhdWRpbykge1xuICAgICAgICB0aGlzLmF1ZGlvcy5wdXNoKGF1ZGlvKTtcbiAgICAgIH0sXG4gICAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5hdWRpb3MubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHRoaXMuYXVkaW9zW2ldLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXN1bWU6IGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmF1ZGlvcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgdGhpcy5hdWRpb3NbaV0ucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXRSYXRlOiBmdW5jdGlvbiBzZXRSYXRlKHJhdGVWYWx1ZSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuYXVkaW9zLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICB0aGlzLmF1ZGlvc1tpXS5zZXRSYXRlKHJhdGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVBdWRpbzogZnVuY3Rpb24gY3JlYXRlQXVkaW8oYXNzZXRQYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLmF1ZGlvRmFjdG9yeSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF1ZGlvRmFjdG9yeShhc3NldFBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdpbmRvdy5Ib3dsKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuSG93bCh7XG4gICAgICAgICAgICBzcmM6IFthc3NldFBhdGhdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzUGxheWluZzogZmFsc2UsXG4gICAgICAgICAgcGxheTogZnVuY3Rpb24gcGxheSgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNlZWs6IGZ1bmN0aW9uIHNlZWsoKSB7XG4gICAgICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcGxheWluZzogZnVuY3Rpb24gcGxheWluZygpIHt9LFxuICAgICAgICAgIHJhdGU6IGZ1bmN0aW9uIHJhdGUoKSB7fSxcbiAgICAgICAgICBzZXRWb2x1bWU6IGZ1bmN0aW9uIHNldFZvbHVtZSgpIHt9XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgc2V0QXVkaW9GYWN0b3J5OiBmdW5jdGlvbiBzZXRBdWRpb0ZhY3RvcnkoYXVkaW9GYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuYXVkaW9GYWN0b3J5ID0gYXVkaW9GYWN0b3J5O1xuICAgICAgfSxcbiAgICAgIHNldFZvbHVtZTogZnVuY3Rpb24gc2V0Vm9sdW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZvbHVtZSA9IHZhbHVlO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xuICAgICAgfSxcbiAgICAgIG11dGU6IGZ1bmN0aW9uIG11dGUoKSB7XG4gICAgICAgIHRoaXMuX2lzTXV0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xuICAgICAgfSxcbiAgICAgIHVubXV0ZTogZnVuY3Rpb24gdW5tdXRlKCkge1xuICAgICAgICB0aGlzLl9pc011dGVkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlVm9sdW1lKCk7XG4gICAgICB9LFxuICAgICAgZ2V0Vm9sdW1lOiBmdW5jdGlvbiBnZXRWb2x1bWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92b2x1bWU7XG4gICAgICB9LFxuICAgICAgX3VwZGF0ZVZvbHVtZTogZnVuY3Rpb24gX3VwZGF0ZVZvbHVtZSgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmF1ZGlvcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgdGhpcy5hdWRpb3NbaV0udm9sdW1lKHRoaXMuX3ZvbHVtZSAqICh0aGlzLl9pc011dGVkID8gMCA6IDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgQXVkaW9Db250cm9sbGVyKCk7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBjcmVhdGVUeXBlZEFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlZ3VsYXJBcnJheSh0eXBlLCBsZW4pIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgICAgY2FzZSAndWludDhjJzpcbiAgICAgICAgICB2YWx1ZSA9IDE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YWx1ZSA9IDEuMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGFyci5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVUeXBlZEFycmF5RmFjdG9yeSh0eXBlLCBsZW4pIHtcbiAgICAgIGlmICh0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobGVuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdpbnQxNicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGxlbik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSAndWludDhjJykge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGxlbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVSZWd1bGFyQXJyYXkodHlwZSwgbGVuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjcmVhdGVUeXBlZEFycmF5RmFjdG9yeTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlUmVndWxhckFycmF5O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2l6ZWRBcnJheShsZW4pIHtcbiAgICByZXR1cm4gQXJyYXkuYXBwbHkobnVsbCwge1xuICAgICAgbGVuZ3RoOiBsZW5cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90eXBlb2YkNihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiQ2ID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YkNiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mJDYob2JqKTsgfVxuICB2YXIgc3ViZnJhbWVFbmFibGVkID0gdHJ1ZTtcbiAgdmFyIGV4cHJlc3Npb25zUGx1Z2luID0gbnVsbDtcbiAgdmFyIGV4cHJlc3Npb25zSW50ZXJmYWNlcyA9IG51bGw7XG4gIHZhciBpZFByZWZpeCQxID0gJyc7XG4gIHZhciBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciBfc2hvdWxkUm91bmRWYWx1ZXMgPSBmYWxzZTtcbiAgdmFyIGJtUG93ID0gTWF0aC5wb3c7XG4gIHZhciBibVNxcnQgPSBNYXRoLnNxcnQ7XG4gIHZhciBibUZsb29yID0gTWF0aC5mbG9vcjtcbiAgdmFyIGJtTWF4ID0gTWF0aC5tYXg7XG4gIHZhciBibU1pbiA9IE1hdGgubWluO1xuICB2YXIgQk1NYXRoID0ge307XG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvcGVydHlOYW1lcyA9IFsnYWJzJywgJ2Fjb3MnLCAnYWNvc2gnLCAnYXNpbicsICdhc2luaCcsICdhdGFuJywgJ2F0YW5oJywgJ2F0YW4yJywgJ2NlaWwnLCAnY2JydCcsICdleHBtMScsICdjbHozMicsICdjb3MnLCAnY29zaCcsICdleHAnLCAnZmxvb3InLCAnZnJvdW5kJywgJ2h5cG90JywgJ2ltdWwnLCAnbG9nJywgJ2xvZzFwJywgJ2xvZzInLCAnbG9nMTAnLCAnbWF4JywgJ21pbicsICdwb3cnLCAncmFuZG9tJywgJ3JvdW5kJywgJ3NpZ24nLCAnc2luJywgJ3NpbmgnLCAnc3FydCcsICd0YW4nLCAndGFuaCcsICd0cnVuYycsICdFJywgJ0xOMTAnLCAnTE4yJywgJ0xPRzEwRScsICdMT0cyRScsICdQSScsICdTUVJUMV8yJywgJ1NRUlQyJ107XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHByb3BlcnR5TmFtZXMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBCTU1hdGhbcHJvcGVydHlOYW1lc1tpXV0gPSBNYXRoW3Byb3BlcnR5TmFtZXNbaV1dO1xuICAgIH1cbiAgfSkoKTtcblxuICBmdW5jdGlvbiBQcm9qZWN0SW50ZXJmYWNlJDEoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgQk1NYXRoLnJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4gIEJNTWF0aC5hYnMgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIHRPZlZhbCA9IF90eXBlb2YkNih2YWwpO1xuXG4gICAgaWYgKHRPZlZhbCA9PT0gJ29iamVjdCcgJiYgdmFsLmxlbmd0aCkge1xuICAgICAgdmFyIGFic0FyciA9IGNyZWF0ZVNpemVkQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYWJzQXJyW2ldID0gTWF0aC5hYnModmFsW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFic0FycjtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5hYnModmFsKTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEN1cnZlU2VnbWVudHMgPSAxNTA7XG4gIHZhciBkZWdUb1JhZHMgPSBNYXRoLlBJIC8gMTgwO1xuICB2YXIgcm91bmRDb3JuZXIgPSAwLjU1MTk7XG5cbiAgZnVuY3Rpb24gcm91bmRWYWx1ZXMoZmxhZykge1xuICAgIF9zaG91bGRSb3VuZFZhbHVlcyA9ICEhZmxhZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGJtUm5kKHZhbHVlKSB7XG4gICAgaWYgKF9zaG91bGRSb3VuZFZhbHVlcykge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0eWxlRGl2KGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBlbGVtZW50LnN0eWxlLnRvcCA9IDA7XG4gICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gMDtcbiAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMCc7XG4gICAgZWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSAnMCAwJztcbiAgICBlbGVtZW50LnN0eWxlLmJhY2tmYWNlVmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICBlbGVtZW50LnN0eWxlLndlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybVN0eWxlID0gJ3ByZXNlcnZlLTNkJztcbiAgICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybVN0eWxlID0gJ3ByZXNlcnZlLTNkJztcbiAgICBlbGVtZW50LnN0eWxlLm1velRyYW5zZm9ybVN0eWxlID0gJ3ByZXNlcnZlLTNkJztcbiAgfVxuXG4gIGZ1bmN0aW9uIEJNRW50ZXJGcmFtZUV2ZW50KHR5cGUsIGN1cnJlbnRUaW1lLCB0b3RhbFRpbWUsIGZyYW1lTXVsdGlwbGllcikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHRoaXMudG90YWxUaW1lID0gdG90YWxUaW1lO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gZnJhbWVNdWx0aXBsaWVyIDwgMCA/IC0xIDogMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEJNQ29tcGxldGVFdmVudCh0eXBlLCBmcmFtZU11bHRpcGxpZXIpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gZnJhbWVNdWx0aXBsaWVyIDwgMCA/IC0xIDogMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEJNQ29tcGxldGVMb29wRXZlbnQodHlwZSwgdG90YWxMb29wcywgY3VycmVudExvb3AsIGZyYW1lTXVsdGlwbGllcikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5jdXJyZW50TG9vcCA9IGN1cnJlbnRMb29wO1xuICAgIHRoaXMudG90YWxMb29wcyA9IHRvdGFsTG9vcHM7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSBmcmFtZU11bHRpcGxpZXIgPCAwID8gLTEgOiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gQk1TZWdtZW50U3RhcnRFdmVudCh0eXBlLCBmaXJzdEZyYW1lLCB0b3RhbEZyYW1lcykge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5maXJzdEZyYW1lID0gZmlyc3RGcmFtZTtcbiAgICB0aGlzLnRvdGFsRnJhbWVzID0gdG90YWxGcmFtZXM7XG4gIH1cblxuICBmdW5jdGlvbiBCTURlc3Ryb3lFdmVudCh0eXBlLCB0YXJnZXQpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gQk1SZW5kZXJGcmFtZUVycm9yRXZlbnQobmF0aXZlRXJyb3IsIGN1cnJlbnRUaW1lKSB7XG4gICAgdGhpcy50eXBlID0gJ3JlbmRlckZyYW1lRXJyb3InO1xuICAgIHRoaXMubmF0aXZlRXJyb3IgPSBuYXRpdmVFcnJvcjtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBCTUNvbmZpZ0Vycm9yRXZlbnQobmF0aXZlRXJyb3IpIHtcbiAgICB0aGlzLnR5cGUgPSAnY29uZmlnRXJyb3InO1xuICAgIHRoaXMubmF0aXZlRXJyb3IgPSBuYXRpdmVFcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIEJNQW5pbWF0aW9uQ29uZmlnRXJyb3JFdmVudCh0eXBlLCBuYXRpdmVFcnJvcikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5uYXRpdmVFcnJvciA9IG5hdGl2ZUVycm9yO1xuICB9XG5cbiAgdmFyIGNyZWF0ZUVsZW1lbnRJRCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2NvdW50ID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlSUQoKSB7XG4gICAgICBfY291bnQgKz0gMTtcbiAgICAgIHJldHVybiBpZFByZWZpeCQxICsgJ19fbG90dGllX2VsZW1lbnRfJyArIF9jb3VudDtcbiAgICB9O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gSFNWdG9SR0IoaCwgcywgdikge1xuICAgIHZhciByO1xuICAgIHZhciBnO1xuICAgIHZhciBiO1xuICAgIHZhciBpO1xuICAgIHZhciBmO1xuICAgIHZhciBwO1xuICAgIHZhciBxO1xuICAgIHZhciB0O1xuICAgIGkgPSBNYXRoLmZsb29yKGggKiA2KTtcbiAgICBmID0gaCAqIDYgLSBpO1xuICAgIHAgPSB2ICogKDEgLSBzKTtcbiAgICBxID0gdiAqICgxIC0gZiAqIHMpO1xuICAgIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG5cbiAgICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHIgPSB2O1xuICAgICAgICBnID0gdDtcbiAgICAgICAgYiA9IHA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIHIgPSBxO1xuICAgICAgICBnID0gdjtcbiAgICAgICAgYiA9IHA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHIgPSBwO1xuICAgICAgICBnID0gdjtcbiAgICAgICAgYiA9IHQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHIgPSBwO1xuICAgICAgICBnID0gcTtcbiAgICAgICAgYiA9IHY7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHIgPSB0O1xuICAgICAgICBnID0gcDtcbiAgICAgICAgYiA9IHY7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDU6XG4gICAgICAgIHIgPSB2O1xuICAgICAgICBnID0gcDtcbiAgICAgICAgYiA9IHE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gW3IsIGcsIGJdO1xuICB9XG5cbiAgZnVuY3Rpb24gUkdCdG9IU1YociwgZywgYikge1xuICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgdmFyIGg7XG4gICAgdmFyIHMgPSBtYXggPT09IDAgPyAwIDogZCAvIG1heDtcbiAgICB2YXIgdiA9IG1heCAvIDI1NTtcblxuICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICBjYXNlIG1pbjpcbiAgICAgICAgaCA9IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHI6XG4gICAgICAgIGggPSBnIC0gYiArIGQgKiAoZyA8IGIgPyA2IDogMCk7XG4gICAgICAgIGggLz0gNiAqIGQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGc6XG4gICAgICAgIGggPSBiIC0gciArIGQgKiAyO1xuICAgICAgICBoIC89IDYgKiBkO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBiOlxuICAgICAgICBoID0gciAtIGcgKyBkICogNDtcbiAgICAgICAgaCAvPSA2ICogZDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBbaCwgcywgdl07XG4gIH1cblxuICBmdW5jdGlvbiBhZGRTYXR1cmF0aW9uVG9SR0IoY29sb3IsIG9mZnNldCkge1xuICAgIHZhciBoc3YgPSBSR0J0b0hTVihjb2xvclswXSAqIDI1NSwgY29sb3JbMV0gKiAyNTUsIGNvbG9yWzJdICogMjU1KTtcbiAgICBoc3ZbMV0gKz0gb2Zmc2V0O1xuXG4gICAgaWYgKGhzdlsxXSA+IDEpIHtcbiAgICAgIGhzdlsxXSA9IDE7XG4gICAgfSBlbHNlIGlmIChoc3ZbMV0gPD0gMCkge1xuICAgICAgaHN2WzFdID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gSFNWdG9SR0IoaHN2WzBdLCBoc3ZbMV0sIGhzdlsyXSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRCcmlnaHRuZXNzVG9SR0IoY29sb3IsIG9mZnNldCkge1xuICAgIHZhciBoc3YgPSBSR0J0b0hTVihjb2xvclswXSAqIDI1NSwgY29sb3JbMV0gKiAyNTUsIGNvbG9yWzJdICogMjU1KTtcbiAgICBoc3ZbMl0gKz0gb2Zmc2V0O1xuXG4gICAgaWYgKGhzdlsyXSA+IDEpIHtcbiAgICAgIGhzdlsyXSA9IDE7XG4gICAgfSBlbHNlIGlmIChoc3ZbMl0gPCAwKSB7XG4gICAgICBoc3ZbMl0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBIU1Z0b1JHQihoc3ZbMF0sIGhzdlsxXSwgaHN2WzJdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEh1ZVRvUkdCKGNvbG9yLCBvZmZzZXQpIHtcbiAgICB2YXIgaHN2ID0gUkdCdG9IU1YoY29sb3JbMF0gKiAyNTUsIGNvbG9yWzFdICogMjU1LCBjb2xvclsyXSAqIDI1NSk7XG4gICAgaHN2WzBdICs9IG9mZnNldCAvIDM2MDtcblxuICAgIGlmIChoc3ZbMF0gPiAxKSB7XG4gICAgICBoc3ZbMF0gLT0gMTtcbiAgICB9IGVsc2UgaWYgKGhzdlswXSA8IDApIHtcbiAgICAgIGhzdlswXSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBIU1Z0b1JHQihoc3ZbMF0sIGhzdlsxXSwgaHN2WzJdKTtcbiAgfVxuXG4gIHZhciByZ2JUb0hleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29sb3JNYXAgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgaGV4O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSArPSAxKSB7XG4gICAgICBoZXggPSBpLnRvU3RyaW5nKDE2KTtcbiAgICAgIGNvbG9yTWFwW2ldID0gaGV4Lmxlbmd0aCA9PT0gMSA/ICcwJyArIGhleCA6IGhleDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICAgIGlmIChyIDwgMCkge1xuICAgICAgICByID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGcgPCAwKSB7XG4gICAgICAgIGcgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoYiA8IDApIHtcbiAgICAgICAgYiA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnIycgKyBjb2xvck1hcFtyXSArIGNvbG9yTWFwW2ddICsgY29sb3JNYXBbYl07XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBzZXRTdWJmcmFtZUVuYWJsZWQgPSBmdW5jdGlvbiBzZXRTdWJmcmFtZUVuYWJsZWQoZmxhZykge1xuICAgIHN1YmZyYW1lRW5hYmxlZCA9ICEhZmxhZztcbiAgfTtcblxuICB2YXIgZ2V0U3ViZnJhbWVFbmFibGVkID0gZnVuY3Rpb24gZ2V0U3ViZnJhbWVFbmFibGVkKCkge1xuICAgIHJldHVybiBzdWJmcmFtZUVuYWJsZWQ7XG4gIH07XG5cbiAgdmFyIHNldEV4cHJlc3Npb25zUGx1Z2luID0gZnVuY3Rpb24gc2V0RXhwcmVzc2lvbnNQbHVnaW4odmFsdWUpIHtcbiAgICBleHByZXNzaW9uc1BsdWdpbiA9IHZhbHVlO1xuICB9O1xuXG4gIHZhciBnZXRFeHByZXNzaW9uc1BsdWdpbiA9IGZ1bmN0aW9uIGdldEV4cHJlc3Npb25zUGx1Z2luKCkge1xuICAgIHJldHVybiBleHByZXNzaW9uc1BsdWdpbjtcbiAgfTtcblxuICB2YXIgc2V0RXhwcmVzc2lvbkludGVyZmFjZXMgPSBmdW5jdGlvbiBzZXRFeHByZXNzaW9uSW50ZXJmYWNlcyh2YWx1ZSkge1xuICAgIGV4cHJlc3Npb25zSW50ZXJmYWNlcyA9IHZhbHVlO1xuICB9O1xuXG4gIHZhciBnZXRFeHByZXNzaW9uSW50ZXJmYWNlcyA9IGZ1bmN0aW9uIGdldEV4cHJlc3Npb25JbnRlcmZhY2VzKCkge1xuICAgIHJldHVybiBleHByZXNzaW9uc0ludGVyZmFjZXM7XG4gIH07XG5cbiAgdmFyIHNldERlZmF1bHRDdXJ2ZVNlZ21lbnRzID0gZnVuY3Rpb24gc2V0RGVmYXVsdEN1cnZlU2VnbWVudHModmFsdWUpIHtcbiAgICBkZWZhdWx0Q3VydmVTZWdtZW50cyA9IHZhbHVlO1xuICB9O1xuXG4gIHZhciBnZXREZWZhdWx0Q3VydmVTZWdtZW50cyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDdXJ2ZVNlZ21lbnRzKCkge1xuICAgIHJldHVybiBkZWZhdWx0Q3VydmVTZWdtZW50cztcbiAgfTtcblxuICB2YXIgc2V0SWRQcmVmaXggPSBmdW5jdGlvbiBzZXRJZFByZWZpeCh2YWx1ZSkge1xuICAgIGlkUHJlZml4JDEgPSB2YWx1ZTtcbiAgfTtcblxuICB2YXIgZ2V0SWRQcmVmaXggPSBmdW5jdGlvbiBnZXRJZFByZWZpeCgpIHtcbiAgICByZXR1cm4gaWRQcmVmaXgkMTtcbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVOUyh0eXBlKSB7XG4gICAgLy8gcmV0dXJuIHthcHBlbmRDaGlsZDpmdW5jdGlvbigpe30sc2V0QXR0cmlidXRlOmZ1bmN0aW9uKCl7fSxzdHlsZTp7fX1cbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCB0eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90eXBlb2YkNShvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiQ1ID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YkNSA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mJDUob2JqKTsgfVxuXG4gIHZhciBkYXRhTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2NvdW50ZXJJZCA9IDE7XG4gICAgdmFyIHByb2Nlc3NlcyA9IFtdO1xuICAgIHZhciB3b3JrZXJGbjtcbiAgICB2YXIgd29ya2VySW5zdGFuY2U7XG4gICAgdmFyIHdvcmtlclByb3h5ID0ge1xuICAgICAgb25tZXNzYWdlOiBmdW5jdGlvbiBvbm1lc3NhZ2UoKSB7fSxcbiAgICAgIHBvc3RNZXNzYWdlOiBmdW5jdGlvbiBwb3N0TWVzc2FnZShwYXRoKSB7XG4gICAgICAgIHdvcmtlckZuKHtcbiAgICAgICAgICBkYXRhOiBwYXRoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIF93b3JrZXJTZWxmID0ge1xuICAgICAgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgd29ya2VyUHJveHkub25tZXNzYWdlKHtcbiAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVXb3JrZXIoZm4pIHtcbiAgICAgIGlmICh3aW5kb3cuV29ya2VyICYmIHdpbmRvdy5CbG9iICYmIGdldFdlYldvcmtlcigpKSB7XG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoWyd2YXIgX3dvcmtlclNlbGYgPSBzZWxmOyBzZWxmLm9ubWVzc2FnZSA9ICcsIGZuLnRvU3RyaW5nKCldLCB7XG4gICAgICAgICAgdHlwZTogJ3RleHQvamF2YXNjcmlwdCdcbiAgICAgICAgfSk7IC8vIHZhciBibG9iID0gbmV3IEJsb2IoWydzZWxmLm9ubWVzc2FnZSA9ICcsIGZuLnRvU3RyaW5nKCldLCB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pO1xuXG4gICAgICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICByZXR1cm4gbmV3IFdvcmtlcih1cmwpO1xuICAgICAgfVxuXG4gICAgICB3b3JrZXJGbiA9IGZuO1xuICAgICAgcmV0dXJuIHdvcmtlclByb3h5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldHVwV29ya2VyKCkge1xuICAgICAgaWYgKCF3b3JrZXJJbnN0YW5jZSkge1xuICAgICAgICB3b3JrZXJJbnN0YW5jZSA9IGNyZWF0ZVdvcmtlcihmdW5jdGlvbiB3b3JrZXJTdGFydChlKSB7XG4gICAgICAgICAgZnVuY3Rpb24gZGF0YUZ1bmN0aW9uTWFuYWdlcigpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlTGF5ZXJzKGxheWVycywgY29tcHMpIHtcbiAgICAgICAgICAgICAgdmFyIGxheWVyRGF0YTtcbiAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgIHZhciBsZW4gPSBsYXllcnMubGVuZ3RoO1xuICAgICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgICAgdmFyIGpMZW47XG4gICAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgICB2YXIga0xlbjtcblxuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBsYXllckRhdGEgPSBsYXllcnNbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoJ2tzJyBpbiBsYXllckRhdGEgJiYgIWxheWVyRGF0YS5jb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIGxheWVyRGF0YS5jb21wbGV0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobGF5ZXJEYXRhLmhhc01hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hc2tQcm9wcyA9IGxheWVyRGF0YS5tYXNrc1Byb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgICAgIGpMZW4gPSBtYXNrUHJvcHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1Byb3BzW2pdLnB0LmsuaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyhtYXNrUHJvcHNbal0ucHQuayk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtMZW4gPSBtYXNrUHJvcHNbal0ucHQuay5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBrTGVuOyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rW2tdLnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0UGF0aHNUb0Fic29sdXRlVmFsdWVzKG1hc2tQcm9wc1tqXS5wdC5rW2tdLnNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rW2tdLmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0UGF0aHNUb0Fic29sdXRlVmFsdWVzKG1hc2tQcm9wc1tqXS5wdC5rW2tdLmVbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChsYXllckRhdGEudHkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJEYXRhLmxheWVycyA9IGZpbmRDb21wTGF5ZXJzKGxheWVyRGF0YS5yZWZJZCwgY29tcHMpO1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUxheWVycyhsYXllckRhdGEubGF5ZXJzLCBjb21wcyk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxheWVyRGF0YS50eSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVNoYXBlcyhsYXllckRhdGEuc2hhcGVzKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5ZXJEYXRhLnR5ID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlVGV4dChsYXllckRhdGEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjb21wbGV0ZUNoYXJzKGNoYXJzLCBhc3NldHMpIHtcbiAgICAgICAgICAgICAgaWYgKGNoYXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBjaGFycy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyc1tpXS50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBjb21wRGF0YSA9IGZpbmRDb21wKGNoYXJzW2ldLmRhdGEucmVmSWQsIGFzc2V0cyk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzW2ldLmRhdGEubGF5ZXJzID0gZmluZENvbXBMYXllcnMoY2hhcnNbaV0uZGF0YS5yZWZJZCwgYXNzZXRzKTsgLy8gY2hhcnNbaV0uZGF0YS5pcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYXJzW2ldLmRhdGEub3AgPSA5OTk5OTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhcnNbaV0uZGF0YS5zdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYXJzW2ldLmRhdGEuc3IgPSAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGFyc1tpXS53ID0gY29tcERhdGEudztcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhcnNbaV0uZGF0YS5rcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICBhOiB7IGs6IFswLCAwLCAwXSwgYTogMCB9LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHA6IHsgazogWzAsIC1jb21wRGF0YS5oLCAwXSwgYTogMCB9LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHI6IHsgazogMCwgYTogMCB9LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHM6IHsgazogWzEwMCwgMTAwXSwgYTogMCB9LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIG86IHsgazogMTAwLCBhOiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIH07XG5cbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVMYXllcnMoY2hhcnNbaV0uZGF0YS5sYXllcnMsIGFzc2V0cyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRDb21wKGlkLCBjb21wcykge1xuICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgIHZhciBsZW4gPSBjb21wcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcHNbaV0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29tcHNbaV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRDb21wTGF5ZXJzKGlkLCBjb21wcykge1xuICAgICAgICAgICAgICB2YXIgY29tcCA9IGZpbmRDb21wKGlkLCBjb21wcyk7XG5cbiAgICAgICAgICAgICAgaWYgKGNvbXApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXAubGF5ZXJzLl9fdXNlZCkge1xuICAgICAgICAgICAgICAgICAgY29tcC5sYXllcnMuX191c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wLmxheWVycztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb21wLmxheWVycykpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlU2hhcGVzKGFycikge1xuICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgICAgICAgIHZhciBqO1xuICAgICAgICAgICAgICB2YXIgakxlbjtcblxuICAgICAgICAgICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChhcnJbaV0udHkgPT09ICdzaCcpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV0ua3Muay5pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMoYXJyW2ldLmtzLmspO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgakxlbiA9IGFycltpXS5rcy5rLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFycltpXS5rcy5rW2pdLnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMoYXJyW2ldLmtzLmtbal0uc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFycltpXS5rcy5rW2pdLmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMoYXJyW2ldLmtzLmtbal0uZVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdncicpIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRlU2hhcGVzKGFycltpXS5pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMocGF0aCkge1xuICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGguaS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5pW2ldWzBdICs9IHBhdGgudltpXVswXTtcbiAgICAgICAgICAgICAgICBwYXRoLmlbaV1bMV0gKz0gcGF0aC52W2ldWzFdO1xuICAgICAgICAgICAgICAgIHBhdGgub1tpXVswXSArPSBwYXRoLnZbaV1bMF07XG4gICAgICAgICAgICAgICAgcGF0aC5vW2ldWzFdICs9IHBhdGgudltpXVsxXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjaGVja1ZlcnNpb24obWluaW11bSwgYW5pbVZlcnNpb25TdHJpbmcpIHtcbiAgICAgICAgICAgICAgdmFyIGFuaW1WZXJzaW9uID0gYW5pbVZlcnNpb25TdHJpbmcgPyBhbmltVmVyc2lvblN0cmluZy5zcGxpdCgnLicpIDogWzEwMCwgMTAwLCAxMDBdO1xuXG4gICAgICAgICAgICAgIGlmIChtaW5pbXVtWzBdID4gYW5pbVZlcnNpb25bMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChhbmltVmVyc2lvblswXSA+IG1pbmltdW1bMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobWluaW11bVsxXSA+IGFuaW1WZXJzaW9uWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYW5pbVZlcnNpb25bMV0gPiBtaW5pbXVtWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG1pbmltdW1bMl0gPiBhbmltVmVyc2lvblsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGFuaW1WZXJzaW9uWzJdID4gbWluaW11bVsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2hlY2tUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgbWluaW11bVZlcnNpb24gPSBbNCwgNCwgMTRdO1xuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRleHRMYXllcih0ZXh0TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jdW1lbnREYXRhID0gdGV4dExheWVyLnQuZDtcbiAgICAgICAgICAgICAgICB0ZXh0TGF5ZXIudC5kID0ge1xuICAgICAgICAgICAgICAgICAgazogW3tcbiAgICAgICAgICAgICAgICAgICAgczogZG9jdW1lbnREYXRhLFxuICAgICAgICAgICAgICAgICAgICB0OiAwXG4gICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmdW5jdGlvbiBpdGVyYXRlTGF5ZXJzKGxheWVycykge1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBsYXllcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobGF5ZXJzW2ldLnR5ID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRleHRMYXllcihsYXllcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1ZlcnNpb24obWluaW11bVZlcnNpb24sIGFuaW1hdGlvbkRhdGEudikpIHtcbiAgICAgICAgICAgICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5sYXllcnMpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5hc3NldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRpb25EYXRhLmFzc2V0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgdmFyIGNoZWNrQ2hhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBtaW5pbXVtVmVyc2lvbiA9IFs0LCA3LCA5OV07XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25EYXRhLmNoYXJzICYmICFjaGVja1ZlcnNpb24obWluaW11bVZlcnNpb24sIGFuaW1hdGlvbkRhdGEudikpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGFuaW1hdGlvbkRhdGEuY2hhcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJEYXRhID0gYW5pbWF0aW9uRGF0YS5jaGFyc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckRhdGEuZGF0YSAmJiBjaGFyRGF0YS5kYXRhLnNoYXBlcykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlU2hhcGVzKGNoYXJEYXRhLmRhdGEuc2hhcGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyRGF0YS5kYXRhLmlwID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyRGF0YS5kYXRhLm9wID0gOTk5OTk7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckRhdGEuZGF0YS5zdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckRhdGEuZGF0YS5zciA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckRhdGEuZGF0YS5rcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgazogWzAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBrOiBbMTAwLCAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBrOiBbMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGs6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGs6IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFuaW1hdGlvbkRhdGEuY2hhcnNbaV0udCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhckRhdGEuZGF0YS5zaGFwZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5OiAnbm8nXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJEYXRhLmRhdGEuc2hhcGVzWzBdLml0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgazogWzAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGs6IFsxMDAsIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgazogWzAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGs6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgazogMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2s6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2E6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHk6ICd0cidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgdmFyIGNoZWNrUGF0aFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBtaW5pbXVtVmVyc2lvbiA9IFs1LCA3LCAxNV07XG5cbiAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlVGV4dExheWVyKHRleHRMYXllcikge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHRleHRMYXllci50LnA7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhdGhEYXRhLmEgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICBwYXRoRGF0YS5hID0ge1xuICAgICAgICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICAgICAgICBrOiBwYXRoRGF0YS5hXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0aERhdGEucCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgIHBhdGhEYXRhLnAgPSB7XG4gICAgICAgICAgICAgICAgICAgIGE6IDAsXG4gICAgICAgICAgICAgICAgICAgIGs6IHBhdGhEYXRhLnBcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXRoRGF0YS5yID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgcGF0aERhdGEuciA9IHtcbiAgICAgICAgICAgICAgICAgICAgYTogMCxcbiAgICAgICAgICAgICAgICAgICAgazogcGF0aERhdGEuclxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmdW5jdGlvbiBpdGVyYXRlTGF5ZXJzKGxheWVycykge1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBsYXllcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobGF5ZXJzW2ldLnR5ID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRleHRMYXllcihsYXllcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1ZlcnNpb24obWluaW11bVZlcnNpb24sIGFuaW1hdGlvbkRhdGEudikpIHtcbiAgICAgICAgICAgICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5sYXllcnMpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5hc3NldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRpb25EYXRhLmFzc2V0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgdmFyIGNoZWNrQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgbWluaW11bVZlcnNpb24gPSBbNCwgMSwgOV07XG5cbiAgICAgICAgICAgICAgZnVuY3Rpb24gaXRlcmF0ZVNoYXBlcyhzaGFwZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gc2hhcGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgICAgICB2YXIgakxlbjtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ2dyJykge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlU2hhcGVzKHNoYXBlc1tpXS5pdCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ2ZsJyB8fCBzaGFwZXNbaV0udHkgPT09ICdzdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlc1tpXS5jLmsgJiYgc2hhcGVzW2ldLmMua1swXS5pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgakxlbiA9IHNoYXBlc1tpXS5jLmsubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlc1tpXS5jLmtbal0ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbMF0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbMV0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbMl0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbM10gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcGVzW2ldLmMua1tqXS5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uZVswXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uZVsxXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uZVsyXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uZVszXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbMF0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbMV0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbMl0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbM10gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZnVuY3Rpb24gaXRlcmF0ZUxheWVycyhsYXllcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gbGF5ZXJzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGxheWVyc1tpXS50eSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlU2hhcGVzKGxheWVyc1tpXS5zaGFwZXMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1ZlcnNpb24obWluaW11bVZlcnNpb24sIGFuaW1hdGlvbkRhdGEudikpIHtcbiAgICAgICAgICAgICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5sYXllcnMpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5hc3NldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRpb25EYXRhLmFzc2V0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgdmFyIGNoZWNrU2hhcGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgbWluaW11bVZlcnNpb24gPSBbNCwgNCwgMThdO1xuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlQ2xvc2luZ1NoYXBlcyhhcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgICAgICB2YXIgakxlbjtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYXJyW2ldLnR5ID09PSAnc2gnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV0ua3Muay5pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXJyW2ldLmtzLmsuYyA9IGFycltpXS5jbG9zZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgakxlbiA9IGFycltpXS5rcy5rLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV0ua3Mua1tqXS5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFycltpXS5rcy5rW2pdLnNbMF0uYyA9IGFycltpXS5jbG9zZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV0ua3Mua1tqXS5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFycltpXS5rcy5rW2pdLmVbMF0uYyA9IGFycltpXS5jbG9zZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ2dyJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUNsb3NpbmdTaGFwZXMoYXJyW2ldLml0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmdW5jdGlvbiBpdGVyYXRlTGF5ZXJzKGxheWVycykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllckRhdGE7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGxheWVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGo7XG4gICAgICAgICAgICAgICAgdmFyIGpMZW47XG4gICAgICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICAgICAgdmFyIGtMZW47XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgIGxheWVyRGF0YSA9IGxheWVyc1tpXTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGxheWVyRGF0YS5oYXNNYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXNrUHJvcHMgPSBsYXllckRhdGEubWFza3NQcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICAgICAgICBqTGVuID0gbWFza1Byb3BzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rLmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tQcm9wc1tqXS5wdC5rLmMgPSBtYXNrUHJvcHNbal0uY2w7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtMZW4gPSBtYXNrUHJvcHNbal0ucHQuay5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBrTGVuOyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rW2tdLnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrUHJvcHNbal0ucHQua1trXS5zWzBdLmMgPSBtYXNrUHJvcHNbal0uY2w7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1Byb3BzW2pdLnB0Lmtba10uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tQcm9wc1tqXS5wdC5rW2tdLmVbMF0uYyA9IG1hc2tQcm9wc1tqXS5jbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAobGF5ZXJEYXRhLnR5ID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlQ2xvc2luZ1NoYXBlcyhsYXllckRhdGEuc2hhcGVzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFuaW1hdGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tWZXJzaW9uKG1pbmltdW1WZXJzaW9uLCBhbmltYXRpb25EYXRhLnYpKSB7XG4gICAgICAgICAgICAgICAgICBpdGVyYXRlTGF5ZXJzKGFuaW1hdGlvbkRhdGEubGF5ZXJzKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gYW5pbWF0aW9uRGF0YS5hc3NldHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5hc3NldHNbaV0ubGF5ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlRGF0YShhbmltYXRpb25EYXRhKSB7XG4gICAgICAgICAgICAgIGlmIChhbmltYXRpb25EYXRhLl9fY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjaGVja0NvbG9ycyhhbmltYXRpb25EYXRhKTtcbiAgICAgICAgICAgICAgY2hlY2tUZXh0KGFuaW1hdGlvbkRhdGEpO1xuICAgICAgICAgICAgICBjaGVja0NoYXJzKGFuaW1hdGlvbkRhdGEpO1xuICAgICAgICAgICAgICBjaGVja1BhdGhQcm9wZXJ0aWVzKGFuaW1hdGlvbkRhdGEpO1xuICAgICAgICAgICAgICBjaGVja1NoYXBlcyhhbmltYXRpb25EYXRhKTtcbiAgICAgICAgICAgICAgY29tcGxldGVMYXllcnMoYW5pbWF0aW9uRGF0YS5sYXllcnMsIGFuaW1hdGlvbkRhdGEuYXNzZXRzKTtcbiAgICAgICAgICAgICAgY29tcGxldGVDaGFycyhhbmltYXRpb25EYXRhLmNoYXJzLCBhbmltYXRpb25EYXRhLmFzc2V0cyk7XG4gICAgICAgICAgICAgIGFuaW1hdGlvbkRhdGEuX19jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlVGV4dChkYXRhKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhLnQuYS5sZW5ndGggPT09IDAgJiYgISgnbScgaW4gZGF0YS50LnApKSB7Ly8gZGF0YS5zaW5nbGVTaGFwZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1vZHVsZU9iID0ge307XG4gICAgICAgICAgICBtb2R1bGVPYi5jb21wbGV0ZURhdGEgPSBjb21wbGV0ZURhdGE7XG4gICAgICAgICAgICBtb2R1bGVPYi5jaGVja0NvbG9ycyA9IGNoZWNrQ29sb3JzO1xuICAgICAgICAgICAgbW9kdWxlT2IuY2hlY2tDaGFycyA9IGNoZWNrQ2hhcnM7XG4gICAgICAgICAgICBtb2R1bGVPYi5jaGVja1BhdGhQcm9wZXJ0aWVzID0gY2hlY2tQYXRoUHJvcGVydGllcztcbiAgICAgICAgICAgIG1vZHVsZU9iLmNoZWNrU2hhcGVzID0gY2hlY2tTaGFwZXM7XG4gICAgICAgICAgICBtb2R1bGVPYi5jb21wbGV0ZUxheWVycyA9IGNvbXBsZXRlTGF5ZXJzO1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZU9iO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghX3dvcmtlclNlbGYuZGF0YU1hbmFnZXIpIHtcbiAgICAgICAgICAgIF93b3JrZXJTZWxmLmRhdGFNYW5hZ2VyID0gZGF0YUZ1bmN0aW9uTWFuYWdlcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghX3dvcmtlclNlbGYuYXNzZXRMb2FkZXIpIHtcbiAgICAgICAgICAgIF93b3JrZXJTZWxmLmFzc2V0TG9hZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXRSZXNwb25zZSh4aHIpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2luZyB0eXBlb2YgZG91YmxlcyB0aGUgdGltZSBvZiBleGVjdXRpb24gb2YgdGhpcyBtZXRob2QsXG4gICAgICAgICAgICAgICAgLy8gc28gaWYgYXZhaWxhYmxlLCBpdCdzIGJldHRlciB0byB1c2UgdGhlIGhlYWRlciB0byB2YWxpZGF0ZSB0aGUgdHlwZVxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZUhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGVIZWFkZXIgJiYgeGhyLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nICYmIGNvbnRlbnRUeXBlSGVhZGVyLmluZGV4T2YoJ2pzb24nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHhoci5yZXNwb25zZSAmJiBfdHlwZW9mJDUoeGhyLnJlc3BvbnNlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHhoci5yZXNwb25zZSAmJiB0eXBlb2YgeGhyLnJlc3BvbnNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoeGhyLnJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmdW5jdGlvbiBsb2FkQXNzZXQocGF0aCwgZnVsbFBhdGgsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTsgLy8gc2V0IHJlc3BvbnNlVHlwZSBhZnRlciBjYWxsaW5nIG9wZW4gb3IgSUUgd2lsbCBicmVhay5cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGlzIGNyYXNoZXMgb24gQW5kcm9pZCBXZWJWaWV3IHByaW9yIHRvIEtpdEthdFxuICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcblxuXG4gICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBmb3JtYXRSZXNwb25zZSh4aHIpO1xuICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBmb3JtYXRSZXNwb25zZSh4aHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgLy8gSGFjayB0byB3b3JrYXJvdW5kIGJhbm5lciB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgICB4aHIub3BlbihbJ0cnLCAnRScsICdUJ10uam9pbignJyksIHBhdGgsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAvLyBIYWNrIHRvIHdvcmthcm91bmQgYmFubmVyIHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICAgIHhoci5vcGVuKFsnRycsICdFJywgJ1QnXS5qb2luKCcnKSwgZnVsbFBhdGggKyAnLycgKyBwYXRoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsb2FkOiBsb2FkQXNzZXRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZS5kYXRhLnR5cGUgPT09ICdsb2FkQW5pbWF0aW9uJykge1xuICAgICAgICAgICAgX3dvcmtlclNlbGYuYXNzZXRMb2FkZXIubG9hZChlLmRhdGEucGF0aCwgZS5kYXRhLmZ1bGxQYXRoLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICBfd29ya2VyU2VsZi5kYXRhTWFuYWdlci5jb21wbGV0ZURhdGEoZGF0YSk7XG5cbiAgICAgICAgICAgICAgX3dvcmtlclNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBlLmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogZGF0YSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdzdWNjZXNzJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3dvcmtlclNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBlLmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEudHlwZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGUuZGF0YS5hbmltYXRpb247XG5cbiAgICAgICAgICAgIF93b3JrZXJTZWxmLmRhdGFNYW5hZ2VyLmNvbXBsZXRlRGF0YShhbmltYXRpb24pO1xuXG4gICAgICAgICAgICBfd29ya2VyU2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIGlkOiBlLmRhdGEuaWQsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IGFuaW1hdGlvbixcbiAgICAgICAgICAgICAgc3RhdHVzOiAnc3VjY2VzcydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLnR5cGUgPT09ICdsb2FkRGF0YScpIHtcbiAgICAgICAgICAgIF93b3JrZXJTZWxmLmFzc2V0TG9hZGVyLmxvYWQoZS5kYXRhLnBhdGgsIGUuZGF0YS5mdWxsUGF0aCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgX3dvcmtlclNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBlLmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogZGF0YSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdzdWNjZXNzJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3dvcmtlclNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBlLmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB3b3JrZXJJbnN0YW5jZS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgdmFyIGlkID0gZGF0YS5pZDtcbiAgICAgICAgICB2YXIgcHJvY2VzcyA9IHByb2Nlc3Nlc1tpZF07XG4gICAgICAgICAgcHJvY2Vzc2VzW2lkXSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoZGF0YS5zdGF0dXMgPT09ICdzdWNjZXNzJykge1xuICAgICAgICAgICAgcHJvY2Vzcy5vbkNvbXBsZXRlKGRhdGEucGF5bG9hZCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLm9uRXJyb3IpIHtcbiAgICAgICAgICAgIHByb2Nlc3Mub25FcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9jZXNzKG9uQ29tcGxldGUsIG9uRXJyb3IpIHtcbiAgICAgIF9jb3VudGVySWQgKz0gMTtcbiAgICAgIHZhciBpZCA9ICdwcm9jZXNzSWRfJyArIF9jb3VudGVySWQ7XG4gICAgICBwcm9jZXNzZXNbaWRdID0ge1xuICAgICAgICBvbkNvbXBsZXRlOiBvbkNvbXBsZXRlLFxuICAgICAgICBvbkVycm9yOiBvbkVycm9yXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRBbmltYXRpb24ocGF0aCwgb25Db21wbGV0ZSwgb25FcnJvcikge1xuICAgICAgc2V0dXBXb3JrZXIoKTtcbiAgICAgIHZhciBwcm9jZXNzSWQgPSBjcmVhdGVQcm9jZXNzKG9uQ29tcGxldGUsIG9uRXJyb3IpO1xuICAgICAgd29ya2VySW5zdGFuY2UucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiAnbG9hZEFuaW1hdGlvbicsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIGZ1bGxQYXRoOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBpZDogcHJvY2Vzc0lkXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkRGF0YShwYXRoLCBvbkNvbXBsZXRlLCBvbkVycm9yKSB7XG4gICAgICBzZXR1cFdvcmtlcigpO1xuICAgICAgdmFyIHByb2Nlc3NJZCA9IGNyZWF0ZVByb2Nlc3Mob25Db21wbGV0ZSwgb25FcnJvcik7XG4gICAgICB3b3JrZXJJbnN0YW5jZS5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICdsb2FkRGF0YScsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIGZ1bGxQYXRoOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBpZDogcHJvY2Vzc0lkXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZUFuaW1hdGlvbihhbmltLCBvbkNvbXBsZXRlLCBvbkVycm9yKSB7XG4gICAgICBzZXR1cFdvcmtlcigpO1xuICAgICAgdmFyIHByb2Nlc3NJZCA9IGNyZWF0ZVByb2Nlc3Mob25Db21wbGV0ZSwgb25FcnJvcik7XG4gICAgICB3b3JrZXJJbnN0YW5jZS5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICdjb21wbGV0ZScsXG4gICAgICAgIGFuaW1hdGlvbjogYW5pbSxcbiAgICAgICAgaWQ6IHByb2Nlc3NJZFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxvYWRBbmltYXRpb246IGxvYWRBbmltYXRpb24sXG4gICAgICBsb2FkRGF0YTogbG9hZERhdGEsXG4gICAgICBjb21wbGV0ZUFuaW1hdGlvbjogY29tcGxldGVBbmltYXRpb25cbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIEltYWdlUHJlbG9hZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm94eUltYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhbnZhcyA9IGNyZWF0ZVRhZygnY2FudmFzJyk7XG4gICAgICBjYW52YXMud2lkdGggPSAxO1xuICAgICAgY2FudmFzLmhlaWdodCA9IDE7XG4gICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9KCk7XG5cbiAgICBmdW5jdGlvbiBpbWFnZUxvYWRlZCgpIHtcbiAgICAgIHRoaXMubG9hZGVkQXNzZXRzICs9IDE7XG5cbiAgICAgIGlmICh0aGlzLmxvYWRlZEFzc2V0cyA9PT0gdGhpcy50b3RhbEltYWdlcyAmJiB0aGlzLmxvYWRlZEZvb3RhZ2VzQ291bnQgPT09IHRoaXMudG90YWxGb290YWdlcykge1xuICAgICAgICBpZiAodGhpcy5pbWFnZXNMb2FkZWRDYikge1xuICAgICAgICAgIHRoaXMuaW1hZ2VzTG9hZGVkQ2IobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb290YWdlTG9hZGVkKCkge1xuICAgICAgdGhpcy5sb2FkZWRGb290YWdlc0NvdW50ICs9IDE7XG5cbiAgICAgIGlmICh0aGlzLmxvYWRlZEFzc2V0cyA9PT0gdGhpcy50b3RhbEltYWdlcyAmJiB0aGlzLmxvYWRlZEZvb3RhZ2VzQ291bnQgPT09IHRoaXMudG90YWxGb290YWdlcykge1xuICAgICAgICBpZiAodGhpcy5pbWFnZXNMb2FkZWRDYikge1xuICAgICAgICAgIHRoaXMuaW1hZ2VzTG9hZGVkQ2IobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBc3NldHNQYXRoKGFzc2V0RGF0YSwgYXNzZXRzUGF0aCwgb3JpZ2luYWxQYXRoKSB7XG4gICAgICB2YXIgcGF0aCA9ICcnO1xuXG4gICAgICBpZiAoYXNzZXREYXRhLmUpIHtcbiAgICAgICAgcGF0aCA9IGFzc2V0RGF0YS5wO1xuICAgICAgfSBlbHNlIGlmIChhc3NldHNQYXRoKSB7XG4gICAgICAgIHZhciBpbWFnZVBhdGggPSBhc3NldERhdGEucDtcblxuICAgICAgICBpZiAoaW1hZ2VQYXRoLmluZGV4T2YoJ2ltYWdlcy8nKSAhPT0gLTEpIHtcbiAgICAgICAgICBpbWFnZVBhdGggPSBpbWFnZVBhdGguc3BsaXQoJy8nKVsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGggPSBhc3NldHNQYXRoICsgaW1hZ2VQYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aCA9IG9yaWdpbmFsUGF0aDtcbiAgICAgICAgcGF0aCArPSBhc3NldERhdGEudSA/IGFzc2V0RGF0YS51IDogJyc7XG4gICAgICAgIHBhdGggKz0gYXNzZXREYXRhLnA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RJbWFnZUxvYWRlZChpbWcpIHtcbiAgICAgIHZhciBfY291bnQgPSAwO1xuICAgICAgdmFyIGludGVydmFsSWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBib3ggPSBpbWcuZ2V0QkJveCgpO1xuXG4gICAgICAgIGlmIChib3gud2lkdGggfHwgX2NvdW50ID4gNTAwKSB7XG4gICAgICAgICAgdGhpcy5faW1hZ2VMb2FkZWQoKTtcblxuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBfY291bnQgKz0gMTtcbiAgICAgIH0uYmluZCh0aGlzKSwgNTApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUltYWdlRGF0YShhc3NldERhdGEpIHtcbiAgICAgIHZhciBwYXRoID0gZ2V0QXNzZXRzUGF0aChhc3NldERhdGEsIHRoaXMuYXNzZXRzUGF0aCwgdGhpcy5wYXRoKTtcbiAgICAgIHZhciBpbWcgPSBjcmVhdGVOUygnaW1hZ2UnKTtcblxuICAgICAgaWYgKGlzU2FmYXJpKSB7XG4gICAgICAgIHRoaXMudGVzdEltYWdlTG9hZGVkKGltZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2ltYWdlTG9hZGVkLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2IuaW1nID0gcHJveHlJbWFnZTtcblxuICAgICAgICB0aGlzLl9pbWFnZUxvYWRlZCgpO1xuICAgICAgfS5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgICBpbWcuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicsIHBhdGgpO1xuXG4gICAgICBpZiAodGhpcy5fZWxlbWVudEhlbHBlci5hcHBlbmQpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudEhlbHBlci5hcHBlbmQoaW1nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRIZWxwZXIuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9iID0ge1xuICAgICAgICBpbWc6IGltZyxcbiAgICAgICAgYXNzZXREYXRhOiBhc3NldERhdGFcbiAgICAgIH07XG4gICAgICByZXR1cm4gb2I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW1nRGF0YShhc3NldERhdGEpIHtcbiAgICAgIHZhciBwYXRoID0gZ2V0QXNzZXRzUGF0aChhc3NldERhdGEsIHRoaXMuYXNzZXRzUGF0aCwgdGhpcy5wYXRoKTtcbiAgICAgIHZhciBpbWcgPSBjcmVhdGVUYWcoJ2ltZycpO1xuICAgICAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2ltYWdlTG9hZGVkLCBmYWxzZSk7XG4gICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9iLmltZyA9IHByb3h5SW1hZ2U7XG5cbiAgICAgICAgdGhpcy5faW1hZ2VMb2FkZWQoKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgaW1nLnNyYyA9IHBhdGg7XG4gICAgICB2YXIgb2IgPSB7XG4gICAgICAgIGltZzogaW1nLFxuICAgICAgICBhc3NldERhdGE6IGFzc2V0RGF0YVxuICAgICAgfTtcbiAgICAgIHJldHVybiBvYjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGb290YWdlRGF0YShkYXRhKSB7XG4gICAgICB2YXIgb2IgPSB7XG4gICAgICAgIGFzc2V0RGF0YTogZGF0YVxuICAgICAgfTtcbiAgICAgIHZhciBwYXRoID0gZ2V0QXNzZXRzUGF0aChkYXRhLCB0aGlzLmFzc2V0c1BhdGgsIHRoaXMucGF0aCk7XG4gICAgICBkYXRhTWFuYWdlci5sb2FkRGF0YShwYXRoLCBmdW5jdGlvbiAoZm9vdGFnZURhdGEpIHtcbiAgICAgICAgb2IuaW1nID0gZm9vdGFnZURhdGE7XG5cbiAgICAgICAgdGhpcy5fZm9vdGFnZUxvYWRlZCgpO1xuICAgICAgfS5iaW5kKHRoaXMpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9iLmltZyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2Zvb3RhZ2VMb2FkZWQoKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICByZXR1cm4gb2I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZEFzc2V0cyhhc3NldHMsIGNiKSB7XG4gICAgICB0aGlzLmltYWdlc0xvYWRlZENiID0gY2I7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBhc3NldHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKCFhc3NldHNbaV0ubGF5ZXJzKSB7XG4gICAgICAgICAgaWYgKCFhc3NldHNbaV0udCB8fCBhc3NldHNbaV0udCA9PT0gJ3NlcScpIHtcbiAgICAgICAgICAgIHRoaXMudG90YWxJbWFnZXMgKz0gMTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VzLnB1c2godGhpcy5fY3JlYXRlSW1hZ2VEYXRhKGFzc2V0c1tpXSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXNzZXRzW2ldLnQgPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMudG90YWxGb290YWdlcyArPSAxO1xuICAgICAgICAgICAgdGhpcy5pbWFnZXMucHVzaCh0aGlzLmNyZWF0ZUZvb3RhZ2VEYXRhKGFzc2V0c1tpXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFBhdGgocGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcGF0aCB8fCAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRBc3NldHNQYXRoKHBhdGgpIHtcbiAgICAgIHRoaXMuYXNzZXRzUGF0aCA9IHBhdGggfHwgJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QXNzZXQoYXNzZXREYXRhKSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gdGhpcy5pbWFnZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAodGhpcy5pbWFnZXNbaV0uYXNzZXREYXRhID09PSBhc3NldERhdGEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbWFnZXNbaV0uaW1nO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5pbWFnZXNMb2FkZWRDYiA9IG51bGw7XG4gICAgICB0aGlzLmltYWdlcy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRlZEltYWdlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvdGFsSW1hZ2VzID09PSB0aGlzLmxvYWRlZEFzc2V0cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkZWRGb290YWdlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvdGFsRm9vdGFnZXMgPT09IHRoaXMubG9hZGVkRm9vdGFnZXNDb3VudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRDYWNoZVR5cGUodHlwZSwgZWxlbWVudEhlbHBlcikge1xuICAgICAgaWYgKHR5cGUgPT09ICdzdmcnKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRIZWxwZXIgPSBlbGVtZW50SGVscGVyO1xuICAgICAgICB0aGlzLl9jcmVhdGVJbWFnZURhdGEgPSB0aGlzLmNyZWF0ZUltYWdlRGF0YS5iaW5kKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlSW1hZ2VEYXRhID0gdGhpcy5jcmVhdGVJbWdEYXRhLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSW1hZ2VQcmVsb2FkZXJGYWN0b3J5KCkge1xuICAgICAgdGhpcy5faW1hZ2VMb2FkZWQgPSBpbWFnZUxvYWRlZC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fZm9vdGFnZUxvYWRlZCA9IGZvb3RhZ2VMb2FkZWQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMudGVzdEltYWdlTG9hZGVkID0gdGVzdEltYWdlTG9hZGVkLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmNyZWF0ZUZvb3RhZ2VEYXRhID0gY3JlYXRlRm9vdGFnZURhdGEuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuYXNzZXRzUGF0aCA9ICcnO1xuICAgICAgdGhpcy5wYXRoID0gJyc7XG4gICAgICB0aGlzLnRvdGFsSW1hZ2VzID0gMDtcbiAgICAgIHRoaXMudG90YWxGb290YWdlcyA9IDA7XG4gICAgICB0aGlzLmxvYWRlZEFzc2V0cyA9IDA7XG4gICAgICB0aGlzLmxvYWRlZEZvb3RhZ2VzQ291bnQgPSAwO1xuICAgICAgdGhpcy5pbWFnZXNMb2FkZWRDYiA9IG51bGw7XG4gICAgICB0aGlzLmltYWdlcyA9IFtdO1xuICAgIH1cblxuICAgIEltYWdlUHJlbG9hZGVyRmFjdG9yeS5wcm90b3R5cGUgPSB7XG4gICAgICBsb2FkQXNzZXRzOiBsb2FkQXNzZXRzLFxuICAgICAgc2V0QXNzZXRzUGF0aDogc2V0QXNzZXRzUGF0aCxcbiAgICAgIHNldFBhdGg6IHNldFBhdGgsXG4gICAgICBsb2FkZWRJbWFnZXM6IGxvYWRlZEltYWdlcyxcbiAgICAgIGxvYWRlZEZvb3RhZ2VzOiBsb2FkZWRGb290YWdlcyxcbiAgICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgICBnZXRBc3NldDogZ2V0QXNzZXQsXG4gICAgICBjcmVhdGVJbWdEYXRhOiBjcmVhdGVJbWdEYXRhLFxuICAgICAgY3JlYXRlSW1hZ2VEYXRhOiBjcmVhdGVJbWFnZURhdGEsXG4gICAgICBpbWFnZUxvYWRlZDogaW1hZ2VMb2FkZWQsXG4gICAgICBmb290YWdlTG9hZGVkOiBmb290YWdlTG9hZGVkLFxuICAgICAgc2V0Q2FjaGVUeXBlOiBzZXRDYWNoZVR5cGVcbiAgICB9O1xuICAgIHJldHVybiBJbWFnZVByZWxvYWRlckZhY3Rvcnk7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBCYXNlRXZlbnQoKSB7fVxuXG4gIEJhc2VFdmVudC5wcm90b3R5cGUgPSB7XG4gICAgdHJpZ2dlckV2ZW50OiBmdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZXZlbnROYW1lLCBhcmdzKSB7XG4gICAgICBpZiAodGhpcy5fY2JzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2Nic1tldmVudE5hbWVdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgY2FsbGJhY2tzW2ldKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICghdGhpcy5fY2JzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdGhpcy5fY2JzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2JzW2V2ZW50TmFtZV0ucHVzaChjYWxsYmFjayk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH0uYmluZCh0aGlzKTtcbiAgICB9LFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9jYnNbZXZlbnROYW1lXSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2Nic1tldmVudE5hbWVdKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuX2Nic1tldmVudE5hbWVdLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgIGlmICh0aGlzLl9jYnNbZXZlbnROYW1lXVtpXSA9PT0gY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX2Nic1tldmVudE5hbWVdLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgbGVuIC09IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jYnNbZXZlbnROYW1lXS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9jYnNbZXZlbnROYW1lXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIG1hcmtlclBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBwYXJzZVBheWxvYWRMaW5lcyhwYXlsb2FkKSB7XG4gICAgICB2YXIgbGluZXMgPSBwYXlsb2FkLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgIHZhciBrZXlzID0ge307XG4gICAgICB2YXIgbGluZTtcbiAgICAgIHZhciBrZXlzQ291bnQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxpbmUgPSBsaW5lc1tpXS5zcGxpdCgnOicpO1xuXG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGtleXNbbGluZVswXV0gPSBsaW5lWzFdLnRyaW0oKTtcbiAgICAgICAgICBrZXlzQ291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoa2V5c0NvdW50ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKF9tYXJrZXJzKSB7XG4gICAgICB2YXIgbWFya2VycyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9tYXJrZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBfbWFya2VyID0gX21hcmtlcnNbaV07XG4gICAgICAgIHZhciBtYXJrZXJEYXRhID0ge1xuICAgICAgICAgIHRpbWU6IF9tYXJrZXIudG0sXG4gICAgICAgICAgZHVyYXRpb246IF9tYXJrZXIuZHJcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIG1hcmtlckRhdGEucGF5bG9hZCA9IEpTT04ucGFyc2UoX21hcmtlcnNbaV0uY20pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1hcmtlckRhdGEucGF5bG9hZCA9IHBhcnNlUGF5bG9hZExpbmVzKF9tYXJrZXJzW2ldLmNtKTtcbiAgICAgICAgICB9IGNhdGNoIChfXykge1xuICAgICAgICAgICAgbWFya2VyRGF0YS5wYXlsb2FkID0ge1xuICAgICAgICAgICAgICBuYW1lOiBfbWFya2Vyc1tpXS5jbVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtYXJrZXJzLnB1c2gobWFya2VyRGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgUHJvamVjdEludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiByZWdpc3RlckNvbXBvc2l0aW9uKGNvbXApIHtcbiAgICAgIHRoaXMuY29tcG9zaXRpb25zLnB1c2goY29tcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF90aGlzUHJvamVjdEZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5jb21wb3NpdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY29tcG9zaXRpb25zW2ldLmRhdGEgJiYgdGhpcy5jb21wb3NpdGlvbnNbaV0uZGF0YS5ubSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9zaXRpb25zW2ldLnByZXBhcmVGcmFtZSAmJiB0aGlzLmNvbXBvc2l0aW9uc1tpXS5kYXRhLnh0KSB7XG4gICAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25zW2ldLnByZXBhcmVGcmFtZSh0aGlzLmN1cnJlbnRGcmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBvc2l0aW9uc1tpXS5jb21wSW50ZXJmYWNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBfdGhpc1Byb2plY3RGdW5jdGlvbi5jb21wb3NpdGlvbnMgPSBbXTtcbiAgICAgIF90aGlzUHJvamVjdEZ1bmN0aW9uLmN1cnJlbnRGcmFtZSA9IDA7XG4gICAgICBfdGhpc1Byb2plY3RGdW5jdGlvbi5yZWdpc3RlckNvbXBvc2l0aW9uID0gcmVnaXN0ZXJDb21wb3NpdGlvbjtcbiAgICAgIHJldHVybiBfdGhpc1Byb2plY3RGdW5jdGlvbjtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIHJlbmRlcmVycyA9IHt9O1xuXG4gIHZhciByZWdpc3RlclJlbmRlcmVyID0gZnVuY3Rpb24gcmVnaXN0ZXJSZW5kZXJlcihrZXksIHZhbHVlKSB7XG4gICAgcmVuZGVyZXJzW2tleV0gPSB2YWx1ZTtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRSZW5kZXJlcihrZXkpIHtcbiAgICByZXR1cm4gcmVuZGVyZXJzW2tleV07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSZWdpc3RlcmVkUmVuZGVyZXIoKSB7XG4gICAgLy8gUmV0dXJucyBjYW52YXMgYnkgZGVmYXVsdCBmb3IgY29tcGF0aWJpbGl0eVxuICAgIGlmIChyZW5kZXJlcnMuY2FudmFzKSB7XG4gICAgICByZXR1cm4gJ2NhbnZhcyc7XG4gICAgfSAvLyBSZXR1cm5zIGFueSByZW5kZXJlciB0aGF0IGlzIHJlZ2lzdGVyZWRcblxuXG4gICAgZm9yICh2YXIga2V5IGluIHJlbmRlcmVycykge1xuICAgICAgaWYgKHJlbmRlcmVyc1trZXldKSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgZnVuY3Rpb24gX3R5cGVvZiQ0KG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mJDQgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiQ0ID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2YkNChvYmopOyB9XG5cbiAgdmFyIEFuaW1hdGlvbkl0ZW0gPSBmdW5jdGlvbiBBbmltYXRpb25JdGVtKCkge1xuICAgIHRoaXMuX2NicyA9IFtdO1xuICAgIHRoaXMubmFtZSA9ICcnO1xuICAgIHRoaXMucGF0aCA9ICcnO1xuICAgIHRoaXMuaXNMb2FkZWQgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG4gICAgdGhpcy5jdXJyZW50UmF3RnJhbWUgPSAwO1xuICAgIHRoaXMuZmlyc3RGcmFtZSA9IDA7XG4gICAgdGhpcy50b3RhbEZyYW1lcyA9IDA7XG4gICAgdGhpcy5mcmFtZVJhdGUgPSAwO1xuICAgIHRoaXMuZnJhbWVNdWx0ID0gMDtcbiAgICB0aGlzLnBsYXlTcGVlZCA9IDE7XG4gICAgdGhpcy5wbGF5RGlyZWN0aW9uID0gMTtcbiAgICB0aGlzLnBsYXlDb3VudCA9IDA7XG4gICAgdGhpcy5hbmltYXRpb25EYXRhID0ge307XG4gICAgdGhpcy5hc3NldHMgPSBbXTtcbiAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLmF1dG9wbGF5ID0gZmFsc2U7XG4gICAgdGhpcy5sb29wID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLmFuaW1hdGlvbklEID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgdGhpcy5hc3NldHNQYXRoID0gJyc7XG4gICAgdGhpcy50aW1lQ29tcGxldGVkID0gMDtcbiAgICB0aGlzLnNlZ21lbnRQb3MgPSAwO1xuICAgIHRoaXMuaXNTdWJmcmFtZUVuYWJsZWQgPSBnZXRTdWJmcmFtZUVuYWJsZWQoKTtcbiAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgdGhpcy5faWRsZSA9IHRydWU7XG4gICAgdGhpcy5fY29tcGxldGVkTG9vcCA9IGZhbHNlO1xuICAgIHRoaXMucHJvamVjdEludGVyZmFjZSA9IFByb2plY3RJbnRlcmZhY2UoKTtcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyID0gbmV3IEltYWdlUHJlbG9hZGVyKCk7XG4gICAgdGhpcy5hdWRpb0NvbnRyb2xsZXIgPSBhdWRpb0NvbnRyb2xsZXJGYWN0b3J5KCk7XG4gICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgdGhpcy5jb25maWdBbmltYXRpb24gPSB0aGlzLmNvbmZpZ0FuaW1hdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25TZXR1cEVycm9yID0gdGhpcy5vblNldHVwRXJyb3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uU2VnbWVudENvbXBsZXRlID0gdGhpcy5vblNlZ21lbnRDb21wbGV0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZHJhd25GcmFtZUV2ZW50ID0gbmV3IEJNRW50ZXJGcmFtZUV2ZW50KCdkcmF3bkZyYW1lJywgMCwgMCwgMCk7XG4gICAgdGhpcy5leHByZXNzaW9uc1BsdWdpbiA9IGdldEV4cHJlc3Npb25zUGx1Z2luKCk7XG4gIH07XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRXZlbnRdLCBBbmltYXRpb25JdGVtKTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy53cmFwcGVyIHx8IHBhcmFtcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMud3JhcHBlciA9IHBhcmFtcy53cmFwcGVyIHx8IHBhcmFtcy5jb250YWluZXI7XG4gICAgfVxuXG4gICAgdmFyIGFuaW1UeXBlID0gJ3N2Zyc7XG5cbiAgICBpZiAocGFyYW1zLmFuaW1UeXBlKSB7XG4gICAgICBhbmltVHlwZSA9IHBhcmFtcy5hbmltVHlwZTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5yZW5kZXJlcikge1xuICAgICAgYW5pbVR5cGUgPSBwYXJhbXMucmVuZGVyZXI7XG4gICAgfVxuXG4gICAgdmFyIFJlbmRlcmVyQ2xhc3MgPSBnZXRSZW5kZXJlcihhbmltVHlwZSk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlckNsYXNzKHRoaXMsIHBhcmFtcy5yZW5kZXJlclNldHRpbmdzKTtcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyLnNldENhY2hlVHlwZShhbmltVHlwZSwgdGhpcy5yZW5kZXJlci5nbG9iYWxEYXRhLmRlZnMpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvamVjdEludGVyZmFjZSh0aGlzLnByb2plY3RJbnRlcmZhY2UpO1xuICAgIHRoaXMuYW5pbVR5cGUgPSBhbmltVHlwZTtcblxuICAgIGlmIChwYXJhbXMubG9vcCA9PT0gJycgfHwgcGFyYW1zLmxvb3AgPT09IG51bGwgfHwgcGFyYW1zLmxvb3AgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMubG9vcCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5sb29wID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5sb29wID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5sb29wID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9vcCA9IHBhcnNlSW50KHBhcmFtcy5sb29wLCAxMCk7XG4gICAgfVxuXG4gICAgdGhpcy5hdXRvcGxheSA9ICdhdXRvcGxheScgaW4gcGFyYW1zID8gcGFyYW1zLmF1dG9wbGF5IDogdHJ1ZTtcbiAgICB0aGlzLm5hbWUgPSBwYXJhbXMubmFtZSA/IHBhcmFtcy5uYW1lIDogJyc7XG4gICAgdGhpcy5hdXRvbG9hZFNlZ21lbnRzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywgJ2F1dG9sb2FkU2VnbWVudHMnKSA/IHBhcmFtcy5hdXRvbG9hZFNlZ21lbnRzIDogdHJ1ZTtcbiAgICB0aGlzLmFzc2V0c1BhdGggPSBwYXJhbXMuYXNzZXRzUGF0aDtcbiAgICB0aGlzLmluaXRpYWxTZWdtZW50ID0gcGFyYW1zLmluaXRpYWxTZWdtZW50O1xuXG4gICAgaWYgKHBhcmFtcy5hdWRpb0ZhY3RvcnkpIHtcbiAgICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLnNldEF1ZGlvRmFjdG9yeShwYXJhbXMuYXVkaW9GYWN0b3J5KTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmFuaW1hdGlvbkRhdGEpIHtcbiAgICAgIHRoaXMuc2V0dXBBbmltYXRpb24ocGFyYW1zLmFuaW1hdGlvbkRhdGEpO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zLnBhdGgpIHtcbiAgICAgIGlmIChwYXJhbXMucGF0aC5sYXN0SW5kZXhPZignXFxcXCcpICE9PSAtMSkge1xuICAgICAgICB0aGlzLnBhdGggPSBwYXJhbXMucGF0aC5zdWJzdHIoMCwgcGFyYW1zLnBhdGgubGFzdEluZGV4T2YoJ1xcXFwnKSArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXRoID0gcGFyYW1zLnBhdGguc3Vic3RyKDAsIHBhcmFtcy5wYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5maWxlTmFtZSA9IHBhcmFtcy5wYXRoLnN1YnN0cihwYXJhbXMucGF0aC5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgICB0aGlzLmZpbGVOYW1lID0gdGhpcy5maWxlTmFtZS5zdWJzdHIoMCwgdGhpcy5maWxlTmFtZS5sYXN0SW5kZXhPZignLmpzb24nKSk7XG4gICAgICBkYXRhTWFuYWdlci5sb2FkQW5pbWF0aW9uKHBhcmFtcy5wYXRoLCB0aGlzLmNvbmZpZ0FuaW1hdGlvbiwgdGhpcy5vblNldHVwRXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5vblNldHVwRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdkYXRhX2ZhaWxlZCcpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldHVwQW5pbWF0aW9uID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkYXRhTWFuYWdlci5jb21wbGV0ZUFuaW1hdGlvbihkYXRhLCB0aGlzLmNvbmZpZ0FuaW1hdGlvbik7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uICh3cmFwcGVyLCBhbmltYXRpb25EYXRhKSB7XG4gICAgaWYgKGFuaW1hdGlvbkRhdGEpIHtcbiAgICAgIGlmIChfdHlwZW9mJDQoYW5pbWF0aW9uRGF0YSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGFuaW1hdGlvbkRhdGEgPSBKU09OLnBhcnNlKGFuaW1hdGlvbkRhdGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICB3cmFwcGVyOiB3cmFwcGVyLFxuICAgICAgYW5pbWF0aW9uRGF0YTogYW5pbWF0aW9uRGF0YVxuICAgIH07XG4gICAgdmFyIHdyYXBwZXJBdHRyaWJ1dGVzID0gd3JhcHBlci5hdHRyaWJ1dGVzO1xuICAgIHBhcmFtcy5wYXRoID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW1hdGlvbi1wYXRoJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW1hdGlvbi1wYXRoJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcGF0aCcpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1wYXRoJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLXBhdGgnKSA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcGF0aCcpLnZhbHVlIDogJyc7XG4gICAgcGFyYW1zLmFuaW1UeXBlID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tdHlwZScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLXR5cGUnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS10eXBlJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXR5cGUnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tdHlwZScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tdHlwZScpLnZhbHVlIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXJlbmRlcmVyJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXJlbmRlcmVyJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLXJlbmRlcmVyJykgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLXJlbmRlcmVyJykudmFsdWUgOiBnZXRSZWdpc3RlcmVkUmVuZGVyZXIoKSB8fCAnY2FudmFzJztcbiAgICB2YXIgbG9vcCA9IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLWxvb3AnKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbS1sb29wJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tbG9vcCcpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1sb29wJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLWxvb3AnKSA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tbG9vcCcpLnZhbHVlIDogJyc7XG5cbiAgICBpZiAobG9vcCA9PT0gJ2ZhbHNlJykge1xuICAgICAgcGFyYW1zLmxvb3AgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGxvb3AgPT09ICd0cnVlJykge1xuICAgICAgcGFyYW1zLmxvb3AgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobG9vcCAhPT0gJycpIHtcbiAgICAgIHBhcmFtcy5sb29wID0gcGFyc2VJbnQobG9vcCwgMTApO1xuICAgIH1cblxuICAgIHZhciBhdXRvcGxheSA9IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLWF1dG9wbGF5JykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tYXV0b3BsYXknKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1hdXRvcGxheScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1hdXRvcGxheScpLnZhbHVlIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1hdXRvcGxheScpID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1hdXRvcGxheScpLnZhbHVlIDogdHJ1ZTtcbiAgICBwYXJhbXMuYXV0b3BsYXkgPSBhdXRvcGxheSAhPT0gJ2ZhbHNlJztcbiAgICBwYXJhbXMubmFtZSA9IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1uYW1lJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLW5hbWUnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1uYW1lJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLW5hbWUnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tbmFtZScpID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1uYW1lJykudmFsdWUgOiAnJztcbiAgICB2YXIgcHJlcmVuZGVyID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tcHJlcmVuZGVyJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tcHJlcmVuZGVyJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcHJlcmVuZGVyJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXByZXJlbmRlcicpLnZhbHVlIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1wcmVyZW5kZXInKSA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcHJlcmVuZGVyJykudmFsdWUgOiAnJztcblxuICAgIGlmIChwcmVyZW5kZXIgPT09ICdmYWxzZScpIHtcbiAgICAgIHBhcmFtcy5wcmVyZW5kZXIgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5wYXRoKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2Rlc3Ryb3knKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRQYXJhbXMocGFyYW1zKTtcbiAgICB9XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuaW5jbHVkZUxheWVycyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKGRhdGEub3AgPiB0aGlzLmFuaW1hdGlvbkRhdGEub3ApIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRGF0YS5vcCA9IGRhdGEub3A7XG4gICAgICB0aGlzLnRvdGFsRnJhbWVzID0gTWF0aC5mbG9vcihkYXRhLm9wIC0gdGhpcy5hbmltYXRpb25EYXRhLmlwKTtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5hbmltYXRpb25EYXRhLmxheWVycztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gbGF5ZXJzLmxlbmd0aDtcbiAgICB2YXIgbmV3TGF5ZXJzID0gZGF0YS5sYXllcnM7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW4gPSBuZXdMYXllcnMubGVuZ3RoO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGlmIChsYXllcnNbaV0uaWQgPT09IG5ld0xheWVyc1tqXS5pZCkge1xuICAgICAgICAgIGxheWVyc1tpXSA9IG5ld0xheWVyc1tqXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGF0YS5jaGFycyB8fCBkYXRhLmZvbnRzKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuYWRkQ2hhcnMoZGF0YS5jaGFycyk7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuYWRkRm9udHMoZGF0YS5mb250cywgdGhpcy5yZW5kZXJlci5nbG9iYWxEYXRhLmRlZnMpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmFzc2V0cykge1xuICAgICAgbGVuID0gZGF0YS5hc3NldHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25EYXRhLmFzc2V0cy5wdXNoKGRhdGEuYXNzZXRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGlvbkRhdGEuX19jb21wbGV0ZSA9IGZhbHNlO1xuICAgIGRhdGFNYW5hZ2VyLmNvbXBsZXRlQW5pbWF0aW9uKHRoaXMuYW5pbWF0aW9uRGF0YSwgdGhpcy5vblNlZ21lbnRDb21wbGV0ZSk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUub25TZWdtZW50Q29tcGxldGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuYW5pbWF0aW9uRGF0YSA9IGRhdGE7XG4gICAgdmFyIGV4cHJlc3Npb25zUGx1Z2luID0gZ2V0RXhwcmVzc2lvbnNQbHVnaW4oKTtcblxuICAgIGlmIChleHByZXNzaW9uc1BsdWdpbikge1xuICAgICAgZXhwcmVzc2lvbnNQbHVnaW4uaW5pdEV4cHJlc3Npb25zKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMubG9hZE5leHRTZWdtZW50KCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUubG9hZE5leHRTZWdtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWdtZW50cyA9IHRoaXMuYW5pbWF0aW9uRGF0YS5zZWdtZW50cztcblxuICAgIGlmICghc2VnbWVudHMgfHwgc2VnbWVudHMubGVuZ3RoID09PSAwIHx8ICF0aGlzLmF1dG9sb2FkU2VnbWVudHMpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignZGF0YV9yZWFkeScpO1xuICAgICAgdGhpcy50aW1lQ29tcGxldGVkID0gdGhpcy50b3RhbEZyYW1lcztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzLnNoaWZ0KCk7XG4gICAgdGhpcy50aW1lQ29tcGxldGVkID0gc2VnbWVudC50aW1lICogdGhpcy5mcmFtZVJhdGU7XG4gICAgdmFyIHNlZ21lbnRQYXRoID0gdGhpcy5wYXRoICsgdGhpcy5maWxlTmFtZSArICdfJyArIHRoaXMuc2VnbWVudFBvcyArICcuanNvbic7XG4gICAgdGhpcy5zZWdtZW50UG9zICs9IDE7XG4gICAgZGF0YU1hbmFnZXIubG9hZERhdGEoc2VnbWVudFBhdGgsIHRoaXMuaW5jbHVkZUxheWVycy5iaW5kKHRoaXMpLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RhdGFfZmFpbGVkJyk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5sb2FkU2VnbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlZ21lbnRzID0gdGhpcy5hbmltYXRpb25EYXRhLnNlZ21lbnRzO1xuXG4gICAgaWYgKCFzZWdtZW50cykge1xuICAgICAgdGhpcy50aW1lQ29tcGxldGVkID0gdGhpcy50b3RhbEZyYW1lcztcbiAgICB9XG5cbiAgICB0aGlzLmxvYWROZXh0U2VnbWVudCgpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmltYWdlc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2xvYWRlZF9pbWFnZXMnKTtcbiAgICB0aGlzLmNoZWNrTG9hZGVkKCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucHJlbG9hZEltYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyLnNldEFzc2V0c1BhdGgodGhpcy5hc3NldHNQYXRoKTtcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyLmxvYWRBc3NldHModGhpcy5hbmltYXRpb25EYXRhLmFzc2V0cywgdGhpcy5pbWFnZXNMb2FkZWQuYmluZCh0aGlzKSk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuY29uZmlnQW5pbWF0aW9uID0gZnVuY3Rpb24gKGFuaW1EYXRhKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRGF0YSA9IGFuaW1EYXRhO1xuXG4gICAgICBpZiAodGhpcy5pbml0aWFsU2VnbWVudCkge1xuICAgICAgICB0aGlzLnRvdGFsRnJhbWVzID0gTWF0aC5mbG9vcih0aGlzLmluaXRpYWxTZWdtZW50WzFdIC0gdGhpcy5pbml0aWFsU2VnbWVudFswXSk7XG4gICAgICAgIHRoaXMuZmlyc3RGcmFtZSA9IE1hdGgucm91bmQodGhpcy5pbml0aWFsU2VnbWVudFswXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRvdGFsRnJhbWVzID0gTWF0aC5mbG9vcih0aGlzLmFuaW1hdGlvbkRhdGEub3AgLSB0aGlzLmFuaW1hdGlvbkRhdGEuaXApO1xuICAgICAgICB0aGlzLmZpcnN0RnJhbWUgPSBNYXRoLnJvdW5kKHRoaXMuYW5pbWF0aW9uRGF0YS5pcCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyZXIuY29uZmlnQW5pbWF0aW9uKGFuaW1EYXRhKTtcblxuICAgICAgaWYgKCFhbmltRGF0YS5hc3NldHMpIHtcbiAgICAgICAgYW5pbURhdGEuYXNzZXRzID0gW107XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXNzZXRzID0gdGhpcy5hbmltYXRpb25EYXRhLmFzc2V0cztcbiAgICAgIHRoaXMuZnJhbWVSYXRlID0gdGhpcy5hbmltYXRpb25EYXRhLmZyO1xuICAgICAgdGhpcy5mcmFtZU11bHQgPSB0aGlzLmFuaW1hdGlvbkRhdGEuZnIgLyAxMDAwO1xuICAgICAgdGhpcy5yZW5kZXJlci5zZWFyY2hFeHRyYUNvbXBvc2l0aW9ucyhhbmltRGF0YS5hc3NldHMpO1xuICAgICAgdGhpcy5tYXJrZXJzID0gbWFya2VyUGFyc2VyKGFuaW1EYXRhLm1hcmtlcnMgfHwgW10pO1xuICAgICAgdGhpcy50cmlnZ2VyKCdjb25maWdfcmVhZHknKTtcbiAgICAgIHRoaXMucHJlbG9hZEltYWdlcygpO1xuICAgICAgdGhpcy5sb2FkU2VnbWVudHMoKTtcbiAgICAgIHRoaXMudXBkYUZyYW1lTW9kaWZpZXIoKTtcbiAgICAgIHRoaXMud2FpdEZvckZvbnRzTG9hZGVkKCk7XG5cbiAgICAgIGlmICh0aGlzLmlzUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMudHJpZ2dlckNvbmZpZ0Vycm9yKGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUud2FpdEZvckZvbnRzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuaXNMb2FkZWQpIHtcbiAgICAgIHRoaXMuY2hlY2tMb2FkZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dCh0aGlzLndhaXRGb3JGb250c0xvYWRlZC5iaW5kKHRoaXMpLCAyMCk7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmNoZWNrTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0xvYWRlZCAmJiB0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuaXNMb2FkZWQgJiYgKHRoaXMuaW1hZ2VQcmVsb2FkZXIubG9hZGVkSW1hZ2VzKCkgfHwgdGhpcy5yZW5kZXJlci5yZW5kZXJlclR5cGUgIT09ICdjYW52YXMnKSAmJiB0aGlzLmltYWdlUHJlbG9hZGVyLmxvYWRlZEZvb3RhZ2VzKCkpIHtcbiAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgdmFyIGV4cHJlc3Npb25zUGx1Z2luID0gZ2V0RXhwcmVzc2lvbnNQbHVnaW4oKTtcblxuICAgICAgaWYgKGV4cHJlc3Npb25zUGx1Z2luKSB7XG4gICAgICAgIGV4cHJlc3Npb25zUGx1Z2luLmluaXRFeHByZXNzaW9ucyh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJlci5pbml0SXRlbXMoKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ0RPTUxvYWRlZCcpO1xuICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgICAgIHRoaXMuZ290b0ZyYW1lKCk7XG5cbiAgICAgIGlmICh0aGlzLmF1dG9wbGF5KSB7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgIC8vIEFkZGluZyB0aGlzIHZhbGlkYXRpb24gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGluIGNhc2UgYW4gZXZlbnQgb2JqZWN0IHdhcyBiZWluZyBwYXNzZWQgZG93blxuICAgIHZhciBfd2lkdGggPSB0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInID8gd2lkdGggOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgX2hlaWdodCA9IHR5cGVvZiBoZWlnaHQgPT09ICdudW1iZXInID8gaGVpZ2h0IDogdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5yZW5kZXJlci51cGRhdGVDb250YWluZXJTaXplKF93aWR0aCwgX2hlaWdodCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0U3ViZnJhbWUgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgIHRoaXMuaXNTdWJmcmFtZUVuYWJsZWQgPSAhIWZsYWc7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ290b0ZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gdGhpcy5pc1N1YmZyYW1lRW5hYmxlZCA/IHRoaXMuY3VycmVudFJhd0ZyYW1lIDogfn50aGlzLmN1cnJlbnRSYXdGcmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1iaXR3aXNlXG5cbiAgICBpZiAodGhpcy50aW1lQ29tcGxldGVkICE9PSB0aGlzLnRvdGFsRnJhbWVzICYmIHRoaXMuY3VycmVudEZyYW1lID4gdGhpcy50aW1lQ29tcGxldGVkKSB7XG4gICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IHRoaXMudGltZUNvbXBsZXRlZDtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2VudGVyRnJhbWUnKTtcbiAgICB0aGlzLnJlbmRlckZyYW1lKCk7XG4gICAgdGhpcy50cmlnZ2VyKCdkcmF3bkZyYW1lJyk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNMb2FkZWQgPT09IGZhbHNlIHx8ICF0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmV4cHJlc3Npb25zUGx1Z2luKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnNQbHVnaW4ucmVzZXRGcmFtZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlckZyYW1lKHRoaXMuY3VycmVudEZyYW1lICsgdGhpcy5maXJzdEZyYW1lKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy50cmlnZ2VyUmVuZGVyRnJhbWVFcnJvcihlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzUGF1c2VkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG4gICAgICB0aGlzLnRyaWdnZXIoJ19wbGF5Jyk7XG4gICAgICB0aGlzLmF1ZGlvQ29udHJvbGxlci5yZXN1bWUoKTtcblxuICAgICAgaWYgKHRoaXMuX2lkbGUpIHtcbiAgICAgICAgdGhpcy5faWRsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ19hY3RpdmUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzUGF1c2VkID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gICAgICB0aGlzLnRyaWdnZXIoJ19wYXVzZScpO1xuICAgICAgdGhpcy5faWRsZSA9IHRydWU7XG4gICAgICB0aGlzLnRyaWdnZXIoJ19pZGxlJyk7XG4gICAgICB0aGlzLmF1ZGlvQ29udHJvbGxlci5wYXVzZSgpO1xuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS50b2dnbGVQYXVzZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNQYXVzZWQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucGF1c2UoKTtcbiAgICB0aGlzLnBsYXlDb3VudCA9IDA7XG4gICAgdGhpcy5fY29tcGxldGVkTG9vcCA9IGZhbHNlO1xuICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUoMCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ2V0TWFya2VyRGF0YSA9IGZ1bmN0aW9uIChtYXJrZXJOYW1lKSB7XG4gICAgdmFyIG1hcmtlcjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBtYXJrZXIgPSB0aGlzLm1hcmtlcnNbaV07XG5cbiAgICAgIGlmIChtYXJrZXIucGF5bG9hZCAmJiBtYXJrZXIucGF5bG9hZC5uYW1lID09PSBtYXJrZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ29Ub0FuZFN0b3AgPSBmdW5jdGlvbiAodmFsdWUsIGlzRnJhbWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAmJiB0aGlzLm5hbWUgIT09IG5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbnVtVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXG4gICAgaWYgKGlzTmFOKG51bVZhbHVlKSkge1xuICAgICAgdmFyIG1hcmtlciA9IHRoaXMuZ2V0TWFya2VyRGF0YSh2YWx1ZSk7XG5cbiAgICAgIGlmIChtYXJrZXIpIHtcbiAgICAgICAgdGhpcy5nb1RvQW5kU3RvcChtYXJrZXIudGltZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0ZyYW1lKSB7XG4gICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZSh2YWx1ZSAqIHRoaXMuZnJhbWVNb2RpZmllcik7XG4gICAgfVxuXG4gICAgdGhpcy5wYXVzZSgpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmdvVG9BbmRQbGF5ID0gZnVuY3Rpb24gKHZhbHVlLCBpc0ZyYW1lLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG51bVZhbHVlID0gTnVtYmVyKHZhbHVlKTtcblxuICAgIGlmIChpc05hTihudW1WYWx1ZSkpIHtcbiAgICAgIHZhciBtYXJrZXIgPSB0aGlzLmdldE1hcmtlckRhdGEodmFsdWUpO1xuXG4gICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgIGlmICghbWFya2VyLmR1cmF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5nb1RvQW5kU3RvcChtYXJrZXIudGltZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wbGF5U2VnbWVudHMoW21hcmtlci50aW1lLCBtYXJrZXIudGltZSArIG1hcmtlci5kdXJhdGlvbl0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ29Ub0FuZFN0b3AobnVtVmFsdWUsIGlzRnJhbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIHRoaXMucGxheSgpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmFkdmFuY2VUaW1lID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNQYXVzZWQgPT09IHRydWUgfHwgdGhpcy5pc0xvYWRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFZhbHVlID0gdGhpcy5jdXJyZW50UmF3RnJhbWUgKyB2YWx1ZSAqIHRoaXMuZnJhbWVNb2RpZmllcjtcbiAgICB2YXIgX2lzQ29tcGxldGUgPSBmYWxzZTsgLy8gQ2hlY2tpbmcgaWYgbmV4dFZhbHVlID4gdG90YWxGcmFtZXMgLSAxIGZvciBhZGRyZXNzaW5nIG5vbiBsb29waW5nIGFuZCBsb29waW5nIGFuaW1hdGlvbnMuXG4gICAgLy8gSWYgYW5pbWF0aW9uIHdvbid0IGxvb3AsIGl0IHNob3VsZCBzdG9wIGF0IHRvdGFsRnJhbWVzIC0gMS4gSWYgaXQgd2lsbCBsb29wIGl0IHNob3VsZCBjb21wbGV0ZSB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlbiBsb29wLlxuXG4gICAgaWYgKG5leHRWYWx1ZSA+PSB0aGlzLnRvdGFsRnJhbWVzIC0gMSAmJiB0aGlzLmZyYW1lTW9kaWZpZXIgPiAwKSB7XG4gICAgICBpZiAoIXRoaXMubG9vcCB8fCB0aGlzLnBsYXlDb3VudCA9PT0gdGhpcy5sb29wKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGVja1NlZ21lbnRzKG5leHRWYWx1ZSA+IHRoaXMudG90YWxGcmFtZXMgPyBuZXh0VmFsdWUgJSB0aGlzLnRvdGFsRnJhbWVzIDogMCkpIHtcbiAgICAgICAgICBfaXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgbmV4dFZhbHVlID0gdGhpcy50b3RhbEZyYW1lcyAtIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobmV4dFZhbHVlID49IHRoaXMudG90YWxGcmFtZXMpIHtcbiAgICAgICAgdGhpcy5wbGF5Q291bnQgKz0gMTtcblxuICAgICAgICBpZiAoIXRoaXMuY2hlY2tTZWdtZW50cyhuZXh0VmFsdWUgJSB0aGlzLnRvdGFsRnJhbWVzKSkge1xuICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUobmV4dFZhbHVlICUgdGhpcy50b3RhbEZyYW1lcyk7XG4gICAgICAgICAgdGhpcy5fY29tcGxldGVkTG9vcCA9IHRydWU7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb29wQ29tcGxldGUnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZShuZXh0VmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dFZhbHVlIDwgMCkge1xuICAgICAgaWYgKCF0aGlzLmNoZWNrU2VnbWVudHMobmV4dFZhbHVlICUgdGhpcy50b3RhbEZyYW1lcykpIHtcbiAgICAgICAgaWYgKHRoaXMubG9vcCAmJiAhKHRoaXMucGxheUNvdW50LS0gPD0gMCAmJiB0aGlzLmxvb3AgIT09IHRydWUpKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wbHVzcGx1c1xuICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUodGhpcy50b3RhbEZyYW1lcyArIG5leHRWYWx1ZSAlIHRoaXMudG90YWxGcmFtZXMpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLl9jb21wbGV0ZWRMb29wKSB7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRMb29wID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb29wQ29tcGxldGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2lzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgIG5leHRWYWx1ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZShuZXh0VmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChfaXNDb21wbGV0ZSkge1xuICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZShuZXh0VmFsdWUpO1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdjb21wbGV0ZScpO1xuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5hZGp1c3RTZWdtZW50ID0gZnVuY3Rpb24gKGFyciwgb2Zmc2V0KSB7XG4gICAgdGhpcy5wbGF5Q291bnQgPSAwO1xuXG4gICAgaWYgKGFyclsxXSA8IGFyclswXSkge1xuICAgICAgaWYgKHRoaXMuZnJhbWVNb2RpZmllciA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMucGxheVNwZWVkIDwgMCkge1xuICAgICAgICAgIHRoaXMuc2V0U3BlZWQoLXRoaXMucGxheVNwZWVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNldERpcmVjdGlvbigtMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy50b3RhbEZyYW1lcyA9IGFyclswXSAtIGFyclsxXTtcbiAgICAgIHRoaXMudGltZUNvbXBsZXRlZCA9IHRoaXMudG90YWxGcmFtZXM7XG4gICAgICB0aGlzLmZpcnN0RnJhbWUgPSBhcnJbMV07XG4gICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKHRoaXMudG90YWxGcmFtZXMgLSAwLjAwMSAtIG9mZnNldCk7XG4gICAgfSBlbHNlIGlmIChhcnJbMV0gPiBhcnJbMF0pIHtcbiAgICAgIGlmICh0aGlzLmZyYW1lTW9kaWZpZXIgPCAwKSB7XG4gICAgICAgIGlmICh0aGlzLnBsYXlTcGVlZCA8IDApIHtcbiAgICAgICAgICB0aGlzLnNldFNwZWVkKC10aGlzLnBsYXlTcGVlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXREaXJlY3Rpb24oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy50b3RhbEZyYW1lcyA9IGFyclsxXSAtIGFyclswXTtcbiAgICAgIHRoaXMudGltZUNvbXBsZXRlZCA9IHRoaXMudG90YWxGcmFtZXM7XG4gICAgICB0aGlzLmZpcnN0RnJhbWUgPSBhcnJbMF07XG4gICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKDAuMDAxICsgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3NlZ21lbnRTdGFydCcpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldFNlZ21lbnQgPSBmdW5jdGlvbiAoaW5pdCwgZW5kKSB7XG4gICAgdmFyIHBlbmRpbmdGcmFtZSA9IC0xO1xuXG4gICAgaWYgKHRoaXMuaXNQYXVzZWQpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRSYXdGcmFtZSArIHRoaXMuZmlyc3RGcmFtZSA8IGluaXQpIHtcbiAgICAgICAgcGVuZGluZ0ZyYW1lID0gaW5pdDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50UmF3RnJhbWUgKyB0aGlzLmZpcnN0RnJhbWUgPiBlbmQpIHtcbiAgICAgICAgcGVuZGluZ0ZyYW1lID0gZW5kIC0gaW5pdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZpcnN0RnJhbWUgPSBpbml0O1xuICAgIHRoaXMudG90YWxGcmFtZXMgPSBlbmQgLSBpbml0O1xuICAgIHRoaXMudGltZUNvbXBsZXRlZCA9IHRoaXMudG90YWxGcmFtZXM7XG5cbiAgICBpZiAocGVuZGluZ0ZyYW1lICE9PSAtMSkge1xuICAgICAgdGhpcy5nb1RvQW5kU3RvcChwZW5kaW5nRnJhbWUsIHRydWUpO1xuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5wbGF5U2VnbWVudHMgPSBmdW5jdGlvbiAoYXJyLCBmb3JjZUZsYWcpIHtcbiAgICBpZiAoZm9yY2VGbGFnKSB7XG4gICAgICB0aGlzLnNlZ21lbnRzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKF90eXBlb2YkNChhcnJbMF0pID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMucHVzaChhcnJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlZ21lbnRzLnB1c2goYXJyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zZWdtZW50cy5sZW5ndGggJiYgZm9yY2VGbGFnKSB7XG4gICAgICB0aGlzLmFkanVzdFNlZ21lbnQodGhpcy5zZWdtZW50cy5zaGlmdCgpLCAwKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1BhdXNlZCkge1xuICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnJlc2V0U2VnbWVudHMgPSBmdW5jdGlvbiAoZm9yY2VGbGFnKSB7XG4gICAgdGhpcy5zZWdtZW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuc2VnbWVudHMucHVzaChbdGhpcy5hbmltYXRpb25EYXRhLmlwLCB0aGlzLmFuaW1hdGlvbkRhdGEub3BdKTtcblxuICAgIGlmIChmb3JjZUZsYWcpIHtcbiAgICAgIHRoaXMuY2hlY2tTZWdtZW50cygwKTtcbiAgICB9XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuY2hlY2tTZWdtZW50cyA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICBpZiAodGhpcy5zZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYWRqdXN0U2VnbWVudCh0aGlzLnNlZ21lbnRzLnNoaWZ0KCksIG9mZnNldCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lIHx8ICF0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlci5kZXN0cm95KCk7XG4gICAgdGhpcy5pbWFnZVByZWxvYWRlci5kZXN0cm95KCk7XG4gICAgdGhpcy50cmlnZ2VyKCdkZXN0cm95Jyk7XG4gICAgdGhpcy5fY2JzID0gbnVsbDtcbiAgICB0aGlzLm9uRW50ZXJGcmFtZSA9IG51bGw7XG4gICAgdGhpcy5vbkxvb3BDb21wbGV0ZSA9IG51bGw7XG4gICAgdGhpcy5vbkNvbXBsZXRlID0gbnVsbDtcbiAgICB0aGlzLm9uU2VnbWVudFN0YXJ0ID0gbnVsbDtcbiAgICB0aGlzLm9uRGVzdHJveSA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5leHByZXNzaW9uc1BsdWdpbiA9IG51bGw7XG4gICAgdGhpcy5pbWFnZVByZWxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5wcm9qZWN0SW50ZXJmYWNlID0gbnVsbDtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuY3VycmVudFJhd0ZyYW1lID0gdmFsdWU7XG4gICAgdGhpcy5nb3RvRnJhbWUoKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXRTcGVlZCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLnBsYXlTcGVlZCA9IHZhbDtcbiAgICB0aGlzLnVwZGFGcmFtZU1vZGlmaWVyKCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMucGxheURpcmVjdGlvbiA9IHZhbCA8IDAgPyAtMSA6IDE7XG4gICAgdGhpcy51cGRhRnJhbWVNb2RpZmllcigpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAoaXNMb29waW5nKSB7XG4gICAgdGhpcy5sb29wID0gaXNMb29waW5nO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldFZvbHVtZSA9IGZ1bmN0aW9uICh2YWwsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAmJiB0aGlzLm5hbWUgIT09IG5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmF1ZGlvQ29udHJvbGxlci5zZXRWb2x1bWUodmFsKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5nZXRWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXVkaW9Db250cm9sbGVyLmdldFZvbHVtZSgpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLm11dGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLm11dGUoKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS51bm11dGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLnVubXV0ZSgpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnVwZGFGcmFtZU1vZGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnJhbWVNb2RpZmllciA9IHRoaXMuZnJhbWVNdWx0ICogdGhpcy5wbGF5U3BlZWQgKiB0aGlzLnBsYXlEaXJlY3Rpb247XG4gICAgdGhpcy5hdWRpb0NvbnRyb2xsZXIuc2V0UmF0ZSh0aGlzLnBsYXlTcGVlZCAqIHRoaXMucGxheURpcmVjdGlvbik7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRoO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmdldEFzc2V0c1BhdGggPSBmdW5jdGlvbiAoYXNzZXREYXRhKSB7XG4gICAgdmFyIHBhdGggPSAnJztcblxuICAgIGlmIChhc3NldERhdGEuZSkge1xuICAgICAgcGF0aCA9IGFzc2V0RGF0YS5wO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hc3NldHNQYXRoKSB7XG4gICAgICB2YXIgaW1hZ2VQYXRoID0gYXNzZXREYXRhLnA7XG5cbiAgICAgIGlmIChpbWFnZVBhdGguaW5kZXhPZignaW1hZ2VzLycpICE9PSAtMSkge1xuICAgICAgICBpbWFnZVBhdGggPSBpbWFnZVBhdGguc3BsaXQoJy8nKVsxXTtcbiAgICAgIH1cblxuICAgICAgcGF0aCA9IHRoaXMuYXNzZXRzUGF0aCArIGltYWdlUGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgIHBhdGggKz0gYXNzZXREYXRhLnUgPyBhc3NldERhdGEudSA6ICcnO1xuICAgICAgcGF0aCArPSBhc3NldERhdGEucDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5nZXRBc3NldERhdGEgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHRoaXMuYXNzZXRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAoaWQgPT09IHRoaXMuYXNzZXRzW2ldLmlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2V0c1tpXTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5oaWRlKCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnNob3coKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5nZXREdXJhdGlvbiA9IGZ1bmN0aW9uIChpc0ZyYW1lKSB7XG4gICAgcmV0dXJuIGlzRnJhbWUgPyB0aGlzLnRvdGFsRnJhbWVzIDogdGhpcy50b3RhbEZyYW1lcyAvIHRoaXMuZnJhbWVSYXRlO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50RGF0YSA9IGZ1bmN0aW9uIChwYXRoLCBkb2N1bWVudERhdGEsIGluZGV4KSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5yZW5kZXJlci5nZXRFbGVtZW50QnlQYXRoKHBhdGgpO1xuICAgICAgZWxlbWVudC51cGRhdGVEb2N1bWVudERhdGEoZG9jdW1lbnREYXRhLCBpbmRleCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBUT0RPOiBkZWNpZGUgaG93IHRvIGhhbmRsZSBjYXRjaCBjYXNlXG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh0aGlzLl9jYnMgJiYgdGhpcy5fY2JzW25hbWVdKSB7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSAnZW50ZXJGcmFtZSc6XG4gICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmFtZSwgbmV3IEJNRW50ZXJGcmFtZUV2ZW50KG5hbWUsIHRoaXMuY3VycmVudEZyYW1lLCB0aGlzLnRvdGFsRnJhbWVzLCB0aGlzLmZyYW1lTW9kaWZpZXIpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkcmF3bkZyYW1lJzpcbiAgICAgICAgICB0aGlzLmRyYXduRnJhbWVFdmVudC5jdXJyZW50VGltZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgICAgICAgIHRoaXMuZHJhd25GcmFtZUV2ZW50LnRvdGFsVGltZSA9IHRoaXMudG90YWxGcmFtZXM7XG4gICAgICAgICAgdGhpcy5kcmF3bkZyYW1lRXZlbnQuZGlyZWN0aW9uID0gdGhpcy5mcmFtZU1vZGlmaWVyO1xuICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIHRoaXMuZHJhd25GcmFtZUV2ZW50KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdsb29wQ29tcGxldGUnOlxuICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIG5ldyBCTUNvbXBsZXRlTG9vcEV2ZW50KG5hbWUsIHRoaXMubG9vcCwgdGhpcy5wbGF5Q291bnQsIHRoaXMuZnJhbWVNdWx0KSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY29tcGxldGUnOlxuICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIG5ldyBCTUNvbXBsZXRlRXZlbnQobmFtZSwgdGhpcy5mcmFtZU11bHQpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzZWdtZW50U3RhcnQnOlxuICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIG5ldyBCTVNlZ21lbnRTdGFydEV2ZW50KG5hbWUsIHRoaXMuZmlyc3RGcmFtZSwgdGhpcy50b3RhbEZyYW1lcykpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rlc3Ryb3knOlxuICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIG5ldyBCTURlc3Ryb3lFdmVudChuYW1lLCB0aGlzKSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ2VudGVyRnJhbWUnICYmIHRoaXMub25FbnRlckZyYW1lKSB7XG4gICAgICB0aGlzLm9uRW50ZXJGcmFtZS5jYWxsKHRoaXMsIG5ldyBCTUVudGVyRnJhbWVFdmVudChuYW1lLCB0aGlzLmN1cnJlbnRGcmFtZSwgdGhpcy50b3RhbEZyYW1lcywgdGhpcy5mcmFtZU11bHQpKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ2xvb3BDb21wbGV0ZScgJiYgdGhpcy5vbkxvb3BDb21wbGV0ZSkge1xuICAgICAgdGhpcy5vbkxvb3BDb21wbGV0ZS5jYWxsKHRoaXMsIG5ldyBCTUNvbXBsZXRlTG9vcEV2ZW50KG5hbWUsIHRoaXMubG9vcCwgdGhpcy5wbGF5Q291bnQsIHRoaXMuZnJhbWVNdWx0KSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICdjb21wbGV0ZScgJiYgdGhpcy5vbkNvbXBsZXRlKSB7XG4gICAgICB0aGlzLm9uQ29tcGxldGUuY2FsbCh0aGlzLCBuZXcgQk1Db21wbGV0ZUV2ZW50KG5hbWUsIHRoaXMuZnJhbWVNdWx0KSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICdzZWdtZW50U3RhcnQnICYmIHRoaXMub25TZWdtZW50U3RhcnQpIHtcbiAgICAgIHRoaXMub25TZWdtZW50U3RhcnQuY2FsbCh0aGlzLCBuZXcgQk1TZWdtZW50U3RhcnRFdmVudChuYW1lLCB0aGlzLmZpcnN0RnJhbWUsIHRoaXMudG90YWxGcmFtZXMpKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ2Rlc3Ryb3knICYmIHRoaXMub25EZXN0cm95KSB7XG4gICAgICB0aGlzLm9uRGVzdHJveS5jYWxsKHRoaXMsIG5ldyBCTURlc3Ryb3lFdmVudChuYW1lLCB0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnRyaWdnZXJSZW5kZXJGcmFtZUVycm9yID0gZnVuY3Rpb24gKG5hdGl2ZUVycm9yKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEJNUmVuZGVyRnJhbWVFcnJvckV2ZW50KG5hdGl2ZUVycm9yLCB0aGlzLmN1cnJlbnRGcmFtZSk7XG4gICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2Vycm9yJywgZXJyb3IpO1xuXG4gICAgaWYgKHRoaXMub25FcnJvcikge1xuICAgICAgdGhpcy5vbkVycm9yLmNhbGwodGhpcywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS50cmlnZ2VyQ29uZmlnRXJyb3IgPSBmdW5jdGlvbiAobmF0aXZlRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgQk1Db25maWdFcnJvckV2ZW50KG5hdGl2ZUVycm9yLCB0aGlzLmN1cnJlbnRGcmFtZSk7XG4gICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2Vycm9yJywgZXJyb3IpO1xuXG4gICAgaWYgKHRoaXMub25FcnJvcikge1xuICAgICAgdGhpcy5vbkVycm9yLmNhbGwodGhpcywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYW5pbWF0aW9uTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kdWxlT2IgPSB7fTtcbiAgICB2YXIgcmVnaXN0ZXJlZEFuaW1hdGlvbnMgPSBbXTtcbiAgICB2YXIgaW5pdFRpbWUgPSAwO1xuICAgIHZhciBsZW4gPSAwO1xuICAgIHZhciBwbGF5aW5nQW5pbWF0aW9uc051bSA9IDA7XG4gICAgdmFyIF9zdG9wcGVkID0gdHJ1ZTtcbiAgICB2YXIgX2lzRnJvemVuID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiByZW1vdmVFbGVtZW50KGV2KSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgYW5pbUl0ZW0gPSBldi50YXJnZXQ7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGlmIChyZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24gPT09IGFuaW1JdGVtKSB7XG4gICAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICBsZW4gLT0gMTtcblxuICAgICAgICAgIGlmICghYW5pbUl0ZW0uaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHN1YnRyYWN0UGxheWluZ0NvdW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyQW5pbWF0aW9uKGVsZW1lbnQsIGFuaW1hdGlvbkRhdGEpIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAocmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uZWxlbSA9PT0gZWxlbWVudCAmJiByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5lbGVtICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFuaW1JdGVtID0gbmV3IEFuaW1hdGlvbkl0ZW0oKTtcbiAgICAgIHNldHVwQW5pbWF0aW9uKGFuaW1JdGVtLCBlbGVtZW50KTtcbiAgICAgIGFuaW1JdGVtLnNldERhdGEoZWxlbWVudCwgYW5pbWF0aW9uRGF0YSk7XG4gICAgICByZXR1cm4gYW5pbUl0ZW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZEFuaW1hdGlvbnMoKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW5BbmltcyA9IHJlZ2lzdGVyZWRBbmltYXRpb25zLmxlbmd0aDtcbiAgICAgIHZhciBhbmltYXRpb25zID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5BbmltczsgaSArPSAxKSB7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaChyZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRQbGF5aW5nQ291bnQoKSB7XG4gICAgICBwbGF5aW5nQW5pbWF0aW9uc051bSArPSAxO1xuICAgICAgYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWJ0cmFjdFBsYXlpbmdDb3VudCgpIHtcbiAgICAgIHBsYXlpbmdBbmltYXRpb25zTnVtIC09IDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dXBBbmltYXRpb24oYW5pbUl0ZW0sIGVsZW1lbnQpIHtcbiAgICAgIGFuaW1JdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2Rlc3Ryb3knLCByZW1vdmVFbGVtZW50KTtcbiAgICAgIGFuaW1JdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ19hY3RpdmUnLCBhZGRQbGF5aW5nQ291bnQpO1xuICAgICAgYW5pbUl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignX2lkbGUnLCBzdWJ0cmFjdFBsYXlpbmdDb3VudCk7XG4gICAgICByZWdpc3RlcmVkQW5pbWF0aW9ucy5wdXNoKHtcbiAgICAgICAgZWxlbTogZWxlbWVudCxcbiAgICAgICAgYW5pbWF0aW9uOiBhbmltSXRlbVxuICAgICAgfSk7XG4gICAgICBsZW4gKz0gMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkQW5pbWF0aW9uKHBhcmFtcykge1xuICAgICAgdmFyIGFuaW1JdGVtID0gbmV3IEFuaW1hdGlvbkl0ZW0oKTtcbiAgICAgIHNldHVwQW5pbWF0aW9uKGFuaW1JdGVtLCBudWxsKTtcbiAgICAgIGFuaW1JdGVtLnNldFBhcmFtcyhwYXJhbXMpO1xuICAgICAgcmV0dXJuIGFuaW1JdGVtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFNwZWVkKHZhbCwgYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5zZXRTcGVlZCh2YWwsIGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0RGlyZWN0aW9uKHZhbCwgYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5zZXREaXJlY3Rpb24odmFsLCBhbmltYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBsYXkoYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5wbGF5KGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzdW1lKG5vd1RpbWUpIHtcbiAgICAgIHZhciBlbGFwc2VkVGltZSA9IG5vd1RpbWUgLSBpbml0VGltZTtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLmFkdmFuY2VUaW1lKGVsYXBzZWRUaW1lKTtcbiAgICAgIH1cblxuICAgICAgaW5pdFRpbWUgPSBub3dUaW1lO1xuXG4gICAgICBpZiAocGxheWluZ0FuaW1hdGlvbnNOdW0gJiYgIV9pc0Zyb3plbikge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc3VtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfc3RvcHBlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlyc3Qobm93VGltZSkge1xuICAgICAgaW5pdFRpbWUgPSBub3dUaW1lO1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyZXN1bWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhdXNlKGFuaW1hdGlvbikge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24ucGF1c2UoYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnb1RvQW5kU3RvcCh2YWx1ZSwgaXNGcmFtZSwgYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5nb1RvQW5kU3RvcCh2YWx1ZSwgaXNGcmFtZSwgYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdG9wKGFuaW1hdGlvbikge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24uc3RvcChhbmltYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvZ2dsZVBhdXNlKGFuaW1hdGlvbikge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24udG9nZ2xlUGF1c2UoYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXN0cm95KGFuaW1hdGlvbikge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5kZXN0cm95KGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VhcmNoQW5pbWF0aW9ucyhhbmltYXRpb25EYXRhLCBzdGFuZGFsb25lLCByZW5kZXJlcikge1xuICAgICAgdmFyIGFuaW1FbGVtZW50cyA9IFtdLmNvbmNhdChbXS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xvdHRpZScpKSwgW10uc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdib2R5bW92aW4nKSkpO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuQW5pbXMgPSBhbmltRWxlbWVudHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuQW5pbXM7IGkgKz0gMSkge1xuICAgICAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgICAgICBhbmltRWxlbWVudHNbaV0uc2V0QXR0cmlidXRlKCdkYXRhLWJtLXR5cGUnLCByZW5kZXJlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckFuaW1hdGlvbihhbmltRWxlbWVudHNbaV0sIGFuaW1hdGlvbkRhdGEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhbmRhbG9uZSAmJiBsZW5BbmltcyA9PT0gMCkge1xuICAgICAgICBpZiAoIXJlbmRlcmVyKSB7XG4gICAgICAgICAgcmVuZGVyZXIgPSAnc3ZnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXTtcbiAgICAgICAgYm9keS5pbm5lclRleHQgPSAnJztcbiAgICAgICAgdmFyIGRpdiA9IGNyZWF0ZVRhZygnZGl2Jyk7XG4gICAgICAgIGRpdi5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnZGF0YS1ibS10eXBlJywgcmVuZGVyZXIpO1xuICAgICAgICBib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgIHJlZ2lzdGVyQW5pbWF0aW9uKGRpdiwgYW5pbWF0aW9uRGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24ucmVzaXplKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWN0aXZhdGUoKSB7XG4gICAgICBpZiAoIV9pc0Zyb3plbiAmJiBwbGF5aW5nQW5pbWF0aW9uc051bSkge1xuICAgICAgICBpZiAoX3N0b3BwZWQpIHtcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZpcnN0KTtcbiAgICAgICAgICBfc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJlZXplKCkge1xuICAgICAgX2lzRnJvemVuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmZyZWV6ZSgpIHtcbiAgICAgIF9pc0Zyb3plbiA9IGZhbHNlO1xuICAgICAgYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRWb2x1bWUodmFsLCBhbmltYXRpb24pIHtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnNldFZvbHVtZSh2YWwsIGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXV0ZShhbmltYXRpb24pIHtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLm11dGUoYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bm11dGUoYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi51bm11dGUoYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGVPYi5yZWdpc3RlckFuaW1hdGlvbiA9IHJlZ2lzdGVyQW5pbWF0aW9uO1xuICAgIG1vZHVsZU9iLmxvYWRBbmltYXRpb24gPSBsb2FkQW5pbWF0aW9uO1xuICAgIG1vZHVsZU9iLnNldFNwZWVkID0gc2V0U3BlZWQ7XG4gICAgbW9kdWxlT2Iuc2V0RGlyZWN0aW9uID0gc2V0RGlyZWN0aW9uO1xuICAgIG1vZHVsZU9iLnBsYXkgPSBwbGF5O1xuICAgIG1vZHVsZU9iLnBhdXNlID0gcGF1c2U7XG4gICAgbW9kdWxlT2Iuc3RvcCA9IHN0b3A7XG4gICAgbW9kdWxlT2IudG9nZ2xlUGF1c2UgPSB0b2dnbGVQYXVzZTtcbiAgICBtb2R1bGVPYi5zZWFyY2hBbmltYXRpb25zID0gc2VhcmNoQW5pbWF0aW9ucztcbiAgICBtb2R1bGVPYi5yZXNpemUgPSByZXNpemU7IC8vIG1vZHVsZU9iLnN0YXJ0ID0gc3RhcnQ7XG5cbiAgICBtb2R1bGVPYi5nb1RvQW5kU3RvcCA9IGdvVG9BbmRTdG9wO1xuICAgIG1vZHVsZU9iLmRlc3Ryb3kgPSBkZXN0cm95O1xuICAgIG1vZHVsZU9iLmZyZWV6ZSA9IGZyZWV6ZTtcbiAgICBtb2R1bGVPYi51bmZyZWV6ZSA9IHVuZnJlZXplO1xuICAgIG1vZHVsZU9iLnNldFZvbHVtZSA9IHNldFZvbHVtZTtcbiAgICBtb2R1bGVPYi5tdXRlID0gbXV0ZTtcbiAgICBtb2R1bGVPYi51bm11dGUgPSB1bm11dGU7XG4gICAgbW9kdWxlT2IuZ2V0UmVnaXN0ZXJlZEFuaW1hdGlvbnMgPSBnZXRSZWdpc3RlcmVkQW5pbWF0aW9ucztcbiAgICByZXR1cm4gbW9kdWxlT2I7XG4gIH0oKTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICB2YXIgQmV6aWVyRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcclxuICAgICAgICogQmV6aWVyRWFzaW5nIC0gdXNlIGJlemllciBjdXJ2ZSBmb3IgdHJhbnNpdGlvbiBlYXNpbmcgZnVuY3Rpb25cclxuICAgICAgICogYnkgR2HDq3RhbiBSZW5hdWRlYXUgMjAxNCAtIDIwMTUg4oCTIE1JVCBMaWNlbnNlXHJcbiAgICAgICAqXHJcbiAgICAgICAqIENyZWRpdHM6IGlzIGJhc2VkIG9uIEZpcmVmb3gncyBuc1NNSUxLZXlTcGxpbmUuY3BwXHJcbiAgICAgICAqIFVzYWdlOlxyXG4gICAgICAgKiB2YXIgc3BsaW5lID0gQmV6aWVyRWFzaW5nKFsgMC4yNSwgMC4xLCAwLjI1LCAxLjAgXSlcclxuICAgICAgICogc3BsaW5lLmdldCh4KSA9PiByZXR1cm5zIHRoZSBlYXNpbmcgdmFsdWUgfCB4IG11c3QgYmUgaW4gWzAsIDFdIHJhbmdlXHJcbiAgICAgICAqXHJcbiAgICAgICAqL1xuICAgIHZhciBvYiA9IHt9O1xuICAgIG9iLmdldEJlemllckVhc2luZyA9IGdldEJlemllckVhc2luZztcbiAgICB2YXIgYmV6aWVycyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZ2V0QmV6aWVyRWFzaW5nKGEsIGIsIGMsIGQsIG5tKSB7XG4gICAgICB2YXIgc3RyID0gbm0gfHwgKCdiZXpfJyArIGEgKyAnXycgKyBiICsgJ18nICsgYyArICdfJyArIGQpLnJlcGxhY2UoL1xcLi9nLCAncCcpO1xuXG4gICAgICBpZiAoYmV6aWVyc1tzdHJdKSB7XG4gICAgICAgIHJldHVybiBiZXppZXJzW3N0cl07XG4gICAgICB9XG5cbiAgICAgIHZhciBiZXpFYXNpbmcgPSBuZXcgQmV6aWVyRWFzaW5nKFthLCBiLCBjLCBkXSk7XG4gICAgICBiZXppZXJzW3N0cl0gPSBiZXpFYXNpbmc7XG4gICAgICByZXR1cm4gYmV6RWFzaW5nO1xuICAgIH0gLy8gVGhlc2UgdmFsdWVzIGFyZSBlc3RhYmxpc2hlZCBieSBlbXBpcmljaXNtIHdpdGggdGVzdHMgKHRyYWRlb2ZmOiBwZXJmb3JtYW5jZSBWUyBwcmVjaXNpb24pXG5cblxuICAgIHZhciBORVdUT05fSVRFUkFUSU9OUyA9IDQ7XG4gICAgdmFyIE5FV1RPTl9NSU5fU0xPUEUgPSAwLjAwMTtcbiAgICB2YXIgU1VCRElWSVNJT05fUFJFQ0lTSU9OID0gMC4wMDAwMDAxO1xuICAgIHZhciBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwO1xuICAgIHZhciBrU3BsaW5lVGFibGVTaXplID0gMTE7XG4gICAgdmFyIGtTYW1wbGVTdGVwU2l6ZSA9IDEuMCAvIChrU3BsaW5lVGFibGVTaXplIC0gMS4wKTtcbiAgICB2YXIgZmxvYXQzMkFycmF5U3VwcG9ydGVkID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ2Z1bmN0aW9uJztcblxuICAgIGZ1bmN0aW9uIEEoYUExLCBhQTIpIHtcbiAgICAgIHJldHVybiAxLjAgLSAzLjAgKiBhQTIgKyAzLjAgKiBhQTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQihhQTEsIGFBMikge1xuICAgICAgcmV0dXJuIDMuMCAqIGFBMiAtIDYuMCAqIGFBMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDKGFBMSkge1xuICAgICAgcmV0dXJuIDMuMCAqIGFBMTtcbiAgICB9IC8vIFJldHVybnMgeCh0KSBnaXZlbiB0LCB4MSwgYW5kIHgyLCBvciB5KHQpIGdpdmVuIHQsIHkxLCBhbmQgeTIuXG5cblxuICAgIGZ1bmN0aW9uIGNhbGNCZXppZXIoYVQsIGFBMSwgYUEyKSB7XG4gICAgICByZXR1cm4gKChBKGFBMSwgYUEyKSAqIGFUICsgQihhQTEsIGFBMikpICogYVQgKyBDKGFBMSkpICogYVQ7XG4gICAgfSAvLyBSZXR1cm5zIGR4L2R0IGdpdmVuIHQsIHgxLCBhbmQgeDIsIG9yIGR5L2R0IGdpdmVuIHQsIHkxLCBhbmQgeTIuXG5cblxuICAgIGZ1bmN0aW9uIGdldFNsb3BlKGFULCBhQTEsIGFBMikge1xuICAgICAgcmV0dXJuIDMuMCAqIEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIuMCAqIEIoYUExLCBhQTIpICogYVQgKyBDKGFBMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKGFYLCBhQSwgYUIsIG1YMSwgbVgyKSB7XG4gICAgICB2YXIgY3VycmVudFgsXG4gICAgICAgICAgY3VycmVudFQsXG4gICAgICAgICAgaSA9IDA7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcbiAgICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcblxuICAgICAgICBpZiAoY3VycmVudFggPiAwLjApIHtcbiAgICAgICAgICBhQiA9IGN1cnJlbnRUO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFBID0gY3VycmVudFQ7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTiAmJiArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyk7XG5cbiAgICAgIHJldHVybiBjdXJyZW50VDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgYUd1ZXNzVCwgbVgxLCBtWDIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTkVXVE9OX0lURVJBVElPTlM7ICsraSkge1xuICAgICAgICB2YXIgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgICAgICBpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHJldHVybiBhR3Vlc3NUO1xuICAgICAgICB2YXIgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYUd1ZXNzVDtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgICAqIHBvaW50cyBpcyBhbiBhcnJheSBvZiBbIG1YMSwgbVkxLCBtWDIsIG1ZMiBdXHJcbiAgICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBCZXppZXJFYXNpbmcocG9pbnRzKSB7XG4gICAgICB0aGlzLl9wID0gcG9pbnRzO1xuICAgICAgdGhpcy5fbVNhbXBsZVZhbHVlcyA9IGZsb2F0MzJBcnJheVN1cHBvcnRlZCA/IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSkgOiBuZXcgQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG4gICAgICB0aGlzLl9wcmVjb21wdXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5nZXQgPSB0aGlzLmdldC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIEJlemllckVhc2luZy5wcm90b3R5cGUgPSB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCh4KSB7XG4gICAgICAgIHZhciBtWDEgPSB0aGlzLl9wWzBdLFxuICAgICAgICAgICAgbVkxID0gdGhpcy5fcFsxXSxcbiAgICAgICAgICAgIG1YMiA9IHRoaXMuX3BbMl0sXG4gICAgICAgICAgICBtWTIgPSB0aGlzLl9wWzNdO1xuICAgICAgICBpZiAoIXRoaXMuX3ByZWNvbXB1dGVkKSB0aGlzLl9wcmVjb21wdXRlKCk7XG4gICAgICAgIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikgcmV0dXJuIHg7IC8vIGxpbmVhclxuICAgICAgICAvLyBCZWNhdXNlIEphdmFTY3JpcHQgbnVtYmVyIGFyZSBpbXByZWNpc2UsIHdlIHNob3VsZCBndWFyYW50ZWUgdGhlIGV4dHJlbWVzIGFyZSByaWdodC5cblxuICAgICAgICBpZiAoeCA9PT0gMCkgcmV0dXJuIDA7XG4gICAgICAgIGlmICh4ID09PSAxKSByZXR1cm4gMTtcbiAgICAgICAgcmV0dXJuIGNhbGNCZXppZXIodGhpcy5fZ2V0VEZvclgoeCksIG1ZMSwgbVkyKTtcbiAgICAgIH0sXG4gICAgICAvLyBQcml2YXRlIHBhcnRcbiAgICAgIF9wcmVjb21wdXRlOiBmdW5jdGlvbiBfcHJlY29tcHV0ZSgpIHtcbiAgICAgICAgdmFyIG1YMSA9IHRoaXMuX3BbMF0sXG4gICAgICAgICAgICBtWTEgPSB0aGlzLl9wWzFdLFxuICAgICAgICAgICAgbVgyID0gdGhpcy5fcFsyXSxcbiAgICAgICAgICAgIG1ZMiA9IHRoaXMuX3BbM107XG4gICAgICAgIHRoaXMuX3ByZWNvbXB1dGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAobVgxICE9PSBtWTEgfHwgbVgyICE9PSBtWTIpIHtcbiAgICAgICAgICB0aGlzLl9jYWxjU2FtcGxlVmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY2FsY1NhbXBsZVZhbHVlczogZnVuY3Rpb24gX2NhbGNTYW1wbGVWYWx1ZXMoKSB7XG4gICAgICAgIHZhciBtWDEgPSB0aGlzLl9wWzBdLFxuICAgICAgICAgICAgbVgyID0gdGhpcy5fcFsyXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xuICAgICAgICAgIHRoaXMuX21TYW1wbGVWYWx1ZXNbaV0gPSBjYWxjQmV6aWVyKGkgKiBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBnZXRURm9yWCBjaG9zZSB0aGUgZmFzdGVzdCBoZXVyaXN0aWMgdG8gZGV0ZXJtaW5lIHRoZSBwZXJjZW50YWdlIHZhbHVlIHByZWNpc2VseSBmcm9tIGEgZ2l2ZW4gWCBwcm9qZWN0aW9uLlxyXG4gICAgICAgICAgICovXG4gICAgICBfZ2V0VEZvclg6IGZ1bmN0aW9uIF9nZXRURm9yWChhWCkge1xuICAgICAgICB2YXIgbVgxID0gdGhpcy5fcFswXSxcbiAgICAgICAgICAgIG1YMiA9IHRoaXMuX3BbMl0sXG4gICAgICAgICAgICBtU2FtcGxlVmFsdWVzID0gdGhpcy5fbVNhbXBsZVZhbHVlcztcbiAgICAgICAgdmFyIGludGVydmFsU3RhcnQgPSAwLjA7XG4gICAgICAgIHZhciBjdXJyZW50U2FtcGxlID0gMTtcbiAgICAgICAgdmFyIGxhc3RTYW1wbGUgPSBrU3BsaW5lVGFibGVTaXplIC0gMTtcblxuICAgICAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcbiAgICAgICAgICBpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC0tY3VycmVudFNhbXBsZTsgLy8gSW50ZXJwb2xhdGUgdG8gcHJvdmlkZSBhbiBpbml0aWFsIGd1ZXNzIGZvciB0XG5cbiAgICAgICAgdmFyIGRpc3QgPSAoYVggLSBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pO1xuICAgICAgICB2YXIgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG4gICAgICAgIHZhciBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcblxuICAgICAgICBpZiAoaW5pdGlhbFNsb3BlID49IE5FV1RPTl9NSU5fU0xPUEUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluaXRpYWxTbG9wZSA9PT0gMC4wKSB7XG4gICAgICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIHZhciBwb29saW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9kb3VibGUoYXJyKSB7XG4gICAgICByZXR1cm4gYXJyLmNvbmNhdChjcmVhdGVTaXplZEFycmF5KGFyci5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgXCJkb3VibGVcIjogX2RvdWJsZVxuICAgIH07XG4gIH0oKTtcblxuICB2YXIgcG9vbEZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbml0aWFsTGVuZ3RoLCBfY3JlYXRlLCBfcmVsZWFzZSkge1xuICAgICAgdmFyIF9sZW5ndGggPSAwO1xuICAgICAgdmFyIF9tYXhMZW5ndGggPSBpbml0aWFsTGVuZ3RoO1xuICAgICAgdmFyIHBvb2wgPSBjcmVhdGVTaXplZEFycmF5KF9tYXhMZW5ndGgpO1xuICAgICAgdmFyIG9iID0ge1xuICAgICAgICBuZXdFbGVtZW50OiBuZXdFbGVtZW50LFxuICAgICAgICByZWxlYXNlOiByZWxlYXNlXG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBuZXdFbGVtZW50KCkge1xuICAgICAgICB2YXIgZWxlbWVudDtcblxuICAgICAgICBpZiAoX2xlbmd0aCkge1xuICAgICAgICAgIF9sZW5ndGggLT0gMTtcbiAgICAgICAgICBlbGVtZW50ID0gcG9vbFtfbGVuZ3RoXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50ID0gX2NyZWF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbGVhc2UoZWxlbWVudCkge1xuICAgICAgICBpZiAoX2xlbmd0aCA9PT0gX21heExlbmd0aCkge1xuICAgICAgICAgIHBvb2wgPSBwb29saW5nW1wiZG91YmxlXCJdKHBvb2wpO1xuICAgICAgICAgIF9tYXhMZW5ndGggKj0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfcmVsZWFzZSkge1xuICAgICAgICAgIF9yZWxlYXNlKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9vbFtfbGVuZ3RoXSA9IGVsZW1lbnQ7XG4gICAgICAgIF9sZW5ndGggKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgYmV6aWVyTGVuZ3RoUG9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRlZExlbmd0aDogMCxcbiAgICAgICAgcGVyY2VudHM6IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBnZXREZWZhdWx0Q3VydmVTZWdtZW50cygpKSxcbiAgICAgICAgbGVuZ3RoczogY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGdldERlZmF1bHRDdXJ2ZVNlZ21lbnRzKCkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwb29sRmFjdG9yeSg4LCBjcmVhdGUpO1xuICB9KCk7XG5cbiAgdmFyIHNlZ21lbnRzTGVuZ3RoUG9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZW5ndGhzOiBbXSxcbiAgICAgICAgdG90YWxMZW5ndGg6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVsZWFzZShlbGVtZW50KSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBlbGVtZW50Lmxlbmd0aHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYmV6aWVyTGVuZ3RoUG9vbC5yZWxlYXNlKGVsZW1lbnQubGVuZ3Roc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQubGVuZ3Rocy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBwb29sRmFjdG9yeSg4LCBjcmVhdGUsIHJlbGVhc2UpO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gYmV6RnVuY3Rpb24oKSB7XG4gICAgdmFyIG1hdGggPSBNYXRoO1xuXG4gICAgZnVuY3Rpb24gcG9pbnRPbkxpbmUyRCh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICB2YXIgZGV0MSA9IHgxICogeTIgKyB5MSAqIHgzICsgeDIgKiB5MyAtIHgzICogeTIgLSB5MyAqIHgxIC0geDIgKiB5MTtcbiAgICAgIHJldHVybiBkZXQxID4gLTAuMDAxICYmIGRldDEgPCAwLjAwMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2ludE9uTGluZTNEKHgxLCB5MSwgejEsIHgyLCB5MiwgejIsIHgzLCB5MywgejMpIHtcbiAgICAgIGlmICh6MSA9PT0gMCAmJiB6MiA9PT0gMCAmJiB6MyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcG9pbnRPbkxpbmUyRCh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpc3QxID0gbWF0aC5zcXJ0KG1hdGgucG93KHgyIC0geDEsIDIpICsgbWF0aC5wb3coeTIgLSB5MSwgMikgKyBtYXRoLnBvdyh6MiAtIHoxLCAyKSk7XG4gICAgICB2YXIgZGlzdDIgPSBtYXRoLnNxcnQobWF0aC5wb3coeDMgLSB4MSwgMikgKyBtYXRoLnBvdyh5MyAtIHkxLCAyKSArIG1hdGgucG93KHozIC0gejEsIDIpKTtcbiAgICAgIHZhciBkaXN0MyA9IG1hdGguc3FydChtYXRoLnBvdyh4MyAtIHgyLCAyKSArIG1hdGgucG93KHkzIC0geTIsIDIpICsgbWF0aC5wb3coejMgLSB6MiwgMikpO1xuICAgICAgdmFyIGRpZmZEaXN0O1xuXG4gICAgICBpZiAoZGlzdDEgPiBkaXN0Mikge1xuICAgICAgICBpZiAoZGlzdDEgPiBkaXN0Mykge1xuICAgICAgICAgIGRpZmZEaXN0ID0gZGlzdDEgLSBkaXN0MiAtIGRpc3QzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZEaXN0ID0gZGlzdDMgLSBkaXN0MiAtIGRpc3QxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRpc3QzID4gZGlzdDIpIHtcbiAgICAgICAgZGlmZkRpc3QgPSBkaXN0MyAtIGRpc3QyIC0gZGlzdDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWZmRGlzdCA9IGRpc3QyIC0gZGlzdDEgLSBkaXN0MztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpZmZEaXN0ID4gLTAuMDAwMSAmJiBkaWZmRGlzdCA8IDAuMDAwMTtcbiAgICB9XG5cbiAgICB2YXIgZ2V0QmV6aWVyTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwdDEsIHB0MiwgcHQzLCBwdDQpIHtcbiAgICAgICAgdmFyIGN1cnZlU2VnbWVudHMgPSBnZXREZWZhdWx0Q3VydmVTZWdtZW50cygpO1xuICAgICAgICB2YXIgaztcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW47XG4gICAgICAgIHZhciBwdENvb3JkO1xuICAgICAgICB2YXIgcGVyYztcbiAgICAgICAgdmFyIGFkZGVkTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHB0RGlzdGFuY2U7XG4gICAgICAgIHZhciBwb2ludCA9IFtdO1xuICAgICAgICB2YXIgbGFzdFBvaW50ID0gW107XG4gICAgICAgIHZhciBsZW5ndGhEYXRhID0gYmV6aWVyTGVuZ3RoUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICAgIGxlbiA9IHB0My5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChrID0gMDsgayA8IGN1cnZlU2VnbWVudHM7IGsgKz0gMSkge1xuICAgICAgICAgIHBlcmMgPSBrIC8gKGN1cnZlU2VnbWVudHMgLSAxKTtcbiAgICAgICAgICBwdERpc3RhbmNlID0gMDtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcHRDb29yZCA9IGJtUG93KDEgLSBwZXJjLCAzKSAqIHB0MVtpXSArIDMgKiBibVBvdygxIC0gcGVyYywgMikgKiBwZXJjICogcHQzW2ldICsgMyAqICgxIC0gcGVyYykgKiBibVBvdyhwZXJjLCAyKSAqIHB0NFtpXSArIGJtUG93KHBlcmMsIDMpICogcHQyW2ldO1xuICAgICAgICAgICAgcG9pbnRbaV0gPSBwdENvb3JkO1xuXG4gICAgICAgICAgICBpZiAobGFzdFBvaW50W2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHB0RGlzdGFuY2UgKz0gYm1Qb3cocG9pbnRbaV0gLSBsYXN0UG9pbnRbaV0sIDIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0UG9pbnRbaV0gPSBwb2ludFtpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHREaXN0YW5jZSkge1xuICAgICAgICAgICAgcHREaXN0YW5jZSA9IGJtU3FydChwdERpc3RhbmNlKTtcbiAgICAgICAgICAgIGFkZGVkTGVuZ3RoICs9IHB0RGlzdGFuY2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGVuZ3RoRGF0YS5wZXJjZW50c1trXSA9IHBlcmM7XG4gICAgICAgICAgbGVuZ3RoRGF0YS5sZW5ndGhzW2tdID0gYWRkZWRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGhEYXRhLmFkZGVkTGVuZ3RoID0gYWRkZWRMZW5ndGg7XG4gICAgICAgIHJldHVybiBsZW5ndGhEYXRhO1xuICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICBmdW5jdGlvbiBnZXRTZWdtZW50c0xlbmd0aChzaGFwZURhdGEpIHtcbiAgICAgIHZhciBzZWdtZW50c0xlbmd0aCA9IHNlZ21lbnRzTGVuZ3RoUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICB2YXIgY2xvc2VkID0gc2hhcGVEYXRhLmM7XG4gICAgICB2YXIgcGF0aFYgPSBzaGFwZURhdGEudjtcbiAgICAgIHZhciBwYXRoTyA9IHNoYXBlRGF0YS5vO1xuICAgICAgdmFyIHBhdGhJID0gc2hhcGVEYXRhLmk7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBzaGFwZURhdGEuX2xlbmd0aDtcbiAgICAgIHZhciBsZW5ndGhzID0gc2VnbWVudHNMZW5ndGgubGVuZ3RocztcbiAgICAgIHZhciB0b3RhbExlbmd0aCA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpICs9IDEpIHtcbiAgICAgICAgbGVuZ3Roc1tpXSA9IGdldEJlemllckxlbmd0aChwYXRoVltpXSwgcGF0aFZbaSArIDFdLCBwYXRoT1tpXSwgcGF0aElbaSArIDFdKTtcbiAgICAgICAgdG90YWxMZW5ndGggKz0gbGVuZ3Roc1tpXS5hZGRlZExlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsb3NlZCAmJiBsZW4pIHtcbiAgICAgICAgbGVuZ3Roc1tpXSA9IGdldEJlemllckxlbmd0aChwYXRoVltpXSwgcGF0aFZbMF0sIHBhdGhPW2ldLCBwYXRoSVswXSk7XG4gICAgICAgIHRvdGFsTGVuZ3RoICs9IGxlbmd0aHNbaV0uYWRkZWRMZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnRzTGVuZ3RoLnRvdGFsTGVuZ3RoID0gdG90YWxMZW5ndGg7XG4gICAgICByZXR1cm4gc2VnbWVudHNMZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQmV6aWVyRGF0YShsZW5ndGgpIHtcbiAgICAgIHRoaXMuc2VnbWVudExlbmd0aCA9IDA7XG4gICAgICB0aGlzLnBvaW50cyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBvaW50RGF0YShwYXJ0aWFsLCBwb2ludCkge1xuICAgICAgdGhpcy5wYXJ0aWFsTGVuZ3RoID0gcGFydGlhbDtcbiAgICAgIHRoaXMucG9pbnQgPSBwb2ludDtcbiAgICB9XG5cbiAgICB2YXIgYnVpbGRCZXppZXJEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0b3JlZERhdGEgPSB7fTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAocHQxLCBwdDIsIHB0MywgcHQ0KSB7XG4gICAgICAgIHZhciBiZXppZXJOYW1lID0gKHB0MVswXSArICdfJyArIHB0MVsxXSArICdfJyArIHB0MlswXSArICdfJyArIHB0MlsxXSArICdfJyArIHB0M1swXSArICdfJyArIHB0M1sxXSArICdfJyArIHB0NFswXSArICdfJyArIHB0NFsxXSkucmVwbGFjZSgvXFwuL2csICdwJyk7XG5cbiAgICAgICAgaWYgKCFzdG9yZWREYXRhW2Jlemllck5hbWVdKSB7XG4gICAgICAgICAgdmFyIGN1cnZlU2VnbWVudHMgPSBnZXREZWZhdWx0Q3VydmVTZWdtZW50cygpO1xuICAgICAgICAgIHZhciBrO1xuICAgICAgICAgIHZhciBpO1xuICAgICAgICAgIHZhciBsZW47XG4gICAgICAgICAgdmFyIHB0Q29vcmQ7XG4gICAgICAgICAgdmFyIHBlcmM7XG4gICAgICAgICAgdmFyIGFkZGVkTGVuZ3RoID0gMDtcbiAgICAgICAgICB2YXIgcHREaXN0YW5jZTtcbiAgICAgICAgICB2YXIgcG9pbnQ7XG4gICAgICAgICAgdmFyIGxhc3RQb2ludCA9IG51bGw7XG5cbiAgICAgICAgICBpZiAocHQxLmxlbmd0aCA9PT0gMiAmJiAocHQxWzBdICE9PSBwdDJbMF0gfHwgcHQxWzFdICE9PSBwdDJbMV0pICYmIHBvaW50T25MaW5lMkQocHQxWzBdLCBwdDFbMV0sIHB0MlswXSwgcHQyWzFdLCBwdDFbMF0gKyBwdDNbMF0sIHB0MVsxXSArIHB0M1sxXSkgJiYgcG9pbnRPbkxpbmUyRChwdDFbMF0sIHB0MVsxXSwgcHQyWzBdLCBwdDJbMV0sIHB0MlswXSArIHB0NFswXSwgcHQyWzFdICsgcHQ0WzFdKSkge1xuICAgICAgICAgICAgY3VydmVTZWdtZW50cyA9IDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJlemllckRhdGEgPSBuZXcgQmV6aWVyRGF0YShjdXJ2ZVNlZ21lbnRzKTtcbiAgICAgICAgICBsZW4gPSBwdDMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChrID0gMDsgayA8IGN1cnZlU2VnbWVudHM7IGsgKz0gMSkge1xuICAgICAgICAgICAgcG9pbnQgPSBjcmVhdGVTaXplZEFycmF5KGxlbik7XG4gICAgICAgICAgICBwZXJjID0gayAvIChjdXJ2ZVNlZ21lbnRzIC0gMSk7XG4gICAgICAgICAgICBwdERpc3RhbmNlID0gMDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIHB0Q29vcmQgPSBibVBvdygxIC0gcGVyYywgMykgKiBwdDFbaV0gKyAzICogYm1Qb3coMSAtIHBlcmMsIDIpICogcGVyYyAqIChwdDFbaV0gKyBwdDNbaV0pICsgMyAqICgxIC0gcGVyYykgKiBibVBvdyhwZXJjLCAyKSAqIChwdDJbaV0gKyBwdDRbaV0pICsgYm1Qb3cocGVyYywgMykgKiBwdDJbaV07XG4gICAgICAgICAgICAgIHBvaW50W2ldID0gcHRDb29yZDtcblxuICAgICAgICAgICAgICBpZiAobGFzdFBvaW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHREaXN0YW5jZSArPSBibVBvdyhwb2ludFtpXSAtIGxhc3RQb2ludFtpXSwgMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHREaXN0YW5jZSA9IGJtU3FydChwdERpc3RhbmNlKTtcbiAgICAgICAgICAgIGFkZGVkTGVuZ3RoICs9IHB0RGlzdGFuY2U7XG4gICAgICAgICAgICBiZXppZXJEYXRhLnBvaW50c1trXSA9IG5ldyBQb2ludERhdGEocHREaXN0YW5jZSwgcG9pbnQpO1xuICAgICAgICAgICAgbGFzdFBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmV6aWVyRGF0YS5zZWdtZW50TGVuZ3RoID0gYWRkZWRMZW5ndGg7XG4gICAgICAgICAgc3RvcmVkRGF0YVtiZXppZXJOYW1lXSA9IGJlemllckRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RvcmVkRGF0YVtiZXppZXJOYW1lXTtcbiAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgZnVuY3Rpb24gZ2V0RGlzdGFuY2VQZXJjKHBlcmMsIGJlemllckRhdGEpIHtcbiAgICAgIHZhciBwZXJjZW50cyA9IGJlemllckRhdGEucGVyY2VudHM7XG4gICAgICB2YXIgbGVuZ3RocyA9IGJlemllckRhdGEubGVuZ3RocztcbiAgICAgIHZhciBsZW4gPSBwZXJjZW50cy5sZW5ndGg7XG4gICAgICB2YXIgaW5pdFBvcyA9IGJtRmxvb3IoKGxlbiAtIDEpICogcGVyYyk7XG4gICAgICB2YXIgbGVuZ3RoUG9zID0gcGVyYyAqIGJlemllckRhdGEuYWRkZWRMZW5ndGg7XG4gICAgICB2YXIgbFBlcmMgPSAwO1xuXG4gICAgICBpZiAoaW5pdFBvcyA9PT0gbGVuIC0gMSB8fCBpbml0UG9zID09PSAwIHx8IGxlbmd0aFBvcyA9PT0gbGVuZ3Roc1tpbml0UG9zXSkge1xuICAgICAgICByZXR1cm4gcGVyY2VudHNbaW5pdFBvc107XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXIgPSBsZW5ndGhzW2luaXRQb3NdID4gbGVuZ3RoUG9zID8gLTEgOiAxO1xuICAgICAgdmFyIGZsYWcgPSB0cnVlO1xuXG4gICAgICB3aGlsZSAoZmxhZykge1xuICAgICAgICBpZiAobGVuZ3Roc1tpbml0UG9zXSA8PSBsZW5ndGhQb3MgJiYgbGVuZ3Roc1tpbml0UG9zICsgMV0gPiBsZW5ndGhQb3MpIHtcbiAgICAgICAgICBsUGVyYyA9IChsZW5ndGhQb3MgLSBsZW5ndGhzW2luaXRQb3NdKSAvIChsZW5ndGhzW2luaXRQb3MgKyAxXSAtIGxlbmd0aHNbaW5pdFBvc10pO1xuICAgICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbml0UG9zICs9IGRpcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbml0UG9zIDwgMCB8fCBpbml0UG9zID49IGxlbiAtIDEpIHtcbiAgICAgICAgICAvLyBGSVggZm9yIFR5cGVkQXJyYXlzIHRoYXQgZG9uJ3Qgc3RvcmUgZmxvYXRpbmcgcG9pbnQgdmFsdWVzIHdpdGggZW5vdWdoIGFjY3VyYWN5XG4gICAgICAgICAgaWYgKGluaXRQb3MgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiBwZXJjZW50c1tpbml0UG9zXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBlcmNlbnRzW2luaXRQb3NdICsgKHBlcmNlbnRzW2luaXRQb3MgKyAxXSAtIHBlcmNlbnRzW2luaXRQb3NdKSAqIGxQZXJjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBvaW50SW5TZWdtZW50KHB0MSwgcHQyLCBwdDMsIHB0NCwgcGVyY2VudCwgYmV6aWVyRGF0YSkge1xuICAgICAgdmFyIHQxID0gZ2V0RGlzdGFuY2VQZXJjKHBlcmNlbnQsIGJlemllckRhdGEpO1xuICAgICAgdmFyIHUxID0gMSAtIHQxO1xuICAgICAgdmFyIHB0WCA9IG1hdGgucm91bmQoKHUxICogdTEgKiB1MSAqIHB0MVswXSArICh0MSAqIHUxICogdTEgKyB1MSAqIHQxICogdTEgKyB1MSAqIHUxICogdDEpICogcHQzWzBdICsgKHQxICogdDEgKiB1MSArIHUxICogdDEgKiB0MSArIHQxICogdTEgKiB0MSkgKiBwdDRbMF0gKyB0MSAqIHQxICogdDEgKiBwdDJbMF0pICogMTAwMCkgLyAxMDAwO1xuICAgICAgdmFyIHB0WSA9IG1hdGgucm91bmQoKHUxICogdTEgKiB1MSAqIHB0MVsxXSArICh0MSAqIHUxICogdTEgKyB1MSAqIHQxICogdTEgKyB1MSAqIHUxICogdDEpICogcHQzWzFdICsgKHQxICogdDEgKiB1MSArIHUxICogdDEgKiB0MSArIHQxICogdTEgKiB0MSkgKiBwdDRbMV0gKyB0MSAqIHQxICogdDEgKiBwdDJbMV0pICogMTAwMCkgLyAxMDAwO1xuICAgICAgcmV0dXJuIFtwdFgsIHB0WV07XG4gICAgfVxuXG4gICAgdmFyIGJlemllclNlZ21lbnRQb2ludHMgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgOCk7XG5cbiAgICBmdW5jdGlvbiBnZXROZXdTZWdtZW50KHB0MSwgcHQyLCBwdDMsIHB0NCwgc3RhcnRQZXJjLCBlbmRQZXJjLCBiZXppZXJEYXRhKSB7XG4gICAgICBpZiAoc3RhcnRQZXJjIDwgMCkge1xuICAgICAgICBzdGFydFBlcmMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzdGFydFBlcmMgPiAxKSB7XG4gICAgICAgIHN0YXJ0UGVyYyA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciB0MCA9IGdldERpc3RhbmNlUGVyYyhzdGFydFBlcmMsIGJlemllckRhdGEpO1xuICAgICAgZW5kUGVyYyA9IGVuZFBlcmMgPiAxID8gMSA6IGVuZFBlcmM7XG4gICAgICB2YXIgdDEgPSBnZXREaXN0YW5jZVBlcmMoZW5kUGVyYywgYmV6aWVyRGF0YSk7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBwdDEubGVuZ3RoO1xuICAgICAgdmFyIHUwID0gMSAtIHQwO1xuICAgICAgdmFyIHUxID0gMSAtIHQxO1xuICAgICAgdmFyIHUwdTB1MCA9IHUwICogdTAgKiB1MDtcbiAgICAgIHZhciB0MHUwdTBfMyA9IHQwICogdTAgKiB1MCAqIDM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cbiAgICAgIHZhciB0MHQwdTBfMyA9IHQwICogdDAgKiB1MCAqIDM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cbiAgICAgIHZhciB0MHQwdDAgPSB0MCAqIHQwICogdDA7IC8vXG5cbiAgICAgIHZhciB1MHUwdTEgPSB1MCAqIHUwICogdTE7XG4gICAgICB2YXIgdDB1MHUxXzMgPSB0MCAqIHUwICogdTEgKyB1MCAqIHQwICogdTEgKyB1MCAqIHUwICogdDE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cbiAgICAgIHZhciB0MHQwdTFfMyA9IHQwICogdDAgKiB1MSArIHUwICogdDAgKiB0MSArIHQwICogdTAgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcblxuICAgICAgdmFyIHQwdDB0MSA9IHQwICogdDAgKiB0MTsgLy9cblxuICAgICAgdmFyIHUwdTF1MSA9IHUwICogdTEgKiB1MTtcbiAgICAgIHZhciB0MHUxdTFfMyA9IHQwICogdTEgKiB1MSArIHUwICogdDEgKiB1MSArIHUwICogdTEgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcblxuICAgICAgdmFyIHQwdDF1MV8zID0gdDAgKiB0MSAqIHUxICsgdTAgKiB0MSAqIHQxICsgdDAgKiB1MSAqIHQxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuXG4gICAgICB2YXIgdDB0MXQxID0gdDAgKiB0MSAqIHQxOyAvL1xuXG4gICAgICB2YXIgdTF1MXUxID0gdTEgKiB1MSAqIHUxO1xuICAgICAgdmFyIHQxdTF1MV8zID0gdDEgKiB1MSAqIHUxICsgdTEgKiB0MSAqIHUxICsgdTEgKiB1MSAqIHQxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuXG4gICAgICB2YXIgdDF0MXUxXzMgPSB0MSAqIHQxICogdTEgKyB1MSAqIHQxICogdDEgKyB0MSAqIHUxICogdDE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cbiAgICAgIHZhciB0MXQxdDEgPSB0MSAqIHQxICogdDE7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBiZXppZXJTZWdtZW50UG9pbnRzW2kgKiA0XSA9IG1hdGgucm91bmQoKHUwdTB1MCAqIHB0MVtpXSArIHQwdTB1MF8zICogcHQzW2ldICsgdDB0MHUwXzMgKiBwdDRbaV0gKyB0MHQwdDAgKiBwdDJbaV0pICogMTAwMCkgLyAxMDAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuXG4gICAgICAgIGJlemllclNlZ21lbnRQb2ludHNbaSAqIDQgKyAxXSA9IG1hdGgucm91bmQoKHUwdTB1MSAqIHB0MVtpXSArIHQwdTB1MV8zICogcHQzW2ldICsgdDB0MHUxXzMgKiBwdDRbaV0gKyB0MHQwdDEgKiBwdDJbaV0pICogMTAwMCkgLyAxMDAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuXG4gICAgICAgIGJlemllclNlZ21lbnRQb2ludHNbaSAqIDQgKyAyXSA9IG1hdGgucm91bmQoKHUwdTF1MSAqIHB0MVtpXSArIHQwdTF1MV8zICogcHQzW2ldICsgdDB0MXUxXzMgKiBwdDRbaV0gKyB0MHQxdDEgKiBwdDJbaV0pICogMTAwMCkgLyAxMDAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuXG4gICAgICAgIGJlemllclNlZ21lbnRQb2ludHNbaSAqIDQgKyAzXSA9IG1hdGgucm91bmQoKHUxdTF1MSAqIHB0MVtpXSArIHQxdTF1MV8zICogcHQzW2ldICsgdDF0MXUxXzMgKiBwdDRbaV0gKyB0MXQxdDEgKiBwdDJbaV0pICogMTAwMCkgLyAxMDAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmV6aWVyU2VnbWVudFBvaW50cztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0U2VnbWVudHNMZW5ndGg6IGdldFNlZ21lbnRzTGVuZ3RoLFxuICAgICAgZ2V0TmV3U2VnbWVudDogZ2V0TmV3U2VnbWVudCxcbiAgICAgIGdldFBvaW50SW5TZWdtZW50OiBnZXRQb2ludEluU2VnbWVudCxcbiAgICAgIGJ1aWxkQmV6aWVyRGF0YTogYnVpbGRCZXppZXJEYXRhLFxuICAgICAgcG9pbnRPbkxpbmUyRDogcG9pbnRPbkxpbmUyRCxcbiAgICAgIHBvaW50T25MaW5lM0Q6IHBvaW50T25MaW5lM0RcbiAgICB9O1xuICB9XG5cbiAgdmFyIGJleiA9IGJlekZ1bmN0aW9uKCk7XG5cbiAgdmFyIGluaXRGcmFtZSA9IGluaXRpYWxEZWZhdWx0RnJhbWU7XG4gIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGVWYWx1ZShmcmFtZU51bSwgY2FjaGluZykge1xuICAgIHZhciBvZmZzZXRUaW1lID0gdGhpcy5vZmZzZXRUaW1lO1xuICAgIHZhciBuZXdWYWx1ZTtcblxuICAgIGlmICh0aGlzLnByb3BUeXBlID09PSAnbXVsdGlkaW1lbnNpb25hbCcpIHtcbiAgICAgIG5ld1ZhbHVlID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIHRoaXMucHYubGVuZ3RoKTtcbiAgICB9XG5cbiAgICB2YXIgaXRlcmF0aW9uSW5kZXggPSBjYWNoaW5nLmxhc3RJbmRleDtcbiAgICB2YXIgaSA9IGl0ZXJhdGlvbkluZGV4O1xuICAgIHZhciBsZW4gPSB0aGlzLmtleWZyYW1lcy5sZW5ndGggLSAxO1xuICAgIHZhciBmbGFnID0gdHJ1ZTtcbiAgICB2YXIga2V5RGF0YTtcbiAgICB2YXIgbmV4dEtleURhdGE7XG4gICAgdmFyIGtleWZyYW1lTWV0YWRhdGE7XG5cbiAgICB3aGlsZSAoZmxhZykge1xuICAgICAga2V5RGF0YSA9IHRoaXMua2V5ZnJhbWVzW2ldO1xuICAgICAgbmV4dEtleURhdGEgPSB0aGlzLmtleWZyYW1lc1tpICsgMV07XG5cbiAgICAgIGlmIChpID09PSBsZW4gLSAxICYmIGZyYW1lTnVtID49IG5leHRLZXlEYXRhLnQgLSBvZmZzZXRUaW1lKSB7XG4gICAgICAgIGlmIChrZXlEYXRhLmgpIHtcbiAgICAgICAgICBrZXlEYXRhID0gbmV4dEtleURhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVyYXRpb25JbmRleCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV4dEtleURhdGEudCAtIG9mZnNldFRpbWUgPiBmcmFtZU51bSkge1xuICAgICAgICBpdGVyYXRpb25JbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IGxlbiAtIDEpIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0aW9uSW5kZXggPSAwO1xuICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAga2V5ZnJhbWVNZXRhZGF0YSA9IHRoaXMua2V5ZnJhbWVzTWV0YWRhdGFbaV0gfHwge307XG4gICAgdmFyIGs7XG4gICAgdmFyIGtMZW47XG4gICAgdmFyIHBlcmM7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIGo7XG4gICAgdmFyIGZuYztcbiAgICB2YXIgbmV4dEtleVRpbWUgPSBuZXh0S2V5RGF0YS50IC0gb2Zmc2V0VGltZTtcbiAgICB2YXIga2V5VGltZSA9IGtleURhdGEudCAtIG9mZnNldFRpbWU7XG4gICAgdmFyIGVuZFZhbHVlO1xuXG4gICAgaWYgKGtleURhdGEudG8pIHtcbiAgICAgIGlmICgha2V5ZnJhbWVNZXRhZGF0YS5iZXppZXJEYXRhKSB7XG4gICAgICAgIGtleWZyYW1lTWV0YWRhdGEuYmV6aWVyRGF0YSA9IGJlei5idWlsZEJlemllckRhdGEoa2V5RGF0YS5zLCBuZXh0S2V5RGF0YS5zIHx8IGtleURhdGEuZSwga2V5RGF0YS50bywga2V5RGF0YS50aSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBiZXppZXJEYXRhID0ga2V5ZnJhbWVNZXRhZGF0YS5iZXppZXJEYXRhO1xuXG4gICAgICBpZiAoZnJhbWVOdW0gPj0gbmV4dEtleVRpbWUgfHwgZnJhbWVOdW0gPCBrZXlUaW1lKSB7XG4gICAgICAgIHZhciBpbmQgPSBmcmFtZU51bSA+PSBuZXh0S2V5VGltZSA/IGJlemllckRhdGEucG9pbnRzLmxlbmd0aCAtIDEgOiAwO1xuICAgICAgICBrTGVuID0gYmV6aWVyRGF0YS5wb2ludHNbaW5kXS5wb2ludC5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChrID0gMDsgayA8IGtMZW47IGsgKz0gMSkge1xuICAgICAgICAgIG5ld1ZhbHVlW2tdID0gYmV6aWVyRGF0YS5wb2ludHNbaW5kXS5wb2ludFtrXTtcbiAgICAgICAgfSAvLyBjYWNoaW5nLl9sYXN0S2V5ZnJhbWVJbmRleCA9IC0xO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3QpIHtcbiAgICAgICAgICBmbmMgPSBrZXlmcmFtZU1ldGFkYXRhLl9fZm5jdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbmMgPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZyhrZXlEYXRhLm8ueCwga2V5RGF0YS5vLnksIGtleURhdGEuaS54LCBrZXlEYXRhLmkueSwga2V5RGF0YS5uKS5nZXQ7XG4gICAgICAgICAga2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3QgPSBmbmM7XG4gICAgICAgIH1cblxuICAgICAgICBwZXJjID0gZm5jKChmcmFtZU51bSAtIGtleVRpbWUpIC8gKG5leHRLZXlUaW1lIC0ga2V5VGltZSkpO1xuICAgICAgICB2YXIgZGlzdGFuY2VJbkxpbmUgPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGggKiBwZXJjO1xuICAgICAgICB2YXIgc2VnbWVudFBlcmM7XG4gICAgICAgIHZhciBhZGRlZExlbmd0aCA9IGNhY2hpbmcubGFzdEZyYW1lIDwgZnJhbWVOdW0gJiYgY2FjaGluZy5fbGFzdEtleWZyYW1lSW5kZXggPT09IGkgPyBjYWNoaW5nLl9sYXN0QWRkZWRMZW5ndGggOiAwO1xuICAgICAgICBqID0gY2FjaGluZy5sYXN0RnJhbWUgPCBmcmFtZU51bSAmJiBjYWNoaW5nLl9sYXN0S2V5ZnJhbWVJbmRleCA9PT0gaSA/IGNhY2hpbmcuX2xhc3RQb2ludCA6IDA7XG4gICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICBqTGVuID0gYmV6aWVyRGF0YS5wb2ludHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChmbGFnKSB7XG4gICAgICAgICAgYWRkZWRMZW5ndGggKz0gYmV6aWVyRGF0YS5wb2ludHNbal0ucGFydGlhbExlbmd0aDtcblxuICAgICAgICAgIGlmIChkaXN0YW5jZUluTGluZSA9PT0gMCB8fCBwZXJjID09PSAwIHx8IGogPT09IGJlemllckRhdGEucG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGtMZW4gPSBiZXppZXJEYXRhLnBvaW50c1tqXS5wb2ludC5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBrTGVuOyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgbmV3VmFsdWVba10gPSBiZXppZXJEYXRhLnBvaW50c1tqXS5wb2ludFtrXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaXN0YW5jZUluTGluZSA+PSBhZGRlZExlbmd0aCAmJiBkaXN0YW5jZUluTGluZSA8IGFkZGVkTGVuZ3RoICsgYmV6aWVyRGF0YS5wb2ludHNbaiArIDFdLnBhcnRpYWxMZW5ndGgpIHtcbiAgICAgICAgICAgIHNlZ21lbnRQZXJjID0gKGRpc3RhbmNlSW5MaW5lIC0gYWRkZWRMZW5ndGgpIC8gYmV6aWVyRGF0YS5wb2ludHNbaiArIDFdLnBhcnRpYWxMZW5ndGg7XG4gICAgICAgICAgICBrTGVuID0gYmV6aWVyRGF0YS5wb2ludHNbal0ucG9pbnQubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwga0xlbjsgayArPSAxKSB7XG4gICAgICAgICAgICAgIG5ld1ZhbHVlW2tdID0gYmV6aWVyRGF0YS5wb2ludHNbal0ucG9pbnRba10gKyAoYmV6aWVyRGF0YS5wb2ludHNbaiArIDFdLnBvaW50W2tdIC0gYmV6aWVyRGF0YS5wb2ludHNbal0ucG9pbnRba10pICogc2VnbWVudFBlcmM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChqIDwgakxlbiAtIDEpIHtcbiAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhY2hpbmcuX2xhc3RQb2ludCA9IGo7XG4gICAgICAgIGNhY2hpbmcuX2xhc3RBZGRlZExlbmd0aCA9IGFkZGVkTGVuZ3RoIC0gYmV6aWVyRGF0YS5wb2ludHNbal0ucGFydGlhbExlbmd0aDtcbiAgICAgICAgY2FjaGluZy5fbGFzdEtleWZyYW1lSW5kZXggPSBpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3V0WDtcbiAgICAgIHZhciBvdXRZO1xuICAgICAgdmFyIGluWDtcbiAgICAgIHZhciBpblk7XG4gICAgICB2YXIga2V5VmFsdWU7XG4gICAgICBsZW4gPSBrZXlEYXRhLnMubGVuZ3RoO1xuICAgICAgZW5kVmFsdWUgPSBuZXh0S2V5RGF0YS5zIHx8IGtleURhdGEuZTtcblxuICAgICAgaWYgKHRoaXMuc2ggJiYga2V5RGF0YS5oICE9PSAxKSB7XG4gICAgICAgIGlmIChmcmFtZU51bSA+PSBuZXh0S2V5VGltZSkge1xuICAgICAgICAgIG5ld1ZhbHVlWzBdID0gZW5kVmFsdWVbMF07XG4gICAgICAgICAgbmV3VmFsdWVbMV0gPSBlbmRWYWx1ZVsxXTtcbiAgICAgICAgICBuZXdWYWx1ZVsyXSA9IGVuZFZhbHVlWzJdO1xuICAgICAgICB9IGVsc2UgaWYgKGZyYW1lTnVtIDw9IGtleVRpbWUpIHtcbiAgICAgICAgICBuZXdWYWx1ZVswXSA9IGtleURhdGEuc1swXTtcbiAgICAgICAgICBuZXdWYWx1ZVsxXSA9IGtleURhdGEuc1sxXTtcbiAgICAgICAgICBuZXdWYWx1ZVsyXSA9IGtleURhdGEuc1syXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcXVhdFN0YXJ0ID0gY3JlYXRlUXVhdGVybmlvbihrZXlEYXRhLnMpO1xuICAgICAgICAgIHZhciBxdWF0RW5kID0gY3JlYXRlUXVhdGVybmlvbihlbmRWYWx1ZSk7XG4gICAgICAgICAgdmFyIHRpbWUgPSAoZnJhbWVOdW0gLSBrZXlUaW1lKSAvIChuZXh0S2V5VGltZSAtIGtleVRpbWUpO1xuICAgICAgICAgIHF1YXRlcm5pb25Ub0V1bGVyKG5ld1ZhbHVlLCBzbGVycChxdWF0U3RhcnQsIHF1YXRFbmQsIHRpbWUpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKGtleURhdGEuaCAhPT0gMSkge1xuICAgICAgICAgICAgaWYgKGZyYW1lTnVtID49IG5leHRLZXlUaW1lKSB7XG4gICAgICAgICAgICAgIHBlcmMgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmcmFtZU51bSA8IGtleVRpbWUpIHtcbiAgICAgICAgICAgICAgcGVyYyA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoa2V5RGF0YS5vLnguY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZXlmcmFtZU1ldGFkYXRhLl9fZm5jdCkge1xuICAgICAgICAgICAgICAgICAga2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3QgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWtleWZyYW1lTWV0YWRhdGEuX19mbmN0W2ldKSB7XG4gICAgICAgICAgICAgICAgICBvdXRYID0ga2V5RGF0YS5vLnhbaV0gPT09IHVuZGVmaW5lZCA/IGtleURhdGEuby54WzBdIDoga2V5RGF0YS5vLnhbaV07XG4gICAgICAgICAgICAgICAgICBvdXRZID0ga2V5RGF0YS5vLnlbaV0gPT09IHVuZGVmaW5lZCA/IGtleURhdGEuby55WzBdIDoga2V5RGF0YS5vLnlbaV07XG4gICAgICAgICAgICAgICAgICBpblggPSBrZXlEYXRhLmkueFtpXSA9PT0gdW5kZWZpbmVkID8ga2V5RGF0YS5pLnhbMF0gOiBrZXlEYXRhLmkueFtpXTtcbiAgICAgICAgICAgICAgICAgIGluWSA9IGtleURhdGEuaS55W2ldID09PSB1bmRlZmluZWQgPyBrZXlEYXRhLmkueVswXSA6IGtleURhdGEuaS55W2ldO1xuICAgICAgICAgICAgICAgICAgZm5jID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcob3V0WCwgb3V0WSwgaW5YLCBpblkpLmdldDtcbiAgICAgICAgICAgICAgICAgIGtleWZyYW1lTWV0YWRhdGEuX19mbmN0W2ldID0gZm5jO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmbmMgPSBrZXlmcmFtZU1ldGFkYXRhLl9fZm5jdFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWtleWZyYW1lTWV0YWRhdGEuX19mbmN0KSB7XG4gICAgICAgICAgICAgICAgb3V0WCA9IGtleURhdGEuby54O1xuICAgICAgICAgICAgICAgIG91dFkgPSBrZXlEYXRhLm8ueTtcbiAgICAgICAgICAgICAgICBpblggPSBrZXlEYXRhLmkueDtcbiAgICAgICAgICAgICAgICBpblkgPSBrZXlEYXRhLmkueTtcbiAgICAgICAgICAgICAgICBmbmMgPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZyhvdXRYLCBvdXRZLCBpblgsIGluWSkuZ2V0O1xuICAgICAgICAgICAgICAgIGtleURhdGEua2V5ZnJhbWVNZXRhZGF0YSA9IGZuYztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbmMgPSBrZXlmcmFtZU1ldGFkYXRhLl9fZm5jdDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHBlcmMgPSBmbmMoKGZyYW1lTnVtIC0ga2V5VGltZSkgLyAobmV4dEtleVRpbWUgLSBrZXlUaW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZW5kVmFsdWUgPSBuZXh0S2V5RGF0YS5zIHx8IGtleURhdGEuZTtcbiAgICAgICAgICBrZXlWYWx1ZSA9IGtleURhdGEuaCA9PT0gMSA/IGtleURhdGEuc1tpXSA6IGtleURhdGEuc1tpXSArIChlbmRWYWx1ZVtpXSAtIGtleURhdGEuc1tpXSkgKiBwZXJjO1xuXG4gICAgICAgICAgaWYgKHRoaXMucHJvcFR5cGUgPT09ICdtdWx0aWRpbWVuc2lvbmFsJykge1xuICAgICAgICAgICAgbmV3VmFsdWVbaV0gPSBrZXlWYWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBrZXlWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYWNoaW5nLmxhc3RJbmRleCA9IGl0ZXJhdGlvbkluZGV4O1xuICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgfSAvLyBiYXNlZCBvbiBAVG9qaSdzIGh0dHBzOi8vZ2l0aHViLmNvbS90b2ppL2dsLW1hdHJpeC9cblxuXG4gIGZ1bmN0aW9uIHNsZXJwKGEsIGIsIHQpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgdmFyIGF4ID0gYVswXTtcbiAgICB2YXIgYXkgPSBhWzFdO1xuICAgIHZhciBheiA9IGFbMl07XG4gICAgdmFyIGF3ID0gYVszXTtcbiAgICB2YXIgYnggPSBiWzBdO1xuICAgIHZhciBieSA9IGJbMV07XG4gICAgdmFyIGJ6ID0gYlsyXTtcbiAgICB2YXIgYncgPSBiWzNdO1xuICAgIHZhciBvbWVnYTtcbiAgICB2YXIgY29zb207XG4gICAgdmFyIHNpbm9tO1xuICAgIHZhciBzY2FsZTA7XG4gICAgdmFyIHNjYWxlMTtcbiAgICBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7XG5cbiAgICBpZiAoY29zb20gPCAwLjApIHtcbiAgICAgIGNvc29tID0gLWNvc29tO1xuICAgICAgYnggPSAtYng7XG4gICAgICBieSA9IC1ieTtcbiAgICAgIGJ6ID0gLWJ6O1xuICAgICAgYncgPSAtYnc7XG4gICAgfVxuXG4gICAgaWYgKDEuMCAtIGNvc29tID4gMC4wMDAwMDEpIHtcbiAgICAgIG9tZWdhID0gTWF0aC5hY29zKGNvc29tKTtcbiAgICAgIHNpbm9tID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgICAgc2NhbGUwID0gTWF0aC5zaW4oKDEuMCAtIHQpICogb21lZ2EpIC8gc2lub207XG4gICAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7XG4gICAgICBzY2FsZTEgPSB0O1xuICAgIH1cblxuICAgIG91dFswXSA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XG4gICAgb3V0WzFdID0gc2NhbGUwICogYXkgKyBzY2FsZTEgKiBieTtcbiAgICBvdXRbMl0gPSBzY2FsZTAgKiBheiArIHNjYWxlMSAqIGJ6O1xuICAgIG91dFszXSA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1YXRlcm5pb25Ub0V1bGVyKG91dCwgcXVhdCkge1xuICAgIHZhciBxeCA9IHF1YXRbMF07XG4gICAgdmFyIHF5ID0gcXVhdFsxXTtcbiAgICB2YXIgcXogPSBxdWF0WzJdO1xuICAgIHZhciBxdyA9IHF1YXRbM107XG4gICAgdmFyIGhlYWRpbmcgPSBNYXRoLmF0YW4yKDIgKiBxeSAqIHF3IC0gMiAqIHF4ICogcXosIDEgLSAyICogcXkgKiBxeSAtIDIgKiBxeiAqIHF6KTtcbiAgICB2YXIgYXR0aXR1ZGUgPSBNYXRoLmFzaW4oMiAqIHF4ICogcXkgKyAyICogcXogKiBxdyk7XG4gICAgdmFyIGJhbmsgPSBNYXRoLmF0YW4yKDIgKiBxeCAqIHF3IC0gMiAqIHF5ICogcXosIDEgLSAyICogcXggKiBxeCAtIDIgKiBxeiAqIHF6KTtcbiAgICBvdXRbMF0gPSBoZWFkaW5nIC8gZGVnVG9SYWRzO1xuICAgIG91dFsxXSA9IGF0dGl0dWRlIC8gZGVnVG9SYWRzO1xuICAgIG91dFsyXSA9IGJhbmsgLyBkZWdUb1JhZHM7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVRdWF0ZXJuaW9uKHZhbHVlcykge1xuICAgIHZhciBoZWFkaW5nID0gdmFsdWVzWzBdICogZGVnVG9SYWRzO1xuICAgIHZhciBhdHRpdHVkZSA9IHZhbHVlc1sxXSAqIGRlZ1RvUmFkcztcbiAgICB2YXIgYmFuayA9IHZhbHVlc1syXSAqIGRlZ1RvUmFkcztcbiAgICB2YXIgYzEgPSBNYXRoLmNvcyhoZWFkaW5nIC8gMik7XG4gICAgdmFyIGMyID0gTWF0aC5jb3MoYXR0aXR1ZGUgLyAyKTtcbiAgICB2YXIgYzMgPSBNYXRoLmNvcyhiYW5rIC8gMik7XG4gICAgdmFyIHMxID0gTWF0aC5zaW4oaGVhZGluZyAvIDIpO1xuICAgIHZhciBzMiA9IE1hdGguc2luKGF0dGl0dWRlIC8gMik7XG4gICAgdmFyIHMzID0gTWF0aC5zaW4oYmFuayAvIDIpO1xuICAgIHZhciB3ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuICAgIHZhciB4ID0gczEgKiBzMiAqIGMzICsgYzEgKiBjMiAqIHMzO1xuICAgIHZhciB5ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgIHZhciB6ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgIHJldHVybiBbeCwgeSwgeiwgd107XG4gIH1cblxuICBmdW5jdGlvbiBnZXRWYWx1ZUF0Q3VycmVudFRpbWUoKSB7XG4gICAgdmFyIGZyYW1lTnVtID0gdGhpcy5jb21wLnJlbmRlcmVkRnJhbWUgLSB0aGlzLm9mZnNldFRpbWU7XG4gICAgdmFyIGluaXRUaW1lID0gdGhpcy5rZXlmcmFtZXNbMF0udCAtIHRoaXMub2Zmc2V0VGltZTtcbiAgICB2YXIgZW5kVGltZSA9IHRoaXMua2V5ZnJhbWVzW3RoaXMua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQgLSB0aGlzLm9mZnNldFRpbWU7XG5cbiAgICBpZiAoIShmcmFtZU51bSA9PT0gdGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgfHwgdGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgIT09IGluaXRGcmFtZSAmJiAodGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgPj0gZW5kVGltZSAmJiBmcmFtZU51bSA+PSBlbmRUaW1lIHx8IHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lIDwgaW5pdFRpbWUgJiYgZnJhbWVOdW0gPCBpbml0VGltZSkpKSB7XG4gICAgICBpZiAodGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgPj0gZnJhbWVOdW0pIHtcbiAgICAgICAgdGhpcy5fY2FjaGluZy5fbGFzdEtleWZyYW1lSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5fY2FjaGluZy5sYXN0SW5kZXggPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVuZGVyUmVzdWx0ID0gdGhpcy5pbnRlcnBvbGF0ZVZhbHVlKGZyYW1lTnVtLCB0aGlzLl9jYWNoaW5nKTtcbiAgICAgIHRoaXMucHYgPSByZW5kZXJSZXN1bHQ7XG4gICAgfVxuXG4gICAgdGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgPSBmcmFtZU51bTtcbiAgICByZXR1cm4gdGhpcy5wdjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFZWYWx1ZSh2YWwpIHtcbiAgICB2YXIgbXVsdGlwbGllZFZhbHVlO1xuXG4gICAgaWYgKHRoaXMucHJvcFR5cGUgPT09ICd1bmlkaW1lbnNpb25hbCcpIHtcbiAgICAgIG11bHRpcGxpZWRWYWx1ZSA9IHZhbCAqIHRoaXMubXVsdDtcblxuICAgICAgaWYgKG1hdGhBYnModGhpcy52IC0gbXVsdGlwbGllZFZhbHVlKSA+IDAuMDAwMDEpIHtcbiAgICAgICAgdGhpcy52ID0gbXVsdGlwbGllZFZhbHVlO1xuICAgICAgICB0aGlzLl9tZGYgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gdGhpcy52Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgbXVsdGlwbGllZFZhbHVlID0gdmFsW2ldICogdGhpcy5tdWx0O1xuXG4gICAgICAgIGlmIChtYXRoQWJzKHRoaXMudltpXSAtIG11bHRpcGxpZWRWYWx1ZSkgPiAwLjAwMDAxKSB7XG4gICAgICAgICAgdGhpcy52W2ldID0gbXVsdGlwbGllZFZhbHVlO1xuICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZSgpIHtcbiAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkIHx8ICF0aGlzLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sb2NrKSB7XG4gICAgICB0aGlzLnNldFZWYWx1ZSh0aGlzLnB2KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmxvY2sgPSB0cnVlO1xuICAgIHRoaXMuX21kZiA9IHRoaXMuX2lzRmlyc3RGcmFtZTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoO1xuICAgIHZhciBmaW5hbFZhbHVlID0gdGhpcy5rZiA/IHRoaXMucHYgOiB0aGlzLmRhdGEuaztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgZmluYWxWYWx1ZSA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlW2ldKGZpbmFsVmFsdWUpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0VlZhbHVlKGZpbmFsVmFsdWUpO1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IGZhbHNlO1xuICAgIHRoaXMubG9jayA9IGZhbHNlO1xuICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRFZmZlY3QoZWZmZWN0RnVuY3Rpb24pIHtcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZS5wdXNoKGVmZmVjdEZ1bmN0aW9uKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hZGREeW5hbWljUHJvcGVydHkodGhpcyk7XG4gIH1cblxuICBmdW5jdGlvbiBWYWx1ZVByb3BlcnR5KGVsZW0sIGRhdGEsIG11bHQsIGNvbnRhaW5lcikge1xuICAgIHRoaXMucHJvcFR5cGUgPSAndW5pZGltZW5zaW9uYWwnO1xuICAgIHRoaXMubXVsdCA9IG11bHQgfHwgMTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMudiA9IG11bHQgPyBkYXRhLmsgKiBtdWx0IDogZGF0YS5rO1xuICAgIHRoaXMucHYgPSBkYXRhLms7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XG4gICAgdGhpcy5rID0gZmFsc2U7XG4gICAgdGhpcy5rZiA9IGZhbHNlO1xuICAgIHRoaXMudmVsID0gMDtcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtdO1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHByb2Nlc3NFZmZlY3RzU2VxdWVuY2U7XG4gICAgdGhpcy5zZXRWVmFsdWUgPSBzZXRWVmFsdWU7XG4gICAgdGhpcy5hZGRFZmZlY3QgPSBhZGRFZmZlY3Q7XG4gIH1cblxuICBmdW5jdGlvbiBNdWx0aURpbWVuc2lvbmFsUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wcm9wVHlwZSA9ICdtdWx0aWRpbWVuc2lvbmFsJztcbiAgICB0aGlzLm11bHQgPSBtdWx0IHx8IDE7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICB0aGlzLmtmID0gZmFsc2U7XG4gICAgdGhpcy5mcmFtZUlkID0gLTE7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGRhdGEuay5sZW5ndGg7XG4gICAgdGhpcy52ID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG4gICAgdGhpcy5wdiA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuICAgIHRoaXMudmVsID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMudltpXSA9IGRhdGEua1tpXSAqIHRoaXMubXVsdDtcbiAgICAgIHRoaXMucHZbaV0gPSBkYXRhLmtbaV07XG4gICAgfVxuXG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtdO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSBwcm9jZXNzRWZmZWN0c1NlcXVlbmNlO1xuICAgIHRoaXMuc2V0VlZhbHVlID0gc2V0VlZhbHVlO1xuICAgIHRoaXMuYWRkRWZmZWN0ID0gYWRkRWZmZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gS2V5ZnJhbWVkVmFsdWVQcm9wZXJ0eShlbGVtLCBkYXRhLCBtdWx0LCBjb250YWluZXIpIHtcbiAgICB0aGlzLnByb3BUeXBlID0gJ3VuaWRpbWVuc2lvbmFsJztcbiAgICB0aGlzLmtleWZyYW1lcyA9IGRhdGEuaztcbiAgICB0aGlzLmtleWZyYW1lc01ldGFkYXRhID0gW107XG4gICAgdGhpcy5vZmZzZXRUaW1lID0gZWxlbS5kYXRhLnN0O1xuICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xuICAgIHRoaXMuX2NhY2hpbmcgPSB7XG4gICAgICBsYXN0RnJhbWU6IGluaXRGcmFtZSxcbiAgICAgIGxhc3RJbmRleDogMCxcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgX2xhc3RLZXlmcmFtZUluZGV4OiAtMVxuICAgIH07XG4gICAgdGhpcy5rID0gdHJ1ZTtcbiAgICB0aGlzLmtmID0gdHJ1ZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMubXVsdCA9IG11bHQgfHwgMTtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICB0aGlzLnYgPSBpbml0RnJhbWU7XG4gICAgdGhpcy5wdiA9IGluaXRGcmFtZTtcbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSBwcm9jZXNzRWZmZWN0c1NlcXVlbmNlO1xuICAgIHRoaXMuc2V0VlZhbHVlID0gc2V0VlZhbHVlO1xuICAgIHRoaXMuaW50ZXJwb2xhdGVWYWx1ZSA9IGludGVycG9sYXRlVmFsdWU7XG4gICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UgPSBbZ2V0VmFsdWVBdEN1cnJlbnRUaW1lLmJpbmQodGhpcyldO1xuICAgIHRoaXMuYWRkRWZmZWN0ID0gYWRkRWZmZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gS2V5ZnJhbWVkTXVsdGlkaW1lbnNpb25hbFByb3BlcnR5KGVsZW0sIGRhdGEsIG11bHQsIGNvbnRhaW5lcikge1xuICAgIHRoaXMucHJvcFR5cGUgPSAnbXVsdGlkaW1lbnNpb25hbCc7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGRhdGEuay5sZW5ndGg7XG4gICAgdmFyIHM7XG4gICAgdmFyIGU7XG4gICAgdmFyIHRvO1xuICAgIHZhciB0aTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpICs9IDEpIHtcbiAgICAgIGlmIChkYXRhLmtbaV0udG8gJiYgZGF0YS5rW2ldLnMgJiYgZGF0YS5rW2kgKyAxXSAmJiBkYXRhLmtbaSArIDFdLnMpIHtcbiAgICAgICAgcyA9IGRhdGEua1tpXS5zO1xuICAgICAgICBlID0gZGF0YS5rW2kgKyAxXS5zO1xuICAgICAgICB0byA9IGRhdGEua1tpXS50bztcbiAgICAgICAgdGkgPSBkYXRhLmtbaV0udGk7XG5cbiAgICAgICAgaWYgKHMubGVuZ3RoID09PSAyICYmICEoc1swXSA9PT0gZVswXSAmJiBzWzFdID09PSBlWzFdKSAmJiBiZXoucG9pbnRPbkxpbmUyRChzWzBdLCBzWzFdLCBlWzBdLCBlWzFdLCBzWzBdICsgdG9bMF0sIHNbMV0gKyB0b1sxXSkgJiYgYmV6LnBvaW50T25MaW5lMkQoc1swXSwgc1sxXSwgZVswXSwgZVsxXSwgZVswXSArIHRpWzBdLCBlWzFdICsgdGlbMV0pIHx8IHMubGVuZ3RoID09PSAzICYmICEoc1swXSA9PT0gZVswXSAmJiBzWzFdID09PSBlWzFdICYmIHNbMl0gPT09IGVbMl0pICYmIGJlei5wb2ludE9uTGluZTNEKHNbMF0sIHNbMV0sIHNbMl0sIGVbMF0sIGVbMV0sIGVbMl0sIHNbMF0gKyB0b1swXSwgc1sxXSArIHRvWzFdLCBzWzJdICsgdG9bMl0pICYmIGJlei5wb2ludE9uTGluZTNEKHNbMF0sIHNbMV0sIHNbMl0sIGVbMF0sIGVbMV0sIGVbMl0sIGVbMF0gKyB0aVswXSwgZVsxXSArIHRpWzFdLCBlWzJdICsgdGlbMl0pKSB7XG4gICAgICAgICAgZGF0YS5rW2ldLnRvID0gbnVsbDtcbiAgICAgICAgICBkYXRhLmtbaV0udGkgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNbMF0gPT09IGVbMF0gJiYgc1sxXSA9PT0gZVsxXSAmJiB0b1swXSA9PT0gMCAmJiB0b1sxXSA9PT0gMCAmJiB0aVswXSA9PT0gMCAmJiB0aVsxXSA9PT0gMCkge1xuICAgICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMiB8fCBzWzJdID09PSBlWzJdICYmIHRvWzJdID09PSAwICYmIHRpWzJdID09PSAwKSB7XG4gICAgICAgICAgICBkYXRhLmtbaV0udG8gPSBudWxsO1xuICAgICAgICAgICAgZGF0YS5rW2ldLnRpID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtnZXRWYWx1ZUF0Q3VycmVudFRpbWUuYmluZCh0aGlzKV07XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmtleWZyYW1lcyA9IGRhdGEuaztcbiAgICB0aGlzLmtleWZyYW1lc01ldGFkYXRhID0gW107XG4gICAgdGhpcy5vZmZzZXRUaW1lID0gZWxlbS5kYXRhLnN0O1xuICAgIHRoaXMuayA9IHRydWU7XG4gICAgdGhpcy5rZiA9IHRydWU7XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICB0aGlzLm11bHQgPSBtdWx0IHx8IDE7XG4gICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHByb2Nlc3NFZmZlY3RzU2VxdWVuY2U7XG4gICAgdGhpcy5zZXRWVmFsdWUgPSBzZXRWVmFsdWU7XG4gICAgdGhpcy5pbnRlcnBvbGF0ZVZhbHVlID0gaW50ZXJwb2xhdGVWYWx1ZTtcbiAgICB0aGlzLmZyYW1lSWQgPSAtMTtcbiAgICB2YXIgYXJyTGVuID0gZGF0YS5rWzBdLnMubGVuZ3RoO1xuICAgIHRoaXMudiA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBhcnJMZW4pO1xuICAgIHRoaXMucHYgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgYXJyTGVuKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBhcnJMZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy52W2ldID0gaW5pdEZyYW1lO1xuICAgICAgdGhpcy5wdltpXSA9IGluaXRGcmFtZTtcbiAgICB9XG5cbiAgICB0aGlzLl9jYWNoaW5nID0ge1xuICAgICAgbGFzdEZyYW1lOiBpbml0RnJhbWUsXG4gICAgICBsYXN0SW5kZXg6IDAsXG4gICAgICB2YWx1ZTogY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGFyckxlbilcbiAgICB9O1xuICAgIHRoaXMuYWRkRWZmZWN0ID0gYWRkRWZmZWN0O1xuICB9XG5cbiAgdmFyIFByb3BlcnR5RmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBnZXRQcm9wKGVsZW0sIGRhdGEsIHR5cGUsIG11bHQsIGNvbnRhaW5lcikge1xuICAgICAgaWYgKGRhdGEuc2lkKSB7XG4gICAgICAgIGRhdGEgPSBlbGVtLmdsb2JhbERhdGEuc2xvdE1hbmFnZXIuZ2V0UHJvcChkYXRhKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHA7XG5cbiAgICAgIGlmICghZGF0YS5rLmxlbmd0aCkge1xuICAgICAgICBwID0gbmV3IFZhbHVlUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEua1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcCA9IG5ldyBNdWx0aURpbWVuc2lvbmFsUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHAgPSBuZXcgS2V5ZnJhbWVkVmFsdWVQcm9wZXJ0eShlbGVtLCBkYXRhLCBtdWx0LCBjb250YWluZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBwID0gbmV3IEtleWZyYW1lZE11bHRpZGltZW5zaW9uYWxQcm9wZXJ0eShlbGVtLCBkYXRhLCBtdWx0LCBjb250YWluZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHAuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICBjb250YWluZXIuYWRkRHluYW1pY1Byb3BlcnR5KHApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICB2YXIgb2IgPSB7XG4gICAgICBnZXRQcm9wOiBnZXRQcm9wXG4gICAgfTtcbiAgICByZXR1cm4gb2I7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBEeW5hbWljUHJvcGVydHlDb250YWluZXIoKSB7fVxuXG4gIER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lci5wcm90b3R5cGUgPSB7XG4gICAgYWRkRHluYW1pY1Byb3BlcnR5OiBmdW5jdGlvbiBhZGREeW5hbWljUHJvcGVydHkocHJvcCkge1xuICAgICAgaWYgKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGREeW5hbWljUHJvcGVydHkodGhpcyk7XG4gICAgICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzOiBmdW5jdGlvbiBpdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKSB7XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllc1tpXS5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLl9tZGYpIHtcbiAgICAgICAgICB0aGlzLl9tZGYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBpbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyOiBmdW5jdGlvbiBpbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gW107XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBvaW50UG9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIDIpO1xuICAgIH1cblxuICAgIHJldHVybiBwb29sRmFjdG9yeSg4LCBjcmVhdGUpO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gU2hhcGVQYXRoKCkge1xuICAgIHRoaXMuYyA9IGZhbHNlO1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gODtcbiAgICB0aGlzLnYgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMuX21heExlbmd0aCk7XG4gICAgdGhpcy5vID0gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpO1xuICAgIHRoaXMuaSA9IGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKTtcbiAgfVxuXG4gIFNoYXBlUGF0aC5wcm90b3R5cGUuc2V0UGF0aERhdGEgPSBmdW5jdGlvbiAoY2xvc2VkLCBsZW4pIHtcbiAgICB0aGlzLmMgPSBjbG9zZWQ7XG4gICAgdGhpcy5zZXRMZW5ndGgobGVuKTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgdGhpcy52W2ldID0gcG9pbnRQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgIHRoaXMub1tpXSA9IHBvaW50UG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICB0aGlzLmlbaV0gPSBwb2ludFBvb2wubmV3RWxlbWVudCgpO1xuICAgICAgaSArPSAxO1xuICAgIH1cbiAgfTtcblxuICBTaGFwZVBhdGgucHJvdG90eXBlLnNldExlbmd0aCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgICB3aGlsZSAodGhpcy5fbWF4TGVuZ3RoIDwgbGVuKSB7XG4gICAgICB0aGlzLmRvdWJsZUFycmF5TGVuZ3RoKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xuICB9O1xuXG4gIFNoYXBlUGF0aC5wcm90b3R5cGUuZG91YmxlQXJyYXlMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy52ID0gdGhpcy52LmNvbmNhdChjcmVhdGVTaXplZEFycmF5KHRoaXMuX21heExlbmd0aCkpO1xuICAgIHRoaXMuaSA9IHRoaXMuaS5jb25jYXQoY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpKTtcbiAgICB0aGlzLm8gPSB0aGlzLm8uY29uY2F0KGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKSk7XG4gICAgdGhpcy5fbWF4TGVuZ3RoICo9IDI7XG4gIH07XG5cbiAgU2hhcGVQYXRoLnByb3RvdHlwZS5zZXRYWUF0ID0gZnVuY3Rpb24gKHgsIHksIHR5cGUsIHBvcywgcmVwbGFjZSkge1xuICAgIHZhciBhcnI7XG4gICAgdGhpcy5fbGVuZ3RoID0gTWF0aC5tYXgodGhpcy5fbGVuZ3RoLCBwb3MgKyAxKTtcblxuICAgIGlmICh0aGlzLl9sZW5ndGggPj0gdGhpcy5fbWF4TGVuZ3RoKSB7XG4gICAgICB0aGlzLmRvdWJsZUFycmF5TGVuZ3RoKCk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICd2JzpcbiAgICAgICAgYXJyID0gdGhpcy52O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaSc6XG4gICAgICAgIGFyciA9IHRoaXMuaTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ28nOlxuICAgICAgICBhcnIgPSB0aGlzLm87XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcnIgPSBbXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKCFhcnJbcG9zXSB8fCBhcnJbcG9zXSAmJiAhcmVwbGFjZSkge1xuICAgICAgYXJyW3Bvc10gPSBwb2ludFBvb2wubmV3RWxlbWVudCgpO1xuICAgIH1cblxuICAgIGFycltwb3NdWzBdID0geDtcbiAgICBhcnJbcG9zXVsxXSA9IHk7XG4gIH07XG5cbiAgU2hhcGVQYXRoLnByb3RvdHlwZS5zZXRUcmlwbGVBdCA9IGZ1bmN0aW9uICh2WCwgdlksIG9YLCBvWSwgaVgsIGlZLCBwb3MsIHJlcGxhY2UpIHtcbiAgICB0aGlzLnNldFhZQXQodlgsIHZZLCAndicsIHBvcywgcmVwbGFjZSk7XG4gICAgdGhpcy5zZXRYWUF0KG9YLCBvWSwgJ28nLCBwb3MsIHJlcGxhY2UpO1xuICAgIHRoaXMuc2V0WFlBdChpWCwgaVksICdpJywgcG9zLCByZXBsYWNlKTtcbiAgfTtcblxuICBTaGFwZVBhdGgucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5ld1BhdGggPSBuZXcgU2hhcGVQYXRoKCk7XG4gICAgbmV3UGF0aC5zZXRQYXRoRGF0YSh0aGlzLmMsIHRoaXMuX2xlbmd0aCk7XG4gICAgdmFyIHZlcnRpY2VzID0gdGhpcy52O1xuICAgIHZhciBvdXRQb2ludHMgPSB0aGlzLm87XG4gICAgdmFyIGluUG9pbnRzID0gdGhpcy5pO1xuICAgIHZhciBpbml0ID0gMDtcblxuICAgIGlmICh0aGlzLmMpIHtcbiAgICAgIG5ld1BhdGguc2V0VHJpcGxlQXQodmVydGljZXNbMF1bMF0sIHZlcnRpY2VzWzBdWzFdLCBpblBvaW50c1swXVswXSwgaW5Qb2ludHNbMF1bMV0sIG91dFBvaW50c1swXVswXSwgb3V0UG9pbnRzWzBdWzFdLCAwLCBmYWxzZSk7XG4gICAgICBpbml0ID0gMTtcbiAgICB9XG5cbiAgICB2YXIgY250ID0gdGhpcy5fbGVuZ3RoIC0gMTtcbiAgICB2YXIgbGVuID0gdGhpcy5fbGVuZ3RoO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gaW5pdDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBuZXdQYXRoLnNldFRyaXBsZUF0KHZlcnRpY2VzW2NudF1bMF0sIHZlcnRpY2VzW2NudF1bMV0sIGluUG9pbnRzW2NudF1bMF0sIGluUG9pbnRzW2NudF1bMV0sIG91dFBvaW50c1tjbnRdWzBdLCBvdXRQb2ludHNbY250XVsxXSwgaSwgZmFsc2UpO1xuICAgICAgY250IC09IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1BhdGg7XG4gIH07XG5cbiAgU2hhcGVQYXRoLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgfTtcblxuICB2YXIgc2hhcGVQb29sID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHJldHVybiBuZXcgU2hhcGVQYXRoKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVsZWFzZShzaGFwZVBhdGgpIHtcbiAgICAgIHZhciBsZW4gPSBzaGFwZVBhdGguX2xlbmd0aDtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcG9pbnRQb29sLnJlbGVhc2Uoc2hhcGVQYXRoLnZbaV0pO1xuICAgICAgICBwb2ludFBvb2wucmVsZWFzZShzaGFwZVBhdGguaVtpXSk7XG4gICAgICAgIHBvaW50UG9vbC5yZWxlYXNlKHNoYXBlUGF0aC5vW2ldKTtcbiAgICAgICAgc2hhcGVQYXRoLnZbaV0gPSBudWxsO1xuICAgICAgICBzaGFwZVBhdGguaVtpXSA9IG51bGw7XG4gICAgICAgIHNoYXBlUGF0aC5vW2ldID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc2hhcGVQYXRoLl9sZW5ndGggPSAwO1xuICAgICAgc2hhcGVQYXRoLmMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZShzaGFwZSkge1xuICAgICAgdmFyIGNsb25lZCA9IGZhY3RvcnkubmV3RWxlbWVudCgpO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc2hhcGUuX2xlbmd0aCA9PT0gdW5kZWZpbmVkID8gc2hhcGUudi5sZW5ndGggOiBzaGFwZS5fbGVuZ3RoO1xuICAgICAgY2xvbmVkLnNldExlbmd0aChsZW4pO1xuICAgICAgY2xvbmVkLmMgPSBzaGFwZS5jO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgY2xvbmVkLnNldFRyaXBsZUF0KHNoYXBlLnZbaV1bMF0sIHNoYXBlLnZbaV1bMV0sIHNoYXBlLm9baV1bMF0sIHNoYXBlLm9baV1bMV0sIHNoYXBlLmlbaV1bMF0sIHNoYXBlLmlbaV1bMV0sIGkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH1cblxuICAgIHZhciBmYWN0b3J5ID0gcG9vbEZhY3RvcnkoNCwgY3JlYXRlLCByZWxlYXNlKTtcbiAgICBmYWN0b3J5LmNsb25lID0gY2xvbmU7XG4gICAgcmV0dXJuIGZhY3Rvcnk7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBTaGFwZUNvbGxlY3Rpb24oKSB7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXhMZW5ndGggPSA0O1xuICAgIHRoaXMuc2hhcGVzID0gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpO1xuICB9XG5cbiAgU2hhcGVDb2xsZWN0aW9uLnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uIChzaGFwZURhdGEpIHtcbiAgICBpZiAodGhpcy5fbGVuZ3RoID09PSB0aGlzLl9tYXhMZW5ndGgpIHtcbiAgICAgIHRoaXMuc2hhcGVzID0gdGhpcy5zaGFwZXMuY29uY2F0KGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKSk7XG4gICAgICB0aGlzLl9tYXhMZW5ndGggKj0gMjtcbiAgICB9XG5cbiAgICB0aGlzLnNoYXBlc1t0aGlzLl9sZW5ndGhdID0gc2hhcGVEYXRhO1xuICAgIHRoaXMuX2xlbmd0aCArPSAxO1xuICB9O1xuXG4gIFNoYXBlQ29sbGVjdGlvbi5wcm90b3R5cGUucmVsZWFzZVNoYXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgc2hhcGVQb29sLnJlbGVhc2UodGhpcy5zaGFwZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gIH07XG5cbiAgdmFyIHNoYXBlQ29sbGVjdGlvblBvb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iID0ge1xuICAgICAgbmV3U2hhcGVDb2xsZWN0aW9uOiBuZXdTaGFwZUNvbGxlY3Rpb24sXG4gICAgICByZWxlYXNlOiByZWxlYXNlXG4gICAgfTtcbiAgICB2YXIgX2xlbmd0aCA9IDA7XG4gICAgdmFyIF9tYXhMZW5ndGggPSA0O1xuICAgIHZhciBwb29sID0gY3JlYXRlU2l6ZWRBcnJheShfbWF4TGVuZ3RoKTtcblxuICAgIGZ1bmN0aW9uIG5ld1NoYXBlQ29sbGVjdGlvbigpIHtcbiAgICAgIHZhciBzaGFwZUNvbGxlY3Rpb247XG5cbiAgICAgIGlmIChfbGVuZ3RoKSB7XG4gICAgICAgIF9sZW5ndGggLT0gMTtcbiAgICAgICAgc2hhcGVDb2xsZWN0aW9uID0gcG9vbFtfbGVuZ3RoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNoYXBlQ29sbGVjdGlvbiA9IG5ldyBTaGFwZUNvbGxlY3Rpb24oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNoYXBlQ29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxlYXNlKHNoYXBlQ29sbGVjdGlvbikge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc2hhcGVDb2xsZWN0aW9uLl9sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBzaGFwZVBvb2wucmVsZWFzZShzaGFwZUNvbGxlY3Rpb24uc2hhcGVzW2ldKTtcbiAgICAgIH1cblxuICAgICAgc2hhcGVDb2xsZWN0aW9uLl9sZW5ndGggPSAwO1xuXG4gICAgICBpZiAoX2xlbmd0aCA9PT0gX21heExlbmd0aCkge1xuICAgICAgICBwb29sID0gcG9vbGluZ1tcImRvdWJsZVwiXShwb29sKTtcbiAgICAgICAgX21heExlbmd0aCAqPSAyO1xuICAgICAgfVxuXG4gICAgICBwb29sW19sZW5ndGhdID0gc2hhcGVDb2xsZWN0aW9uO1xuICAgICAgX2xlbmd0aCArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIHZhciBTaGFwZVByb3BlcnR5RmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5pdEZyYW1lID0gLTk5OTk5OTtcblxuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlU2hhcGUoZnJhbWVOdW0sIHByZXZpb3VzVmFsdWUsIGNhY2hpbmcpIHtcbiAgICAgIHZhciBpdGVyYXRpb25JbmRleCA9IGNhY2hpbmcubGFzdEluZGV4O1xuICAgICAgdmFyIGtleVByb3BTO1xuICAgICAgdmFyIGtleVByb3BFO1xuICAgICAgdmFyIGlzSG9sZDtcbiAgICAgIHZhciBqO1xuICAgICAgdmFyIGs7XG4gICAgICB2YXIgakxlbjtcbiAgICAgIHZhciBrTGVuO1xuICAgICAgdmFyIHBlcmM7XG4gICAgICB2YXIgdmVydGV4VmFsdWU7XG4gICAgICB2YXIga2YgPSB0aGlzLmtleWZyYW1lcztcblxuICAgICAgaWYgKGZyYW1lTnVtIDwga2ZbMF0udCAtIHRoaXMub2Zmc2V0VGltZSkge1xuICAgICAgICBrZXlQcm9wUyA9IGtmWzBdLnNbMF07XG4gICAgICAgIGlzSG9sZCA9IHRydWU7XG4gICAgICAgIGl0ZXJhdGlvbkluZGV4ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoZnJhbWVOdW0gPj0ga2Zba2YubGVuZ3RoIC0gMV0udCAtIHRoaXMub2Zmc2V0VGltZSkge1xuICAgICAgICBrZXlQcm9wUyA9IGtmW2tmLmxlbmd0aCAtIDFdLnMgPyBrZltrZi5sZW5ndGggLSAxXS5zWzBdIDoga2Zba2YubGVuZ3RoIC0gMl0uZVswXTtcbiAgICAgICAgLyogaWYoa2Zba2YubGVuZ3RoIC0gMV0ucyl7XHJcbiAgICAgICAgICAgICAgICAgIGtleVByb3BTID0ga2Zba2YubGVuZ3RoIC0gMV0uc1swXTtcclxuICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAga2V5UHJvcFMgPSBrZltrZi5sZW5ndGggLSAyXS5lWzBdO1xyXG4gICAgICAgICAgICAgIH0gKi9cblxuICAgICAgICBpc0hvbGQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSBpdGVyYXRpb25JbmRleDtcbiAgICAgICAgdmFyIGxlbiA9IGtmLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBmbGFnID0gdHJ1ZTtcbiAgICAgICAgdmFyIGtleURhdGE7XG4gICAgICAgIHZhciBuZXh0S2V5RGF0YTtcbiAgICAgICAgdmFyIGtleWZyYW1lTWV0YWRhdGE7XG5cbiAgICAgICAgd2hpbGUgKGZsYWcpIHtcbiAgICAgICAgICBrZXlEYXRhID0ga2ZbaV07XG4gICAgICAgICAgbmV4dEtleURhdGEgPSBrZltpICsgMV07XG5cbiAgICAgICAgICBpZiAobmV4dEtleURhdGEudCAtIHRoaXMub2Zmc2V0VGltZSA+IGZyYW1lTnVtKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA8IGxlbiAtIDEpIHtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGtleWZyYW1lTWV0YWRhdGEgPSB0aGlzLmtleWZyYW1lc01ldGFkYXRhW2ldIHx8IHt9O1xuICAgICAgICBpc0hvbGQgPSBrZXlEYXRhLmggPT09IDE7XG4gICAgICAgIGl0ZXJhdGlvbkluZGV4ID0gaTtcblxuICAgICAgICBpZiAoIWlzSG9sZCkge1xuICAgICAgICAgIGlmIChmcmFtZU51bSA+PSBuZXh0S2V5RGF0YS50IC0gdGhpcy5vZmZzZXRUaW1lKSB7XG4gICAgICAgICAgICBwZXJjID0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lTnVtIDwga2V5RGF0YS50IC0gdGhpcy5vZmZzZXRUaW1lKSB7XG4gICAgICAgICAgICBwZXJjID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZuYztcblxuICAgICAgICAgICAgaWYgKGtleWZyYW1lTWV0YWRhdGEuX19mbmN0KSB7XG4gICAgICAgICAgICAgIGZuYyA9IGtleWZyYW1lTWV0YWRhdGEuX19mbmN0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm5jID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcoa2V5RGF0YS5vLngsIGtleURhdGEuby55LCBrZXlEYXRhLmkueCwga2V5RGF0YS5pLnkpLmdldDtcbiAgICAgICAgICAgICAga2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3QgPSBmbmM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBlcmMgPSBmbmMoKGZyYW1lTnVtIC0gKGtleURhdGEudCAtIHRoaXMub2Zmc2V0VGltZSkpIC8gKG5leHRLZXlEYXRhLnQgLSB0aGlzLm9mZnNldFRpbWUgLSAoa2V5RGF0YS50IC0gdGhpcy5vZmZzZXRUaW1lKSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGtleVByb3BFID0gbmV4dEtleURhdGEucyA/IG5leHRLZXlEYXRhLnNbMF0gOiBrZXlEYXRhLmVbMF07XG4gICAgICAgIH1cblxuICAgICAgICBrZXlQcm9wUyA9IGtleURhdGEuc1swXTtcbiAgICAgIH1cblxuICAgICAgakxlbiA9IHByZXZpb3VzVmFsdWUuX2xlbmd0aDtcbiAgICAgIGtMZW4gPSBrZXlQcm9wUy5pWzBdLmxlbmd0aDtcbiAgICAgIGNhY2hpbmcubGFzdEluZGV4ID0gaXRlcmF0aW9uSW5kZXg7XG5cbiAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGtMZW47IGsgKz0gMSkge1xuICAgICAgICAgIHZlcnRleFZhbHVlID0gaXNIb2xkID8ga2V5UHJvcFMuaVtqXVtrXSA6IGtleVByb3BTLmlbal1ba10gKyAoa2V5UHJvcEUuaVtqXVtrXSAtIGtleVByb3BTLmlbal1ba10pICogcGVyYztcbiAgICAgICAgICBwcmV2aW91c1ZhbHVlLmlbal1ba10gPSB2ZXJ0ZXhWYWx1ZTtcbiAgICAgICAgICB2ZXJ0ZXhWYWx1ZSA9IGlzSG9sZCA/IGtleVByb3BTLm9bal1ba10gOiBrZXlQcm9wUy5vW2pdW2tdICsgKGtleVByb3BFLm9bal1ba10gLSBrZXlQcm9wUy5vW2pdW2tdKSAqIHBlcmM7XG4gICAgICAgICAgcHJldmlvdXNWYWx1ZS5vW2pdW2tdID0gdmVydGV4VmFsdWU7XG4gICAgICAgICAgdmVydGV4VmFsdWUgPSBpc0hvbGQgPyBrZXlQcm9wUy52W2pdW2tdIDoga2V5UHJvcFMudltqXVtrXSArIChrZXlQcm9wRS52W2pdW2tdIC0ga2V5UHJvcFMudltqXVtrXSkgKiBwZXJjO1xuICAgICAgICAgIHByZXZpb3VzVmFsdWUudltqXVtrXSA9IHZlcnRleFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVTaGFwZUN1cnJlbnRUaW1lKCkge1xuICAgICAgdmFyIGZyYW1lTnVtID0gdGhpcy5jb21wLnJlbmRlcmVkRnJhbWUgLSB0aGlzLm9mZnNldFRpbWU7XG4gICAgICB2YXIgaW5pdFRpbWUgPSB0aGlzLmtleWZyYW1lc1swXS50IC0gdGhpcy5vZmZzZXRUaW1lO1xuICAgICAgdmFyIGVuZFRpbWUgPSB0aGlzLmtleWZyYW1lc1t0aGlzLmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC0gdGhpcy5vZmZzZXRUaW1lO1xuICAgICAgdmFyIGxhc3RGcmFtZSA9IHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lO1xuXG4gICAgICBpZiAoIShsYXN0RnJhbWUgIT09IGluaXRGcmFtZSAmJiAobGFzdEZyYW1lIDwgaW5pdFRpbWUgJiYgZnJhbWVOdW0gPCBpbml0VGltZSB8fCBsYXN0RnJhbWUgPiBlbmRUaW1lICYmIGZyYW1lTnVtID4gZW5kVGltZSkpKSB7XG4gICAgICAgIC8vLyAvXG4gICAgICAgIHRoaXMuX2NhY2hpbmcubGFzdEluZGV4ID0gbGFzdEZyYW1lIDwgZnJhbWVOdW0gPyB0aGlzLl9jYWNoaW5nLmxhc3RJbmRleCA6IDA7XG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGVTaGFwZShmcmFtZU51bSwgdGhpcy5wdiwgdGhpcy5fY2FjaGluZyk7IC8vLyAvXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lID0gZnJhbWVOdW07XG4gICAgICByZXR1cm4gdGhpcy5wdjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldFNoYXBlKCkge1xuICAgICAgdGhpcy5wYXRocyA9IHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hhcGVzRXF1YWwoc2hhcGUxLCBzaGFwZTIpIHtcbiAgICAgIGlmIChzaGFwZTEuX2xlbmd0aCAhPT0gc2hhcGUyLl9sZW5ndGggfHwgc2hhcGUxLmMgIT09IHNoYXBlMi5jKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc2hhcGUxLl9sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoc2hhcGUxLnZbaV1bMF0gIT09IHNoYXBlMi52W2ldWzBdIHx8IHNoYXBlMS52W2ldWzFdICE9PSBzaGFwZTIudltpXVsxXSB8fCBzaGFwZTEub1tpXVswXSAhPT0gc2hhcGUyLm9baV1bMF0gfHwgc2hhcGUxLm9baV1bMV0gIT09IHNoYXBlMi5vW2ldWzFdIHx8IHNoYXBlMS5pW2ldWzBdICE9PSBzaGFwZTIuaVtpXVswXSB8fCBzaGFwZTEuaVtpXVsxXSAhPT0gc2hhcGUyLmlbaV1bMV0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VlZhbHVlKG5ld1BhdGgpIHtcbiAgICAgIGlmICghc2hhcGVzRXF1YWwodGhpcy52LCBuZXdQYXRoKSkge1xuICAgICAgICB0aGlzLnYgPSBzaGFwZVBvb2wuY2xvbmUobmV3UGF0aCk7XG4gICAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xuICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uLmFkZFNoYXBlKHRoaXMudik7XG4gICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgIHRoaXMucGF0aHMgPSB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NFZmZlY3RzU2VxdWVuY2UoKSB7XG4gICAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubG9jaykge1xuICAgICAgICB0aGlzLnNldFZWYWx1ZSh0aGlzLnB2KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxvY2sgPSB0cnVlO1xuICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgICB2YXIgZmluYWxWYWx1ZTtcblxuICAgICAgaWYgKHRoaXMua2YpIHtcbiAgICAgICAgZmluYWxWYWx1ZSA9IHRoaXMucHY7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5rcykge1xuICAgICAgICBmaW5hbFZhbHVlID0gdGhpcy5kYXRhLmtzLms7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5hbFZhbHVlID0gdGhpcy5kYXRhLnB0Lms7XG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGZpbmFsVmFsdWUgPSB0aGlzLmVmZmVjdHNTZXF1ZW5jZVtpXShmaW5hbFZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRWVmFsdWUoZmluYWxWYWx1ZSk7XG4gICAgICB0aGlzLmxvY2sgPSBmYWxzZTtcbiAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhLCB0eXBlKSB7XG4gICAgICB0aGlzLnByb3BUeXBlID0gJ3NoYXBlJztcbiAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gZWxlbTtcbiAgICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgdGhpcy5rID0gZmFsc2U7XG4gICAgICB0aGlzLmtmID0gZmFsc2U7XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICAgIHZhciBwYXRoRGF0YSA9IHR5cGUgPT09IDMgPyBkYXRhLnB0LmsgOiBkYXRhLmtzLms7XG4gICAgICB0aGlzLnYgPSBzaGFwZVBvb2wuY2xvbmUocGF0aERhdGEpO1xuICAgICAgdGhpcy5wdiA9IHNoYXBlUG9vbC5jbG9uZSh0aGlzLnYpO1xuICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlQ29sbGVjdGlvblBvb2wubmV3U2hhcGVDb2xsZWN0aW9uKCk7XG4gICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgIHRoaXMucGF0aHMuYWRkU2hhcGUodGhpcy52KTtcbiAgICAgIHRoaXMucmVzZXQgPSByZXNldFNoYXBlO1xuICAgICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UgPSBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRFZmZlY3QoZWZmZWN0RnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlLnB1c2goZWZmZWN0RnVuY3Rpb24pO1xuICAgICAgdGhpcy5jb250YWluZXIuYWRkRHluYW1pY1Byb3BlcnR5KHRoaXMpO1xuICAgIH1cblxuICAgIFNoYXBlUHJvcGVydHkucHJvdG90eXBlLmludGVycG9sYXRlU2hhcGUgPSBpbnRlcnBvbGF0ZVNoYXBlO1xuICAgIFNoYXBlUHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZTtcbiAgICBTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5zZXRWVmFsdWUgPSBzZXRWVmFsdWU7XG4gICAgU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuYWRkRWZmZWN0ID0gYWRkRWZmZWN0O1xuXG4gICAgZnVuY3Rpb24gS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhLCB0eXBlKSB7XG4gICAgICB0aGlzLnByb3BUeXBlID0gJ3NoYXBlJztcbiAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IGVsZW07XG4gICAgICB0aGlzLm9mZnNldFRpbWUgPSBlbGVtLmRhdGEuc3Q7XG4gICAgICB0aGlzLmtleWZyYW1lcyA9IHR5cGUgPT09IDMgPyBkYXRhLnB0LmsgOiBkYXRhLmtzLms7XG4gICAgICB0aGlzLmtleWZyYW1lc01ldGFkYXRhID0gW107XG4gICAgICB0aGlzLmsgPSB0cnVlO1xuICAgICAgdGhpcy5rZiA9IHRydWU7XG4gICAgICB2YXIgbGVuID0gdGhpcy5rZXlmcmFtZXNbMF0uc1swXS5pLmxlbmd0aDtcbiAgICAgIHRoaXMudiA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICB0aGlzLnYuc2V0UGF0aERhdGEodGhpcy5rZXlmcmFtZXNbMF0uc1swXS5jLCBsZW4pO1xuICAgICAgdGhpcy5wdiA9IHNoYXBlUG9vbC5jbG9uZSh0aGlzLnYpO1xuICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlQ29sbGVjdGlvblBvb2wubmV3U2hhcGVDb2xsZWN0aW9uKCk7XG4gICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgIHRoaXMucGF0aHMuYWRkU2hhcGUodGhpcy52KTtcbiAgICAgIHRoaXMubGFzdEZyYW1lID0gaW5pdEZyYW1lO1xuICAgICAgdGhpcy5yZXNldCA9IHJlc2V0U2hhcGU7XG4gICAgICB0aGlzLl9jYWNoaW5nID0ge1xuICAgICAgICBsYXN0RnJhbWU6IGluaXRGcmFtZSxcbiAgICAgICAgbGFzdEluZGV4OiAwXG4gICAgICB9O1xuICAgICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UgPSBbaW50ZXJwb2xhdGVTaGFwZUN1cnJlbnRUaW1lLmJpbmQodGhpcyldO1xuICAgIH1cblxuICAgIEtleWZyYW1lZFNoYXBlUHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZTtcbiAgICBLZXlmcmFtZWRTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5pbnRlcnBvbGF0ZVNoYXBlID0gaW50ZXJwb2xhdGVTaGFwZTtcbiAgICBLZXlmcmFtZWRTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5zZXRWVmFsdWUgPSBzZXRWVmFsdWU7XG4gICAgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuYWRkRWZmZWN0ID0gYWRkRWZmZWN0O1xuXG4gICAgdmFyIEVsbFNoYXBlUHJvcGVydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY1BvaW50ID0gcm91bmRDb3JuZXI7XG5cbiAgICAgIGZ1bmN0aW9uIEVsbFNoYXBlUHJvcGVydHlGYWN0b3J5KGVsZW0sIGRhdGEpIHtcbiAgICAgICAgdGhpcy52ID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgICAgdGhpcy52LnNldFBhdGhEYXRhKHRydWUsIDQpO1xuICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5wYXRocyA9IHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy52KTtcbiAgICAgICAgdGhpcy5kID0gZGF0YS5kO1xuICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XG4gICAgICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xuICAgICAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucCwgMSwgMCwgdGhpcyk7XG4gICAgICAgIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucywgMSwgMCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5rID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbnZlcnRFbGxUb1BhdGgoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBFbGxTaGFwZVByb3BlcnR5RmFjdG9yeS5wcm90b3R5cGUgPSB7XG4gICAgICAgIHJlc2V0OiByZXNldFNoYXBlLFxuICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gICAgICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9tZGYpIHtcbiAgICAgICAgICAgIHRoaXMuY29udmVydEVsbFRvUGF0aCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29udmVydEVsbFRvUGF0aDogZnVuY3Rpb24gY29udmVydEVsbFRvUGF0aCgpIHtcbiAgICAgICAgICB2YXIgcDAgPSB0aGlzLnAudlswXTtcbiAgICAgICAgICB2YXIgcDEgPSB0aGlzLnAudlsxXTtcbiAgICAgICAgICB2YXIgczAgPSB0aGlzLnMudlswXSAvIDI7XG4gICAgICAgICAgdmFyIHMxID0gdGhpcy5zLnZbMV0gLyAyO1xuXG4gICAgICAgICAgdmFyIF9jdyA9IHRoaXMuZCAhPT0gMztcblxuICAgICAgICAgIHZhciBfdiA9IHRoaXMudjtcbiAgICAgICAgICBfdi52WzBdWzBdID0gcDA7XG4gICAgICAgICAgX3YudlswXVsxXSA9IHAxIC0gczE7XG4gICAgICAgICAgX3YudlsxXVswXSA9IF9jdyA/IHAwICsgczAgOiBwMCAtIHMwO1xuICAgICAgICAgIF92LnZbMV1bMV0gPSBwMTtcbiAgICAgICAgICBfdi52WzJdWzBdID0gcDA7XG4gICAgICAgICAgX3YudlsyXVsxXSA9IHAxICsgczE7XG4gICAgICAgICAgX3YudlszXVswXSA9IF9jdyA/IHAwIC0gczAgOiBwMCArIHMwO1xuICAgICAgICAgIF92LnZbM11bMV0gPSBwMTtcbiAgICAgICAgICBfdi5pWzBdWzBdID0gX2N3ID8gcDAgLSBzMCAqIGNQb2ludCA6IHAwICsgczAgKiBjUG9pbnQ7XG4gICAgICAgICAgX3YuaVswXVsxXSA9IHAxIC0gczE7XG4gICAgICAgICAgX3YuaVsxXVswXSA9IF9jdyA/IHAwICsgczAgOiBwMCAtIHMwO1xuICAgICAgICAgIF92LmlbMV1bMV0gPSBwMSAtIHMxICogY1BvaW50O1xuICAgICAgICAgIF92LmlbMl1bMF0gPSBfY3cgPyBwMCArIHMwICogY1BvaW50IDogcDAgLSBzMCAqIGNQb2ludDtcbiAgICAgICAgICBfdi5pWzJdWzFdID0gcDEgKyBzMTtcbiAgICAgICAgICBfdi5pWzNdWzBdID0gX2N3ID8gcDAgLSBzMCA6IHAwICsgczA7XG4gICAgICAgICAgX3YuaVszXVsxXSA9IHAxICsgczEgKiBjUG9pbnQ7XG4gICAgICAgICAgX3Yub1swXVswXSA9IF9jdyA/IHAwICsgczAgKiBjUG9pbnQgOiBwMCAtIHMwICogY1BvaW50O1xuICAgICAgICAgIF92Lm9bMF1bMV0gPSBwMSAtIHMxO1xuICAgICAgICAgIF92Lm9bMV1bMF0gPSBfY3cgPyBwMCArIHMwIDogcDAgLSBzMDtcbiAgICAgICAgICBfdi5vWzFdWzFdID0gcDEgKyBzMSAqIGNQb2ludDtcbiAgICAgICAgICBfdi5vWzJdWzBdID0gX2N3ID8gcDAgLSBzMCAqIGNQb2ludCA6IHAwICsgczAgKiBjUG9pbnQ7XG4gICAgICAgICAgX3Yub1syXVsxXSA9IHAxICsgczE7XG4gICAgICAgICAgX3Yub1szXVswXSA9IF9jdyA/IHAwIC0gczAgOiBwMCArIHMwO1xuICAgICAgICAgIF92Lm9bM11bMV0gPSBwMSAtIHMxICogY1BvaW50O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBFbGxTaGFwZVByb3BlcnR5RmFjdG9yeSk7XG4gICAgICByZXR1cm4gRWxsU2hhcGVQcm9wZXJ0eUZhY3Rvcnk7XG4gICAgfSgpO1xuXG4gICAgdmFyIFN0YXJTaGFwZVByb3BlcnR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3RhclNoYXBlUHJvcGVydHlGYWN0b3J5KGVsZW0sIGRhdGEpIHtcbiAgICAgICAgdGhpcy52ID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgICAgdGhpcy52LnNldFBhdGhEYXRhKHRydWUsIDApO1xuICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xuICAgICAgICB0aGlzLmQgPSBkYXRhLmQ7XG4gICAgICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcblxuICAgICAgICBpZiAoZGF0YS5zeSA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuaXIgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmlyLCAwLCAwLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLmlzID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5pcywgMCwgMC4wMSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5jb252ZXJ0VG9QYXRoID0gdGhpcy5jb252ZXJ0U3RhclRvUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvbnZlcnRUb1BhdGggPSB0aGlzLmNvbnZlcnRQb2x5Z29uVG9QYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wdCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucHQsIDAsIDAsIHRoaXMpO1xuICAgICAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnAsIDEsIDAsIHRoaXMpO1xuICAgICAgICB0aGlzLnIgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnIsIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgICAgIHRoaXMub3IgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm9yLCAwLCAwLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vcyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEub3MsIDAsIDAuMDEsIHRoaXMpO1xuICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnYpO1xuICAgICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcblxuICAgICAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmsgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuayA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuY29udmVydFRvUGF0aCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIFN0YXJTaGFwZVByb3BlcnR5RmFjdG9yeS5wcm90b3R5cGUgPSB7XG4gICAgICAgIHJlc2V0OiByZXNldFNoYXBlLFxuICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gICAgICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9tZGYpIHtcbiAgICAgICAgICAgIHRoaXMuY29udmVydFRvUGF0aCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29udmVydFN0YXJUb1BhdGg6IGZ1bmN0aW9uIGNvbnZlcnRTdGFyVG9QYXRoKCkge1xuICAgICAgICAgIHZhciBudW1QdHMgPSBNYXRoLmZsb29yKHRoaXMucHQudikgKiAyO1xuICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguUEkgKiAyIC8gbnVtUHRzO1xuICAgICAgICAgIC8qIHRoaXMudi52Lmxlbmd0aCA9IG51bVB0cztcclxuICAgICAgICAgICAgICAgICAgdGhpcy52LmkubGVuZ3RoID0gbnVtUHRzO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLnYuby5sZW5ndGggPSBudW1QdHM7ICovXG5cbiAgICAgICAgICB2YXIgbG9uZ0ZsYWcgPSB0cnVlO1xuICAgICAgICAgIHZhciBsb25nUmFkID0gdGhpcy5vci52O1xuICAgICAgICAgIHZhciBzaG9ydFJhZCA9IHRoaXMuaXIudjtcbiAgICAgICAgICB2YXIgbG9uZ1JvdW5kID0gdGhpcy5vcy52O1xuICAgICAgICAgIHZhciBzaG9ydFJvdW5kID0gdGhpcy5pcy52O1xuICAgICAgICAgIHZhciBsb25nUGVyaW1TZWdtZW50ID0gMiAqIE1hdGguUEkgKiBsb25nUmFkIC8gKG51bVB0cyAqIDIpO1xuICAgICAgICAgIHZhciBzaG9ydFBlcmltU2VnbWVudCA9IDIgKiBNYXRoLlBJICogc2hvcnRSYWQgLyAobnVtUHRzICogMik7XG4gICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgdmFyIHJhZDtcbiAgICAgICAgICB2YXIgcm91bmRuZXNzO1xuICAgICAgICAgIHZhciBwZXJpbVNlZ21lbnQ7XG4gICAgICAgICAgdmFyIGN1cnJlbnRBbmcgPSAtTWF0aC5QSSAvIDI7XG4gICAgICAgICAgY3VycmVudEFuZyArPSB0aGlzLnIudjtcbiAgICAgICAgICB2YXIgZGlyID0gdGhpcy5kYXRhLmQgPT09IDMgPyAtMSA6IDE7XG4gICAgICAgICAgdGhpcy52Ll9sZW5ndGggPSAwO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVB0czsgaSArPSAxKSB7XG4gICAgICAgICAgICByYWQgPSBsb25nRmxhZyA/IGxvbmdSYWQgOiBzaG9ydFJhZDtcbiAgICAgICAgICAgIHJvdW5kbmVzcyA9IGxvbmdGbGFnID8gbG9uZ1JvdW5kIDogc2hvcnRSb3VuZDtcbiAgICAgICAgICAgIHBlcmltU2VnbWVudCA9IGxvbmdGbGFnID8gbG9uZ1BlcmltU2VnbWVudCA6IHNob3J0UGVyaW1TZWdtZW50O1xuICAgICAgICAgICAgdmFyIHggPSByYWQgKiBNYXRoLmNvcyhjdXJyZW50QW5nKTtcbiAgICAgICAgICAgIHZhciB5ID0gcmFkICogTWF0aC5zaW4oY3VycmVudEFuZyk7XG4gICAgICAgICAgICB2YXIgb3ggPSB4ID09PSAwICYmIHkgPT09IDAgPyAwIDogeSAvIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgICAgICAgIHZhciBveSA9IHggPT09IDAgJiYgeSA9PT0gMCA/IDAgOiAteCAvIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgICAgICAgIHggKz0gK3RoaXMucC52WzBdO1xuICAgICAgICAgICAgeSArPSArdGhpcy5wLnZbMV07XG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQoeCwgeSwgeCAtIG94ICogcGVyaW1TZWdtZW50ICogcm91bmRuZXNzICogZGlyLCB5IC0gb3kgKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIHggKyBveCAqIHBlcmltU2VnbWVudCAqIHJvdW5kbmVzcyAqIGRpciwgeSArIG95ICogcGVyaW1TZWdtZW50ICogcm91bmRuZXNzICogZGlyLCBpLCB0cnVlKTtcbiAgICAgICAgICAgIC8qIHRoaXMudi52W2ldID0gW3gseV07XHJcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnYuaVtpXSA9IFt4K294KnBlcmltU2VnbWVudCpyb3VuZG5lc3MqZGlyLHkrb3kqcGVyaW1TZWdtZW50KnJvdW5kbmVzcypkaXJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy52Lm9baV0gPSBbeC1veCpwZXJpbVNlZ21lbnQqcm91bmRuZXNzKmRpcix5LW95KnBlcmltU2VnbWVudCpyb3VuZG5lc3MqZGlyXTtcclxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMudi5fbGVuZ3RoID0gbnVtUHRzOyAqL1xuXG4gICAgICAgICAgICBsb25nRmxhZyA9ICFsb25nRmxhZztcbiAgICAgICAgICAgIGN1cnJlbnRBbmcgKz0gYW5nbGUgKiBkaXI7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb252ZXJ0UG9seWdvblRvUGF0aDogZnVuY3Rpb24gY29udmVydFBvbHlnb25Ub1BhdGgoKSB7XG4gICAgICAgICAgdmFyIG51bVB0cyA9IE1hdGguZmxvb3IodGhpcy5wdC52KTtcbiAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLlBJICogMiAvIG51bVB0cztcbiAgICAgICAgICB2YXIgcmFkID0gdGhpcy5vci52O1xuICAgICAgICAgIHZhciByb3VuZG5lc3MgPSB0aGlzLm9zLnY7XG4gICAgICAgICAgdmFyIHBlcmltU2VnbWVudCA9IDIgKiBNYXRoLlBJICogcmFkIC8gKG51bVB0cyAqIDQpO1xuICAgICAgICAgIHZhciBpO1xuICAgICAgICAgIHZhciBjdXJyZW50QW5nID0gLU1hdGguUEkgKiAwLjU7XG4gICAgICAgICAgdmFyIGRpciA9IHRoaXMuZGF0YS5kID09PSAzID8gLTEgOiAxO1xuICAgICAgICAgIGN1cnJlbnRBbmcgKz0gdGhpcy5yLnY7XG4gICAgICAgICAgdGhpcy52Ll9sZW5ndGggPSAwO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVB0czsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHJhZCAqIE1hdGguY29zKGN1cnJlbnRBbmcpO1xuICAgICAgICAgICAgdmFyIHkgPSByYWQgKiBNYXRoLnNpbihjdXJyZW50QW5nKTtcbiAgICAgICAgICAgIHZhciBveCA9IHggPT09IDAgJiYgeSA9PT0gMCA/IDAgOiB5IC8gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICAgICAgdmFyIG95ID0geCA9PT0gMCAmJiB5ID09PSAwID8gMCA6IC14IC8gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICAgICAgeCArPSArdGhpcy5wLnZbMF07XG4gICAgICAgICAgICB5ICs9ICt0aGlzLnAudlsxXTtcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdCh4LCB5LCB4IC0gb3ggKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIHkgLSBveSAqIHBlcmltU2VnbWVudCAqIHJvdW5kbmVzcyAqIGRpciwgeCArIG94ICogcGVyaW1TZWdtZW50ICogcm91bmRuZXNzICogZGlyLCB5ICsgb3kgKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIGksIHRydWUpO1xuICAgICAgICAgICAgY3VycmVudEFuZyArPSBhbmdsZSAqIGRpcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnBhdGhzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgdGhpcy5wYXRoc1swXSA9IHRoaXMudjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU3RhclNoYXBlUHJvcGVydHlGYWN0b3J5KTtcbiAgICAgIHJldHVybiBTdGFyU2hhcGVQcm9wZXJ0eUZhY3Rvcnk7XG4gICAgfSgpO1xuXG4gICAgdmFyIFJlY3RTaGFwZVByb3BlcnR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUmVjdFNoYXBlUHJvcGVydHlGYWN0b3J5KGVsZW0sIGRhdGEpIHtcbiAgICAgICAgdGhpcy52ID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgICAgdGhpcy52LmMgPSB0cnVlO1xuICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnYpO1xuICAgICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xuICAgICAgICB0aGlzLmZyYW1lSWQgPSAtMTtcbiAgICAgICAgdGhpcy5kID0gZGF0YS5kO1xuICAgICAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucCwgMSwgMCwgdGhpcyk7XG4gICAgICAgIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucywgMSwgMCwgdGhpcyk7XG4gICAgICAgIHRoaXMuciA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuciwgMCwgMCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5rID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbnZlcnRSZWN0VG9QYXRoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgUmVjdFNoYXBlUHJvcGVydHlGYWN0b3J5LnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29udmVydFJlY3RUb1BhdGg6IGZ1bmN0aW9uIGNvbnZlcnRSZWN0VG9QYXRoKCkge1xuICAgICAgICAgIHZhciBwMCA9IHRoaXMucC52WzBdO1xuICAgICAgICAgIHZhciBwMSA9IHRoaXMucC52WzFdO1xuICAgICAgICAgIHZhciB2MCA9IHRoaXMucy52WzBdIC8gMjtcbiAgICAgICAgICB2YXIgdjEgPSB0aGlzLnMudlsxXSAvIDI7XG4gICAgICAgICAgdmFyIHJvdW5kID0gYm1NaW4odjAsIHYxLCB0aGlzLnIudik7XG4gICAgICAgICAgdmFyIGNQb2ludCA9IHJvdW5kICogKDEgLSByb3VuZENvcm5lcik7XG4gICAgICAgICAgdGhpcy52Ll9sZW5ndGggPSAwO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZCA9PT0gMiB8fCB0aGlzLmQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCArIHYwLCBwMSAtIHYxICsgcm91bmQsIHAwICsgdjAsIHAxIC0gdjEgKyByb3VuZCwgcDAgKyB2MCwgcDEgLSB2MSArIGNQb2ludCwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCwgcDEgKyB2MSAtIHJvdW5kLCBwMCArIHYwLCBwMSArIHYxIC0gY1BvaW50LCBwMCArIHYwLCBwMSArIHYxIC0gcm91bmQsIDEsIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAocm91bmQgIT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAgLSByb3VuZCwgcDEgKyB2MSwgcDAgKyB2MCAtIHJvdW5kLCBwMSArIHYxLCBwMCArIHYwIC0gY1BvaW50LCBwMSArIHYxLCAyLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAgKyByb3VuZCwgcDEgKyB2MSwgcDAgLSB2MCArIGNQb2ludCwgcDEgKyB2MSwgcDAgLSB2MCArIHJvdW5kLCBwMSArIHYxLCAzLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxICsgdjEgLSByb3VuZCwgcDAgLSB2MCwgcDEgKyB2MSAtIHJvdW5kLCBwMCAtIHYwLCBwMSArIHYxIC0gY1BvaW50LCA0LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxIC0gdjEgKyByb3VuZCwgcDAgLSB2MCwgcDEgLSB2MSArIGNQb2ludCwgcDAgLSB2MCwgcDEgLSB2MSArIHJvdW5kLCA1LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAgKyByb3VuZCwgcDEgLSB2MSwgcDAgLSB2MCArIHJvdW5kLCBwMSAtIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSAtIHYxLCA2LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAgLSByb3VuZCwgcDEgLSB2MSwgcDAgKyB2MCAtIGNQb2ludCwgcDEgLSB2MSwgcDAgKyB2MCAtIHJvdW5kLCBwMSAtIHYxLCA3LCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCAtIHYwLCBwMSArIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSArIHYxLCBwMCAtIHYwLCBwMSArIHYxLCAyKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxIC0gdjEsIHAwIC0gdjAsIHAxIC0gdjEgKyBjUG9pbnQsIHAwIC0gdjAsIHAxIC0gdjEsIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCwgcDEgLSB2MSArIHJvdW5kLCBwMCArIHYwLCBwMSAtIHYxICsgY1BvaW50LCBwMCArIHYwLCBwMSAtIHYxICsgcm91bmQsIDAsIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAocm91bmQgIT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAgLSByb3VuZCwgcDEgLSB2MSwgcDAgKyB2MCAtIHJvdW5kLCBwMSAtIHYxLCBwMCArIHYwIC0gY1BvaW50LCBwMSAtIHYxLCAxLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAgKyByb3VuZCwgcDEgLSB2MSwgcDAgLSB2MCArIGNQb2ludCwgcDEgLSB2MSwgcDAgLSB2MCArIHJvdW5kLCBwMSAtIHYxLCAyLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxIC0gdjEgKyByb3VuZCwgcDAgLSB2MCwgcDEgLSB2MSArIHJvdW5kLCBwMCAtIHYwLCBwMSAtIHYxICsgY1BvaW50LCAzLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxICsgdjEgLSByb3VuZCwgcDAgLSB2MCwgcDEgKyB2MSAtIGNQb2ludCwgcDAgLSB2MCwgcDEgKyB2MSAtIHJvdW5kLCA0LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAgKyByb3VuZCwgcDEgKyB2MSwgcDAgLSB2MCArIHJvdW5kLCBwMSArIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSArIHYxLCA1LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAgLSByb3VuZCwgcDEgKyB2MSwgcDAgKyB2MCAtIGNQb2ludCwgcDEgKyB2MSwgcDAgKyB2MCAtIHJvdW5kLCBwMSArIHYxLCA2LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAsIHAxICsgdjEgLSByb3VuZCwgcDAgKyB2MCwgcDEgKyB2MSAtIHJvdW5kLCBwMCArIHYwLCBwMSArIHYxIC0gY1BvaW50LCA3LCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCAtIHYwLCBwMSAtIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSAtIHYxLCBwMCAtIHYwLCBwMSAtIHYxLCAxLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxICsgdjEsIHAwIC0gdjAsIHAxICsgdjEgLSBjUG9pbnQsIHAwIC0gdjAsIHAxICsgdjEsIDIsIHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCwgcDEgKyB2MSwgcDAgKyB2MCAtIGNQb2ludCwgcDEgKyB2MSwgcDAgKyB2MCwgcDEgKyB2MSwgMywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gICAgICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9tZGYpIHtcbiAgICAgICAgICAgIHRoaXMuY29udmVydFJlY3RUb1BhdGgoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0OiByZXNldFNoYXBlXG4gICAgICB9O1xuICAgICAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBSZWN0U2hhcGVQcm9wZXJ0eUZhY3RvcnkpO1xuICAgICAgcmV0dXJuIFJlY3RTaGFwZVByb3BlcnR5RmFjdG9yeTtcbiAgICB9KCk7XG5cbiAgICBmdW5jdGlvbiBnZXRTaGFwZVByb3AoZWxlbSwgZGF0YSwgdHlwZSkge1xuICAgICAgdmFyIHByb3A7XG5cbiAgICAgIGlmICh0eXBlID09PSAzIHx8IHR5cGUgPT09IDQpIHtcbiAgICAgICAgdmFyIGRhdGFQcm9wID0gdHlwZSA9PT0gMyA/IGRhdGEucHQgOiBkYXRhLmtzO1xuICAgICAgICB2YXIga2V5cyA9IGRhdGFQcm9wLms7XG5cbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgcHJvcCA9IG5ldyBLZXlmcmFtZWRTaGFwZVByb3BlcnR5KGVsZW0sIGRhdGEsIHR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3AgPSBuZXcgU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA1KSB7XG4gICAgICAgIHByb3AgPSBuZXcgUmVjdFNoYXBlUHJvcGVydHkoZWxlbSwgZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDYpIHtcbiAgICAgICAgcHJvcCA9IG5ldyBFbGxTaGFwZVByb3BlcnR5KGVsZW0sIGRhdGEpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA3KSB7XG4gICAgICAgIHByb3AgPSBuZXcgU3RhclNoYXBlUHJvcGVydHkoZWxlbSwgZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wLmspIHtcbiAgICAgICAgZWxlbS5hZGREeW5hbWljUHJvcGVydHkocHJvcCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENvbnN0cnVjdG9yRnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gU2hhcGVQcm9wZXJ0eTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRLZXlmcmFtZWRDb25zdHJ1Y3RvckZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEtleWZyYW1lZFNoYXBlUHJvcGVydHk7XG4gICAgfVxuXG4gICAgdmFyIG9iID0ge307XG4gICAgb2IuZ2V0U2hhcGVQcm9wID0gZ2V0U2hhcGVQcm9wO1xuICAgIG9iLmdldENvbnN0cnVjdG9yRnVuY3Rpb24gPSBnZXRDb25zdHJ1Y3RvckZ1bmN0aW9uO1xuICAgIG9iLmdldEtleWZyYW1lZENvbnN0cnVjdG9yRnVuY3Rpb24gPSBnZXRLZXlmcmFtZWRDb25zdHJ1Y3RvckZ1bmN0aW9uO1xuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIC8qIVxyXG4gICBUcmFuc2Zvcm1hdGlvbiBNYXRyaXggdjIuMFxyXG4gICAoYykgRXBpc3RlbWV4IDIwMTQtMjAxNVxyXG4gICB3d3cuZXBpc3RlbWV4LmNvbVxyXG4gICBCeSBLZW4gRnlyc3RlbmJlcmdcclxuICAgQ29udHJpYnV0aW9ucyBieSBsZWVvbml5YS5cclxuICAgTGljZW5zZTogTUlULCBoZWFkZXIgcmVxdWlyZWQuXHJcbiAgICovXG5cbiAgLyoqXHJcbiAgICogMkQgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9iamVjdCBpbml0aWFsaXplZCB3aXRoIGlkZW50aXR5IG1hdHJpeC5cclxuICAgKlxyXG4gICAqIFRoZSBtYXRyaXggY2FuIHN5bmNocm9uaXplIGEgY2FudmFzIGNvbnRleHQgYnkgc3VwcGx5aW5nIHRoZSBjb250ZXh0XHJcbiAgICogYXMgYW4gYXJndW1lbnQsIG9yIGxhdGVyIGFwcGx5IGN1cnJlbnQgYWJzb2x1dGUgdHJhbnNmb3JtIHRvIGFuXHJcbiAgICogZXhpc3RpbmcgY29udGV4dC5cclxuICAgKlxyXG4gICAqIEFsbCB2YWx1ZXMgYXJlIGhhbmRsZWQgYXMgZmxvYXRpbmcgcG9pbnQgdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFtjb250ZXh0XSAtIE9wdGlvbmFsIGNvbnRleHQgdG8gc3luYyB3aXRoIE1hdHJpeFxyXG4gICAqIEBwcm9wIHtudW1iZXJ9IGEgLSBzY2FsZSB4XHJcbiAgICogQHByb3Age251bWJlcn0gYiAtIHNoZWFyIHlcclxuICAgKiBAcHJvcCB7bnVtYmVyfSBjIC0gc2hlYXIgeFxyXG4gICAqIEBwcm9wIHtudW1iZXJ9IGQgLSBzY2FsZSB5XHJcbiAgICogQHByb3Age251bWJlcn0gZSAtIHRyYW5zbGF0ZSB4XHJcbiAgICogQHByb3Age251bWJlcn0gZiAtIHRyYW5zbGF0ZSB5XHJcbiAgICogQHByb3Age0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxudWxsfSBbY29udGV4dD1udWxsXSAtIHNldCBvciBnZXQgY3VycmVudCBjYW52YXMgY29udGV4dFxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqL1xuXG4gIHZhciBNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9jb3MgPSBNYXRoLmNvcztcbiAgICB2YXIgX3NpbiA9IE1hdGguc2luO1xuICAgIHZhciBfdGFuID0gTWF0aC50YW47XG4gICAgdmFyIF9ybmQgPSBNYXRoLnJvdW5kO1xuXG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLnByb3BzWzBdID0gMTtcbiAgICAgIHRoaXMucHJvcHNbMV0gPSAwO1xuICAgICAgdGhpcy5wcm9wc1syXSA9IDA7XG4gICAgICB0aGlzLnByb3BzWzNdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbNF0gPSAwO1xuICAgICAgdGhpcy5wcm9wc1s1XSA9IDE7XG4gICAgICB0aGlzLnByb3BzWzZdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbN10gPSAwO1xuICAgICAgdGhpcy5wcm9wc1s4XSA9IDA7XG4gICAgICB0aGlzLnByb3BzWzldID0gMDtcbiAgICAgIHRoaXMucHJvcHNbMTBdID0gMTtcbiAgICAgIHRoaXMucHJvcHNbMTFdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbMTJdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbMTNdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbMTRdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbMTVdID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJvdGF0ZShhbmdsZSkge1xuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbUNvcyA9IF9jb3MoYW5nbGUpO1xuXG4gICAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fdChtQ29zLCAtbVNpbiwgMCwgMCwgbVNpbiwgbUNvcywgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm90YXRlWChhbmdsZSkge1xuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbUNvcyA9IF9jb3MoYW5nbGUpO1xuXG4gICAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fdCgxLCAwLCAwLCAwLCAwLCBtQ29zLCAtbVNpbiwgMCwgMCwgbVNpbiwgbUNvcywgMCwgMCwgMCwgMCwgMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm90YXRlWShhbmdsZSkge1xuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbUNvcyA9IF9jb3MoYW5nbGUpO1xuXG4gICAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fdChtQ29zLCAwLCBtU2luLCAwLCAwLCAxLCAwLCAwLCAtbVNpbiwgMCwgbUNvcywgMCwgMCwgMCwgMCwgMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm90YXRlWihhbmdsZSkge1xuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbUNvcyA9IF9jb3MoYW5nbGUpO1xuXG4gICAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fdChtQ29zLCAtbVNpbiwgMCwgMCwgbVNpbiwgbUNvcywgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hlYXIoc3gsIHN5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fdCgxLCBzeSwgc3gsIDEsIDAsIDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNrZXcoYXgsIGF5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zaGVhcihfdGFuKGF4KSwgX3RhbihheSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNrZXdGcm9tQXhpcyhheCwgYW5nbGUpIHtcbiAgICAgIHZhciBtQ29zID0gX2NvcyhhbmdsZSk7XG5cbiAgICAgIHZhciBtU2luID0gX3NpbihhbmdsZSk7XG5cbiAgICAgIHJldHVybiB0aGlzLl90KG1Db3MsIG1TaW4sIDAsIDAsIC1tU2luLCBtQ29zLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKS5fdCgxLCAwLCAwLCAwLCBfdGFuKGF4KSwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSkuX3QobUNvcywgLW1TaW4sIDAsIDAsIG1TaW4sIG1Db3MsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpOyAvLyByZXR1cm4gdGhpcy5fdChtQ29zLCBtU2luLCAtbVNpbiwgbUNvcywgMCwgMCkuX3QoMSwgMCwgX3RhbihheCksIDEsIDAsIDApLl90KG1Db3MsIC1tU2luLCBtU2luLCBtQ29zLCAwLCAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZShzeCwgc3ksIHN6KSB7XG4gICAgICBpZiAoIXN6ICYmIHN6ICE9PSAwKSB7XG4gICAgICAgIHN6ID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN4ID09PSAxICYmIHN5ID09PSAxICYmIHN6ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fdChzeCwgMCwgMCwgMCwgMCwgc3ksIDAsIDAsIDAsIDAsIHN6LCAwLCAwLCAwLCAwLCAxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCwgbSwgbiwgbywgcCkge1xuICAgICAgdGhpcy5wcm9wc1swXSA9IGE7XG4gICAgICB0aGlzLnByb3BzWzFdID0gYjtcbiAgICAgIHRoaXMucHJvcHNbMl0gPSBjO1xuICAgICAgdGhpcy5wcm9wc1szXSA9IGQ7XG4gICAgICB0aGlzLnByb3BzWzRdID0gZTtcbiAgICAgIHRoaXMucHJvcHNbNV0gPSBmO1xuICAgICAgdGhpcy5wcm9wc1s2XSA9IGc7XG4gICAgICB0aGlzLnByb3BzWzddID0gaDtcbiAgICAgIHRoaXMucHJvcHNbOF0gPSBpO1xuICAgICAgdGhpcy5wcm9wc1s5XSA9IGo7XG4gICAgICB0aGlzLnByb3BzWzEwXSA9IGs7XG4gICAgICB0aGlzLnByb3BzWzExXSA9IGw7XG4gICAgICB0aGlzLnByb3BzWzEyXSA9IG07XG4gICAgICB0aGlzLnByb3BzWzEzXSA9IG47XG4gICAgICB0aGlzLnByb3BzWzE0XSA9IG87XG4gICAgICB0aGlzLnByb3BzWzE1XSA9IHA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUodHgsIHR5LCB0eikge1xuICAgICAgdHogPSB0eiB8fCAwO1xuXG4gICAgICBpZiAodHggIT09IDAgfHwgdHkgIT09IDAgfHwgdHogIT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3QoMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgdHgsIHR5LCB0eiwgMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShhMiwgYjIsIGMyLCBkMiwgZTIsIGYyLCBnMiwgaDIsIGkyLCBqMiwgazIsIGwyLCBtMiwgbjIsIG8yLCBwMikge1xuICAgICAgdmFyIF9wID0gdGhpcy5wcm9wcztcblxuICAgICAgaWYgKGEyID09PSAxICYmIGIyID09PSAwICYmIGMyID09PSAwICYmIGQyID09PSAwICYmIGUyID09PSAwICYmIGYyID09PSAxICYmIGcyID09PSAwICYmIGgyID09PSAwICYmIGkyID09PSAwICYmIGoyID09PSAwICYmIGsyID09PSAxICYmIGwyID09PSAwKSB7XG4gICAgICAgIC8vIE5PVEU6IGNvbW1lbnRpbmcgdGhpcyBjb25kaXRpb24gYmVjYXVzZSBUdXJib0ZhbiBkZW9wdGltaXplcyBjb2RlIHdoZW4gcHJlc2VudFxuICAgICAgICAvLyBpZihtMiAhPT0gMCB8fCBuMiAhPT0gMCB8fCBvMiAhPT0gMCl7XG4gICAgICAgIF9wWzEyXSA9IF9wWzEyXSAqIGEyICsgX3BbMTVdICogbTI7XG4gICAgICAgIF9wWzEzXSA9IF9wWzEzXSAqIGYyICsgX3BbMTVdICogbjI7XG4gICAgICAgIF9wWzE0XSA9IF9wWzE0XSAqIGsyICsgX3BbMTVdICogbzI7XG4gICAgICAgIF9wWzE1XSAqPSBwMjsgLy8gfVxuXG4gICAgICAgIHRoaXMuX2lkZW50aXR5Q2FsY3VsYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIGExID0gX3BbMF07XG4gICAgICB2YXIgYjEgPSBfcFsxXTtcbiAgICAgIHZhciBjMSA9IF9wWzJdO1xuICAgICAgdmFyIGQxID0gX3BbM107XG4gICAgICB2YXIgZTEgPSBfcFs0XTtcbiAgICAgIHZhciBmMSA9IF9wWzVdO1xuICAgICAgdmFyIGcxID0gX3BbNl07XG4gICAgICB2YXIgaDEgPSBfcFs3XTtcbiAgICAgIHZhciBpMSA9IF9wWzhdO1xuICAgICAgdmFyIGoxID0gX3BbOV07XG4gICAgICB2YXIgazEgPSBfcFsxMF07XG4gICAgICB2YXIgbDEgPSBfcFsxMV07XG4gICAgICB2YXIgbTEgPSBfcFsxMl07XG4gICAgICB2YXIgbjEgPSBfcFsxM107XG4gICAgICB2YXIgbzEgPSBfcFsxNF07XG4gICAgICB2YXIgcDEgPSBfcFsxNV07XG4gICAgICAvKiBtYXRyaXggb3JkZXIgKGNhbnZhcyBjb21wYXRpYmxlKTpcclxuICAgICAgICAgICAqIGFjZVxyXG4gICAgICAgICAgICogYmRmXHJcbiAgICAgICAgICAgKiAwMDFcclxuICAgICAgICAgICAqL1xuXG4gICAgICBfcFswXSA9IGExICogYTIgKyBiMSAqIGUyICsgYzEgKiBpMiArIGQxICogbTI7XG4gICAgICBfcFsxXSA9IGExICogYjIgKyBiMSAqIGYyICsgYzEgKiBqMiArIGQxICogbjI7XG4gICAgICBfcFsyXSA9IGExICogYzIgKyBiMSAqIGcyICsgYzEgKiBrMiArIGQxICogbzI7XG4gICAgICBfcFszXSA9IGExICogZDIgKyBiMSAqIGgyICsgYzEgKiBsMiArIGQxICogcDI7XG4gICAgICBfcFs0XSA9IGUxICogYTIgKyBmMSAqIGUyICsgZzEgKiBpMiArIGgxICogbTI7XG4gICAgICBfcFs1XSA9IGUxICogYjIgKyBmMSAqIGYyICsgZzEgKiBqMiArIGgxICogbjI7XG4gICAgICBfcFs2XSA9IGUxICogYzIgKyBmMSAqIGcyICsgZzEgKiBrMiArIGgxICogbzI7XG4gICAgICBfcFs3XSA9IGUxICogZDIgKyBmMSAqIGgyICsgZzEgKiBsMiArIGgxICogcDI7XG4gICAgICBfcFs4XSA9IGkxICogYTIgKyBqMSAqIGUyICsgazEgKiBpMiArIGwxICogbTI7XG4gICAgICBfcFs5XSA9IGkxICogYjIgKyBqMSAqIGYyICsgazEgKiBqMiArIGwxICogbjI7XG4gICAgICBfcFsxMF0gPSBpMSAqIGMyICsgajEgKiBnMiArIGsxICogazIgKyBsMSAqIG8yO1xuICAgICAgX3BbMTFdID0gaTEgKiBkMiArIGoxICogaDIgKyBrMSAqIGwyICsgbDEgKiBwMjtcbiAgICAgIF9wWzEyXSA9IG0xICogYTIgKyBuMSAqIGUyICsgbzEgKiBpMiArIHAxICogbTI7XG4gICAgICBfcFsxM10gPSBtMSAqIGIyICsgbjEgKiBmMiArIG8xICogajIgKyBwMSAqIG4yO1xuICAgICAgX3BbMTRdID0gbTEgKiBjMiArIG4xICogZzIgKyBvMSAqIGsyICsgcDEgKiBvMjtcbiAgICAgIF9wWzE1XSA9IG0xICogZDIgKyBuMSAqIGgyICsgbzEgKiBsMiArIHAxICogcDI7XG4gICAgICB0aGlzLl9pZGVudGl0eUNhbGN1bGF0ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG11bHRpcGx5KG1hdHJpeCkge1xuICAgICAgdmFyIG1hdHJpeFByb3BzID0gbWF0cml4LnByb3BzO1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG1hdHJpeFByb3BzWzBdLCBtYXRyaXhQcm9wc1sxXSwgbWF0cml4UHJvcHNbMl0sIG1hdHJpeFByb3BzWzNdLCBtYXRyaXhQcm9wc1s0XSwgbWF0cml4UHJvcHNbNV0sIG1hdHJpeFByb3BzWzZdLCBtYXRyaXhQcm9wc1s3XSwgbWF0cml4UHJvcHNbOF0sIG1hdHJpeFByb3BzWzldLCBtYXRyaXhQcm9wc1sxMF0sIG1hdHJpeFByb3BzWzExXSwgbWF0cml4UHJvcHNbMTJdLCBtYXRyaXhQcm9wc1sxM10sIG1hdHJpeFByb3BzWzE0XSwgbWF0cml4UHJvcHNbMTVdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aXR5KCkge1xuICAgICAgaWYgKCF0aGlzLl9pZGVudGl0eUNhbGN1bGF0ZWQpIHtcbiAgICAgICAgdGhpcy5faWRlbnRpdHkgPSAhKHRoaXMucHJvcHNbMF0gIT09IDEgfHwgdGhpcy5wcm9wc1sxXSAhPT0gMCB8fCB0aGlzLnByb3BzWzJdICE9PSAwIHx8IHRoaXMucHJvcHNbM10gIT09IDAgfHwgdGhpcy5wcm9wc1s0XSAhPT0gMCB8fCB0aGlzLnByb3BzWzVdICE9PSAxIHx8IHRoaXMucHJvcHNbNl0gIT09IDAgfHwgdGhpcy5wcm9wc1s3XSAhPT0gMCB8fCB0aGlzLnByb3BzWzhdICE9PSAwIHx8IHRoaXMucHJvcHNbOV0gIT09IDAgfHwgdGhpcy5wcm9wc1sxMF0gIT09IDEgfHwgdGhpcy5wcm9wc1sxMV0gIT09IDAgfHwgdGhpcy5wcm9wc1sxMl0gIT09IDAgfHwgdGhpcy5wcm9wc1sxM10gIT09IDAgfHwgdGhpcy5wcm9wc1sxNF0gIT09IDAgfHwgdGhpcy5wcm9wc1sxNV0gIT09IDEpO1xuICAgICAgICB0aGlzLl9pZGVudGl0eUNhbGN1bGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5faWRlbnRpdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXF1YWxzKG1hdHIpIHtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgPCAxNikge1xuICAgICAgICBpZiAobWF0ci5wcm9wc1tpXSAhPT0gdGhpcy5wcm9wc1tpXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUobWF0cikge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XG4gICAgICAgIG1hdHIucHJvcHNbaV0gPSB0aGlzLnByb3BzW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0cjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZUZyb21Qcm9wcyhwcm9wcykge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMucHJvcHNbaV0gPSBwcm9wc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVRvUG9pbnQoeCwgeSwgeikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAqIHRoaXMucHJvcHNbMF0gKyB5ICogdGhpcy5wcm9wc1s0XSArIHogKiB0aGlzLnByb3BzWzhdICsgdGhpcy5wcm9wc1sxMl0sXG4gICAgICAgIHk6IHggKiB0aGlzLnByb3BzWzFdICsgeSAqIHRoaXMucHJvcHNbNV0gKyB6ICogdGhpcy5wcm9wc1s5XSArIHRoaXMucHJvcHNbMTNdLFxuICAgICAgICB6OiB4ICogdGhpcy5wcm9wc1syXSArIHkgKiB0aGlzLnByb3BzWzZdICsgeiAqIHRoaXMucHJvcHNbMTBdICsgdGhpcy5wcm9wc1sxNF1cbiAgICAgIH07XG4gICAgICAvKiByZXR1cm4ge1xyXG4gICAgICAgICAgIHg6IHggKiBtZS5hICsgeSAqIG1lLmMgKyBtZS5lLFxyXG4gICAgICAgICAgIHk6IHggKiBtZS5iICsgeSAqIG1lLmQgKyBtZS5mXHJcbiAgICAgICAgICAgfTsgKi9cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVRvWCh4LCB5LCB6KSB7XG4gICAgICByZXR1cm4geCAqIHRoaXMucHJvcHNbMF0gKyB5ICogdGhpcy5wcm9wc1s0XSArIHogKiB0aGlzLnByb3BzWzhdICsgdGhpcy5wcm9wc1sxMl07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlUb1koeCwgeSwgeikge1xuICAgICAgcmV0dXJuIHggKiB0aGlzLnByb3BzWzFdICsgeSAqIHRoaXMucHJvcHNbNV0gKyB6ICogdGhpcy5wcm9wc1s5XSArIHRoaXMucHJvcHNbMTNdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5VG9aKHgsIHksIHopIHtcbiAgICAgIHJldHVybiB4ICogdGhpcy5wcm9wc1syXSArIHkgKiB0aGlzLnByb3BzWzZdICsgeiAqIHRoaXMucHJvcHNbMTBdICsgdGhpcy5wcm9wc1sxNF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SW52ZXJzZU1hdHJpeCgpIHtcbiAgICAgIHZhciBkZXRlcm1pbmFudCA9IHRoaXMucHJvcHNbMF0gKiB0aGlzLnByb3BzWzVdIC0gdGhpcy5wcm9wc1sxXSAqIHRoaXMucHJvcHNbNF07XG4gICAgICB2YXIgYSA9IHRoaXMucHJvcHNbNV0gLyBkZXRlcm1pbmFudDtcbiAgICAgIHZhciBiID0gLXRoaXMucHJvcHNbMV0gLyBkZXRlcm1pbmFudDtcbiAgICAgIHZhciBjID0gLXRoaXMucHJvcHNbNF0gLyBkZXRlcm1pbmFudDtcbiAgICAgIHZhciBkID0gdGhpcy5wcm9wc1swXSAvIGRldGVybWluYW50O1xuICAgICAgdmFyIGUgPSAodGhpcy5wcm9wc1s0XSAqIHRoaXMucHJvcHNbMTNdIC0gdGhpcy5wcm9wc1s1XSAqIHRoaXMucHJvcHNbMTJdKSAvIGRldGVybWluYW50O1xuICAgICAgdmFyIGYgPSAtKHRoaXMucHJvcHNbMF0gKiB0aGlzLnByb3BzWzEzXSAtIHRoaXMucHJvcHNbMV0gKiB0aGlzLnByb3BzWzEyXSkgLyBkZXRlcm1pbmFudDtcbiAgICAgIHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgICAgaW52ZXJzZU1hdHJpeC5wcm9wc1swXSA9IGE7XG4gICAgICBpbnZlcnNlTWF0cml4LnByb3BzWzFdID0gYjtcbiAgICAgIGludmVyc2VNYXRyaXgucHJvcHNbNF0gPSBjO1xuICAgICAgaW52ZXJzZU1hdHJpeC5wcm9wc1s1XSA9IGQ7XG4gICAgICBpbnZlcnNlTWF0cml4LnByb3BzWzEyXSA9IGU7XG4gICAgICBpbnZlcnNlTWF0cml4LnByb3BzWzEzXSA9IGY7XG4gICAgICByZXR1cm4gaW52ZXJzZU1hdHJpeDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZlcnNlUG9pbnQocHQpIHtcbiAgICAgIHZhciBpbnZlcnNlTWF0cml4ID0gdGhpcy5nZXRJbnZlcnNlTWF0cml4KCk7XG4gICAgICByZXR1cm4gaW52ZXJzZU1hdHJpeC5hcHBseVRvUG9pbnRBcnJheShwdFswXSwgcHRbMV0sIHB0WzJdIHx8IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmVyc2VQb2ludHMocHRzKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBwdHMubGVuZ3RoO1xuICAgICAgdmFyIHJldFB0cyA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmV0UHRzW2ldID0gaW52ZXJzZVBvaW50KHB0c1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXRQdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlUb1RyaXBsZVBvaW50cyhwdDEsIHB0MiwgcHQzKSB7XG4gICAgICB2YXIgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIDYpO1xuXG4gICAgICBpZiAodGhpcy5pc0lkZW50aXR5KCkpIHtcbiAgICAgICAgYXJyWzBdID0gcHQxWzBdO1xuICAgICAgICBhcnJbMV0gPSBwdDFbMV07XG4gICAgICAgIGFyclsyXSA9IHB0MlswXTtcbiAgICAgICAgYXJyWzNdID0gcHQyWzFdO1xuICAgICAgICBhcnJbNF0gPSBwdDNbMF07XG4gICAgICAgIGFycls1XSA9IHB0M1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwMCA9IHRoaXMucHJvcHNbMF07XG4gICAgICAgIHZhciBwMSA9IHRoaXMucHJvcHNbMV07XG4gICAgICAgIHZhciBwNCA9IHRoaXMucHJvcHNbNF07XG4gICAgICAgIHZhciBwNSA9IHRoaXMucHJvcHNbNV07XG4gICAgICAgIHZhciBwMTIgPSB0aGlzLnByb3BzWzEyXTtcbiAgICAgICAgdmFyIHAxMyA9IHRoaXMucHJvcHNbMTNdO1xuICAgICAgICBhcnJbMF0gPSBwdDFbMF0gKiBwMCArIHB0MVsxXSAqIHA0ICsgcDEyO1xuICAgICAgICBhcnJbMV0gPSBwdDFbMF0gKiBwMSArIHB0MVsxXSAqIHA1ICsgcDEzO1xuICAgICAgICBhcnJbMl0gPSBwdDJbMF0gKiBwMCArIHB0MlsxXSAqIHA0ICsgcDEyO1xuICAgICAgICBhcnJbM10gPSBwdDJbMF0gKiBwMSArIHB0MlsxXSAqIHA1ICsgcDEzO1xuICAgICAgICBhcnJbNF0gPSBwdDNbMF0gKiBwMCArIHB0M1sxXSAqIHA0ICsgcDEyO1xuICAgICAgICBhcnJbNV0gPSBwdDNbMF0gKiBwMSArIHB0M1sxXSAqIHA1ICsgcDEzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5VG9Qb2ludEFycmF5KHgsIHksIHopIHtcbiAgICAgIHZhciBhcnI7XG5cbiAgICAgIGlmICh0aGlzLmlzSWRlbnRpdHkoKSkge1xuICAgICAgICBhcnIgPSBbeCwgeSwgel07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnIgPSBbeCAqIHRoaXMucHJvcHNbMF0gKyB5ICogdGhpcy5wcm9wc1s0XSArIHogKiB0aGlzLnByb3BzWzhdICsgdGhpcy5wcm9wc1sxMl0sIHggKiB0aGlzLnByb3BzWzFdICsgeSAqIHRoaXMucHJvcHNbNV0gKyB6ICogdGhpcy5wcm9wc1s5XSArIHRoaXMucHJvcHNbMTNdLCB4ICogdGhpcy5wcm9wc1syXSArIHkgKiB0aGlzLnByb3BzWzZdICsgeiAqIHRoaXMucHJvcHNbMTBdICsgdGhpcy5wcm9wc1sxNF1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKHgsIHkpIHtcbiAgICAgIGlmICh0aGlzLmlzSWRlbnRpdHkoKSkge1xuICAgICAgICByZXR1cm4geCArICcsJyArIHk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcCA9IHRoaXMucHJvcHM7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCgoeCAqIF9wWzBdICsgeSAqIF9wWzRdICsgX3BbMTJdKSAqIDEwMCkgLyAxMDAgKyAnLCcgKyBNYXRoLnJvdW5kKCh4ICogX3BbMV0gKyB5ICogX3BbNV0gKyBfcFsxM10pICogMTAwKSAvIDEwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0NTUygpIHtcbiAgICAgIC8vIERvZXNuJ3QgbWFrZSBtdWNoIHNlbnNlIHRvIGFkZCB0aGlzIG9wdGltaXphdGlvbi4gSWYgaXQgaXMgYW4gaWRlbnRpdHkgbWF0cml4LCBpdCdzIHZlcnkgbGlrZWx5IHRoaXMgd2lsbCBnZXQgY2FsbGVkIG9ubHkgb25jZSBzaW5jZSBpdCB3b24ndCBiZSBrZXlmcmFtZWQuXG5cbiAgICAgIC8qIGlmKHRoaXMuaXNJZGVudGl0eSgpKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgfSAqL1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBjc3NWYWx1ZSA9ICdtYXRyaXgzZCgnO1xuICAgICAgdmFyIHYgPSAxMDAwMDtcblxuICAgICAgd2hpbGUgKGkgPCAxNikge1xuICAgICAgICBjc3NWYWx1ZSArPSBfcm5kKHByb3BzW2ldICogdikgLyB2O1xuICAgICAgICBjc3NWYWx1ZSArPSBpID09PSAxNSA/ICcpJyA6ICcsJztcbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3NzVmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm91bmRNYXRyaXhQcm9wZXJ0eSh2YWwpIHtcbiAgICAgIHZhciB2ID0gMTAwMDA7XG5cbiAgICAgIGlmICh2YWwgPCAwLjAwMDAwMSAmJiB2YWwgPiAwIHx8IHZhbCA+IC0wLjAwMDAwMSAmJiB2YWwgPCAwKSB7XG4gICAgICAgIHJldHVybiBfcm5kKHZhbCAqIHYpIC8gdjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0bzJkQ1NTKCkge1xuICAgICAgLy8gRG9lc24ndCBtYWtlIG11Y2ggc2Vuc2UgdG8gYWRkIHRoaXMgb3B0aW1pemF0aW9uLiBJZiBpdCBpcyBhbiBpZGVudGl0eSBtYXRyaXgsIGl0J3MgdmVyeSBsaWtlbHkgdGhpcyB3aWxsIGdldCBjYWxsZWQgb25seSBvbmNlIHNpbmNlIGl0IHdvbid0IGJlIGtleWZyYW1lZC5cblxuICAgICAgLyogaWYodGhpcy5pc0lkZW50aXR5KCkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICB9ICovXG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuXG4gICAgICB2YXIgX2EgPSByb3VuZE1hdHJpeFByb3BlcnR5KHByb3BzWzBdKTtcblxuICAgICAgdmFyIF9iID0gcm91bmRNYXRyaXhQcm9wZXJ0eShwcm9wc1sxXSk7XG5cbiAgICAgIHZhciBfYyA9IHJvdW5kTWF0cml4UHJvcGVydHkocHJvcHNbNF0pO1xuXG4gICAgICB2YXIgX2QgPSByb3VuZE1hdHJpeFByb3BlcnR5KHByb3BzWzVdKTtcblxuICAgICAgdmFyIF9lID0gcm91bmRNYXRyaXhQcm9wZXJ0eShwcm9wc1sxMl0pO1xuXG4gICAgICB2YXIgX2YgPSByb3VuZE1hdHJpeFByb3BlcnR5KHByb3BzWzEzXSk7XG5cbiAgICAgIHJldHVybiAnbWF0cml4KCcgKyBfYSArICcsJyArIF9iICsgJywnICsgX2MgKyAnLCcgKyBfZCArICcsJyArIF9lICsgJywnICsgX2YgKyAnKSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucmVzZXQgPSByZXNldDtcbiAgICAgIHRoaXMucm90YXRlID0gcm90YXRlO1xuICAgICAgdGhpcy5yb3RhdGVYID0gcm90YXRlWDtcbiAgICAgIHRoaXMucm90YXRlWSA9IHJvdGF0ZVk7XG4gICAgICB0aGlzLnJvdGF0ZVogPSByb3RhdGVaO1xuICAgICAgdGhpcy5za2V3ID0gc2tldztcbiAgICAgIHRoaXMuc2tld0Zyb21BeGlzID0gc2tld0Zyb21BeGlzO1xuICAgICAgdGhpcy5zaGVhciA9IHNoZWFyO1xuICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0gPSBzZXRUcmFuc2Zvcm07XG4gICAgICB0aGlzLnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbiAgICAgIHRoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgdGhpcy5tdWx0aXBseSA9IG11bHRpcGx5O1xuICAgICAgdGhpcy5hcHBseVRvUG9pbnQgPSBhcHBseVRvUG9pbnQ7XG4gICAgICB0aGlzLmFwcGx5VG9YID0gYXBwbHlUb1g7XG4gICAgICB0aGlzLmFwcGx5VG9ZID0gYXBwbHlUb1k7XG4gICAgICB0aGlzLmFwcGx5VG9aID0gYXBwbHlUb1o7XG4gICAgICB0aGlzLmFwcGx5VG9Qb2ludEFycmF5ID0gYXBwbHlUb1BvaW50QXJyYXk7XG4gICAgICB0aGlzLmFwcGx5VG9UcmlwbGVQb2ludHMgPSBhcHBseVRvVHJpcGxlUG9pbnRzO1xuICAgICAgdGhpcy5hcHBseVRvUG9pbnRTdHJpbmdpZmllZCA9IGFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkO1xuICAgICAgdGhpcy50b0NTUyA9IHRvQ1NTO1xuICAgICAgdGhpcy50bzJkQ1NTID0gdG8yZENTUztcbiAgICAgIHRoaXMuY2xvbmUgPSBjbG9uZTtcbiAgICAgIHRoaXMuY2xvbmVGcm9tUHJvcHMgPSBjbG9uZUZyb21Qcm9wcztcbiAgICAgIHRoaXMuZXF1YWxzID0gZXF1YWxzO1xuICAgICAgdGhpcy5pbnZlcnNlUG9pbnRzID0gaW52ZXJzZVBvaW50cztcbiAgICAgIHRoaXMuaW52ZXJzZVBvaW50ID0gaW52ZXJzZVBvaW50O1xuICAgICAgdGhpcy5nZXRJbnZlcnNlTWF0cml4ID0gZ2V0SW52ZXJzZU1hdHJpeDtcbiAgICAgIHRoaXMuX3QgPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgIHRoaXMuaXNJZGVudGl0eSA9IGlzSWRlbnRpdHk7XG4gICAgICB0aGlzLl9pZGVudGl0eSA9IHRydWU7XG4gICAgICB0aGlzLl9pZGVudGl0eUNhbGN1bGF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucHJvcHMgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgMTYpO1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH07XG4gIH0oKTtcblxuICBmdW5jdGlvbiBfdHlwZW9mJDMob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YkMyA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mJDMgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZiQzKG9iaik7IH1cbiAgdmFyIGxvdHRpZSA9IHt9O1xuICB2YXIgc3RhbmRhbG9uZSA9ICdfX1tTVEFOREFMT05FXV9fJztcbiAgdmFyIGFuaW1hdGlvbkRhdGEgPSAnX19bQU5JTUFUSU9OREFUQV1fXyc7XG4gIHZhciByZW5kZXJlciA9ICcnO1xuXG4gIGZ1bmN0aW9uIHNldExvY2F0aW9uKGhyZWYpIHtcbiAgICBzZXRMb2NhdGlvbkhyZWYoaHJlZik7XG4gIH1cblxuICBmdW5jdGlvbiBzZWFyY2hBbmltYXRpb25zKCkge1xuICAgIGlmIChzdGFuZGFsb25lID09PSB0cnVlKSB7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLnNlYXJjaEFuaW1hdGlvbnMoYW5pbWF0aW9uRGF0YSwgc3RhbmRhbG9uZSwgcmVuZGVyZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLnNlYXJjaEFuaW1hdGlvbnMoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTdWJmcmFtZVJlbmRlcmluZyhmbGFnKSB7XG4gICAgc2V0U3ViZnJhbWVFbmFibGVkKGZsYWcpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UHJlZml4KHByZWZpeCkge1xuICAgIHNldElkUHJlZml4KHByZWZpeCk7XG4gIH1cblxuICBmdW5jdGlvbiBsb2FkQW5pbWF0aW9uKHBhcmFtcykge1xuICAgIGlmIChzdGFuZGFsb25lID09PSB0cnVlKSB7XG4gICAgICBwYXJhbXMuYW5pbWF0aW9uRGF0YSA9IEpTT04ucGFyc2UoYW5pbWF0aW9uRGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdGlvbk1hbmFnZXIubG9hZEFuaW1hdGlvbihwYXJhbXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UXVhbGl0eSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2hpZ2gnOlxuICAgICAgICAgIHNldERlZmF1bHRDdXJ2ZVNlZ21lbnRzKDIwMCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2FzZSAnbWVkaXVtJzpcbiAgICAgICAgICBzZXREZWZhdWx0Q3VydmVTZWdtZW50cyg1MCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbG93JzpcbiAgICAgICAgICBzZXREZWZhdWx0Q3VydmVTZWdtZW50cygxMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNOYU4odmFsdWUpICYmIHZhbHVlID4gMSkge1xuICAgICAgc2V0RGVmYXVsdEN1cnZlU2VnbWVudHModmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChnZXREZWZhdWx0Q3VydmVTZWdtZW50cygpID49IDUwKSB7XG4gICAgICByb3VuZFZhbHVlcyhmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdW5kVmFsdWVzKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluQnJvd3NlcigpIHtcbiAgICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnN0YWxsUGx1Z2luKHR5cGUsIHBsdWdpbikge1xuICAgIGlmICh0eXBlID09PSAnZXhwcmVzc2lvbnMnKSB7XG4gICAgICBzZXRFeHByZXNzaW9uc1BsdWdpbihwbHVnaW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZhY3RvcnkobmFtZSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAncHJvcGVydHlGYWN0b3J5JzpcbiAgICAgICAgcmV0dXJuIFByb3BlcnR5RmFjdG9yeTtcblxuICAgICAgY2FzZSAnc2hhcGVQcm9wZXJ0eUZhY3RvcnknOlxuICAgICAgICByZXR1cm4gU2hhcGVQcm9wZXJ0eUZhY3Rvcnk7XG5cbiAgICAgIGNhc2UgJ21hdHJpeCc6XG4gICAgICAgIHJldHVybiBNYXRyaXg7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGxvdHRpZS5wbGF5ID0gYW5pbWF0aW9uTWFuYWdlci5wbGF5O1xuICBsb3R0aWUucGF1c2UgPSBhbmltYXRpb25NYW5hZ2VyLnBhdXNlO1xuICBsb3R0aWUuc2V0TG9jYXRpb25IcmVmID0gc2V0TG9jYXRpb247XG4gIGxvdHRpZS50b2dnbGVQYXVzZSA9IGFuaW1hdGlvbk1hbmFnZXIudG9nZ2xlUGF1c2U7XG4gIGxvdHRpZS5zZXRTcGVlZCA9IGFuaW1hdGlvbk1hbmFnZXIuc2V0U3BlZWQ7XG4gIGxvdHRpZS5zZXREaXJlY3Rpb24gPSBhbmltYXRpb25NYW5hZ2VyLnNldERpcmVjdGlvbjtcbiAgbG90dGllLnN0b3AgPSBhbmltYXRpb25NYW5hZ2VyLnN0b3A7XG4gIGxvdHRpZS5zZWFyY2hBbmltYXRpb25zID0gc2VhcmNoQW5pbWF0aW9ucztcbiAgbG90dGllLnJlZ2lzdGVyQW5pbWF0aW9uID0gYW5pbWF0aW9uTWFuYWdlci5yZWdpc3RlckFuaW1hdGlvbjtcbiAgbG90dGllLmxvYWRBbmltYXRpb24gPSBsb2FkQW5pbWF0aW9uO1xuICBsb3R0aWUuc2V0U3ViZnJhbWVSZW5kZXJpbmcgPSBzZXRTdWJmcmFtZVJlbmRlcmluZztcbiAgbG90dGllLnJlc2l6ZSA9IGFuaW1hdGlvbk1hbmFnZXIucmVzaXplOyAvLyBsb3R0aWUuc3RhcnQgPSBzdGFydDtcblxuICBsb3R0aWUuZ29Ub0FuZFN0b3AgPSBhbmltYXRpb25NYW5hZ2VyLmdvVG9BbmRTdG9wO1xuICBsb3R0aWUuZGVzdHJveSA9IGFuaW1hdGlvbk1hbmFnZXIuZGVzdHJveTtcbiAgbG90dGllLnNldFF1YWxpdHkgPSBzZXRRdWFsaXR5O1xuICBsb3R0aWUuaW5Ccm93c2VyID0gaW5Ccm93c2VyO1xuICBsb3R0aWUuaW5zdGFsbFBsdWdpbiA9IGluc3RhbGxQbHVnaW47XG4gIGxvdHRpZS5mcmVlemUgPSBhbmltYXRpb25NYW5hZ2VyLmZyZWV6ZTtcbiAgbG90dGllLnVuZnJlZXplID0gYW5pbWF0aW9uTWFuYWdlci51bmZyZWV6ZTtcbiAgbG90dGllLnNldFZvbHVtZSA9IGFuaW1hdGlvbk1hbmFnZXIuc2V0Vm9sdW1lO1xuICBsb3R0aWUubXV0ZSA9IGFuaW1hdGlvbk1hbmFnZXIubXV0ZTtcbiAgbG90dGllLnVubXV0ZSA9IGFuaW1hdGlvbk1hbmFnZXIudW5tdXRlO1xuICBsb3R0aWUuZ2V0UmVnaXN0ZXJlZEFuaW1hdGlvbnMgPSBhbmltYXRpb25NYW5hZ2VyLmdldFJlZ2lzdGVyZWRBbmltYXRpb25zO1xuICBsb3R0aWUudXNlV2ViV29ya2VyID0gc2V0V2ViV29ya2VyO1xuICBsb3R0aWUuc2V0SURQcmVmaXggPSBzZXRQcmVmaXg7XG4gIGxvdHRpZS5fX2dldEZhY3RvcnkgPSBnZXRGYWN0b3J5O1xuICBsb3R0aWUudmVyc2lvbiA9ICc1LjEyLjInO1xuXG4gIGZ1bmN0aW9uIGNoZWNrUmVhZHkoKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwocmVhZHlTdGF0ZUNoZWNrSW50ZXJ2YWwpO1xuICAgICAgc2VhcmNoQW5pbWF0aW9ucygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFF1ZXJ5VmFyaWFibGUodmFyaWFibGUpIHtcbiAgICB2YXIgdmFycyA9IHF1ZXJ5U3RyaW5nLnNwbGl0KCcmJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBwYWlyID0gdmFyc1tpXS5zcGxpdCgnPScpO1xuXG4gICAgICBpZiAoZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pID09IHZhcmlhYmxlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcXVlcnlTdHJpbmcgPSAnJztcblxuICBpZiAoc3RhbmRhbG9uZSkge1xuICAgIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICAgIHZhciBpbmRleCA9IHNjcmlwdHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgbXlTY3JpcHQgPSBzY3JpcHRzW2luZGV4XSB8fCB7XG4gICAgICBzcmM6ICcnXG4gICAgfTtcbiAgICBxdWVyeVN0cmluZyA9IG15U2NyaXB0LnNyYyA/IG15U2NyaXB0LnNyYy5yZXBsYWNlKC9eW15cXD9dK1xcPz8vLCAnJykgOiAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuXG4gICAgcmVuZGVyZXIgPSBnZXRRdWVyeVZhcmlhYmxlKCdyZW5kZXJlcicpO1xuICB9XG5cbiAgdmFyIHJlYWR5U3RhdGVDaGVja0ludGVydmFsID0gc2V0SW50ZXJ2YWwoY2hlY2tSZWFkeSwgMTAwKTsgLy8gdGhpcyBhZGRzIGJvZHltb3ZpbiB0byB0aGUgd2luZG93IG9iamVjdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuICB0cnkge1xuICAgIGlmICghKCh0eXBlb2YgZXhwb3J0cyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mJDMoZXhwb3J0cykpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgJiYgISh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICApIHtcbiAgICAgIHdpbmRvdy5ib2R5bW92aW4gPSBsb3R0aWU7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHsvL1xuICB9XG5cbiAgdmFyIFNoYXBlTW9kaWZpZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYiA9IHt9O1xuICAgIHZhciBtb2RpZmllcnMgPSB7fTtcbiAgICBvYi5yZWdpc3Rlck1vZGlmaWVyID0gcmVnaXN0ZXJNb2RpZmllcjtcbiAgICBvYi5nZXRNb2RpZmllciA9IGdldE1vZGlmaWVyO1xuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJNb2RpZmllcihubSwgZmFjdG9yeSkge1xuICAgICAgaWYgKCFtb2RpZmllcnNbbm1dKSB7XG4gICAgICAgIG1vZGlmaWVyc1tubV0gPSBmYWN0b3J5O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE1vZGlmaWVyKG5tLCBlbGVtLCBkYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IG1vZGlmaWVyc1tubV0oZWxlbSwgZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gU2hhcGVNb2RpZmllcigpIHt9XG5cbiAgU2hhcGVNb2RpZmllci5wcm90b3R5cGUuaW5pdE1vZGlmaWVyUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIFNoYXBlTW9kaWZpZXIucHJvdG90eXBlLmFkZFNoYXBlVG9Nb2RpZmllciA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIFNoYXBlTW9kaWZpZXIucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuY2xvc2VkKSB7XG4gICAgICAvLyBBZGRpbmcgc2hhcGUgdG8gZHluYW1pYyBwcm9wZXJ0aWVzLiBJdCBjb3ZlcnMgdGhlIGNhc2Ugd2hlcmUgYSBzaGFwZSBoYXMgbm8gZWZmZWN0cyBhcHBsaWVkLCB0byByZXNldCBpdCdzIF9tZGYgc3RhdGUgb24gZXZlcnkgdGljay5cbiAgICAgIGRhdGEuc2guY29udGFpbmVyLmFkZER5bmFtaWNQcm9wZXJ0eShkYXRhLnNoKTtcbiAgICAgIHZhciBzaGFwZURhdGEgPSB7XG4gICAgICAgIHNoYXBlOiBkYXRhLnNoLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbjogc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKVxuICAgICAgfTtcbiAgICAgIHRoaXMuc2hhcGVzLnB1c2goc2hhcGVEYXRhKTtcbiAgICAgIHRoaXMuYWRkU2hhcGVUb01vZGlmaWVyKHNoYXBlRGF0YSk7XG5cbiAgICAgIGlmICh0aGlzLl9pc0FuaW1hdGVkKSB7XG4gICAgICAgIGRhdGEuc2V0QXNBbmltYXRlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTaGFwZU1vZGlmaWVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLnNoYXBlcyA9IFtdO1xuICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICAgIHRoaXMuaW5pdE1vZGlmaWVyUHJvcGVydGllcyhlbGVtLCBkYXRhKTtcbiAgICB0aGlzLmZyYW1lSWQgPSBpbml0aWFsRGVmYXVsdEZyYW1lO1xuICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5rID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuayA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2V0VmFsdWUodHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIFNoYXBlTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NLZXlzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xuICAgIHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCk7XG4gIH07XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBTaGFwZU1vZGlmaWVyKTtcblxuICBmdW5jdGlvbiBUcmltTW9kaWZpZXIoKSB7fVxuXG4gIGV4dGVuZFByb3RvdHlwZShbU2hhcGVNb2RpZmllcl0sIFRyaW1Nb2RpZmllcik7XG5cbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLnMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnMsIDAsIDAuMDEsIHRoaXMpO1xuICAgIHRoaXMuZSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuZSwgMCwgMC4wMSwgdGhpcyk7XG4gICAgdGhpcy5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5vLCAwLCAwLCB0aGlzKTtcbiAgICB0aGlzLnNWYWx1ZSA9IDA7XG4gICAgdGhpcy5lVmFsdWUgPSAwO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLnByb2Nlc3NLZXlzO1xuICAgIHRoaXMubSA9IGRhdGEubTtcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLnMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCB8fCAhIXRoaXMuZS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoIHx8ICEhdGhpcy5vLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGg7XG4gIH07XG5cbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5hZGRTaGFwZVRvTW9kaWZpZXIgPSBmdW5jdGlvbiAoc2hhcGVEYXRhKSB7XG4gICAgc2hhcGVEYXRhLnBhdGhzRGF0YSA9IFtdO1xuICB9O1xuXG4gIFRyaW1Nb2RpZmllci5wcm90b3R5cGUuY2FsY3VsYXRlU2hhcGVFZGdlcyA9IGZ1bmN0aW9uIChzLCBlLCBzaGFwZUxlbmd0aCwgYWRkZWRMZW5ndGgsIHRvdGFsTW9kaWZpZXJMZW5ndGgpIHtcbiAgICB2YXIgc2VnbWVudHMgPSBbXTtcblxuICAgIGlmIChlIDw9IDEpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICBzOiBzLFxuICAgICAgICBlOiBlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHMgPj0gMSkge1xuICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgIHM6IHMgLSAxLFxuICAgICAgICBlOiBlIC0gMVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICBzOiBzLFxuICAgICAgICBlOiAxXG4gICAgICB9KTtcbiAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICBzOiAwLFxuICAgICAgICBlOiBlIC0gMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHNoYXBlU2VnbWVudHMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gc2VnbWVudHMubGVuZ3RoO1xuICAgIHZhciBzZWdtZW50T2I7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHNlZ21lbnRPYiA9IHNlZ21lbnRzW2ldO1xuXG4gICAgICBpZiAoIShzZWdtZW50T2IuZSAqIHRvdGFsTW9kaWZpZXJMZW5ndGggPCBhZGRlZExlbmd0aCB8fCBzZWdtZW50T2IucyAqIHRvdGFsTW9kaWZpZXJMZW5ndGggPiBhZGRlZExlbmd0aCArIHNoYXBlTGVuZ3RoKSkge1xuICAgICAgICB2YXIgc2hhcGVTO1xuICAgICAgICB2YXIgc2hhcGVFO1xuXG4gICAgICAgIGlmIChzZWdtZW50T2IucyAqIHRvdGFsTW9kaWZpZXJMZW5ndGggPD0gYWRkZWRMZW5ndGgpIHtcbiAgICAgICAgICBzaGFwZVMgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNoYXBlUyA9IChzZWdtZW50T2IucyAqIHRvdGFsTW9kaWZpZXJMZW5ndGggLSBhZGRlZExlbmd0aCkgLyBzaGFwZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWdtZW50T2IuZSAqIHRvdGFsTW9kaWZpZXJMZW5ndGggPj0gYWRkZWRMZW5ndGggKyBzaGFwZUxlbmd0aCkge1xuICAgICAgICAgIHNoYXBlRSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hhcGVFID0gKHNlZ21lbnRPYi5lICogdG90YWxNb2RpZmllckxlbmd0aCAtIGFkZGVkTGVuZ3RoKSAvIHNoYXBlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgc2hhcGVTZWdtZW50cy5wdXNoKFtzaGFwZVMsIHNoYXBlRV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2hhcGVTZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHNoYXBlU2VnbWVudHMucHVzaChbMCwgMF0pO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFwZVNlZ21lbnRzO1xuICB9O1xuXG4gIFRyaW1Nb2RpZmllci5wcm90b3R5cGUucmVsZWFzZVBhdGhzRGF0YSA9IGZ1bmN0aW9uIChwYXRoc0RhdGEpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gcGF0aHNEYXRhLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgc2VnbWVudHNMZW5ndGhQb29sLnJlbGVhc2UocGF0aHNEYXRhW2ldKTtcbiAgICB9XG5cbiAgICBwYXRoc0RhdGEubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gcGF0aHNEYXRhO1xuICB9O1xuXG4gIFRyaW1Nb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1NoYXBlcyA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XG4gICAgdmFyIHM7XG4gICAgdmFyIGU7XG5cbiAgICBpZiAodGhpcy5fbWRmIHx8IF9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBvID0gdGhpcy5vLnYgJSAzNjAgLyAzNjA7XG5cbiAgICAgIGlmIChvIDwgMCkge1xuICAgICAgICBvICs9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnMudiA+IDEpIHtcbiAgICAgICAgcyA9IDEgKyBvO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnMudiA8IDApIHtcbiAgICAgICAgcyA9IDAgKyBvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcyA9IHRoaXMucy52ICsgbztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZS52ID4gMSkge1xuICAgICAgICBlID0gMSArIG87XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZS52IDwgMCkge1xuICAgICAgICBlID0gMCArIG87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlID0gdGhpcy5lLnYgKyBvO1xuICAgICAgfVxuXG4gICAgICBpZiAocyA+IGUpIHtcbiAgICAgICAgdmFyIF9zID0gcztcbiAgICAgICAgcyA9IGU7XG4gICAgICAgIGUgPSBfcztcbiAgICAgIH1cblxuICAgICAgcyA9IE1hdGgucm91bmQocyAqIDEwMDAwKSAqIDAuMDAwMTtcbiAgICAgIGUgPSBNYXRoLnJvdW5kKGUgKiAxMDAwMCkgKiAwLjAwMDE7XG4gICAgICB0aGlzLnNWYWx1ZSA9IHM7XG4gICAgICB0aGlzLmVWYWx1ZSA9IGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSB0aGlzLnNWYWx1ZTtcbiAgICAgIGUgPSB0aGlzLmVWYWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgc2hhcGVQYXRocztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5zaGFwZXMubGVuZ3RoO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBwYXRoc0RhdGE7XG4gICAgdmFyIHBhdGhEYXRhO1xuICAgIHZhciB0b3RhbFNoYXBlTGVuZ3RoO1xuICAgIHZhciB0b3RhbE1vZGlmaWVyTGVuZ3RoID0gMDtcblxuICAgIGlmIChlID09PSBzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5zaGFwZXNbaV0ubG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xuICAgICAgICB0aGlzLnNoYXBlc1tpXS5zaGFwZS5fbWRmID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zaGFwZXNbaV0uc2hhcGUucGF0aHMgPSB0aGlzLnNoYXBlc1tpXS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcblxuICAgICAgICBpZiAodGhpcy5fbWRmKSB7XG4gICAgICAgICAgdGhpcy5zaGFwZXNbaV0ucGF0aHNEYXRhLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoZSA9PT0gMSAmJiBzID09PSAwIHx8IGUgPT09IDAgJiYgcyA9PT0gMSkpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgICAgdmFyIHNoYXBlRGF0YTtcbiAgICAgIHZhciBsb2NhbFNoYXBlQ29sbGVjdGlvbjtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHNoYXBlRGF0YSA9IHRoaXMuc2hhcGVzW2ldOyAvLyBpZiBzaGFwZSBoYXNuJ3QgY2hhbmdlZCBhbmQgdHJpbSBwcm9wZXJ0aWVzIGhhdmVuJ3QgY2hhbmdlZCwgY2FjaGVkIHByZXZpb3VzIHBhdGggY2FuIGJlIHVzZWRcblxuICAgICAgICBpZiAoIXNoYXBlRGF0YS5zaGFwZS5fbWRmICYmICF0aGlzLl9tZGYgJiYgIV9pc0ZpcnN0RnJhbWUgJiYgdGhpcy5tICE9PSAyKSB7XG4gICAgICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNoYXBlUGF0aHMgPSBzaGFwZURhdGEuc2hhcGUucGF0aHM7XG4gICAgICAgICAgakxlbiA9IHNoYXBlUGF0aHMuX2xlbmd0aDtcbiAgICAgICAgICB0b3RhbFNoYXBlTGVuZ3RoID0gMDtcblxuICAgICAgICAgIGlmICghc2hhcGVEYXRhLnNoYXBlLl9tZGYgJiYgc2hhcGVEYXRhLnBhdGhzRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRvdGFsU2hhcGVMZW5ndGggPSBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aHNEYXRhID0gdGhpcy5yZWxlYXNlUGF0aHNEYXRhKHNoYXBlRGF0YS5wYXRoc0RhdGEpO1xuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICAgIHBhdGhEYXRhID0gYmV6LmdldFNlZ21lbnRzTGVuZ3RoKHNoYXBlUGF0aHMuc2hhcGVzW2pdKTtcbiAgICAgICAgICAgICAgcGF0aHNEYXRhLnB1c2gocGF0aERhdGEpO1xuICAgICAgICAgICAgICB0b3RhbFNoYXBlTGVuZ3RoICs9IHBhdGhEYXRhLnRvdGFsTGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aCA9IHRvdGFsU2hhcGVMZW5ndGg7XG4gICAgICAgICAgICBzaGFwZURhdGEucGF0aHNEYXRhID0gcGF0aHNEYXRhO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvdGFsTW9kaWZpZXJMZW5ndGggKz0gdG90YWxTaGFwZUxlbmd0aDtcbiAgICAgICAgICBzaGFwZURhdGEuc2hhcGUuX21kZiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNoYXBlUyA9IHM7XG4gICAgICB2YXIgc2hhcGVFID0gZTtcbiAgICAgIHZhciBhZGRlZExlbmd0aCA9IDA7XG4gICAgICB2YXIgZWRnZXM7XG5cbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHNoYXBlRGF0YSA9IHRoaXMuc2hhcGVzW2ldO1xuXG4gICAgICAgIGlmIChzaGFwZURhdGEuc2hhcGUuX21kZikge1xuICAgICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uLnJlbGVhc2VTaGFwZXMoKTsgLy8gaWYgbSA9PT0gMiBtZWFucyBwYXRocyBhcmUgdHJpbW1lZCBpbmRpdmlkdWFsbHkgc28gZWRnZXMgbmVlZCB0byBiZSBmb3VuZCBmb3IgdGhpcyBzcGVjaWZpYyBzaGFwZSByZWxhdGl2ZSB0byB3aG9lbCBncm91cFxuXG4gICAgICAgICAgaWYgKHRoaXMubSA9PT0gMiAmJiBsZW4gPiAxKSB7XG4gICAgICAgICAgICBlZGdlcyA9IHRoaXMuY2FsY3VsYXRlU2hhcGVFZGdlcyhzLCBlLCBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aCwgYWRkZWRMZW5ndGgsIHRvdGFsTW9kaWZpZXJMZW5ndGgpO1xuICAgICAgICAgICAgYWRkZWRMZW5ndGggKz0gc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVkZ2VzID0gW1tzaGFwZVMsIHNoYXBlRV1dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGpMZW4gPSBlZGdlcy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBzaGFwZVMgPSBlZGdlc1tqXVswXTtcbiAgICAgICAgICAgIHNoYXBlRSA9IGVkZ2VzW2pdWzFdO1xuICAgICAgICAgICAgc2VnbWVudHMubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgaWYgKHNoYXBlRSA8PSAxKSB7XG4gICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHM6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogc2hhcGVTLFxuICAgICAgICAgICAgICAgIGU6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogc2hhcGVFXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZVMgPj0gMSkge1xuICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzOiBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aCAqIChzaGFwZVMgLSAxKSxcbiAgICAgICAgICAgICAgICBlOiBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aCAqIChzaGFwZUUgLSAxKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHM6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogc2hhcGVTLFxuICAgICAgICAgICAgICAgIGU6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzOiAwLFxuICAgICAgICAgICAgICAgIGU6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogKHNoYXBlRSAtIDEpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV3U2hhcGVzRGF0YSA9IHRoaXMuYWRkU2hhcGVzKHNoYXBlRGF0YSwgc2VnbWVudHNbMF0pO1xuXG4gICAgICAgICAgICBpZiAoc2VnbWVudHNbMF0ucyAhPT0gc2VnbWVudHNbMF0uZSkge1xuICAgICAgICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0U2hhcGVJbkNvbGxlY3Rpb24gPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuc2hhcGVzW3NoYXBlRGF0YS5zaGFwZS5wYXRocy5fbGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgICAgICBpZiAobGFzdFNoYXBlSW5Db2xsZWN0aW9uLmMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBsYXN0U2hhcGUgPSBuZXdTaGFwZXNEYXRhLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5hZGRQYXRocyhuZXdTaGFwZXNEYXRhLCBsb2NhbFNoYXBlQ29sbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgICBuZXdTaGFwZXNEYXRhID0gdGhpcy5hZGRTaGFwZXMoc2hhcGVEYXRhLCBzZWdtZW50c1sxXSwgbGFzdFNoYXBlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hZGRQYXRocyhuZXdTaGFwZXNEYXRhLCBsb2NhbFNoYXBlQ29sbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgICBuZXdTaGFwZXNEYXRhID0gdGhpcy5hZGRTaGFwZXMoc2hhcGVEYXRhLCBzZWdtZW50c1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5hZGRQYXRocyhuZXdTaGFwZXNEYXRhLCBsb2NhbFNoYXBlQ29sbGVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gbG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX21kZikge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIC8vIFJlbGVhc2lnbiBUcmltIENhY2hlZCBwYXRocyBkYXRhIHdoZW4gbm8gdHJpbSBhcHBsaWVkIGluIGNhc2Ugc2hhcGVzIGFyZSBtb2RpZmllZCBpbmJldHdlZW4uXG4gICAgICAgIC8vIERvbid0IHJlbW92ZSB0aGlzIGV2ZW4gaWYgaXQncyBsb3NpbmcgY2FjaGVkIGluZm8uXG4gICAgICAgIHRoaXMuc2hhcGVzW2ldLnBhdGhzRGF0YS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnNoYXBlc1tpXS5zaGFwZS5fbWRmID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5hZGRQYXRocyA9IGZ1bmN0aW9uIChuZXdQYXRocywgbG9jYWxTaGFwZUNvbGxlY3Rpb24pIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gbmV3UGF0aHMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZShuZXdQYXRoc1tpXSk7XG4gICAgfVxuICB9O1xuXG4gIFRyaW1Nb2RpZmllci5wcm90b3R5cGUuYWRkU2VnbWVudCA9IGZ1bmN0aW9uIChwdDEsIHB0MiwgcHQzLCBwdDQsIHNoYXBlUGF0aCwgcG9zLCBuZXdTaGFwZSkge1xuICAgIHNoYXBlUGF0aC5zZXRYWUF0KHB0MlswXSwgcHQyWzFdLCAnbycsIHBvcyk7XG4gICAgc2hhcGVQYXRoLnNldFhZQXQocHQzWzBdLCBwdDNbMV0sICdpJywgcG9zICsgMSk7XG5cbiAgICBpZiAobmV3U2hhcGUpIHtcbiAgICAgIHNoYXBlUGF0aC5zZXRYWUF0KHB0MVswXSwgcHQxWzFdLCAndicsIHBvcyk7XG4gICAgfVxuXG4gICAgc2hhcGVQYXRoLnNldFhZQXQocHQ0WzBdLCBwdDRbMV0sICd2JywgcG9zICsgMSk7XG4gIH07XG5cbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5hZGRTZWdtZW50RnJvbUFycmF5ID0gZnVuY3Rpb24gKHBvaW50cywgc2hhcGVQYXRoLCBwb3MsIG5ld1NoYXBlKSB7XG4gICAgc2hhcGVQYXRoLnNldFhZQXQocG9pbnRzWzFdLCBwb2ludHNbNV0sICdvJywgcG9zKTtcbiAgICBzaGFwZVBhdGguc2V0WFlBdChwb2ludHNbMl0sIHBvaW50c1s2XSwgJ2knLCBwb3MgKyAxKTtcblxuICAgIGlmIChuZXdTaGFwZSkge1xuICAgICAgc2hhcGVQYXRoLnNldFhZQXQocG9pbnRzWzBdLCBwb2ludHNbNF0sICd2JywgcG9zKTtcbiAgICB9XG5cbiAgICBzaGFwZVBhdGguc2V0WFlBdChwb2ludHNbM10sIHBvaW50c1s3XSwgJ3YnLCBwb3MgKyAxKTtcbiAgfTtcblxuICBUcmltTW9kaWZpZXIucHJvdG90eXBlLmFkZFNoYXBlcyA9IGZ1bmN0aW9uIChzaGFwZURhdGEsIHNoYXBlU2VnbWVudCwgc2hhcGVQYXRoKSB7XG4gICAgdmFyIHBhdGhzRGF0YSA9IHNoYXBlRGF0YS5wYXRoc0RhdGE7XG4gICAgdmFyIHNoYXBlUGF0aHMgPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuc2hhcGVzO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuX2xlbmd0aDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgYWRkZWRMZW5ndGggPSAwO1xuICAgIHZhciBjdXJyZW50TGVuZ3RoRGF0YTtcbiAgICB2YXIgc2VnbWVudENvdW50O1xuICAgIHZhciBsZW5ndGhzO1xuICAgIHZhciBzZWdtZW50O1xuICAgIHZhciBzaGFwZXMgPSBbXTtcbiAgICB2YXIgaW5pdFBvcztcbiAgICB2YXIgbmV3U2hhcGUgPSB0cnVlO1xuXG4gICAgaWYgKCFzaGFwZVBhdGgpIHtcbiAgICAgIHNoYXBlUGF0aCA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICBzZWdtZW50Q291bnQgPSAwO1xuICAgICAgaW5pdFBvcyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlZ21lbnRDb3VudCA9IHNoYXBlUGF0aC5fbGVuZ3RoO1xuICAgICAgaW5pdFBvcyA9IHNoYXBlUGF0aC5fbGVuZ3RoO1xuICAgIH1cblxuICAgIHNoYXBlcy5wdXNoKHNoYXBlUGF0aCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGxlbmd0aHMgPSBwYXRoc0RhdGFbaV0ubGVuZ3RocztcbiAgICAgIHNoYXBlUGF0aC5jID0gc2hhcGVQYXRoc1tpXS5jO1xuICAgICAgakxlbiA9IHNoYXBlUGF0aHNbaV0uYyA/IGxlbmd0aHMubGVuZ3RoIDogbGVuZ3Rocy5sZW5ndGggKyAxO1xuXG4gICAgICBmb3IgKGogPSAxOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgIGN1cnJlbnRMZW5ndGhEYXRhID0gbGVuZ3Roc1tqIC0gMV07XG5cbiAgICAgICAgaWYgKGFkZGVkTGVuZ3RoICsgY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGggPCBzaGFwZVNlZ21lbnQucykge1xuICAgICAgICAgIGFkZGVkTGVuZ3RoICs9IGN1cnJlbnRMZW5ndGhEYXRhLmFkZGVkTGVuZ3RoO1xuICAgICAgICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoYWRkZWRMZW5ndGggPiBzaGFwZVNlZ21lbnQuZSkge1xuICAgICAgICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNoYXBlU2VnbWVudC5zIDw9IGFkZGVkTGVuZ3RoICYmIHNoYXBlU2VnbWVudC5lID49IGFkZGVkTGVuZ3RoICsgY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLm9baiAtIDFdLCBzaGFwZVBhdGhzW2ldLmlbal0sIHNoYXBlUGF0aHNbaV0udltqXSwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcbiAgICAgICAgICAgIG5ld1NoYXBlID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBiZXouZ2V0TmV3U2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLnZbal0sIHNoYXBlUGF0aHNbaV0ub1tqIC0gMV0sIHNoYXBlUGF0aHNbaV0uaVtqXSwgKHNoYXBlU2VnbWVudC5zIC0gYWRkZWRMZW5ndGgpIC8gY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGgsIChzaGFwZVNlZ21lbnQuZSAtIGFkZGVkTGVuZ3RoKSAvIGN1cnJlbnRMZW5ndGhEYXRhLmFkZGVkTGVuZ3RoLCBsZW5ndGhzW2ogLSAxXSk7XG4gICAgICAgICAgICB0aGlzLmFkZFNlZ21lbnRGcm9tQXJyYXkoc2VnbWVudCwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTsgLy8gdGhpcy5hZGRTZWdtZW50KHNlZ21lbnQucHQxLCBzZWdtZW50LnB0Mywgc2VnbWVudC5wdDQsIHNlZ21lbnQucHQyLCBzaGFwZVBhdGgsIHNlZ21lbnRDb3VudCwgbmV3U2hhcGUpO1xuXG4gICAgICAgICAgICBuZXdTaGFwZSA9IGZhbHNlO1xuICAgICAgICAgICAgc2hhcGVQYXRoLmMgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhZGRlZExlbmd0aCArPSBjdXJyZW50TGVuZ3RoRGF0YS5hZGRlZExlbmd0aDtcbiAgICAgICAgICBzZWdtZW50Q291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2hhcGVQYXRoc1tpXS5jICYmIGxlbmd0aHMubGVuZ3RoKSB7XG4gICAgICAgIGN1cnJlbnRMZW5ndGhEYXRhID0gbGVuZ3Roc1tqIC0gMV07XG5cbiAgICAgICAgaWYgKGFkZGVkTGVuZ3RoIDw9IHNoYXBlU2VnbWVudC5lKSB7XG4gICAgICAgICAgdmFyIHNlZ21lbnRMZW5ndGggPSBsZW5ndGhzW2ogLSAxXS5hZGRlZExlbmd0aDtcblxuICAgICAgICAgIGlmIChzaGFwZVNlZ21lbnQucyA8PSBhZGRlZExlbmd0aCAmJiBzaGFwZVNlZ21lbnQuZSA+PSBhZGRlZExlbmd0aCArIHNlZ21lbnRMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLm9baiAtIDFdLCBzaGFwZVBhdGhzW2ldLmlbMF0sIHNoYXBlUGF0aHNbaV0udlswXSwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcbiAgICAgICAgICAgIG5ld1NoYXBlID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBiZXouZ2V0TmV3U2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLnZbMF0sIHNoYXBlUGF0aHNbaV0ub1tqIC0gMV0sIHNoYXBlUGF0aHNbaV0uaVswXSwgKHNoYXBlU2VnbWVudC5zIC0gYWRkZWRMZW5ndGgpIC8gc2VnbWVudExlbmd0aCwgKHNoYXBlU2VnbWVudC5lIC0gYWRkZWRMZW5ndGgpIC8gc2VnbWVudExlbmd0aCwgbGVuZ3Roc1tqIC0gMV0pO1xuICAgICAgICAgICAgdGhpcy5hZGRTZWdtZW50RnJvbUFycmF5KHNlZ21lbnQsIHNoYXBlUGF0aCwgc2VnbWVudENvdW50LCBuZXdTaGFwZSk7IC8vIHRoaXMuYWRkU2VnbWVudChzZWdtZW50LnB0MSwgc2VnbWVudC5wdDMsIHNlZ21lbnQucHQ0LCBzZWdtZW50LnB0Miwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcblxuICAgICAgICAgICAgbmV3U2hhcGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBhZGRlZExlbmd0aCArPSBjdXJyZW50TGVuZ3RoRGF0YS5hZGRlZExlbmd0aDtcbiAgICAgICAgc2VnbWVudENvdW50ICs9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaGFwZVBhdGguX2xlbmd0aCkge1xuICAgICAgICBzaGFwZVBhdGguc2V0WFlBdChzaGFwZVBhdGgudltpbml0UG9zXVswXSwgc2hhcGVQYXRoLnZbaW5pdFBvc11bMV0sICdpJywgaW5pdFBvcyk7XG4gICAgICAgIHNoYXBlUGF0aC5zZXRYWUF0KHNoYXBlUGF0aC52W3NoYXBlUGF0aC5fbGVuZ3RoIC0gMV1bMF0sIHNoYXBlUGF0aC52W3NoYXBlUGF0aC5fbGVuZ3RoIC0gMV1bMV0sICdvJywgc2hhcGVQYXRoLl9sZW5ndGggLSAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZGVkTGVuZ3RoID4gc2hhcGVTZWdtZW50LmUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChpIDwgbGVuIC0gMSkge1xuICAgICAgICBzaGFwZVBhdGggPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xuICAgICAgICBuZXdTaGFwZSA9IHRydWU7XG4gICAgICAgIHNoYXBlcy5wdXNoKHNoYXBlUGF0aCk7XG4gICAgICAgIHNlZ21lbnRDb3VudCA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYXBlcztcbiAgfTtcblxuICBmdW5jdGlvbiBQdWNrZXJBbmRCbG9hdE1vZGlmaWVyKCkge31cblxuICBleHRlbmRQcm90b3R5cGUoW1NoYXBlTW9kaWZpZXJdLCBQdWNrZXJBbmRCbG9hdE1vZGlmaWVyKTtcblxuICBQdWNrZXJBbmRCbG9hdE1vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5wcm9jZXNzS2V5cztcbiAgICB0aGlzLmFtb3VudCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuYSwgMCwgbnVsbCwgdGhpcyk7XG4gICAgdGhpcy5faXNBbmltYXRlZCA9ICEhdGhpcy5hbW91bnQuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcbiAgfTtcblxuICBQdWNrZXJBbmRCbG9hdE1vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBhbW91bnQpIHtcbiAgICB2YXIgcGVyY2VudCA9IGFtb3VudCAvIDEwMDtcbiAgICB2YXIgY2VudGVyUG9pbnQgPSBbMCwgMF07XG4gICAgdmFyIHBhdGhMZW5ndGggPSBwYXRoLl9sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGhMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2VudGVyUG9pbnRbMF0gKz0gcGF0aC52W2ldWzBdO1xuICAgICAgY2VudGVyUG9pbnRbMV0gKz0gcGF0aC52W2ldWzFdO1xuICAgIH1cblxuICAgIGNlbnRlclBvaW50WzBdIC89IHBhdGhMZW5ndGg7XG4gICAgY2VudGVyUG9pbnRbMV0gLz0gcGF0aExlbmd0aDtcbiAgICB2YXIgY2xvbmVkUGF0aCA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgY2xvbmVkUGF0aC5jID0gcGF0aC5jO1xuICAgIHZhciB2WDtcbiAgICB2YXIgdlk7XG4gICAgdmFyIG9YO1xuICAgIHZhciBvWTtcbiAgICB2YXIgaVg7XG4gICAgdmFyIGlZO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGhMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdlggPSBwYXRoLnZbaV1bMF0gKyAoY2VudGVyUG9pbnRbMF0gLSBwYXRoLnZbaV1bMF0pICogcGVyY2VudDtcbiAgICAgIHZZID0gcGF0aC52W2ldWzFdICsgKGNlbnRlclBvaW50WzFdIC0gcGF0aC52W2ldWzFdKSAqIHBlcmNlbnQ7XG4gICAgICBvWCA9IHBhdGgub1tpXVswXSArIChjZW50ZXJQb2ludFswXSAtIHBhdGgub1tpXVswXSkgKiAtcGVyY2VudDtcbiAgICAgIG9ZID0gcGF0aC5vW2ldWzFdICsgKGNlbnRlclBvaW50WzFdIC0gcGF0aC5vW2ldWzFdKSAqIC1wZXJjZW50O1xuICAgICAgaVggPSBwYXRoLmlbaV1bMF0gKyAoY2VudGVyUG9pbnRbMF0gLSBwYXRoLmlbaV1bMF0pICogLXBlcmNlbnQ7XG4gICAgICBpWSA9IHBhdGguaVtpXVsxXSArIChjZW50ZXJQb2ludFsxXSAtIHBhdGguaVtpXVsxXSkgKiAtcGVyY2VudDtcbiAgICAgIGNsb25lZFBhdGguc2V0VHJpcGxlQXQodlgsIHZZLCBvWCwgb1ksIGlYLCBpWSwgaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lZFBhdGg7XG4gIH07XG5cbiAgUHVja2VyQW5kQmxvYXRNb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1NoYXBlcyA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XG4gICAgdmFyIHNoYXBlUGF0aHM7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc2hhcGVzLmxlbmd0aDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgYW1vdW50ID0gdGhpcy5hbW91bnQudjtcblxuICAgIGlmIChhbW91bnQgIT09IDApIHtcbiAgICAgIHZhciBzaGFwZURhdGE7XG4gICAgICB2YXIgbG9jYWxTaGFwZUNvbGxlY3Rpb247XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBzaGFwZURhdGEgPSB0aGlzLnNoYXBlc1tpXTtcbiAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZURhdGEubG9jYWxTaGFwZUNvbGxlY3Rpb247XG5cbiAgICAgICAgaWYgKCEoIXNoYXBlRGF0YS5zaGFwZS5fbWRmICYmICF0aGlzLl9tZGYgJiYgIV9pc0ZpcnN0RnJhbWUpKSB7XG4gICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xuICAgICAgICAgIHNoYXBlRGF0YS5zaGFwZS5fbWRmID0gdHJ1ZTtcbiAgICAgICAgICBzaGFwZVBhdGhzID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLnNoYXBlcztcbiAgICAgICAgICBqTGVuID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLl9sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnByb2Nlc3NQYXRoKHNoYXBlUGF0aHNbal0sIGFtb3VudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNoYXBlRGF0YS5zaGFwZS5wYXRocyA9IHNoYXBlRGF0YS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGVmYXVsdFZlY3RvciA9IFswLCAwXTtcblxuICAgIGZ1bmN0aW9uIGFwcGx5VG9NYXRyaXgobWF0KSB7XG4gICAgICB2YXIgX21kZiA9IHRoaXMuX21kZjtcbiAgICAgIHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCk7XG4gICAgICB0aGlzLl9tZGYgPSB0aGlzLl9tZGYgfHwgX21kZjtcblxuICAgICAgaWYgKHRoaXMuYSkge1xuICAgICAgICBtYXQudHJhbnNsYXRlKC10aGlzLmEudlswXSwgLXRoaXMuYS52WzFdLCB0aGlzLmEudlsyXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnMpIHtcbiAgICAgICAgbWF0LnNjYWxlKHRoaXMucy52WzBdLCB0aGlzLnMudlsxXSwgdGhpcy5zLnZbMl0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaykge1xuICAgICAgICBtYXQuc2tld0Zyb21BeGlzKC10aGlzLnNrLnYsIHRoaXMuc2Eudik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnIpIHtcbiAgICAgICAgbWF0LnJvdGF0ZSgtdGhpcy5yLnYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0LnJvdGF0ZVooLXRoaXMucnoudikucm90YXRlWSh0aGlzLnJ5LnYpLnJvdGF0ZVgodGhpcy5yeC52KS5yb3RhdGVaKC10aGlzLm9yLnZbMl0pLnJvdGF0ZVkodGhpcy5vci52WzFdKS5yb3RhdGVYKHRoaXMub3IudlswXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRhdGEucC5zKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEucC56KSB7XG4gICAgICAgICAgbWF0LnRyYW5zbGF0ZSh0aGlzLnB4LnYsIHRoaXMucHkudiwgLXRoaXMucHoudik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0LnRyYW5zbGF0ZSh0aGlzLnB4LnYsIHRoaXMucHkudiwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdC50cmFuc2xhdGUodGhpcy5wLnZbMF0sIHRoaXMucC52WzFdLCAtdGhpcy5wLnZbMl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NLZXlzKGZvcmNlUmVuZGVyKSB7XG4gICAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzRGlydHkpIHtcbiAgICAgICAgdGhpcy5wcmVjYWxjdWxhdGVNYXRyaXgoKTtcbiAgICAgICAgdGhpcy5faXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xuXG4gICAgICBpZiAodGhpcy5fbWRmIHx8IGZvcmNlUmVuZGVyKSB7XG4gICAgICAgIHZhciBmcmFtZVJhdGU7XG4gICAgICAgIHRoaXMudi5jbG9uZUZyb21Qcm9wcyh0aGlzLnByZS5wcm9wcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDEpIHtcbiAgICAgICAgICB0aGlzLnYudHJhbnNsYXRlKC10aGlzLmEudlswXSwgLXRoaXMuYS52WzFdLCB0aGlzLmEudlsyXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgMikge1xuICAgICAgICAgIHRoaXMudi5zY2FsZSh0aGlzLnMudlswXSwgdGhpcy5zLnZbMV0sIHRoaXMucy52WzJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNrICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDMpIHtcbiAgICAgICAgICB0aGlzLnYuc2tld0Zyb21BeGlzKC10aGlzLnNrLnYsIHRoaXMuc2Eudik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5yICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDQpIHtcbiAgICAgICAgICB0aGlzLnYucm90YXRlKC10aGlzLnIudik7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuciAmJiB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCA0KSB7XG4gICAgICAgICAgdGhpcy52LnJvdGF0ZVooLXRoaXMucnoudikucm90YXRlWSh0aGlzLnJ5LnYpLnJvdGF0ZVgodGhpcy5yeC52KS5yb3RhdGVaKC10aGlzLm9yLnZbMl0pLnJvdGF0ZVkodGhpcy5vci52WzFdKS5yb3RhdGVYKHRoaXMub3IudlswXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hdXRvT3JpZW50ZWQpIHtcbiAgICAgICAgICB2YXIgdjE7XG4gICAgICAgICAgdmFyIHYyO1xuICAgICAgICAgIGZyYW1lUmF0ZSA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcblxuICAgICAgICAgIGlmICh0aGlzLnAgJiYgdGhpcy5wLmtleWZyYW1lcyAmJiB0aGlzLnAuZ2V0VmFsdWVBdFRpbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnAuX2NhY2hpbmcubGFzdEZyYW1lICsgdGhpcy5wLm9mZnNldFRpbWUgPD0gdGhpcy5wLmtleWZyYW1lc1swXS50KSB7XG4gICAgICAgICAgICAgIHYxID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKCh0aGlzLnAua2V5ZnJhbWVzWzBdLnQgKyAwLjAxKSAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICAgIHYyID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKHRoaXMucC5rZXlmcmFtZXNbMF0udCAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucC5fY2FjaGluZy5sYXN0RnJhbWUgKyB0aGlzLnAub2Zmc2V0VGltZSA+PSB0aGlzLnAua2V5ZnJhbWVzW3RoaXMucC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCkge1xuICAgICAgICAgICAgICB2MSA9IHRoaXMucC5nZXRWYWx1ZUF0VGltZSh0aGlzLnAua2V5ZnJhbWVzW3RoaXMucC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICAgIHYyID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKCh0aGlzLnAua2V5ZnJhbWVzW3RoaXMucC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAtIDAuMDUpIC8gZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHYxID0gdGhpcy5wLnB2O1xuICAgICAgICAgICAgICB2MiA9IHRoaXMucC5nZXRWYWx1ZUF0VGltZSgodGhpcy5wLl9jYWNoaW5nLmxhc3RGcmFtZSArIHRoaXMucC5vZmZzZXRUaW1lIC0gMC4wMSkgLyBmcmFtZVJhdGUsIHRoaXMucC5vZmZzZXRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHggJiYgdGhpcy5weC5rZXlmcmFtZXMgJiYgdGhpcy5weS5rZXlmcmFtZXMgJiYgdGhpcy5weC5nZXRWYWx1ZUF0VGltZSAmJiB0aGlzLnB5LmdldFZhbHVlQXRUaW1lKSB7XG4gICAgICAgICAgICB2MSA9IFtdO1xuICAgICAgICAgICAgdjIgPSBbXTtcbiAgICAgICAgICAgIHZhciBweCA9IHRoaXMucHg7XG4gICAgICAgICAgICB2YXIgcHkgPSB0aGlzLnB5O1xuXG4gICAgICAgICAgICBpZiAocHguX2NhY2hpbmcubGFzdEZyYW1lICsgcHgub2Zmc2V0VGltZSA8PSBweC5rZXlmcmFtZXNbMF0udCkge1xuICAgICAgICAgICAgICB2MVswXSA9IHB4LmdldFZhbHVlQXRUaW1lKChweC5rZXlmcmFtZXNbMF0udCArIDAuMDEpIC8gZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgICAgICAgdjFbMV0gPSBweS5nZXRWYWx1ZUF0VGltZSgocHkua2V5ZnJhbWVzWzBdLnQgKyAwLjAxKSAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICAgIHYyWzBdID0gcHguZ2V0VmFsdWVBdFRpbWUocHgua2V5ZnJhbWVzWzBdLnQgLyBmcmFtZVJhdGUsIDApO1xuICAgICAgICAgICAgICB2MlsxXSA9IHB5LmdldFZhbHVlQXRUaW1lKHB5LmtleWZyYW1lc1swXS50IC8gZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHguX2NhY2hpbmcubGFzdEZyYW1lICsgcHgub2Zmc2V0VGltZSA+PSBweC5rZXlmcmFtZXNbcHgua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQpIHtcbiAgICAgICAgICAgICAgdjFbMF0gPSBweC5nZXRWYWx1ZUF0VGltZShweC5rZXlmcmFtZXNbcHgua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQgLyBmcmFtZVJhdGUsIDApO1xuICAgICAgICAgICAgICB2MVsxXSA9IHB5LmdldFZhbHVlQXRUaW1lKHB5LmtleWZyYW1lc1tweS5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICAgIHYyWzBdID0gcHguZ2V0VmFsdWVBdFRpbWUoKHB4LmtleWZyYW1lc1tweC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAtIDAuMDEpIC8gZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgICAgICAgdjJbMV0gPSBweS5nZXRWYWx1ZUF0VGltZSgocHkua2V5ZnJhbWVzW3B5LmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC0gMC4wMSkgLyBmcmFtZVJhdGUsIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdjEgPSBbcHgucHYsIHB5LnB2XTtcbiAgICAgICAgICAgICAgdjJbMF0gPSBweC5nZXRWYWx1ZUF0VGltZSgocHguX2NhY2hpbmcubGFzdEZyYW1lICsgcHgub2Zmc2V0VGltZSAtIDAuMDEpIC8gZnJhbWVSYXRlLCBweC5vZmZzZXRUaW1lKTtcbiAgICAgICAgICAgICAgdjJbMV0gPSBweS5nZXRWYWx1ZUF0VGltZSgocHkuX2NhY2hpbmcubGFzdEZyYW1lICsgcHkub2Zmc2V0VGltZSAtIDAuMDEpIC8gZnJhbWVSYXRlLCBweS5vZmZzZXRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdjIgPSBkZWZhdWx0VmVjdG9yO1xuICAgICAgICAgICAgdjEgPSB2MjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnYucm90YXRlKC1NYXRoLmF0YW4yKHYxWzFdIC0gdjJbMV0sIHYxWzBdIC0gdjJbMF0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmRhdGEucCAmJiB0aGlzLmRhdGEucC5zKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZGF0YS5wLnopIHtcbiAgICAgICAgICAgIHRoaXMudi50cmFuc2xhdGUodGhpcy5weC52LCB0aGlzLnB5LnYsIC10aGlzLnB6LnYpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnYudHJhbnNsYXRlKHRoaXMucHgudiwgdGhpcy5weS52LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy52LnRyYW5zbGF0ZSh0aGlzLnAudlswXSwgdGhpcy5wLnZbMV0sIC10aGlzLnAudlsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVjYWxjdWxhdGVNYXRyaXgoKSB7XG4gICAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSAwO1xuICAgICAgdGhpcy5wcmUucmVzZXQoKTtcblxuICAgICAgaWYgKCF0aGlzLmEuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnByZS50cmFuc2xhdGUoLXRoaXMuYS52WzBdLCAtdGhpcy5hLnZbMV0sIHRoaXMuYS52WzJdKTtcbiAgICAgICAgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnByZS5zY2FsZSh0aGlzLnMudlswXSwgdGhpcy5zLnZbMV0sIHRoaXMucy52WzJdKTtcbiAgICAgICAgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2spIHtcbiAgICAgICAgaWYgKCF0aGlzLnNrLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggJiYgIXRoaXMuc2EuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMucHJlLnNrZXdGcm9tQXhpcygtdGhpcy5zay52LCB0aGlzLnNhLnYpO1xuICAgICAgICAgIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA9IDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnIuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMucHJlLnJvdGF0ZSgtdGhpcy5yLnYpO1xuICAgICAgICAgIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA9IDQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMucnouZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCAmJiAhdGhpcy5yeS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoICYmICF0aGlzLnJ4LmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggJiYgIXRoaXMub3IuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnByZS5yb3RhdGVaKC10aGlzLnJ6LnYpLnJvdGF0ZVkodGhpcy5yeS52KS5yb3RhdGVYKHRoaXMucngudikucm90YXRlWigtdGhpcy5vci52WzJdKS5yb3RhdGVZKHRoaXMub3IudlsxXSkucm90YXRlWCh0aGlzLm9yLnZbMF0pO1xuICAgICAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSA0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF1dG9PcmllbnQoKSB7Ly9cbiAgICAgIC8vIHZhciBwcmV2UCA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGREeW5hbWljUHJvcGVydHkocHJvcCkge1xuICAgICAgdGhpcy5fYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApO1xuXG4gICAgICB0aGlzLmVsZW0uYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApO1xuICAgICAgdGhpcy5faXNEaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtUHJvcGVydHkoZWxlbSwgZGF0YSwgY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgdGhpcy5mcmFtZUlkID0gLTE7XG4gICAgICB0aGlzLnByb3BUeXBlID0gJ3RyYW5zZm9ybSc7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgdGhpcy52ID0gbmV3IE1hdHJpeCgpOyAvLyBQcmVjYWxjdWxhdGVkIG1hdHJpeCB3aXRoIG5vbiBhbmltYXRlZCBwcm9wZXJ0aWVzXG5cbiAgICAgIHRoaXMucHJlID0gbmV3IE1hdHJpeCgpO1xuICAgICAgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zID0gMDtcbiAgICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihjb250YWluZXIgfHwgZWxlbSk7XG5cbiAgICAgIGlmIChkYXRhLnAgJiYgZGF0YS5wLnMpIHtcbiAgICAgICAgdGhpcy5weCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucC54LCAwLCAwLCB0aGlzKTtcbiAgICAgICAgdGhpcy5weSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucC55LCAwLCAwLCB0aGlzKTtcblxuICAgICAgICBpZiAoZGF0YS5wLnopIHtcbiAgICAgICAgICB0aGlzLnB6ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5wLnosIDAsIDAsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnAgfHwge1xuICAgICAgICAgIGs6IFswLCAwLCAwXVxuICAgICAgICB9LCAxLCAwLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEucngpIHtcbiAgICAgICAgdGhpcy5yeCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucngsIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgICAgIHRoaXMucnkgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnJ5LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgICAgICB0aGlzLnJ6ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yeiwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcblxuICAgICAgICBpZiAoZGF0YS5vci5rWzBdLnRpKSB7XG4gICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgdmFyIGxlbiA9IGRhdGEub3Iuay5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGRhdGEub3Iua1tpXS50byA9IG51bGw7XG4gICAgICAgICAgICBkYXRhLm9yLmtbaV0udGkgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3IgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm9yLCAxLCBkZWdUb1JhZHMsIHRoaXMpOyAvLyBzaCBJbmRpY2F0ZXMgaXQgbmVlZHMgdG8gYmUgY2FwcGVkIGJldHdlZW4gLTE4MCBhbmQgMTgwXG5cbiAgICAgICAgdGhpcy5vci5zaCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnIgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnIgfHwge1xuICAgICAgICAgIGs6IDBcbiAgICAgICAgfSwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuc2spIHtcbiAgICAgICAgdGhpcy5zayA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuc2ssIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgICAgIHRoaXMuc2EgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnNhLCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmEgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmEgfHwge1xuICAgICAgICBrOiBbMCwgMCwgMF1cbiAgICAgIH0sIDEsIDAsIHRoaXMpO1xuICAgICAgdGhpcy5zID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5zIHx8IHtcbiAgICAgICAgazogWzEwMCwgMTAwLCAxMDBdXG4gICAgICB9LCAxLCAwLjAxLCB0aGlzKTsgLy8gT3BhY2l0eSBpcyBub3QgcGFydCBvZiB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMsIHRoYXQncyB3aHkgaXQgd29uJ3QgdXNlIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMuIFRoYXQgd2F5IHRyYW5zZm9ybXMgd29uJ3QgZ2V0IHVwZGF0ZWQgaWYgb3BhY2l0eSBjaGFuZ2VzLlxuXG4gICAgICBpZiAoZGF0YS5vKSB7XG4gICAgICAgIHRoaXMubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubywgMCwgMC4wMSwgZWxlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm8gPSB7XG4gICAgICAgICAgX21kZjogZmFsc2UsXG4gICAgICAgICAgdjogMVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc0RpcnR5ID0gdHJ1ZTtcblxuICAgICAgaWYgKCF0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmdldFZhbHVlKHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFRyYW5zZm9ybVByb3BlcnR5LnByb3RvdHlwZSA9IHtcbiAgICAgIGFwcGx5VG9NYXRyaXg6IGFwcGx5VG9NYXRyaXgsXG4gICAgICBnZXRWYWx1ZTogcHJvY2Vzc0tleXMsXG4gICAgICBwcmVjYWxjdWxhdGVNYXRyaXg6IHByZWNhbGN1bGF0ZU1hdHJpeCxcbiAgICAgIGF1dG9PcmllbnQ6IGF1dG9PcmllbnRcbiAgICB9O1xuICAgIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgVHJhbnNmb3JtUHJvcGVydHkpO1xuICAgIFRyYW5zZm9ybVByb3BlcnR5LnByb3RvdHlwZS5hZGREeW5hbWljUHJvcGVydHkgPSBhZGREeW5hbWljUHJvcGVydHk7XG4gICAgVHJhbnNmb3JtUHJvcGVydHkucHJvdG90eXBlLl9hZGREeW5hbWljUHJvcGVydHkgPSBEeW5hbWljUHJvcGVydHlDb250YWluZXIucHJvdG90eXBlLmFkZER5bmFtaWNQcm9wZXJ0eTtcblxuICAgIGZ1bmN0aW9uIGdldFRyYW5zZm9ybVByb3BlcnR5KGVsZW0sIGRhdGEsIGNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1Qcm9wZXJ0eShlbGVtLCBkYXRhLCBjb250YWluZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBnZXRUcmFuc2Zvcm1Qcm9wZXJ0eTogZ2V0VHJhbnNmb3JtUHJvcGVydHlcbiAgICB9O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gUmVwZWF0ZXJNb2RpZmllcigpIHt9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtTaGFwZU1vZGlmaWVyXSwgUmVwZWF0ZXJNb2RpZmllcik7XG5cbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuaW5pdE1vZGlmaWVyUHJvcGVydGllcyA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhKSB7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMucHJvY2Vzc0tleXM7XG4gICAgdGhpcy5jID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5jLCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm8sIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMudHIgPSBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkuZ2V0VHJhbnNmb3JtUHJvcGVydHkoZWxlbSwgZGF0YS50ciwgdGhpcyk7XG4gICAgdGhpcy5zbyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudHIuc28sIDAsIDAuMDEsIHRoaXMpO1xuICAgIHRoaXMuZW8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnRyLmVvLCAwLCAwLjAxLCB0aGlzKTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuXG4gICAgaWYgKCF0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICB0aGlzLnBNYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5yTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMuc01hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLnRNYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5tYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gIH07XG5cbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuYXBwbHlUcmFuc2Zvcm1zID0gZnVuY3Rpb24gKHBNYXRyaXgsIHJNYXRyaXgsIHNNYXRyaXgsIHRyYW5zZm9ybSwgcGVyYywgaW52KSB7XG4gICAgdmFyIGRpciA9IGludiA/IC0xIDogMTtcbiAgICB2YXIgc2NhbGVYID0gdHJhbnNmb3JtLnMudlswXSArICgxIC0gdHJhbnNmb3JtLnMudlswXSkgKiAoMSAtIHBlcmMpO1xuICAgIHZhciBzY2FsZVkgPSB0cmFuc2Zvcm0ucy52WzFdICsgKDEgLSB0cmFuc2Zvcm0ucy52WzFdKSAqICgxIC0gcGVyYyk7XG4gICAgcE1hdHJpeC50cmFuc2xhdGUodHJhbnNmb3JtLnAudlswXSAqIGRpciAqIHBlcmMsIHRyYW5zZm9ybS5wLnZbMV0gKiBkaXIgKiBwZXJjLCB0cmFuc2Zvcm0ucC52WzJdKTtcbiAgICByTWF0cml4LnRyYW5zbGF0ZSgtdHJhbnNmb3JtLmEudlswXSwgLXRyYW5zZm9ybS5hLnZbMV0sIHRyYW5zZm9ybS5hLnZbMl0pO1xuICAgIHJNYXRyaXgucm90YXRlKC10cmFuc2Zvcm0uci52ICogZGlyICogcGVyYyk7XG4gICAgck1hdHJpeC50cmFuc2xhdGUodHJhbnNmb3JtLmEudlswXSwgdHJhbnNmb3JtLmEudlsxXSwgdHJhbnNmb3JtLmEudlsyXSk7XG4gICAgc01hdHJpeC50cmFuc2xhdGUoLXRyYW5zZm9ybS5hLnZbMF0sIC10cmFuc2Zvcm0uYS52WzFdLCB0cmFuc2Zvcm0uYS52WzJdKTtcbiAgICBzTWF0cml4LnNjYWxlKGludiA/IDEgLyBzY2FsZVggOiBzY2FsZVgsIGludiA/IDEgLyBzY2FsZVkgOiBzY2FsZVkpO1xuICAgIHNNYXRyaXgudHJhbnNsYXRlKHRyYW5zZm9ybS5hLnZbMF0sIHRyYW5zZm9ybS5hLnZbMV0sIHRyYW5zZm9ybS5hLnZbMl0pO1xuICB9O1xuXG4gIFJlcGVhdGVyTW9kaWZpZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZWxlbSwgYXJyLCBwb3MsIGVsZW1zRGF0YSkge1xuICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgdGhpcy5hcnIgPSBhcnI7XG4gICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgdGhpcy5lbGVtc0RhdGEgPSBlbGVtc0RhdGE7XG4gICAgdGhpcy5fY3VycmVudENvcGllcyA9IDA7XG4gICAgdGhpcy5fZWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLl9ncm91cHMgPSBbXTtcbiAgICB0aGlzLmZyYW1lSWQgPSAtMTtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgdGhpcy5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzKGVsZW0sIGFycltwb3NdKTtcblxuICAgIHdoaWxlIChwb3MgPiAwKSB7XG4gICAgICBwb3MgLT0gMTsgLy8gdGhpcy5fZWxlbWVudHMudW5zaGlmdChhcnIuc3BsaWNlKHBvcywxKVswXSk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnRzLnVuc2hpZnQoYXJyW3Bvc10pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5rID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUucmVzZXRFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBlbGVtZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGVsZW1lbnRzW2ldLl9wcm9jZXNzZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGVsZW1lbnRzW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgIHRoaXMucmVzZXRFbGVtZW50cyhlbGVtZW50c1tpXS5pdCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFJlcGVhdGVyTW9kaWZpZXIucHJvdG90eXBlLmNsb25lRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICB2YXIgbmV3RWxlbWVudHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVsZW1lbnRzKSk7XG4gICAgdGhpcy5yZXNldEVsZW1lbnRzKG5ld0VsZW1lbnRzKTtcbiAgICByZXR1cm4gbmV3RWxlbWVudHM7XG4gIH07XG5cbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuY2hhbmdlR3JvdXBSZW5kZXIgPSBmdW5jdGlvbiAoZWxlbWVudHMsIHJlbmRlckZsYWcpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBlbGVtZW50c1tpXS5fcmVuZGVyID0gcmVuZGVyRmxhZztcblxuICAgICAgaWYgKGVsZW1lbnRzW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlR3JvdXBSZW5kZXIoZWxlbWVudHNbaV0uaXQsIHJlbmRlckZsYWcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBSZXBlYXRlck1vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzU2hhcGVzID0gZnVuY3Rpb24gKF9pc0ZpcnN0RnJhbWUpIHtcbiAgICB2YXIgaXRlbXM7XG4gICAgdmFyIGl0ZW1zVHJhbnNmb3JtO1xuICAgIHZhciBpO1xuICAgIHZhciBkaXI7XG4gICAgdmFyIGNvbnQ7XG4gICAgdmFyIGhhc1JlbG9hZGVkID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5fbWRmIHx8IF9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBjb3BpZXMgPSBNYXRoLmNlaWwodGhpcy5jLnYpO1xuXG4gICAgICBpZiAodGhpcy5fZ3JvdXBzLmxlbmd0aCA8IGNvcGllcykge1xuICAgICAgICB3aGlsZSAodGhpcy5fZ3JvdXBzLmxlbmd0aCA8IGNvcGllcykge1xuICAgICAgICAgIHZhciBncm91cCA9IHtcbiAgICAgICAgICAgIGl0OiB0aGlzLmNsb25lRWxlbWVudHModGhpcy5fZWxlbWVudHMpLFxuICAgICAgICAgICAgdHk6ICdncidcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdyb3VwLml0LnB1c2goe1xuICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICBpeDogMSxcbiAgICAgICAgICAgICAgazogWzAsIDBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm06ICdUcmFuc2Zvcm0nLFxuICAgICAgICAgICAgbzoge1xuICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICBpeDogNyxcbiAgICAgICAgICAgICAgazogMTAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcDoge1xuICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICBpeDogMixcbiAgICAgICAgICAgICAgazogWzAsIDBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcjoge1xuICAgICAgICAgICAgICBhOiAxLFxuICAgICAgICAgICAgICBpeDogNixcbiAgICAgICAgICAgICAgazogW3tcbiAgICAgICAgICAgICAgICBzOiAwLFxuICAgICAgICAgICAgICAgIGU6IDAsXG4gICAgICAgICAgICAgICAgdDogMFxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgczogMCxcbiAgICAgICAgICAgICAgICBlOiAwLFxuICAgICAgICAgICAgICAgIHQ6IDFcbiAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzOiB7XG4gICAgICAgICAgICAgIGE6IDAsXG4gICAgICAgICAgICAgIGl4OiAzLFxuICAgICAgICAgICAgICBrOiBbMTAwLCAxMDBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2E6IHtcbiAgICAgICAgICAgICAgYTogMCxcbiAgICAgICAgICAgICAgaXg6IDUsXG4gICAgICAgICAgICAgIGs6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzazoge1xuICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICBpeDogNCxcbiAgICAgICAgICAgICAgazogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHR5OiAndHInXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5hcnIuc3BsaWNlKDAsIDAsIGdyb3VwKTtcblxuICAgICAgICAgIHRoaXMuX2dyb3Vwcy5zcGxpY2UoMCwgMCwgZ3JvdXApO1xuXG4gICAgICAgICAgdGhpcy5fY3VycmVudENvcGllcyArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbGVtLnJlbG9hZFNoYXBlcygpO1xuICAgICAgICBoYXNSZWxvYWRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnQgPSAwO1xuICAgICAgdmFyIHJlbmRlckZsYWc7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPD0gdGhpcy5fZ3JvdXBzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgICByZW5kZXJGbGFnID0gY29udCA8IGNvcGllcztcbiAgICAgICAgdGhpcy5fZ3JvdXBzW2ldLl9yZW5kZXIgPSByZW5kZXJGbGFnO1xuICAgICAgICB0aGlzLmNoYW5nZUdyb3VwUmVuZGVyKHRoaXMuX2dyb3Vwc1tpXS5pdCwgcmVuZGVyRmxhZyk7XG5cbiAgICAgICAgaWYgKCFyZW5kZXJGbGFnKSB7XG4gICAgICAgICAgdmFyIGVsZW1zID0gdGhpcy5lbGVtc0RhdGFbaV0uaXQ7XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybURhdGEgPSBlbGVtc1tlbGVtcy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgIGlmICh0cmFuc2Zvcm1EYXRhLnRyYW5zZm9ybS5vcC52ICE9PSAwKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnRyYW5zZm9ybS5vcC5fbWRmID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyYW5zZm9ybURhdGEudHJhbnNmb3JtLm9wLnYgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnRyYW5zZm9ybS5vcC5fbWRmID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udCArPSAxO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jdXJyZW50Q29waWVzID0gY29waWVzOyAvLy8gL1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vLnY7XG4gICAgICB2YXIgb2Zmc2V0TW9kdWxvID0gb2Zmc2V0ICUgMTtcbiAgICAgIHZhciByb3VuZE9mZnNldCA9IG9mZnNldCA+IDAgPyBNYXRoLmZsb29yKG9mZnNldCkgOiBNYXRoLmNlaWwob2Zmc2V0KTtcbiAgICAgIHZhciBwUHJvcHMgPSB0aGlzLnBNYXRyaXgucHJvcHM7XG4gICAgICB2YXIgclByb3BzID0gdGhpcy5yTWF0cml4LnByb3BzO1xuICAgICAgdmFyIHNQcm9wcyA9IHRoaXMuc01hdHJpeC5wcm9wcztcbiAgICAgIHRoaXMucE1hdHJpeC5yZXNldCgpO1xuICAgICAgdGhpcy5yTWF0cml4LnJlc2V0KCk7XG4gICAgICB0aGlzLnNNYXRyaXgucmVzZXQoKTtcbiAgICAgIHRoaXMudE1hdHJpeC5yZXNldCgpO1xuICAgICAgdGhpcy5tYXRyaXgucmVzZXQoKTtcbiAgICAgIHZhciBpdGVyYXRpb24gPSAwO1xuXG4gICAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgICB3aGlsZSAoaXRlcmF0aW9uIDwgcm91bmRPZmZzZXQpIHtcbiAgICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3Jtcyh0aGlzLnBNYXRyaXgsIHRoaXMuck1hdHJpeCwgdGhpcy5zTWF0cml4LCB0aGlzLnRyLCAxLCBmYWxzZSk7XG4gICAgICAgICAgaXRlcmF0aW9uICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2Zmc2V0TW9kdWxvKSB7XG4gICAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybXModGhpcy5wTWF0cml4LCB0aGlzLnJNYXRyaXgsIHRoaXMuc01hdHJpeCwgdGhpcy50ciwgb2Zmc2V0TW9kdWxvLCBmYWxzZSk7XG4gICAgICAgICAgaXRlcmF0aW9uICs9IG9mZnNldE1vZHVsbztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgIHdoaWxlIChpdGVyYXRpb24gPiByb3VuZE9mZnNldCkge1xuICAgICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1zKHRoaXMucE1hdHJpeCwgdGhpcy5yTWF0cml4LCB0aGlzLnNNYXRyaXgsIHRoaXMudHIsIDEsIHRydWUpO1xuICAgICAgICAgIGl0ZXJhdGlvbiAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9mZnNldE1vZHVsbykge1xuICAgICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1zKHRoaXMucE1hdHJpeCwgdGhpcy5yTWF0cml4LCB0aGlzLnNNYXRyaXgsIHRoaXMudHIsIC1vZmZzZXRNb2R1bG8sIHRydWUpO1xuICAgICAgICAgIGl0ZXJhdGlvbiAtPSBvZmZzZXRNb2R1bG87XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaSA9IHRoaXMuZGF0YS5tID09PSAxID8gMCA6IHRoaXMuX2N1cnJlbnRDb3BpZXMgLSAxO1xuICAgICAgZGlyID0gdGhpcy5kYXRhLm0gPT09IDEgPyAxIDogLTE7XG4gICAgICBjb250ID0gdGhpcy5fY3VycmVudENvcGllcztcbiAgICAgIHZhciBqO1xuICAgICAgdmFyIGpMZW47XG5cbiAgICAgIHdoaWxlIChjb250KSB7XG4gICAgICAgIGl0ZW1zID0gdGhpcy5lbGVtc0RhdGFbaV0uaXQ7XG4gICAgICAgIGl0ZW1zVHJhbnNmb3JtID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm1Qcm9wcy52LnByb3BzO1xuICAgICAgICBqTGVuID0gaXRlbXNUcmFuc2Zvcm0ubGVuZ3RoO1xuICAgICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ubVByb3BzLl9tZGYgPSB0cnVlO1xuICAgICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ub3AuX21kZiA9IHRydWU7XG4gICAgICAgIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnRyYW5zZm9ybS5vcC52ID0gdGhpcy5fY3VycmVudENvcGllcyA9PT0gMSA/IHRoaXMuc28udiA6IHRoaXMuc28udiArICh0aGlzLmVvLnYgLSB0aGlzLnNvLnYpICogKGkgLyAodGhpcy5fY3VycmVudENvcGllcyAtIDEpKTtcblxuICAgICAgICBpZiAoaXRlcmF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgaWYgKGkgIT09IDAgJiYgZGlyID09PSAxIHx8IGkgIT09IHRoaXMuX2N1cnJlbnRDb3BpZXMgLSAxICYmIGRpciA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1zKHRoaXMucE1hdHJpeCwgdGhpcy5yTWF0cml4LCB0aGlzLnNNYXRyaXgsIHRoaXMudHIsIDEsIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm1hdHJpeC50cmFuc2Zvcm0oclByb3BzWzBdLCByUHJvcHNbMV0sIHJQcm9wc1syXSwgclByb3BzWzNdLCByUHJvcHNbNF0sIHJQcm9wc1s1XSwgclByb3BzWzZdLCByUHJvcHNbN10sIHJQcm9wc1s4XSwgclByb3BzWzldLCByUHJvcHNbMTBdLCByUHJvcHNbMTFdLCByUHJvcHNbMTJdLCByUHJvcHNbMTNdLCByUHJvcHNbMTRdLCByUHJvcHNbMTVdKTtcbiAgICAgICAgICB0aGlzLm1hdHJpeC50cmFuc2Zvcm0oc1Byb3BzWzBdLCBzUHJvcHNbMV0sIHNQcm9wc1syXSwgc1Byb3BzWzNdLCBzUHJvcHNbNF0sIHNQcm9wc1s1XSwgc1Byb3BzWzZdLCBzUHJvcHNbN10sIHNQcm9wc1s4XSwgc1Byb3BzWzldLCBzUHJvcHNbMTBdLCBzUHJvcHNbMTFdLCBzUHJvcHNbMTJdLCBzUHJvcHNbMTNdLCBzUHJvcHNbMTRdLCBzUHJvcHNbMTVdKTtcbiAgICAgICAgICB0aGlzLm1hdHJpeC50cmFuc2Zvcm0ocFByb3BzWzBdLCBwUHJvcHNbMV0sIHBQcm9wc1syXSwgcFByb3BzWzNdLCBwUHJvcHNbNF0sIHBQcm9wc1s1XSwgcFByb3BzWzZdLCBwUHJvcHNbN10sIHBQcm9wc1s4XSwgcFByb3BzWzldLCBwUHJvcHNbMTBdLCBwUHJvcHNbMTFdLCBwUHJvcHNbMTJdLCBwUHJvcHNbMTNdLCBwUHJvcHNbMTRdLCBwUHJvcHNbMTVdKTtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGl0ZW1zVHJhbnNmb3JtW2pdID0gdGhpcy5tYXRyaXgucHJvcHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5tYXRyaXgucmVzZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm1hdHJpeC5yZXNldCgpO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgaXRlbXNUcmFuc2Zvcm1bal0gPSB0aGlzLm1hdHJpeC5wcm9wc1tqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpdGVyYXRpb24gKz0gMTtcbiAgICAgICAgY29udCAtPSAxO1xuICAgICAgICBpICs9IGRpcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udCA9IHRoaXMuX2N1cnJlbnRDb3BpZXM7XG4gICAgICBpID0gMDtcbiAgICAgIGRpciA9IDE7XG5cbiAgICAgIHdoaWxlIChjb250KSB7XG4gICAgICAgIGl0ZW1zID0gdGhpcy5lbGVtc0RhdGFbaV0uaXQ7XG4gICAgICAgIGl0ZW1zVHJhbnNmb3JtID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm1Qcm9wcy52LnByb3BzO1xuICAgICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ubVByb3BzLl9tZGYgPSBmYWxzZTtcbiAgICAgICAgaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm9wLl9tZGYgPSBmYWxzZTtcbiAgICAgICAgY29udCAtPSAxO1xuICAgICAgICBpICs9IGRpcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGFzUmVsb2FkZWQ7XG4gIH07XG5cbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBmdW5jdGlvbiBSb3VuZENvcm5lcnNNb2RpZmllcigpIHt9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtTaGFwZU1vZGlmaWVyXSwgUm91bmRDb3JuZXJzTW9kaWZpZXIpO1xuXG4gIFJvdW5kQ29ybmVyc01vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5wcm9jZXNzS2V5cztcbiAgICB0aGlzLnJkID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yLCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLnJkLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGg7XG4gIH07XG5cbiAgUm91bmRDb3JuZXJzTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NQYXRoID0gZnVuY3Rpb24gKHBhdGgsIHJvdW5kKSB7XG4gICAgdmFyIGNsb25lZFBhdGggPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xuICAgIGNsb25lZFBhdGguYyA9IHBhdGguYztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gcGF0aC5fbGVuZ3RoO1xuICAgIHZhciBjdXJyZW50VjtcbiAgICB2YXIgY3VycmVudEk7XG4gICAgdmFyIGN1cnJlbnRPO1xuICAgIHZhciBjbG9zZXJWO1xuICAgIHZhciBkaXN0YW5jZTtcbiAgICB2YXIgbmV3UG9zUGVyYztcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciB2WDtcbiAgICB2YXIgdlk7XG4gICAgdmFyIG9YO1xuICAgIHZhciBvWTtcbiAgICB2YXIgaVg7XG4gICAgdmFyIGlZO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjdXJyZW50ViA9IHBhdGgudltpXTtcbiAgICAgIGN1cnJlbnRPID0gcGF0aC5vW2ldO1xuICAgICAgY3VycmVudEkgPSBwYXRoLmlbaV07XG5cbiAgICAgIGlmIChjdXJyZW50VlswXSA9PT0gY3VycmVudE9bMF0gJiYgY3VycmVudFZbMV0gPT09IGN1cnJlbnRPWzFdICYmIGN1cnJlbnRWWzBdID09PSBjdXJyZW50SVswXSAmJiBjdXJyZW50VlsxXSA9PT0gY3VycmVudElbMV0pIHtcbiAgICAgICAgaWYgKChpID09PSAwIHx8IGkgPT09IGxlbiAtIDEpICYmICFwYXRoLmMpIHtcbiAgICAgICAgICBjbG9uZWRQYXRoLnNldFRyaXBsZUF0KGN1cnJlbnRWWzBdLCBjdXJyZW50VlsxXSwgY3VycmVudE9bMF0sIGN1cnJlbnRPWzFdLCBjdXJyZW50SVswXSwgY3VycmVudElbMV0sIGluZGV4KTtcbiAgICAgICAgICAvKiBjbG9uZWRQYXRoLnZbaW5kZXhdID0gY3VycmVudFY7XHJcbiAgICAgICAgICAgICAgICAgIGNsb25lZFBhdGgub1tpbmRleF0gPSBjdXJyZW50TztcclxuICAgICAgICAgICAgICAgICAgY2xvbmVkUGF0aC5pW2luZGV4XSA9IGN1cnJlbnRJOyAqL1xuXG4gICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgY2xvc2VyViA9IHBhdGgudltsZW4gLSAxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xvc2VyViA9IHBhdGgudltpIC0gMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coY3VycmVudFZbMF0gLSBjbG9zZXJWWzBdLCAyKSArIE1hdGgucG93KGN1cnJlbnRWWzFdIC0gY2xvc2VyVlsxXSwgMikpO1xuICAgICAgICAgIG5ld1Bvc1BlcmMgPSBkaXN0YW5jZSA/IE1hdGgubWluKGRpc3RhbmNlIC8gMiwgcm91bmQpIC8gZGlzdGFuY2UgOiAwO1xuICAgICAgICAgIGlYID0gY3VycmVudFZbMF0gKyAoY2xvc2VyVlswXSAtIGN1cnJlbnRWWzBdKSAqIG5ld1Bvc1BlcmM7XG4gICAgICAgICAgdlggPSBpWDtcbiAgICAgICAgICBpWSA9IGN1cnJlbnRWWzFdIC0gKGN1cnJlbnRWWzFdIC0gY2xvc2VyVlsxXSkgKiBuZXdQb3NQZXJjO1xuICAgICAgICAgIHZZID0gaVk7XG4gICAgICAgICAgb1ggPSB2WCAtICh2WCAtIGN1cnJlbnRWWzBdKSAqIHJvdW5kQ29ybmVyO1xuICAgICAgICAgIG9ZID0gdlkgLSAodlkgLSBjdXJyZW50VlsxXSkgKiByb3VuZENvcm5lcjtcbiAgICAgICAgICBjbG9uZWRQYXRoLnNldFRyaXBsZUF0KHZYLCB2WSwgb1gsIG9ZLCBpWCwgaVksIGluZGV4KTtcbiAgICAgICAgICBpbmRleCArPSAxO1xuXG4gICAgICAgICAgaWYgKGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgIGNsb3NlclYgPSBwYXRoLnZbMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsb3NlclYgPSBwYXRoLnZbaSArIDFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KGN1cnJlbnRWWzBdIC0gY2xvc2VyVlswXSwgMikgKyBNYXRoLnBvdyhjdXJyZW50VlsxXSAtIGNsb3NlclZbMV0sIDIpKTtcbiAgICAgICAgICBuZXdQb3NQZXJjID0gZGlzdGFuY2UgPyBNYXRoLm1pbihkaXN0YW5jZSAvIDIsIHJvdW5kKSAvIGRpc3RhbmNlIDogMDtcbiAgICAgICAgICBvWCA9IGN1cnJlbnRWWzBdICsgKGNsb3NlclZbMF0gLSBjdXJyZW50VlswXSkgKiBuZXdQb3NQZXJjO1xuICAgICAgICAgIHZYID0gb1g7XG4gICAgICAgICAgb1kgPSBjdXJyZW50VlsxXSArIChjbG9zZXJWWzFdIC0gY3VycmVudFZbMV0pICogbmV3UG9zUGVyYztcbiAgICAgICAgICB2WSA9IG9ZO1xuICAgICAgICAgIGlYID0gdlggLSAodlggLSBjdXJyZW50VlswXSkgKiByb3VuZENvcm5lcjtcbiAgICAgICAgICBpWSA9IHZZIC0gKHZZIC0gY3VycmVudFZbMV0pICogcm91bmRDb3JuZXI7XG4gICAgICAgICAgY2xvbmVkUGF0aC5zZXRUcmlwbGVBdCh2WCwgdlksIG9YLCBvWSwgaVgsIGlZLCBpbmRleCk7XG4gICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvbmVkUGF0aC5zZXRUcmlwbGVBdChwYXRoLnZbaV1bMF0sIHBhdGgudltpXVsxXSwgcGF0aC5vW2ldWzBdLCBwYXRoLm9baV1bMV0sIHBhdGguaVtpXVswXSwgcGF0aC5pW2ldWzFdLCBpbmRleCk7XG4gICAgICAgIGluZGV4ICs9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lZFBhdGg7XG4gIH07XG5cbiAgUm91bmRDb3JuZXJzTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NTaGFwZXMgPSBmdW5jdGlvbiAoX2lzRmlyc3RGcmFtZSkge1xuICAgIHZhciBzaGFwZVBhdGhzO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLnNoYXBlcy5sZW5ndGg7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIHJkID0gdGhpcy5yZC52O1xuXG4gICAgaWYgKHJkICE9PSAwKSB7XG4gICAgICB2YXIgc2hhcGVEYXRhO1xuICAgICAgdmFyIGxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgc2hhcGVEYXRhID0gdGhpcy5zaGFwZXNbaV07XG4gICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICAgIGlmICghKCFzaGFwZURhdGEuc2hhcGUuX21kZiAmJiAhdGhpcy5fbWRmICYmICFfaXNGaXJzdEZyYW1lKSkge1xuICAgICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uLnJlbGVhc2VTaGFwZXMoKTtcbiAgICAgICAgICBzaGFwZURhdGEuc2hhcGUuX21kZiA9IHRydWU7XG4gICAgICAgICAgc2hhcGVQYXRocyA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5zaGFwZXM7XG4gICAgICAgICAgakxlbiA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5fbGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy5wcm9jZXNzUGF0aChzaGFwZVBhdGhzW2pdLCByZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNoYXBlRGF0YS5zaGFwZS5wYXRocyA9IHNoYXBlRGF0YS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZmxvYXRFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSAqIDEwMDAwMCA8PSBNYXRoLm1pbihNYXRoLmFicyhhKSwgTWF0aC5hYnMoYikpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmxvYXRaZXJvKGYpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoZikgPD0gMC4wMDAwMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlcnAocDAsIHAxLCBhbW91bnQpIHtcbiAgICByZXR1cm4gcDAgKiAoMSAtIGFtb3VudCkgKyBwMSAqIGFtb3VudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlcnBQb2ludChwMCwgcDEsIGFtb3VudCkge1xuICAgIHJldHVybiBbbGVycChwMFswXSwgcDFbMF0sIGFtb3VudCksIGxlcnAocDBbMV0sIHAxWzFdLCBhbW91bnQpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1YWRSb290cyhhLCBiLCBjKSB7XG4gICAgLy8gbm8gcm9vdFxuICAgIGlmIChhID09PSAwKSByZXR1cm4gW107XG4gICAgdmFyIHMgPSBiICogYiAtIDQgKiBhICogYzsgLy8gQ29tcGxleCByb290c1xuXG4gICAgaWYgKHMgPCAwKSByZXR1cm4gW107XG4gICAgdmFyIHNpbmdsZVJvb3QgPSAtYiAvICgyICogYSk7IC8vIDEgcm9vdFxuXG4gICAgaWYgKHMgPT09IDApIHJldHVybiBbc2luZ2xlUm9vdF07XG4gICAgdmFyIGRlbHRhID0gTWF0aC5zcXJ0KHMpIC8gKDIgKiBhKTsgLy8gMiByb290c1xuXG4gICAgcmV0dXJuIFtzaW5nbGVSb290IC0gZGVsdGEsIHNpbmdsZVJvb3QgKyBkZWx0YV07XG4gIH1cblxuICBmdW5jdGlvbiBwb2x5bm9taWFsQ29lZmZpY2llbnRzKHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgcmV0dXJuIFstcDAgKyAzICogcDEgLSAzICogcDIgKyBwMywgMyAqIHAwIC0gNiAqIHAxICsgMyAqIHAyLCAtMyAqIHAwICsgMyAqIHAxLCBwMF07XG4gIH1cblxuICBmdW5jdGlvbiBzaW5nbGVQb2ludChwKSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsQmV6aWVyKHAsIHAsIHAsIHAsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFBvbHlub21pYWxCZXppZXIocDAsIHAxLCBwMiwgcDMsIGxpbmVhcml6ZSkge1xuICAgIGlmIChsaW5lYXJpemUgJiYgcG9pbnRFcXVhbChwMCwgcDEpKSB7XG4gICAgICBwMSA9IGxlcnBQb2ludChwMCwgcDMsIDEgLyAzKTtcbiAgICB9XG5cbiAgICBpZiAobGluZWFyaXplICYmIHBvaW50RXF1YWwocDIsIHAzKSkge1xuICAgICAgcDIgPSBsZXJwUG9pbnQocDAsIHAzLCAyIC8gMyk7XG4gICAgfVxuXG4gICAgdmFyIGNvZWZmeCA9IHBvbHlub21pYWxDb2VmZmljaWVudHMocDBbMF0sIHAxWzBdLCBwMlswXSwgcDNbMF0pO1xuICAgIHZhciBjb2VmZnkgPSBwb2x5bm9taWFsQ29lZmZpY2llbnRzKHAwWzFdLCBwMVsxXSwgcDJbMV0sIHAzWzFdKTtcbiAgICB0aGlzLmEgPSBbY29lZmZ4WzBdLCBjb2VmZnlbMF1dO1xuICAgIHRoaXMuYiA9IFtjb2VmZnhbMV0sIGNvZWZmeVsxXV07XG4gICAgdGhpcy5jID0gW2NvZWZmeFsyXSwgY29lZmZ5WzJdXTtcbiAgICB0aGlzLmQgPSBbY29lZmZ4WzNdLCBjb2VmZnlbM11dO1xuICAgIHRoaXMucG9pbnRzID0gW3AwLCBwMSwgcDIsIHAzXTtcbiAgfVxuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gWygodGhpcy5hWzBdICogdCArIHRoaXMuYlswXSkgKiB0ICsgdGhpcy5jWzBdKSAqIHQgKyB0aGlzLmRbMF0sICgodGhpcy5hWzFdICogdCArIHRoaXMuYlsxXSkgKiB0ICsgdGhpcy5jWzFdKSAqIHQgKyB0aGlzLmRbMV1dO1xuICB9O1xuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLmRlcml2YXRpdmUgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBbKDMgKiB0ICogdGhpcy5hWzBdICsgMiAqIHRoaXMuYlswXSkgKiB0ICsgdGhpcy5jWzBdLCAoMyAqIHQgKiB0aGlzLmFbMV0gKyAyICogdGhpcy5iWzFdKSAqIHQgKyB0aGlzLmNbMV1dO1xuICB9O1xuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLnRhbmdlbnRBbmdsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHAgPSB0aGlzLmRlcml2YXRpdmUodCk7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIocFsxXSwgcFswXSk7XG4gIH07XG5cbiAgUG9seW5vbWlhbEJlemllci5wcm90b3R5cGUubm9ybWFsQW5nbGUgPSBmdW5jdGlvbiAodCkge1xuICAgIHZhciBwID0gdGhpcy5kZXJpdmF0aXZlKHQpO1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHBbMF0sIHBbMV0pO1xuICB9O1xuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLmluZmxlY3Rpb25Qb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlbm9tID0gdGhpcy5hWzFdICogdGhpcy5iWzBdIC0gdGhpcy5hWzBdICogdGhpcy5iWzFdO1xuICAgIGlmIChmbG9hdFplcm8oZGVub20pKSByZXR1cm4gW107XG4gICAgdmFyIHRjdXNwID0gLTAuNSAqICh0aGlzLmFbMV0gKiB0aGlzLmNbMF0gLSB0aGlzLmFbMF0gKiB0aGlzLmNbMV0pIC8gZGVub207XG4gICAgdmFyIHNxdWFyZSA9IHRjdXNwICogdGN1c3AgLSAxIC8gMyAqICh0aGlzLmJbMV0gKiB0aGlzLmNbMF0gLSB0aGlzLmJbMF0gKiB0aGlzLmNbMV0pIC8gZGVub207XG4gICAgaWYgKHNxdWFyZSA8IDApIHJldHVybiBbXTtcbiAgICB2YXIgcm9vdCA9IE1hdGguc3FydChzcXVhcmUpO1xuXG4gICAgaWYgKGZsb2F0WmVybyhyb290KSkge1xuICAgICAgaWYgKHJvb3QgPiAwICYmIHJvb3QgPCAxKSByZXR1cm4gW3RjdXNwXTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3RjdXNwIC0gcm9vdCwgdGN1c3AgKyByb290XS5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiByID4gMCAmJiByIDwgMTtcbiAgICB9KTtcbiAgfTtcblxuICBQb2x5bm9taWFsQmV6aWVyLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgaWYgKHQgPD0gMCkgcmV0dXJuIFtzaW5nbGVQb2ludCh0aGlzLnBvaW50c1swXSksIHRoaXNdO1xuICAgIGlmICh0ID49IDEpIHJldHVybiBbdGhpcywgc2luZ2xlUG9pbnQodGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMV0pXTtcbiAgICB2YXIgcDEwID0gbGVycFBvaW50KHRoaXMucG9pbnRzWzBdLCB0aGlzLnBvaW50c1sxXSwgdCk7XG4gICAgdmFyIHAxMSA9IGxlcnBQb2ludCh0aGlzLnBvaW50c1sxXSwgdGhpcy5wb2ludHNbMl0sIHQpO1xuICAgIHZhciBwMTIgPSBsZXJwUG9pbnQodGhpcy5wb2ludHNbMl0sIHRoaXMucG9pbnRzWzNdLCB0KTtcbiAgICB2YXIgcDIwID0gbGVycFBvaW50KHAxMCwgcDExLCB0KTtcbiAgICB2YXIgcDIxID0gbGVycFBvaW50KHAxMSwgcDEyLCB0KTtcbiAgICB2YXIgcDMgPSBsZXJwUG9pbnQocDIwLCBwMjEsIHQpO1xuICAgIHJldHVybiBbbmV3IFBvbHlub21pYWxCZXppZXIodGhpcy5wb2ludHNbMF0sIHAxMCwgcDIwLCBwMywgdHJ1ZSksIG5ldyBQb2x5bm9taWFsQmV6aWVyKHAzLCBwMjEsIHAxMiwgdGhpcy5wb2ludHNbM10sIHRydWUpXTtcbiAgfTtcblxuICBmdW5jdGlvbiBleHRyZW1hKGJleiwgY29tcCkge1xuICAgIHZhciBtaW4gPSBiZXoucG9pbnRzWzBdW2NvbXBdO1xuICAgIHZhciBtYXggPSBiZXoucG9pbnRzW2Jlei5wb2ludHMubGVuZ3RoIC0gMV1bY29tcF07XG5cbiAgICBpZiAobWluID4gbWF4KSB7XG4gICAgICB2YXIgZSA9IG1heDtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IGU7XG4gICAgfSAvLyBEZXJpdmF0aXZlIHJvb3RzIHRvIGZpbmQgbWluL21heFxuXG5cbiAgICB2YXIgZiA9IHF1YWRSb290cygzICogYmV6LmFbY29tcF0sIDIgKiBiZXouYltjb21wXSwgYmV6LmNbY29tcF0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoZltpXSA+IDAgJiYgZltpXSA8IDEpIHtcbiAgICAgICAgdmFyIHZhbCA9IGJlei5wb2ludChmW2ldKVtjb21wXTtcbiAgICAgICAgaWYgKHZhbCA8IG1pbikgbWluID0gdmFsO2Vsc2UgaWYgKHZhbCA+IG1heCkgbWF4ID0gdmFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtaW46IG1pbixcbiAgICAgIG1heDogbWF4XG4gICAgfTtcbiAgfVxuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLmJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZXh0cmVtYSh0aGlzLCAwKSxcbiAgICAgIHk6IGV4dHJlbWEodGhpcywgMSlcbiAgICB9O1xuICB9O1xuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLmJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBib3VuZHMgPSB0aGlzLmJvdW5kcygpO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBib3VuZHMueC5taW4sXG4gICAgICByaWdodDogYm91bmRzLngubWF4LFxuICAgICAgdG9wOiBib3VuZHMueS5taW4sXG4gICAgICBib3R0b206IGJvdW5kcy55Lm1heCxcbiAgICAgIHdpZHRoOiBib3VuZHMueC5tYXggLSBib3VuZHMueC5taW4sXG4gICAgICBoZWlnaHQ6IGJvdW5kcy55Lm1heCAtIGJvdW5kcy55Lm1pbixcbiAgICAgIGN4OiAoYm91bmRzLngubWF4ICsgYm91bmRzLngubWluKSAvIDIsXG4gICAgICBjeTogKGJvdW5kcy55Lm1heCArIGJvdW5kcy55Lm1pbikgLyAyXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBpbnRlcnNlY3REYXRhKGJleiwgdDEsIHQyKSB7XG4gICAgdmFyIGJveCA9IGJlei5ib3VuZGluZ0JveCgpO1xuICAgIHJldHVybiB7XG4gICAgICBjeDogYm94LmN4LFxuICAgICAgY3k6IGJveC5jeSxcbiAgICAgIHdpZHRoOiBib3gud2lkdGgsXG4gICAgICBoZWlnaHQ6IGJveC5oZWlnaHQsXG4gICAgICBiZXo6IGJleixcbiAgICAgIHQ6ICh0MSArIHQyKSAvIDIsXG4gICAgICB0MTogdDEsXG4gICAgICB0MjogdDJcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc3BsaXREYXRhKGRhdGEpIHtcbiAgICB2YXIgc3BsaXQgPSBkYXRhLmJlei5zcGxpdCgwLjUpO1xuICAgIHJldHVybiBbaW50ZXJzZWN0RGF0YShzcGxpdFswXSwgZGF0YS50MSwgZGF0YS50KSwgaW50ZXJzZWN0RGF0YShzcGxpdFsxXSwgZGF0YS50LCBkYXRhLnQyKV07XG4gIH1cblxuICBmdW5jdGlvbiBib3hJbnRlcnNlY3QoYjEsIGIyKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGIxLmN4IC0gYjIuY3gpICogMiA8IGIxLndpZHRoICsgYjIud2lkdGggJiYgTWF0aC5hYnMoYjEuY3kgLSBiMi5jeSkgKiAyIDwgYjEuaGVpZ2h0ICsgYjIuaGVpZ2h0O1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJzZWN0c0ltcGwoZDEsIGQyLCBkZXB0aCwgdG9sZXJhbmNlLCBpbnRlcnNlY3Rpb25zLCBtYXhSZWN1cnNpb24pIHtcbiAgICBpZiAoIWJveEludGVyc2VjdChkMSwgZDIpKSByZXR1cm47XG5cbiAgICBpZiAoZGVwdGggPj0gbWF4UmVjdXJzaW9uIHx8IGQxLndpZHRoIDw9IHRvbGVyYW5jZSAmJiBkMS5oZWlnaHQgPD0gdG9sZXJhbmNlICYmIGQyLndpZHRoIDw9IHRvbGVyYW5jZSAmJiBkMi5oZWlnaHQgPD0gdG9sZXJhbmNlKSB7XG4gICAgICBpbnRlcnNlY3Rpb25zLnB1c2goW2QxLnQsIGQyLnRdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZDFzID0gc3BsaXREYXRhKGQxKTtcbiAgICB2YXIgZDJzID0gc3BsaXREYXRhKGQyKTtcbiAgICBpbnRlcnNlY3RzSW1wbChkMXNbMF0sIGQyc1swXSwgZGVwdGggKyAxLCB0b2xlcmFuY2UsIGludGVyc2VjdGlvbnMsIG1heFJlY3Vyc2lvbik7XG4gICAgaW50ZXJzZWN0c0ltcGwoZDFzWzBdLCBkMnNbMV0sIGRlcHRoICsgMSwgdG9sZXJhbmNlLCBpbnRlcnNlY3Rpb25zLCBtYXhSZWN1cnNpb24pO1xuICAgIGludGVyc2VjdHNJbXBsKGQxc1sxXSwgZDJzWzBdLCBkZXB0aCArIDEsIHRvbGVyYW5jZSwgaW50ZXJzZWN0aW9ucywgbWF4UmVjdXJzaW9uKTtcbiAgICBpbnRlcnNlY3RzSW1wbChkMXNbMV0sIGQyc1sxXSwgZGVwdGggKyAxLCB0b2xlcmFuY2UsIGludGVyc2VjdGlvbnMsIG1heFJlY3Vyc2lvbik7XG4gIH1cblxuICBQb2x5bm9taWFsQmV6aWVyLnByb3RvdHlwZS5pbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gKG90aGVyLCB0b2xlcmFuY2UsIG1heFJlY3Vyc2lvbikge1xuICAgIGlmICh0b2xlcmFuY2UgPT09IHVuZGVmaW5lZCkgdG9sZXJhbmNlID0gMjtcbiAgICBpZiAobWF4UmVjdXJzaW9uID09PSB1bmRlZmluZWQpIG1heFJlY3Vyc2lvbiA9IDc7XG4gICAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICBpbnRlcnNlY3RzSW1wbChpbnRlcnNlY3REYXRhKHRoaXMsIDAsIDEpLCBpbnRlcnNlY3REYXRhKG90aGVyLCAwLCAxKSwgMCwgdG9sZXJhbmNlLCBpbnRlcnNlY3Rpb25zLCBtYXhSZWN1cnNpb24pO1xuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9O1xuXG4gIFBvbHlub21pYWxCZXppZXIuc2hhcGVTZWdtZW50ID0gZnVuY3Rpb24gKHNoYXBlUGF0aCwgaW5kZXgpIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gKGluZGV4ICsgMSkgJSBzaGFwZVBhdGgubGVuZ3RoKCk7XG4gICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsQmV6aWVyKHNoYXBlUGF0aC52W2luZGV4XSwgc2hhcGVQYXRoLm9baW5kZXhdLCBzaGFwZVBhdGguaVtuZXh0SW5kZXhdLCBzaGFwZVBhdGgudltuZXh0SW5kZXhdLCB0cnVlKTtcbiAgfTtcblxuICBQb2x5bm9taWFsQmV6aWVyLnNoYXBlU2VnbWVudEludmVydGVkID0gZnVuY3Rpb24gKHNoYXBlUGF0aCwgaW5kZXgpIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gKGluZGV4ICsgMSkgJSBzaGFwZVBhdGgubGVuZ3RoKCk7XG4gICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsQmV6aWVyKHNoYXBlUGF0aC52W25leHRJbmRleF0sIHNoYXBlUGF0aC5pW25leHRJbmRleF0sIHNoYXBlUGF0aC5vW2luZGV4XSwgc2hhcGVQYXRoLnZbaW5kZXhdLCB0cnVlKTtcbiAgfTtcblxuICBmdW5jdGlvbiBjcm9zc1Byb2R1Y3QoYSwgYikge1xuICAgIHJldHVybiBbYVsxXSAqIGJbMl0gLSBhWzJdICogYlsxXSwgYVsyXSAqIGJbMF0gLSBhWzBdICogYlsyXSwgYVswXSAqIGJbMV0gLSBhWzFdICogYlswXV07XG4gIH1cblxuICBmdW5jdGlvbiBsaW5lSW50ZXJzZWN0aW9uKHN0YXJ0MSwgZW5kMSwgc3RhcnQyLCBlbmQyKSB7XG4gICAgdmFyIHYxID0gW3N0YXJ0MVswXSwgc3RhcnQxWzFdLCAxXTtcbiAgICB2YXIgdjIgPSBbZW5kMVswXSwgZW5kMVsxXSwgMV07XG4gICAgdmFyIHYzID0gW3N0YXJ0MlswXSwgc3RhcnQyWzFdLCAxXTtcbiAgICB2YXIgdjQgPSBbZW5kMlswXSwgZW5kMlsxXSwgMV07XG4gICAgdmFyIHIgPSBjcm9zc1Byb2R1Y3QoY3Jvc3NQcm9kdWN0KHYxLCB2MiksIGNyb3NzUHJvZHVjdCh2MywgdjQpKTtcbiAgICBpZiAoZmxvYXRaZXJvKHJbMl0pKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gW3JbMF0gLyByWzJdLCByWzFdIC8gclsyXV07XG4gIH1cblxuICBmdW5jdGlvbiBwb2xhck9mZnNldChwLCBhbmdsZSwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtwWzBdICsgTWF0aC5jb3MoYW5nbGUpICogbGVuZ3RoLCBwWzFdIC0gTWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvaW50RGlzdGFuY2UocDEsIHAyKSB7XG4gICAgcmV0dXJuIE1hdGguaHlwb3QocDFbMF0gLSBwMlswXSwgcDFbMV0gLSBwMlsxXSk7XG4gIH1cblxuICBmdW5jdGlvbiBwb2ludEVxdWFsKHAxLCBwMikge1xuICAgIHJldHVybiBmbG9hdEVxdWFsKHAxWzBdLCBwMlswXSkgJiYgZmxvYXRFcXVhbChwMVsxXSwgcDJbMV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gWmlnWmFnTW9kaWZpZXIoKSB7fVxuXG4gIGV4dGVuZFByb3RvdHlwZShbU2hhcGVNb2RpZmllcl0sIFppZ1phZ01vZGlmaWVyKTtcblxuICBaaWdaYWdNb2RpZmllci5wcm90b3R5cGUuaW5pdE1vZGlmaWVyUHJvcGVydGllcyA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhKSB7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMucHJvY2Vzc0tleXM7XG4gICAgdGhpcy5hbXBsaXR1ZGUgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnMsIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMuZnJlcXVlbmN5ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yLCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLnBvaW50c1R5cGUgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnB0LCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gdGhpcy5hbXBsaXR1ZGUuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCAhPT0gMCB8fCB0aGlzLmZyZXF1ZW5jeS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoICE9PSAwIHx8IHRoaXMucG9pbnRzVHlwZS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoICE9PSAwO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNldFBvaW50KG91dHB1dEJlemllciwgcG9pbnQsIGFuZ2xlLCBkaXJlY3Rpb24sIGFtcGxpdHVkZSwgb3V0QW1wbGl0dWRlLCBpbkFtcGxpdHVkZSkge1xuICAgIHZhciBhbmdPID0gYW5nbGUgLSBNYXRoLlBJIC8gMjtcbiAgICB2YXIgYW5nSSA9IGFuZ2xlICsgTWF0aC5QSSAvIDI7XG4gICAgdmFyIHB4ID0gcG9pbnRbMF0gKyBNYXRoLmNvcyhhbmdsZSkgKiBkaXJlY3Rpb24gKiBhbXBsaXR1ZGU7XG4gICAgdmFyIHB5ID0gcG9pbnRbMV0gLSBNYXRoLnNpbihhbmdsZSkgKiBkaXJlY3Rpb24gKiBhbXBsaXR1ZGU7XG4gICAgb3V0cHV0QmV6aWVyLnNldFRyaXBsZUF0KHB4LCBweSwgcHggKyBNYXRoLmNvcyhhbmdPKSAqIG91dEFtcGxpdHVkZSwgcHkgLSBNYXRoLnNpbihhbmdPKSAqIG91dEFtcGxpdHVkZSwgcHggKyBNYXRoLmNvcyhhbmdJKSAqIGluQW1wbGl0dWRlLCBweSAtIE1hdGguc2luKGFuZ0kpICogaW5BbXBsaXR1ZGUsIG91dHB1dEJlemllci5sZW5ndGgoKSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQZXJwZW5kaWN1bGFyVmVjdG9yKHB0MSwgcHQyKSB7XG4gICAgdmFyIHZlY3RvciA9IFtwdDJbMF0gLSBwdDFbMF0sIHB0MlsxXSAtIHB0MVsxXV07XG4gICAgdmFyIHJvdCA9IC1NYXRoLlBJICogMC41O1xuICAgIHZhciByb3RhdGVkVmVjdG9yID0gW01hdGguY29zKHJvdCkgKiB2ZWN0b3JbMF0gLSBNYXRoLnNpbihyb3QpICogdmVjdG9yWzFdLCBNYXRoLnNpbihyb3QpICogdmVjdG9yWzBdICsgTWF0aC5jb3Mocm90KSAqIHZlY3RvclsxXV07XG4gICAgcmV0dXJuIHJvdGF0ZWRWZWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQcm9qZWN0aW5nQW5nbGUocGF0aCwgY3VyKSB7XG4gICAgdmFyIHByZXZJbmRleCA9IGN1ciA9PT0gMCA/IHBhdGgubGVuZ3RoKCkgLSAxIDogY3VyIC0gMTtcbiAgICB2YXIgbmV4dEluZGV4ID0gKGN1ciArIDEpICUgcGF0aC5sZW5ndGgoKTtcbiAgICB2YXIgcHJldlBvaW50ID0gcGF0aC52W3ByZXZJbmRleF07XG4gICAgdmFyIG5leHRQb2ludCA9IHBhdGgudltuZXh0SW5kZXhdO1xuICAgIHZhciBwVmVjdG9yID0gZ2V0UGVycGVuZGljdWxhclZlY3RvcihwcmV2UG9pbnQsIG5leHRQb2ludCk7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoMCwgMSkgLSBNYXRoLmF0YW4yKHBWZWN0b3JbMV0sIHBWZWN0b3JbMF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gemlnWmFnQ29ybmVyKG91dHB1dEJlemllciwgcGF0aCwgY3VyLCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgYW5nbGUgPSBnZXRQcm9qZWN0aW5nQW5nbGUocGF0aCwgY3VyKTtcbiAgICB2YXIgcG9pbnQgPSBwYXRoLnZbY3VyICUgcGF0aC5fbGVuZ3RoXTtcbiAgICB2YXIgcHJldlBvaW50ID0gcGF0aC52W2N1ciA9PT0gMCA/IHBhdGguX2xlbmd0aCAtIDEgOiBjdXIgLSAxXTtcbiAgICB2YXIgbmV4dFBvaW50ID0gcGF0aC52WyhjdXIgKyAxKSAlIHBhdGguX2xlbmd0aF07XG4gICAgdmFyIHByZXZEaXN0ID0gcG9pbnRUeXBlID09PSAyID8gTWF0aC5zcXJ0KE1hdGgucG93KHBvaW50WzBdIC0gcHJldlBvaW50WzBdLCAyKSArIE1hdGgucG93KHBvaW50WzFdIC0gcHJldlBvaW50WzFdLCAyKSkgOiAwO1xuICAgIHZhciBuZXh0RGlzdCA9IHBvaW50VHlwZSA9PT0gMiA/IE1hdGguc3FydChNYXRoLnBvdyhwb2ludFswXSAtIG5leHRQb2ludFswXSwgMikgKyBNYXRoLnBvdyhwb2ludFsxXSAtIG5leHRQb2ludFsxXSwgMikpIDogMDtcbiAgICBzZXRQb2ludChvdXRwdXRCZXppZXIsIHBhdGgudltjdXIgJSBwYXRoLl9sZW5ndGhdLCBhbmdsZSwgZGlyZWN0aW9uLCBhbXBsaXR1ZGUsIG5leHREaXN0IC8gKChmcmVxdWVuY3kgKyAxKSAqIDIpLCBwcmV2RGlzdCAvICgoZnJlcXVlbmN5ICsgMSkgKiAyKSwgcG9pbnRUeXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHppZ1phZ1NlZ21lbnQob3V0cHV0QmV6aWVyLCBzZWdtZW50LCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlLCBkaXJlY3Rpb24pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyZXF1ZW5jeTsgaSArPSAxKSB7XG4gICAgICB2YXIgdCA9IChpICsgMSkgLyAoZnJlcXVlbmN5ICsgMSk7XG4gICAgICB2YXIgZGlzdCA9IHBvaW50VHlwZSA9PT0gMiA/IE1hdGguc3FydChNYXRoLnBvdyhzZWdtZW50LnBvaW50c1szXVswXSAtIHNlZ21lbnQucG9pbnRzWzBdWzBdLCAyKSArIE1hdGgucG93KHNlZ21lbnQucG9pbnRzWzNdWzFdIC0gc2VnbWVudC5wb2ludHNbMF1bMV0sIDIpKSA6IDA7XG4gICAgICB2YXIgYW5nbGUgPSBzZWdtZW50Lm5vcm1hbEFuZ2xlKHQpO1xuICAgICAgdmFyIHBvaW50ID0gc2VnbWVudC5wb2ludCh0KTtcbiAgICAgIHNldFBvaW50KG91dHB1dEJlemllciwgcG9pbnQsIGFuZ2xlLCBkaXJlY3Rpb24sIGFtcGxpdHVkZSwgZGlzdCAvICgoZnJlcXVlbmN5ICsgMSkgKiAyKSwgZGlzdCAvICgoZnJlcXVlbmN5ICsgMSkgKiAyKSwgcG9pbnRUeXBlKTtcbiAgICAgIGRpcmVjdGlvbiA9IC1kaXJlY3Rpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgfVxuXG4gIFppZ1phZ01vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlKSB7XG4gICAgdmFyIGNvdW50ID0gcGF0aC5fbGVuZ3RoO1xuICAgIHZhciBjbG9uZWRQYXRoID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICBjbG9uZWRQYXRoLmMgPSBwYXRoLmM7XG5cbiAgICBpZiAoIXBhdGguYykge1xuICAgICAgY291bnQgLT0gMTtcbiAgICB9XG5cbiAgICBpZiAoY291bnQgPT09IDApIHJldHVybiBjbG9uZWRQYXRoO1xuICAgIHZhciBkaXJlY3Rpb24gPSAtMTtcbiAgICB2YXIgc2VnbWVudCA9IFBvbHlub21pYWxCZXppZXIuc2hhcGVTZWdtZW50KHBhdGgsIDApO1xuICAgIHppZ1phZ0Nvcm5lcihjbG9uZWRQYXRoLCBwYXRoLCAwLCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlLCBkaXJlY3Rpb24pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBkaXJlY3Rpb24gPSB6aWdaYWdTZWdtZW50KGNsb25lZFBhdGgsIHNlZ21lbnQsIGFtcGxpdHVkZSwgZnJlcXVlbmN5LCBwb2ludFR5cGUsIC1kaXJlY3Rpb24pO1xuXG4gICAgICBpZiAoaSA9PT0gY291bnQgLSAxICYmICFwYXRoLmMpIHtcbiAgICAgICAgc2VnbWVudCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWdtZW50ID0gUG9seW5vbWlhbEJlemllci5zaGFwZVNlZ21lbnQocGF0aCwgKGkgKyAxKSAlIGNvdW50KTtcbiAgICAgIH1cblxuICAgICAgemlnWmFnQ29ybmVyKGNsb25lZFBhdGgsIHBhdGgsIGkgKyAxLCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlLCBkaXJlY3Rpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBjbG9uZWRQYXRoO1xuICB9O1xuXG4gIFppZ1phZ01vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzU2hhcGVzID0gZnVuY3Rpb24gKF9pc0ZpcnN0RnJhbWUpIHtcbiAgICB2YXIgc2hhcGVQYXRocztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5zaGFwZXMubGVuZ3RoO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBhbXBsaXR1ZGUgPSB0aGlzLmFtcGxpdHVkZS52O1xuICAgIHZhciBmcmVxdWVuY3kgPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKHRoaXMuZnJlcXVlbmN5LnYpKTtcbiAgICB2YXIgcG9pbnRUeXBlID0gdGhpcy5wb2ludHNUeXBlLnY7XG5cbiAgICBpZiAoYW1wbGl0dWRlICE9PSAwKSB7XG4gICAgICB2YXIgc2hhcGVEYXRhO1xuICAgICAgdmFyIGxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgc2hhcGVEYXRhID0gdGhpcy5zaGFwZXNbaV07XG4gICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICAgIGlmICghKCFzaGFwZURhdGEuc2hhcGUuX21kZiAmJiAhdGhpcy5fbWRmICYmICFfaXNGaXJzdEZyYW1lKSkge1xuICAgICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uLnJlbGVhc2VTaGFwZXMoKTtcbiAgICAgICAgICBzaGFwZURhdGEuc2hhcGUuX21kZiA9IHRydWU7XG4gICAgICAgICAgc2hhcGVQYXRocyA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5zaGFwZXM7XG4gICAgICAgICAgakxlbiA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5fbGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy5wcm9jZXNzUGF0aChzaGFwZVBhdGhzW2pdLCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBsaW5lYXJPZmZzZXQocDEsIHAyLCBhbW91bnQpIHtcbiAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHAyWzBdIC0gcDFbMF0sIHAyWzFdIC0gcDFbMV0pO1xuICAgIHJldHVybiBbcG9sYXJPZmZzZXQocDEsIGFuZ2xlLCBhbW91bnQpLCBwb2xhck9mZnNldChwMiwgYW5nbGUsIGFtb3VudCldO1xuICB9XG5cbiAgZnVuY3Rpb24gb2Zmc2V0U2VnbWVudChzZWdtZW50LCBhbW91bnQpIHtcbiAgICB2YXIgcDA7XG4gICAgdmFyIHAxYTtcbiAgICB2YXIgcDFiO1xuICAgIHZhciBwMmI7XG4gICAgdmFyIHAyYTtcbiAgICB2YXIgcDM7XG4gICAgdmFyIGU7XG4gICAgZSA9IGxpbmVhck9mZnNldChzZWdtZW50LnBvaW50c1swXSwgc2VnbWVudC5wb2ludHNbMV0sIGFtb3VudCk7XG4gICAgcDAgPSBlWzBdO1xuICAgIHAxYSA9IGVbMV07XG4gICAgZSA9IGxpbmVhck9mZnNldChzZWdtZW50LnBvaW50c1sxXSwgc2VnbWVudC5wb2ludHNbMl0sIGFtb3VudCk7XG4gICAgcDFiID0gZVswXTtcbiAgICBwMmIgPSBlWzFdO1xuICAgIGUgPSBsaW5lYXJPZmZzZXQoc2VnbWVudC5wb2ludHNbMl0sIHNlZ21lbnQucG9pbnRzWzNdLCBhbW91bnQpO1xuICAgIHAyYSA9IGVbMF07XG4gICAgcDMgPSBlWzFdO1xuICAgIHZhciBwMSA9IGxpbmVJbnRlcnNlY3Rpb24ocDAsIHAxYSwgcDFiLCBwMmIpO1xuICAgIGlmIChwMSA9PT0gbnVsbCkgcDEgPSBwMWE7XG4gICAgdmFyIHAyID0gbGluZUludGVyc2VjdGlvbihwMmEsIHAzLCBwMWIsIHAyYik7XG4gICAgaWYgKHAyID09PSBudWxsKSBwMiA9IHAyYTtcbiAgICByZXR1cm4gbmV3IFBvbHlub21pYWxCZXppZXIocDAsIHAxLCBwMiwgcDMpO1xuICB9XG5cbiAgZnVuY3Rpb24gam9pbkxpbmVzKG91dHB1dEJlemllciwgc2VnMSwgc2VnMiwgbGluZUpvaW4sIG1pdGVyTGltaXQpIHtcbiAgICB2YXIgcDAgPSBzZWcxLnBvaW50c1szXTtcbiAgICB2YXIgcDEgPSBzZWcyLnBvaW50c1swXTsgLy8gQmV2ZWxcblxuICAgIGlmIChsaW5lSm9pbiA9PT0gMykgcmV0dXJuIHAwOyAvLyBDb25uZWN0ZWQsIHRoZXkgZG9uJ3QgbmVlZCBhIGpvaW50XG5cbiAgICBpZiAocG9pbnRFcXVhbChwMCwgcDEpKSByZXR1cm4gcDA7IC8vIFJvdW5kXG5cbiAgICBpZiAobGluZUpvaW4gPT09IDIpIHtcbiAgICAgIHZhciBhbmdsZU91dCA9IC1zZWcxLnRhbmdlbnRBbmdsZSgxKTtcbiAgICAgIHZhciBhbmdsZUluID0gLXNlZzIudGFuZ2VudEFuZ2xlKDApICsgTWF0aC5QSTtcbiAgICAgIHZhciBjZW50ZXIgPSBsaW5lSW50ZXJzZWN0aW9uKHAwLCBwb2xhck9mZnNldChwMCwgYW5nbGVPdXQgKyBNYXRoLlBJIC8gMiwgMTAwKSwgcDEsIHBvbGFyT2Zmc2V0KHAxLCBhbmdsZU91dCArIE1hdGguUEkgLyAyLCAxMDApKTtcbiAgICAgIHZhciByYWRpdXMgPSBjZW50ZXIgPyBwb2ludERpc3RhbmNlKGNlbnRlciwgcDApIDogcG9pbnREaXN0YW5jZShwMCwgcDEpIC8gMjtcbiAgICAgIHZhciB0YW4gPSBwb2xhck9mZnNldChwMCwgYW5nbGVPdXQsIDIgKiByYWRpdXMgKiByb3VuZENvcm5lcik7XG4gICAgICBvdXRwdXRCZXppZXIuc2V0WFlBdCh0YW5bMF0sIHRhblsxXSwgJ28nLCBvdXRwdXRCZXppZXIubGVuZ3RoKCkgLSAxKTtcbiAgICAgIHRhbiA9IHBvbGFyT2Zmc2V0KHAxLCBhbmdsZUluLCAyICogcmFkaXVzICogcm91bmRDb3JuZXIpO1xuICAgICAgb3V0cHV0QmV6aWVyLnNldFRyaXBsZUF0KHAxWzBdLCBwMVsxXSwgcDFbMF0sIHAxWzFdLCB0YW5bMF0sIHRhblsxXSwgb3V0cHV0QmV6aWVyLmxlbmd0aCgpKTtcbiAgICAgIHJldHVybiBwMTtcbiAgICB9IC8vIE1pdGVyXG5cblxuICAgIHZhciB0MCA9IHBvaW50RXF1YWwocDAsIHNlZzEucG9pbnRzWzJdKSA/IHNlZzEucG9pbnRzWzBdIDogc2VnMS5wb2ludHNbMl07XG4gICAgdmFyIHQxID0gcG9pbnRFcXVhbChwMSwgc2VnMi5wb2ludHNbMV0pID8gc2VnMi5wb2ludHNbM10gOiBzZWcyLnBvaW50c1sxXTtcbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gbGluZUludGVyc2VjdGlvbih0MCwgcDAsIHAxLCB0MSk7XG5cbiAgICBpZiAoaW50ZXJzZWN0aW9uICYmIHBvaW50RGlzdGFuY2UoaW50ZXJzZWN0aW9uLCBwMCkgPCBtaXRlckxpbWl0KSB7XG4gICAgICBvdXRwdXRCZXppZXIuc2V0VHJpcGxlQXQoaW50ZXJzZWN0aW9uWzBdLCBpbnRlcnNlY3Rpb25bMV0sIGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdLCBpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXSwgb3V0cHV0QmV6aWVyLmxlbmd0aCgpKTtcbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgICB2YXIgaW50ZXJzZWN0ID0gYS5pbnRlcnNlY3Rpb25zKGIpO1xuICAgIGlmIChpbnRlcnNlY3QubGVuZ3RoICYmIGZsb2F0RXF1YWwoaW50ZXJzZWN0WzBdWzBdLCAxKSkgaW50ZXJzZWN0LnNoaWZ0KCk7XG4gICAgaWYgKGludGVyc2VjdC5sZW5ndGgpIHJldHVybiBpbnRlcnNlY3RbMF07XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBwcnVuZVNlZ21lbnRJbnRlcnNlY3Rpb24oYSwgYikge1xuICAgIHZhciBvdXRhID0gYS5zbGljZSgpO1xuICAgIHZhciBvdXRiID0gYi5zbGljZSgpO1xuICAgIHZhciBpbnRlcnNlY3QgPSBnZXRJbnRlcnNlY3Rpb24oYVthLmxlbmd0aCAtIDFdLCBiWzBdKTtcblxuICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgIG91dGFbYS5sZW5ndGggLSAxXSA9IGFbYS5sZW5ndGggLSAxXS5zcGxpdChpbnRlcnNlY3RbMF0pWzBdO1xuICAgICAgb3V0YlswXSA9IGJbMF0uc3BsaXQoaW50ZXJzZWN0WzFdKVsxXTtcbiAgICB9XG5cbiAgICBpZiAoYS5sZW5ndGggPiAxICYmIGIubGVuZ3RoID4gMSkge1xuICAgICAgaW50ZXJzZWN0ID0gZ2V0SW50ZXJzZWN0aW9uKGFbMF0sIGJbYi5sZW5ndGggLSAxXSk7XG5cbiAgICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgICAgcmV0dXJuIFtbYVswXS5zcGxpdChpbnRlcnNlY3RbMF0pWzBdXSwgW2JbYi5sZW5ndGggLSAxXS5zcGxpdChpbnRlcnNlY3RbMV0pWzFdXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtvdXRhLCBvdXRiXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBydW5lSW50ZXJzZWN0aW9ucyhzZWdtZW50cykge1xuICAgIHZhciBlO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgZSA9IHBydW5lU2VnbWVudEludGVyc2VjdGlvbihzZWdtZW50c1tpIC0gMV0sIHNlZ21lbnRzW2ldKTtcbiAgICAgIHNlZ21lbnRzW2kgLSAxXSA9IGVbMF07XG4gICAgICBzZWdtZW50c1tpXSA9IGVbMV07XG4gICAgfVxuXG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGUgPSBwcnVuZVNlZ21lbnRJbnRlcnNlY3Rpb24oc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0sIHNlZ21lbnRzWzBdKTtcbiAgICAgIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdID0gZVswXTtcbiAgICAgIHNlZ21lbnRzWzBdID0gZVsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VnbWVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBvZmZzZXRTZWdtZW50U3BsaXQoc2VnbWVudCwgYW1vdW50KSB7XG4gICAgLypcclxuICAgICAgV2Ugc3BsaXQgZWFjaCBiZXppZXIgc2VnbWVudCBpbnRvIHNtYWxsZXIgcGllY2VzIGJhc2VkXHJcbiAgICAgIG9uIGluZmxlY3Rpb24gcG9pbnRzLCB0aGlzIGVuc3VyZXMgdGhlIGNvbnRyb2wgcG9pbnRcclxuICAgICAgcG9seWdvbiBpcyBjb252ZXguXHJcbiAgICAgICAgKEEgY3ViaWMgYmV6aWVyIGNhbiBoYXZlIG5vbmUsIG9uZSwgb3IgdHdvIGluZmxlY3Rpb24gcG9pbnRzKVxyXG4gICAgKi9cbiAgICB2YXIgZmxleCA9IHNlZ21lbnQuaW5mbGVjdGlvblBvaW50cygpO1xuICAgIHZhciBsZWZ0O1xuICAgIHZhciByaWdodDtcbiAgICB2YXIgc3BsaXQ7XG4gICAgdmFyIG1pZDtcblxuICAgIGlmIChmbGV4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtvZmZzZXRTZWdtZW50KHNlZ21lbnQsIGFtb3VudCldO1xuICAgIH1cblxuICAgIGlmIChmbGV4Lmxlbmd0aCA9PT0gMSB8fCBmbG9hdEVxdWFsKGZsZXhbMV0sIDEpKSB7XG4gICAgICBzcGxpdCA9IHNlZ21lbnQuc3BsaXQoZmxleFswXSk7XG4gICAgICBsZWZ0ID0gc3BsaXRbMF07XG4gICAgICByaWdodCA9IHNwbGl0WzFdO1xuICAgICAgcmV0dXJuIFtvZmZzZXRTZWdtZW50KGxlZnQsIGFtb3VudCksIG9mZnNldFNlZ21lbnQocmlnaHQsIGFtb3VudCldO1xuICAgIH1cblxuICAgIHNwbGl0ID0gc2VnbWVudC5zcGxpdChmbGV4WzBdKTtcbiAgICBsZWZ0ID0gc3BsaXRbMF07XG4gICAgdmFyIHQgPSAoZmxleFsxXSAtIGZsZXhbMF0pIC8gKDEgLSBmbGV4WzBdKTtcbiAgICBzcGxpdCA9IHNwbGl0WzFdLnNwbGl0KHQpO1xuICAgIG1pZCA9IHNwbGl0WzBdO1xuICAgIHJpZ2h0ID0gc3BsaXRbMV07XG4gICAgcmV0dXJuIFtvZmZzZXRTZWdtZW50KGxlZnQsIGFtb3VudCksIG9mZnNldFNlZ21lbnQobWlkLCBhbW91bnQpLCBvZmZzZXRTZWdtZW50KHJpZ2h0LCBhbW91bnQpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIE9mZnNldFBhdGhNb2RpZmllcigpIHt9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtTaGFwZU1vZGlmaWVyXSwgT2Zmc2V0UGF0aE1vZGlmaWVyKTtcblxuICBPZmZzZXRQYXRoTW9kaWZpZXIucHJvdG90eXBlLmluaXRNb2RpZmllclByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSkge1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLnByb2Nlc3NLZXlzO1xuICAgIHRoaXMuYW1vdW50ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5hLCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLm1pdGVyTGltaXQgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm1sLCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLmxpbmVKb2luID0gZGF0YS5sajtcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gdGhpcy5hbW91bnQuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCAhPT0gMDtcbiAgfTtcblxuICBPZmZzZXRQYXRoTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NQYXRoID0gZnVuY3Rpb24gKGlucHV0QmV6aWVyLCBhbW91bnQsIGxpbmVKb2luLCBtaXRlckxpbWl0KSB7XG4gICAgdmFyIG91dHB1dEJlemllciA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgb3V0cHV0QmV6aWVyLmMgPSBpbnB1dEJlemllci5jO1xuICAgIHZhciBjb3VudCA9IGlucHV0QmV6aWVyLmxlbmd0aCgpO1xuXG4gICAgaWYgKCFpbnB1dEJlemllci5jKSB7XG4gICAgICBjb3VudCAtPSAxO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBqO1xuICAgIHZhciBzZWdtZW50O1xuICAgIHZhciBtdWx0aVNlZ21lbnRzID0gW107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgc2VnbWVudCA9IFBvbHlub21pYWxCZXppZXIuc2hhcGVTZWdtZW50KGlucHV0QmV6aWVyLCBpKTtcbiAgICAgIG11bHRpU2VnbWVudHMucHVzaChvZmZzZXRTZWdtZW50U3BsaXQoc2VnbWVudCwgYW1vdW50KSk7XG4gICAgfVxuXG4gICAgaWYgKCFpbnB1dEJlemllci5jKSB7XG4gICAgICBmb3IgKGkgPSBjb3VudCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHNlZ21lbnQgPSBQb2x5bm9taWFsQmV6aWVyLnNoYXBlU2VnbWVudEludmVydGVkKGlucHV0QmV6aWVyLCBpKTtcbiAgICAgICAgbXVsdGlTZWdtZW50cy5wdXNoKG9mZnNldFNlZ21lbnRTcGxpdChzZWdtZW50LCBhbW91bnQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtdWx0aVNlZ21lbnRzID0gcHJ1bmVJbnRlcnNlY3Rpb25zKG11bHRpU2VnbWVudHMpOyAvLyBBZGQgYmV6aWVyIHNlZ21lbnRzIHRvIHRoZSBvdXRwdXQgYW5kIGFwcGx5IGxpbmUgam9pbnRzXG5cbiAgICB2YXIgbGFzdFBvaW50ID0gbnVsbDtcbiAgICB2YXIgbGFzdFNlZyA9IG51bGw7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbXVsdGlTZWdtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIG11bHRpU2VnbWVudCA9IG11bHRpU2VnbWVudHNbaV07XG4gICAgICBpZiAobGFzdFNlZykgbGFzdFBvaW50ID0gam9pbkxpbmVzKG91dHB1dEJlemllciwgbGFzdFNlZywgbXVsdGlTZWdtZW50WzBdLCBsaW5lSm9pbiwgbWl0ZXJMaW1pdCk7XG4gICAgICBsYXN0U2VnID0gbXVsdGlTZWdtZW50W211bHRpU2VnbWVudC5sZW5ndGggLSAxXTtcblxuICAgICAgZm9yIChqID0gMDsgaiA8IG11bHRpU2VnbWVudC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBzZWdtZW50ID0gbXVsdGlTZWdtZW50W2pdO1xuXG4gICAgICAgIGlmIChsYXN0UG9pbnQgJiYgcG9pbnRFcXVhbChzZWdtZW50LnBvaW50c1swXSwgbGFzdFBvaW50KSkge1xuICAgICAgICAgIG91dHB1dEJlemllci5zZXRYWUF0KHNlZ21lbnQucG9pbnRzWzFdWzBdLCBzZWdtZW50LnBvaW50c1sxXVsxXSwgJ28nLCBvdXRwdXRCZXppZXIubGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXRCZXppZXIuc2V0VHJpcGxlQXQoc2VnbWVudC5wb2ludHNbMF1bMF0sIHNlZ21lbnQucG9pbnRzWzBdWzFdLCBzZWdtZW50LnBvaW50c1sxXVswXSwgc2VnbWVudC5wb2ludHNbMV1bMV0sIHNlZ21lbnQucG9pbnRzWzBdWzBdLCBzZWdtZW50LnBvaW50c1swXVsxXSwgb3V0cHV0QmV6aWVyLmxlbmd0aCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dEJlemllci5zZXRUcmlwbGVBdChzZWdtZW50LnBvaW50c1szXVswXSwgc2VnbWVudC5wb2ludHNbM11bMV0sIHNlZ21lbnQucG9pbnRzWzNdWzBdLCBzZWdtZW50LnBvaW50c1szXVsxXSwgc2VnbWVudC5wb2ludHNbMl1bMF0sIHNlZ21lbnQucG9pbnRzWzJdWzFdLCBvdXRwdXRCZXppZXIubGVuZ3RoKCkpO1xuICAgICAgICBsYXN0UG9pbnQgPSBzZWdtZW50LnBvaW50c1szXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobXVsdGlTZWdtZW50cy5sZW5ndGgpIGpvaW5MaW5lcyhvdXRwdXRCZXppZXIsIGxhc3RTZWcsIG11bHRpU2VnbWVudHNbMF1bMF0sIGxpbmVKb2luLCBtaXRlckxpbWl0KTtcbiAgICByZXR1cm4gb3V0cHV0QmV6aWVyO1xuICB9O1xuXG4gIE9mZnNldFBhdGhNb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1NoYXBlcyA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XG4gICAgdmFyIHNoYXBlUGF0aHM7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc2hhcGVzLmxlbmd0aDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgYW1vdW50ID0gdGhpcy5hbW91bnQudjtcbiAgICB2YXIgbWl0ZXJMaW1pdCA9IHRoaXMubWl0ZXJMaW1pdC52O1xuICAgIHZhciBsaW5lSm9pbiA9IHRoaXMubGluZUpvaW47XG5cbiAgICBpZiAoYW1vdW50ICE9PSAwKSB7XG4gICAgICB2YXIgc2hhcGVEYXRhO1xuICAgICAgdmFyIGxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgc2hhcGVEYXRhID0gdGhpcy5zaGFwZXNbaV07XG4gICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICAgIGlmICghKCFzaGFwZURhdGEuc2hhcGUuX21kZiAmJiAhdGhpcy5fbWRmICYmICFfaXNGaXJzdEZyYW1lKSkge1xuICAgICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uLnJlbGVhc2VTaGFwZXMoKTtcbiAgICAgICAgICBzaGFwZURhdGEuc2hhcGUuX21kZiA9IHRydWU7XG4gICAgICAgICAgc2hhcGVQYXRocyA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5zaGFwZXM7XG4gICAgICAgICAgakxlbiA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5fbGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy5wcm9jZXNzUGF0aChzaGFwZVBhdGhzW2pdLCBhbW91bnQsIGxpbmVKb2luLCBtaXRlckxpbWl0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRGb250UHJvcGVydGllcyhmb250RGF0YSkge1xuICAgIHZhciBzdHlsZXMgPSBmb250RGF0YS5mU3R5bGUgPyBmb250RGF0YS5mU3R5bGUuc3BsaXQoJyAnKSA6IFtdO1xuICAgIHZhciBmV2VpZ2h0ID0gJ25vcm1hbCc7XG4gICAgdmFyIGZTdHlsZSA9ICdub3JtYWwnO1xuICAgIHZhciBsZW4gPSBzdHlsZXMubGVuZ3RoO1xuICAgIHZhciBzdHlsZU5hbWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBzdHlsZU5hbWUgPSBzdHlsZXNbaV0udG9Mb3dlckNhc2UoKTtcblxuICAgICAgc3dpdGNoIChzdHlsZU5hbWUpIHtcbiAgICAgICAgY2FzZSAnaXRhbGljJzpcbiAgICAgICAgICBmU3R5bGUgPSAnaXRhbGljJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdib2xkJzpcbiAgICAgICAgICBmV2VpZ2h0ID0gJzcwMCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYmxhY2snOlxuICAgICAgICAgIGZXZWlnaHQgPSAnOTAwJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtZWRpdW0nOlxuICAgICAgICAgIGZXZWlnaHQgPSAnNTAwJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyZWd1bGFyJzpcbiAgICAgICAgY2FzZSAnbm9ybWFsJzpcbiAgICAgICAgICBmV2VpZ2h0ID0gJzQwMCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbGlnaHQnOlxuICAgICAgICBjYXNlICd0aGluJzpcbiAgICAgICAgICBmV2VpZ2h0ID0gJzIwMCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3R5bGU6IGZTdHlsZSxcbiAgICAgIHdlaWdodDogZm9udERhdGEuZldlaWdodCB8fCBmV2VpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIHZhciBGb250TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWF4V2FpdGluZ1RpbWUgPSA1MDAwO1xuICAgIHZhciBlbXB0eUNoYXIgPSB7XG4gICAgICB3OiAwLFxuICAgICAgc2l6ZTogMCxcbiAgICAgIHNoYXBlczogW10sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNoYXBlczogW11cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjb21iaW5lZENoYXJhY3RlcnMgPSBbXTsgLy8gSGluZGkgY2hhcmFjdGVyc1xuXG4gICAgY29tYmluZWRDaGFyYWN0ZXJzID0gY29tYmluZWRDaGFyYWN0ZXJzLmNvbmNhdChbMjMwNCwgMjMwNSwgMjMwNiwgMjMwNywgMjM2MiwgMjM2MywgMjM2NCwgMjM2NCwgMjM2NiwgMjM2NywgMjM2OCwgMjM2OSwgMjM3MCwgMjM3MSwgMjM3MiwgMjM3MywgMjM3NCwgMjM3NSwgMjM3NiwgMjM3NywgMjM3OCwgMjM3OSwgMjM4MCwgMjM4MSwgMjM4MiwgMjM4MywgMjM4NywgMjM4OCwgMjM4OSwgMjM5MCwgMjM5MSwgMjQwMiwgMjQwM10pO1xuICAgIHZhciBCTEFDS19GTEFHX0NPREVfUE9JTlQgPSAxMjc5ODg7XG4gICAgdmFyIENBTkNFTF9UQUdfQ09ERV9QT0lOVCA9IDkxNzYzMTtcbiAgICB2YXIgQV9UQUdfQ09ERV9QT0lOVCA9IDkxNzYwMTtcbiAgICB2YXIgWl9UQUdfQ09ERV9QT0lOVCA9IDkxNzYyNjtcbiAgICB2YXIgVkFSSUFUSU9OX1NFTEVDVE9SXzE2X0NPREVfUE9JTlQgPSA2NTAzOTtcbiAgICB2YXIgWkVST19XSURUSF9KT0lORVJfQ09ERV9QT0lOVCA9IDgyMDU7XG4gICAgdmFyIFJFR0lPTkFMX0NIQVJBQ1RFUl9BX0NPREVfUE9JTlQgPSAxMjc0NjI7XG4gICAgdmFyIFJFR0lPTkFMX0NIQVJBQ1RFUl9aX0NPREVfUE9JTlQgPSAxMjc0ODc7XG4gICAgdmFyIHN1cnJvZ2F0ZU1vZGlmaWVycyA9IFsnZDgzY2RmZmInLCAnZDgzY2RmZmMnLCAnZDgzY2RmZmQnLCAnZDgzY2RmZmUnLCAnZDgzY2RmZmYnXTtcblxuICAgIGZ1bmN0aW9uIHRyaW1Gb250T3B0aW9ucyhmb250KSB7XG4gICAgICB2YXIgZmFtaWx5QXJyYXkgPSBmb250LnNwbGl0KCcsJyk7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBmYW1pbHlBcnJheS5sZW5ndGg7XG4gICAgICB2YXIgZW5hYmxlZEZhbWlsaWVzID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoZmFtaWx5QXJyYXlbaV0gIT09ICdzYW5zLXNlcmlmJyAmJiBmYW1pbHlBcnJheVtpXSAhPT0gJ21vbm9zcGFjZScpIHtcbiAgICAgICAgICBlbmFibGVkRmFtaWxpZXMucHVzaChmYW1pbHlBcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVuYWJsZWRGYW1pbGllcy5qb2luKCcsJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VXBOb2RlKGZvbnQsIGZhbWlseSkge1xuICAgICAgdmFyIHBhcmVudE5vZGUgPSBjcmVhdGVUYWcoJ3NwYW4nKTsgLy8gTm9kZSBpcyBpbnZpc2libGUgdG8gc2NyZWVuIHJlYWRlcnMuXG5cbiAgICAgIHBhcmVudE5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgICAgcGFyZW50Tm9kZS5zdHlsZS5mb250RmFtaWx5ID0gZmFtaWx5O1xuICAgICAgdmFyIG5vZGUgPSBjcmVhdGVUYWcoJ3NwYW4nKTsgLy8gQ2hhcmFjdGVycyB0aGF0IHZhcnkgc2lnbmlmaWNhbnRseSBhbW9uZyBkaWZmZXJlbnQgZm9udHNcblxuICAgICAgbm9kZS5pbm5lclRleHQgPSAnZ2lJdFQxV1F5QCEtLyMnOyAvLyBWaXNpYmxlIC0gc28gd2UgY2FuIG1lYXN1cmUgaXQgLSBidXQgbm90IG9uIHRoZSBzY3JlZW5cblxuICAgICAgcGFyZW50Tm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBwYXJlbnROb2RlLnN0eWxlLmxlZnQgPSAnLTEwMDAwcHgnO1xuICAgICAgcGFyZW50Tm9kZS5zdHlsZS50b3AgPSAnLTEwMDAwcHgnOyAvLyBMYXJnZSBmb250IHNpemUgbWFrZXMgZXZlbiBzdWJ0bGUgY2hhbmdlcyBvYnZpb3VzXG5cbiAgICAgIHBhcmVudE5vZGUuc3R5bGUuZm9udFNpemUgPSAnMzAwcHgnOyAvLyBSZXNldCBhbnkgZm9udCBwcm9wZXJ0aWVzXG5cbiAgICAgIHBhcmVudE5vZGUuc3R5bGUuZm9udFZhcmlhbnQgPSAnbm9ybWFsJztcbiAgICAgIHBhcmVudE5vZGUuc3R5bGUuZm9udFN0eWxlID0gJ25vcm1hbCc7XG4gICAgICBwYXJlbnROb2RlLnN0eWxlLmZvbnRXZWlnaHQgPSAnbm9ybWFsJztcbiAgICAgIHBhcmVudE5vZGUuc3R5bGUubGV0dGVyU3BhY2luZyA9ICcwJztcbiAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBhcmVudE5vZGUpOyAvLyBSZW1lbWJlciB3aWR0aCB3aXRoIG5vIGFwcGxpZWQgd2ViIGZvbnRcblxuICAgICAgdmFyIHdpZHRoID0gbm9kZS5vZmZzZXRXaWR0aDtcbiAgICAgIG5vZGUuc3R5bGUuZm9udEZhbWlseSA9IHRyaW1Gb250T3B0aW9ucyhmb250KSArICcsICcgKyBmYW1pbHk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgcGFyZW50OiBwYXJlbnROb2RlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrTG9hZGVkRm9udHMoKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmZvbnRzLmxlbmd0aDtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdmFyIHc7XG4gICAgICB2YXIgbG9hZGVkQ291bnQgPSBsZW47XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAodGhpcy5mb250c1tpXS5sb2FkZWQpIHtcbiAgICAgICAgICBsb2FkZWRDb3VudCAtPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZm9udHNbaV0uZk9yaWdpbiA9PT0gJ24nIHx8IHRoaXMuZm9udHNbaV0ub3JpZ2luID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5mb250c1tpXS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmZvbnRzW2ldLm1vbm9DYXNlLm5vZGU7XG4gICAgICAgICAgdyA9IHRoaXMuZm9udHNbaV0ubW9ub0Nhc2UudztcblxuICAgICAgICAgIGlmIChub2RlLm9mZnNldFdpZHRoICE9PSB3KSB7XG4gICAgICAgICAgICBsb2FkZWRDb3VudCAtPSAxO1xuICAgICAgICAgICAgdGhpcy5mb250c1tpXS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5mb250c1tpXS5zYW5zQ2FzZS5ub2RlO1xuICAgICAgICAgICAgdyA9IHRoaXMuZm9udHNbaV0uc2Fuc0Nhc2UudztcblxuICAgICAgICAgICAgaWYgKG5vZGUub2Zmc2V0V2lkdGggIT09IHcpIHtcbiAgICAgICAgICAgICAgbG9hZGVkQ291bnQgLT0gMTtcbiAgICAgICAgICAgICAgdGhpcy5mb250c1tpXS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmZvbnRzW2ldLmxvYWRlZCkge1xuICAgICAgICAgICAgdGhpcy5mb250c1tpXS5zYW5zQ2FzZS5wYXJlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvbnRzW2ldLnNhbnNDYXNlLnBhcmVudCk7XG4gICAgICAgICAgICB0aGlzLmZvbnRzW2ldLm1vbm9DYXNlLnBhcmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9udHNbaV0ubW9ub0Nhc2UucGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxvYWRlZENvdW50ICE9PSAwICYmIERhdGUubm93KCkgLSB0aGlzLmluaXRUaW1lIDwgbWF4V2FpdGluZ1RpbWUpIHtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLmNoZWNrTG9hZGVkRm9udHNCaW5kZWQsIDIwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5zZXRJc0xvYWRlZEJpbmRlZCwgMTApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhlbHBlcihmb250RGF0YSwgZGVmKSB7XG4gICAgICB2YXIgZW5naW5lID0gZG9jdW1lbnQuYm9keSAmJiBkZWYgPyAnc3ZnJyA6ICdjYW52YXMnO1xuICAgICAgdmFyIGhlbHBlcjtcbiAgICAgIHZhciBmb250UHJvcHMgPSBnZXRGb250UHJvcGVydGllcyhmb250RGF0YSk7XG5cbiAgICAgIGlmIChlbmdpbmUgPT09ICdzdmcnKSB7XG4gICAgICAgIHZhciB0SGVscGVyID0gY3JlYXRlTlMoJ3RleHQnKTtcbiAgICAgICAgdEhlbHBlci5zdHlsZS5mb250U2l6ZSA9ICcxMDBweCc7IC8vIHRIZWxwZXIuc3R5bGUuZm9udEZhbWlseSA9IGZvbnREYXRhLmZGYW1pbHk7XG5cbiAgICAgICAgdEhlbHBlci5zZXRBdHRyaWJ1dGUoJ2ZvbnQtZmFtaWx5JywgZm9udERhdGEuZkZhbWlseSk7XG4gICAgICAgIHRIZWxwZXIuc2V0QXR0cmlidXRlKCdmb250LXN0eWxlJywgZm9udFByb3BzLnN0eWxlKTtcbiAgICAgICAgdEhlbHBlci5zZXRBdHRyaWJ1dGUoJ2ZvbnQtd2VpZ2h0JywgZm9udFByb3BzLndlaWdodCk7XG4gICAgICAgIHRIZWxwZXIudGV4dENvbnRlbnQgPSAnMSc7XG5cbiAgICAgICAgaWYgKGZvbnREYXRhLmZDbGFzcykge1xuICAgICAgICAgIHRIZWxwZXIuc3R5bGUuZm9udEZhbWlseSA9ICdpbmhlcml0JztcbiAgICAgICAgICB0SGVscGVyLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBmb250RGF0YS5mQ2xhc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRIZWxwZXIuc3R5bGUuZm9udEZhbWlseSA9IGZvbnREYXRhLmZGYW1pbHk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWYuYXBwZW5kQ2hpbGQodEhlbHBlcik7XG4gICAgICAgIGhlbHBlciA9IHRIZWxwZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdENhbnZhc0hlbHBlciA9IG5ldyBPZmZzY3JlZW5DYW52YXMoNTAwLCA1MDApLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRDYW52YXNIZWxwZXIuZm9udCA9IGZvbnRQcm9wcy5zdHlsZSArICcgJyArIGZvbnRQcm9wcy53ZWlnaHQgKyAnIDEwMHB4ICcgKyBmb250RGF0YS5mRmFtaWx5O1xuICAgICAgICBoZWxwZXIgPSB0Q2FudmFzSGVscGVyO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtZWFzdXJlKHRleHQpIHtcbiAgICAgICAgaWYgKGVuZ2luZSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICBoZWxwZXIudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgIHJldHVybiBoZWxwZXIuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGVscGVyLm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZWFzdXJlVGV4dDogbWVhc3VyZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRGb250cyhmb250RGF0YSwgZGVmcykge1xuICAgICAgaWYgKCFmb250RGF0YSkge1xuICAgICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jaGFycykge1xuICAgICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mb250cyA9IGZvbnREYXRhLmxpc3Q7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICBmb250RGF0YS5saXN0LmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBkYXRhLmhlbHBlciA9IGNyZWF0ZUhlbHBlcihkYXRhKTtcbiAgICAgICAgICBkYXRhLmNhY2hlID0ge307XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZvbnRzID0gZm9udERhdGEubGlzdDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZm9udEFyciA9IGZvbnREYXRhLmxpc3Q7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBmb250QXJyLmxlbmd0aDtcbiAgICAgIHZhciBfcGVuZGluZ0ZvbnRzID0gbGVuO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHNob3VsZExvYWRGb250ID0gdHJ1ZTtcbiAgICAgICAgdmFyIGxvYWRlZFNlbGVjdG9yO1xuICAgICAgICB2YXIgajtcbiAgICAgICAgZm9udEFycltpXS5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgZm9udEFycltpXS5tb25vQ2FzZSA9IHNldFVwTm9kZShmb250QXJyW2ldLmZGYW1pbHksICdtb25vc3BhY2UnKTtcbiAgICAgICAgZm9udEFycltpXS5zYW5zQ2FzZSA9IHNldFVwTm9kZShmb250QXJyW2ldLmZGYW1pbHksICdzYW5zLXNlcmlmJyk7XG5cbiAgICAgICAgaWYgKCFmb250QXJyW2ldLmZQYXRoKSB7XG4gICAgICAgICAgZm9udEFycltpXS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgIF9wZW5kaW5nRm9udHMgLT0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChmb250QXJyW2ldLmZPcmlnaW4gPT09ICdwJyB8fCBmb250QXJyW2ldLm9yaWdpbiA9PT0gMykge1xuICAgICAgICAgIGxvYWRlZFNlbGVjdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbZi1mb3JpZ2luPVwicFwiXVtmLWZhbWlseT1cIicgKyBmb250QXJyW2ldLmZGYW1pbHkgKyAnXCJdLCBzdHlsZVtmLW9yaWdpbj1cIjNcIl1bZi1mYW1pbHk9XCInICsgZm9udEFycltpXS5mRmFtaWx5ICsgJ1wiXScpO1xuXG4gICAgICAgICAgaWYgKGxvYWRlZFNlbGVjdG9yLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNob3VsZExvYWRGb250ID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNob3VsZExvYWRGb250KSB7XG4gICAgICAgICAgICB2YXIgcyA9IGNyZWF0ZVRhZygnc3R5bGUnKTtcbiAgICAgICAgICAgIHMuc2V0QXR0cmlidXRlKCdmLWZvcmlnaW4nLCBmb250QXJyW2ldLmZPcmlnaW4pO1xuICAgICAgICAgICAgcy5zZXRBdHRyaWJ1dGUoJ2Ytb3JpZ2luJywgZm9udEFycltpXS5vcmlnaW4pO1xuICAgICAgICAgICAgcy5zZXRBdHRyaWJ1dGUoJ2YtZmFtaWx5JywgZm9udEFycltpXS5mRmFtaWx5KTtcbiAgICAgICAgICAgIHMudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICAgICAgICBzLmlubmVyVGV4dCA9ICdAZm9udC1mYWNlIHtmb250LWZhbWlseTogJyArIGZvbnRBcnJbaV0uZkZhbWlseSArIFwiOyBmb250LXN0eWxlOiBub3JtYWw7IHNyYzogdXJsKCdcIiArIGZvbnRBcnJbaV0uZlBhdGggKyBcIicpO31cIjtcbiAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQocyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZvbnRBcnJbaV0uZk9yaWdpbiA9PT0gJ2cnIHx8IGZvbnRBcnJbaV0ub3JpZ2luID09PSAxKSB7XG4gICAgICAgICAgbG9hZGVkU2VsZWN0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaW5rW2YtZm9yaWdpbj1cImdcIl0sIGxpbmtbZi1vcmlnaW49XCIxXCJdJyk7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbG9hZGVkU2VsZWN0b3IubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChsb2FkZWRTZWxlY3RvcltqXS5ocmVmLmluZGV4T2YoZm9udEFycltpXS5mUGF0aCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgIC8vIEZvbnQgaXMgYWxyZWFkeSBsb2FkZWRcbiAgICAgICAgICAgICAgc2hvdWxkTG9hZEZvbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2hvdWxkTG9hZEZvbnQpIHtcbiAgICAgICAgICAgIHZhciBsID0gY3JlYXRlVGFnKCdsaW5rJyk7XG4gICAgICAgICAgICBsLnNldEF0dHJpYnV0ZSgnZi1mb3JpZ2luJywgZm9udEFycltpXS5mT3JpZ2luKTtcbiAgICAgICAgICAgIGwuc2V0QXR0cmlidXRlKCdmLW9yaWdpbicsIGZvbnRBcnJbaV0ub3JpZ2luKTtcbiAgICAgICAgICAgIGwudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICAgICAgICBsLnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICAgICAgICAgIGwuaHJlZiA9IGZvbnRBcnJbaV0uZlBhdGg7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmb250QXJyW2ldLmZPcmlnaW4gPT09ICd0JyB8fCBmb250QXJyW2ldLm9yaWdpbiA9PT0gMikge1xuICAgICAgICAgIGxvYWRlZFNlbGVjdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0W2YtZm9yaWdpbj1cInRcIl0sIHNjcmlwdFtmLW9yaWdpbj1cIjJcIl0nKTtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsb2FkZWRTZWxlY3Rvci5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgaWYgKGZvbnRBcnJbaV0uZlBhdGggPT09IGxvYWRlZFNlbGVjdG9yW2pdLnNyYykge1xuICAgICAgICAgICAgICAvLyBGb250IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICAgICAgICAgIHNob3VsZExvYWRGb250ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNob3VsZExvYWRGb250KSB7XG4gICAgICAgICAgICB2YXIgc2MgPSBjcmVhdGVUYWcoJ2xpbmsnKTtcbiAgICAgICAgICAgIHNjLnNldEF0dHJpYnV0ZSgnZi1mb3JpZ2luJywgZm9udEFycltpXS5mT3JpZ2luKTtcbiAgICAgICAgICAgIHNjLnNldEF0dHJpYnV0ZSgnZi1vcmlnaW4nLCBmb250QXJyW2ldLm9yaWdpbik7XG4gICAgICAgICAgICBzYy5zZXRBdHRyaWJ1dGUoJ3JlbCcsICdzdHlsZXNoZWV0Jyk7XG4gICAgICAgICAgICBzYy5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBmb250QXJyW2ldLmZQYXRoKTtcbiAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoc2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvbnRBcnJbaV0uaGVscGVyID0gY3JlYXRlSGVscGVyKGZvbnRBcnJbaV0sIGRlZnMpO1xuICAgICAgICBmb250QXJyW2ldLmNhY2hlID0ge307XG4gICAgICAgIHRoaXMuZm9udHMucHVzaChmb250QXJyW2ldKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9wZW5kaW5nRm9udHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbiBzb21lIGNhc2VzIGV2ZW4gaWYgdGhlIGZvbnQgaXMgbG9hZGVkLCBpdCB3b24ndCBsb2FkIGNvcnJlY3RseSB3aGVuIG1lYXN1cmluZyB0ZXh0IG9uIGNhbnZhcy5cbiAgICAgICAgLy8gQWRkaW5nIHRoaXMgdGltZW91dCBzZWVtcyB0byBmaXggaXRcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLmNoZWNrTG9hZGVkRm9udHMuYmluZCh0aGlzKSwgMTAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRDaGFycyhjaGFycykge1xuICAgICAgaWYgKCFjaGFycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5jaGFycykge1xuICAgICAgICB0aGlzLmNoYXJzID0gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IGNoYXJzLmxlbmd0aDtcbiAgICAgIHZhciBqO1xuICAgICAgdmFyIGpMZW4gPSB0aGlzLmNoYXJzLmxlbmd0aDtcbiAgICAgIHZhciBmb3VuZDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGogPSAwO1xuICAgICAgICBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlIChqIDwgakxlbikge1xuICAgICAgICAgIGlmICh0aGlzLmNoYXJzW2pdLnN0eWxlID09PSBjaGFyc1tpXS5zdHlsZSAmJiB0aGlzLmNoYXJzW2pdLmZGYW1pbHkgPT09IGNoYXJzW2ldLmZGYW1pbHkgJiYgdGhpcy5jaGFyc1tqXS5jaCA9PT0gY2hhcnNbaV0uY2gpIHtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgdGhpcy5jaGFycy5wdXNoKGNoYXJzW2ldKTtcbiAgICAgICAgICBqTGVuICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDaGFyRGF0YShfY2hhciwgc3R5bGUsIGZvbnQpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmNoYXJzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhcnNbaV0uY2ggPT09IF9jaGFyICYmIHRoaXMuY2hhcnNbaV0uc3R5bGUgPT09IHN0eWxlICYmIHRoaXMuY2hhcnNbaV0uZkZhbWlseSA9PT0gZm9udCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJzW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHR5cGVvZiBfY2hhciA9PT0gJ3N0cmluZycgJiYgX2NoYXIuY2hhckNvZGVBdCgwKSAhPT0gMTMgfHwgIV9jaGFyKSAmJiBjb25zb2xlICYmIGNvbnNvbGUud2FybiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICYmICF0aGlzLl93YXJuZWQpIHtcbiAgICAgICAgdGhpcy5fd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS53YXJuKCdNaXNzaW5nIGNoYXJhY3RlciBmcm9tIGV4cG9ydGVkIGNoYXJhY3RlcnMgbGlzdDogJywgX2NoYXIsIHN0eWxlLCBmb250KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbXB0eUNoYXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVhc3VyZVRleHQoX2NoYXIyLCBmb250TmFtZSwgc2l6ZSkge1xuICAgICAgdmFyIGZvbnREYXRhID0gdGhpcy5nZXRGb250QnlOYW1lKGZvbnROYW1lKTsgLy8gVXNpbmcgdGhlIGNoYXIgaW5zdGVhZCBvZiBjaGFyLmNoYXJDb2RlQXQoMClcbiAgICAgIC8vIHRvIGF2b2lkIGNvbGxpc2lvbnMgYmV0d2VlbiBlcXVhbCBjaGFyc1xuXG4gICAgICB2YXIgaW5kZXggPSBfY2hhcjI7XG5cbiAgICAgIGlmICghZm9udERhdGEuY2FjaGVbaW5kZXhdKSB7XG4gICAgICAgIHZhciB0SGVscGVyID0gZm9udERhdGEuaGVscGVyO1xuXG4gICAgICAgIGlmIChfY2hhcjIgPT09ICcgJykge1xuICAgICAgICAgIHZhciBkb3VibGVTaXplID0gdEhlbHBlci5tZWFzdXJlVGV4dCgnfCcgKyBfY2hhcjIgKyAnfCcpO1xuICAgICAgICAgIHZhciBzaW5nbGVTaXplID0gdEhlbHBlci5tZWFzdXJlVGV4dCgnfHwnKTtcbiAgICAgICAgICBmb250RGF0YS5jYWNoZVtpbmRleF0gPSAoZG91YmxlU2l6ZSAtIHNpbmdsZVNpemUpIC8gMTAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvbnREYXRhLmNhY2hlW2luZGV4XSA9IHRIZWxwZXIubWVhc3VyZVRleHQoX2NoYXIyKSAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm9udERhdGEuY2FjaGVbaW5kZXhdICogc2l6ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRGb250QnlOYW1lKG5hbWUpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmZvbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuZm9udHNbaV0uZk5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mb250c1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZm9udHNbMF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q29kZVBvaW50KHN0cmluZykge1xuICAgICAgdmFyIGNvZGVQb2ludCA9IDA7XG4gICAgICB2YXIgZmlyc3QgPSBzdHJpbmcuY2hhckNvZGVBdCgwKTtcblxuICAgICAgaWYgKGZpcnN0ID49IDB4RDgwMCAmJiBmaXJzdCA8PSAweERCRkYpIHtcbiAgICAgICAgdmFyIHNlY29uZCA9IHN0cmluZy5jaGFyQ29kZUF0KDEpO1xuXG4gICAgICAgIGlmIChzZWNvbmQgPj0gMHhEQzAwICYmIHNlY29uZCA8PSAweERGRkYpIHtcbiAgICAgICAgICBjb2RlUG9pbnQgPSAoZmlyc3QgLSAweEQ4MDApICogMHg0MDAgKyBzZWNvbmQgLSAweERDMDAgKyAweDEwMDAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2RlUG9pbnQ7XG4gICAgfSAvLyBTa2luIHRvbmUgbW9kaWZpZXJzXG5cblxuICAgIGZ1bmN0aW9uIGlzTW9kaWZpZXIoZmlyc3RDaGFyQ29kZSwgc2Vjb25kQ2hhckNvZGUpIHtcbiAgICAgIHZhciBzdW0gPSBmaXJzdENoYXJDb2RlLnRvU3RyaW5nKDE2KSArIHNlY29uZENoYXJDb2RlLnRvU3RyaW5nKDE2KTtcbiAgICAgIHJldHVybiBzdXJyb2dhdGVNb2RpZmllcnMuaW5kZXhPZihzdW0pICE9PSAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1plcm9XaWR0aEpvaW5lcihjaGFyQ29kZSkge1xuICAgICAgcmV0dXJuIGNoYXJDb2RlID09PSBaRVJPX1dJRFRIX0pPSU5FUl9DT0RFX1BPSU5UO1xuICAgIH0gLy8gVGhpcyBjb2RlcG9pbnQgbWF5IGNoYW5nZSB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgcHJlY2VkaW5nIGNoYXJhY3Rlci5cbiAgICAvLyBJZiB0aGF0IGlzIGEgc3ltYm9sLCBkaW5nYmF0IG9yIGVtb2ppLCBVK0ZFMEYgZm9yY2VzIGl0IHRvIGJlIHJlbmRlcmVkXG4gICAgLy8gYXMgYSBjb2xvcmZ1bCBpbWFnZSBhcyBjb21wYXJlZCB0byBhIG1vbm9jaHJvbWUgdGV4dCB2YXJpYW50LlxuXG5cbiAgICBmdW5jdGlvbiBpc1ZhcmlhdGlvblNlbGVjdG9yKGNoYXJDb2RlKSB7XG4gICAgICByZXR1cm4gY2hhckNvZGUgPT09IFZBUklBVElPTl9TRUxFQ1RPUl8xNl9DT0RFX1BPSU5UO1xuICAgIH0gLy8gVGhlIHJlZ2lvbmFsIGluZGljYXRvciBzeW1ib2xzIGFyZSBhIHNldCBvZiAyNiBhbHBoYWJldGljIFVuaWNvZGVcbiAgICAvLy8gY2hhcmFjdGVycyAoQeKAk1opIGludGVuZGVkIHRvIGJlIHVzZWQgdG8gZW5jb2RlIElTTyAzMTY2LTEgYWxwaGEtMlxuICAgIC8vIHR3by1sZXR0ZXIgY291bnRyeSBjb2RlcyBpbiBhIHdheSB0aGF0IGFsbG93cyBvcHRpb25hbCBzcGVjaWFsIHRyZWF0bWVudC5cblxuXG4gICAgZnVuY3Rpb24gaXNSZWdpb25hbENvZGUoc3RyaW5nKSB7XG4gICAgICB2YXIgY29kZVBvaW50ID0gZ2V0Q29kZVBvaW50KHN0cmluZyk7XG5cbiAgICAgIGlmIChjb2RlUG9pbnQgPj0gUkVHSU9OQUxfQ0hBUkFDVEVSX0FfQ09ERV9QT0lOVCAmJiBjb2RlUG9pbnQgPD0gUkVHSU9OQUxfQ0hBUkFDVEVSX1pfQ09ERV9QT0lOVCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gU29tZSBFbW9qaSBpbXBsZW1lbnRhdGlvbnMgcmVwcmVzZW50IGNvbWJpbmF0aW9ucyBvZlxuICAgIC8vIHR3byDigJxyZWdpb25hbCBpbmRpY2F0b3LigJ0gbGV0dGVycyBhcyBhIHNpbmdsZSBmbGFnIHN5bWJvbC5cblxuXG4gICAgZnVuY3Rpb24gaXNGbGFnRW1vamkoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gaXNSZWdpb25hbENvZGUoc3RyaW5nLnN1YnN0cigwLCAyKSkgJiYgaXNSZWdpb25hbENvZGUoc3RyaW5nLnN1YnN0cigyLCAyKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDb21iaW5lZENoYXJhY3RlcihfY2hhcjMpIHtcbiAgICAgIHJldHVybiBjb21iaW5lZENoYXJhY3RlcnMuaW5kZXhPZihfY2hhcjMpICE9PSAtMTtcbiAgICB9IC8vIFJlZ2lvbmFsIGZsYWdzIHN0YXJ0IHdpdGggYSBCTEFDS19GTEFHX0NPREVfUE9JTlRcbiAgICAvLyBmb2xvd2VkIGJ5IDUgY2hhcnMgaW4gdGhlIFRBRyByYW5nZVxuICAgIC8vIGFuZCBlbmQgd2l0aCBhIENBTkNFTF9UQUdfQ09ERV9QT0lOVFxuXG5cbiAgICBmdW5jdGlvbiBpc1JlZ2lvbmFsRmxhZyh0ZXh0LCBpbmRleCkge1xuICAgICAgdmFyIGNvZGVQb2ludCA9IGdldENvZGVQb2ludCh0ZXh0LnN1YnN0cihpbmRleCwgMikpO1xuXG4gICAgICBpZiAoY29kZVBvaW50ICE9PSBCTEFDS19GTEFHX0NPREVfUE9JTlQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgaW5kZXggKz0gMjtcblxuICAgICAgd2hpbGUgKGNvdW50IDwgNSkge1xuICAgICAgICBjb2RlUG9pbnQgPSBnZXRDb2RlUG9pbnQodGV4dC5zdWJzdHIoaW5kZXgsIDIpKTtcblxuICAgICAgICBpZiAoY29kZVBvaW50IDwgQV9UQUdfQ09ERV9QT0lOVCB8fCBjb2RlUG9pbnQgPiBaX1RBR19DT0RFX1BPSU5UKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldENvZGVQb2ludCh0ZXh0LnN1YnN0cihpbmRleCwgMikpID09PSBDQU5DRUxfVEFHX0NPREVfUE9JTlQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0SXNMb2FkZWQoKSB7XG4gICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgRm9udCA9IGZ1bmN0aW9uIEZvbnQoKSB7XG4gICAgICB0aGlzLmZvbnRzID0gW107XG4gICAgICB0aGlzLmNoYXJzID0gbnVsbDtcbiAgICAgIHRoaXMudHlwZWtpdExvYWRlZCA9IDA7XG4gICAgICB0aGlzLmlzTG9hZGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl93YXJuZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaW5pdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgdGhpcy5zZXRJc0xvYWRlZEJpbmRlZCA9IHRoaXMuc2V0SXNMb2FkZWQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuY2hlY2tMb2FkZWRGb250c0JpbmRlZCA9IHRoaXMuY2hlY2tMb2FkZWRGb250cy5iaW5kKHRoaXMpO1xuICAgIH07XG5cbiAgICBGb250LmlzTW9kaWZpZXIgPSBpc01vZGlmaWVyO1xuICAgIEZvbnQuaXNaZXJvV2lkdGhKb2luZXIgPSBpc1plcm9XaWR0aEpvaW5lcjtcbiAgICBGb250LmlzRmxhZ0Vtb2ppID0gaXNGbGFnRW1vamk7XG4gICAgRm9udC5pc1JlZ2lvbmFsQ29kZSA9IGlzUmVnaW9uYWxDb2RlO1xuICAgIEZvbnQuaXNDb21iaW5lZENoYXJhY3RlciA9IGlzQ29tYmluZWRDaGFyYWN0ZXI7XG4gICAgRm9udC5pc1JlZ2lvbmFsRmxhZyA9IGlzUmVnaW9uYWxGbGFnO1xuICAgIEZvbnQuaXNWYXJpYXRpb25TZWxlY3RvciA9IGlzVmFyaWF0aW9uU2VsZWN0b3I7XG4gICAgRm9udC5CTEFDS19GTEFHX0NPREVfUE9JTlQgPSBCTEFDS19GTEFHX0NPREVfUE9JTlQ7XG4gICAgdmFyIGZvbnRQcm90b3R5cGUgPSB7XG4gICAgICBhZGRDaGFyczogYWRkQ2hhcnMsXG4gICAgICBhZGRGb250czogYWRkRm9udHMsXG4gICAgICBnZXRDaGFyRGF0YTogZ2V0Q2hhckRhdGEsXG4gICAgICBnZXRGb250QnlOYW1lOiBnZXRGb250QnlOYW1lLFxuICAgICAgbWVhc3VyZVRleHQ6IG1lYXN1cmVUZXh0LFxuICAgICAgY2hlY2tMb2FkZWRGb250czogY2hlY2tMb2FkZWRGb250cyxcbiAgICAgIHNldElzTG9hZGVkOiBzZXRJc0xvYWRlZFxuICAgIH07XG4gICAgRm9udC5wcm90b3R5cGUgPSBmb250UHJvdG90eXBlO1xuICAgIHJldHVybiBGb250O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gU2xvdE1hbmFnZXIoYW5pbWF0aW9uRGF0YSkge1xuICAgIHRoaXMuYW5pbWF0aW9uRGF0YSA9IGFuaW1hdGlvbkRhdGE7XG4gIH1cblxuICBTbG90TWFuYWdlci5wcm90b3R5cGUuZ2V0UHJvcCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uRGF0YS5zbG90cyAmJiB0aGlzLmFuaW1hdGlvbkRhdGEuc2xvdHNbZGF0YS5zaWRdKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkYXRhLCB0aGlzLmFuaW1hdGlvbkRhdGEuc2xvdHNbZGF0YS5zaWRdLnApO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNsb3RGYWN0b3J5KGFuaW1hdGlvbkRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFNsb3RNYW5hZ2VyKGFuaW1hdGlvbkRhdGEpO1xuICB9XG5cbiAgZnVuY3Rpb24gUmVuZGVyYWJsZUVsZW1lbnQoKSB7fVxuXG4gIFJlbmRlcmFibGVFbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgICBpbml0UmVuZGVyYWJsZTogZnVuY3Rpb24gaW5pdFJlbmRlcmFibGUoKSB7XG4gICAgICAvLyBsYXllcidzIHZpc2liaWxpdHkgcmVsYXRlZCB0byBpbnBvaW50IGFuZCBvdXRwb2ludC4gUmVuYW1lIGlzVmlzaWJsZSB0byBpc0luUmFuZ2VcbiAgICAgIHRoaXMuaXNJblJhbmdlID0gZmFsc2U7IC8vIGxheWVyJ3MgZGlzcGxheSBzdGF0ZVxuXG4gICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlOyAvLyBJZiBsYXllcidzIHRyYW5zcGFyZW5jeSBlcXVhbHMgMCwgaXQgY2FuIGJlIGhpZGRlblxuXG4gICAgICB0aGlzLmlzVHJhbnNwYXJlbnQgPSBmYWxzZTsgLy8gbGlzdCBvZiBhbmltYXRlZCBjb21wb25lbnRzXG5cbiAgICAgIHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMgPSBbXTtcbiAgICB9LFxuICAgIGFkZFJlbmRlcmFibGVDb21wb25lbnQ6IGZ1bmN0aW9uIGFkZFJlbmRlcmFibGVDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5pbmRleE9mKGNvbXBvbmVudCkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlUmVuZGVyYWJsZUNvbXBvbmVudDogZnVuY3Rpb24gcmVtb3ZlUmVuZGVyYWJsZUNvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmFibGVDb21wb25lbnRzLmluZGV4T2YoY29tcG9uZW50KSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5zcGxpY2UodGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5pbmRleE9mKGNvbXBvbmVudCksIDEpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJlcGFyZVJlbmRlcmFibGVGcmFtZTogZnVuY3Rpb24gcHJlcGFyZVJlbmRlcmFibGVGcmFtZShudW0pIHtcbiAgICAgIHRoaXMuY2hlY2tMYXllckxpbWl0cyhudW0pO1xuICAgIH0sXG4gICAgY2hlY2tUcmFuc3BhcmVuY3k6IGZ1bmN0aW9uIGNoZWNrVHJhbnNwYXJlbmN5KCkge1xuICAgICAgaWYgKHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3Auby52IDw9IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVHJhbnNwYXJlbnQgJiYgdGhpcy5nbG9iYWxEYXRhLnJlbmRlckNvbmZpZy5oaWRlT25UcmFuc3BhcmVudCkge1xuICAgICAgICAgIHRoaXMuaXNUcmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1RyYW5zcGFyZW50KSB7XG4gICAgICAgIHRoaXMuaXNUcmFuc3BhcmVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKiBJbml0aWFsaXplcyBmcmFtZSByZWxhdGVkIHByb3BlcnRpZXMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1cclxuICAgICAgICogY3VycmVudCBmcmFtZSBudW1iZXIgaW4gTGF5ZXIncyB0aW1lXHJcbiAgICAgICAqXHJcbiAgICAgICAqL1xuICAgIGNoZWNrTGF5ZXJMaW1pdHM6IGZ1bmN0aW9uIGNoZWNrTGF5ZXJMaW1pdHMobnVtKSB7XG4gICAgICBpZiAodGhpcy5kYXRhLmlwIC0gdGhpcy5kYXRhLnN0IDw9IG51bSAmJiB0aGlzLmRhdGEub3AgLSB0aGlzLmRhdGEuc3QgPiBudW0pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNJblJhbmdlICE9PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLl9tZGYgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5pc0luUmFuZ2UgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNJblJhbmdlICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEuX21kZiA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNJblJhbmdlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyUmVuZGVyYWJsZTogZnVuY3Rpb24gcmVuZGVyUmVuZGVyYWJsZSgpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50c1tpXS5yZW5kZXJGcmFtZSh0aGlzLl9pc0ZpcnN0RnJhbWUpO1xuICAgICAgfVxuICAgICAgLyogdGhpcy5tYXNrTWFuYWdlci5yZW5kZXJGcmFtZSh0aGlzLmZpbmFsVHJhbnNmb3JtLm1hdCk7XHJcbiAgICAgICAgICB0aGlzLnJlbmRlcmFibGVFZmZlY3RzTWFuYWdlci5yZW5kZXJGcmFtZSh0aGlzLl9pc0ZpcnN0RnJhbWUpOyAqL1xuXG4gICAgfSxcbiAgICBzb3VyY2VSZWN0QXRUaW1lOiBmdW5jdGlvbiBzb3VyY2VSZWN0QXRUaW1lKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB3aWR0aDogMTAwLFxuICAgICAgICBoZWlnaHQ6IDEwMFxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldExheWVyU2l6ZTogZnVuY3Rpb24gZ2V0TGF5ZXJTaXplKCkge1xuICAgICAgaWYgKHRoaXMuZGF0YS50eSA9PT0gNSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHc6IHRoaXMuZGF0YS50ZXh0RGF0YS53aWR0aCxcbiAgICAgICAgICBoOiB0aGlzLmRhdGEudGV4dERhdGEuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHc6IHRoaXMuZGF0YS53aWR0aCxcbiAgICAgICAgaDogdGhpcy5kYXRhLmhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEJsZW5kTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYmxlbmRNb2RlRW51bXMgPSB7XG4gICAgICAwOiAnc291cmNlLW92ZXInLFxuICAgICAgMTogJ211bHRpcGx5JyxcbiAgICAgIDI6ICdzY3JlZW4nLFxuICAgICAgMzogJ292ZXJsYXknLFxuICAgICAgNDogJ2RhcmtlbicsXG4gICAgICA1OiAnbGlnaHRlbicsXG4gICAgICA2OiAnY29sb3ItZG9kZ2UnLFxuICAgICAgNzogJ2NvbG9yLWJ1cm4nLFxuICAgICAgODogJ2hhcmQtbGlnaHQnLFxuICAgICAgOTogJ3NvZnQtbGlnaHQnLFxuICAgICAgMTA6ICdkaWZmZXJlbmNlJyxcbiAgICAgIDExOiAnZXhjbHVzaW9uJyxcbiAgICAgIDEyOiAnaHVlJyxcbiAgICAgIDEzOiAnc2F0dXJhdGlvbicsXG4gICAgICAxNDogJ2NvbG9yJyxcbiAgICAgIDE1OiAnbHVtaW5vc2l0eSdcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kZSkge1xuICAgICAgcmV0dXJuIGJsZW5kTW9kZUVudW1zW21vZGVdIHx8ICcnO1xuICAgIH07XG4gIH0oKTtcblxuICBmdW5jdGlvbiBTbGlkZXJFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAwLCAwLCBjb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gQW5nbGVFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAwLCAwLCBjb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29sb3JFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAxLCAwLCBjb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gUG9pbnRFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAxLCAwLCBjb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gTGF5ZXJJbmRleEVmZmVjdChkYXRhLCBlbGVtLCBjb250YWluZXIpIHtcbiAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnYsIDAsIDAsIGNvbnRhaW5lcik7XG4gIH1cblxuICBmdW5jdGlvbiBNYXNrSW5kZXhFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAwLCAwLCBjb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gQ2hlY2tib3hFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAwLCAwLCBjb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gTm9WYWx1ZUVmZmVjdCgpIHtcbiAgICB0aGlzLnAgPSB7fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEVmZmVjdHNNYW5hZ2VyKGRhdGEsIGVsZW1lbnQpIHtcbiAgICB2YXIgZWZmZWN0cyA9IGRhdGEuZWYgfHwgW107XG4gICAgdGhpcy5lZmZlY3RFbGVtZW50cyA9IFtdO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBlZmZlY3RzLmxlbmd0aDtcbiAgICB2YXIgZWZmZWN0SXRlbTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgZWZmZWN0SXRlbSA9IG5ldyBHcm91cEVmZmVjdChlZmZlY3RzW2ldLCBlbGVtZW50KTtcbiAgICAgIHRoaXMuZWZmZWN0RWxlbWVudHMucHVzaChlZmZlY3RJdGVtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBHcm91cEVmZmVjdChkYXRhLCBlbGVtZW50KSB7XG4gICAgdGhpcy5pbml0KGRhdGEsIGVsZW1lbnQpO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBHcm91cEVmZmVjdCk7XG4gIEdyb3VwRWZmZWN0LnByb3RvdHlwZS5nZXRWYWx1ZSA9IEdyb3VwRWZmZWN0LnByb3RvdHlwZS5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXM7XG5cbiAgR3JvdXBFZmZlY3QucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZGF0YSwgZWxlbWVudCkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5lZmZlY3RFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtZW50KTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5kYXRhLmVmLmxlbmd0aDtcbiAgICB2YXIgZWZmO1xuICAgIHZhciBlZmZlY3RzID0gdGhpcy5kYXRhLmVmO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBlZmYgPSBudWxsO1xuXG4gICAgICBzd2l0Y2ggKGVmZmVjdHNbaV0udHkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGVmZiA9IG5ldyBTbGlkZXJFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGVmZiA9IG5ldyBBbmdsZUVmZmVjdChlZmZlY3RzW2ldLCBlbGVtZW50LCB0aGlzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgZWZmID0gbmV3IENvbG9yRWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBlZmYgPSBuZXcgUG9pbnRFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgZWZmID0gbmV3IENoZWNrYm94RWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgZWZmID0gbmV3IExheWVySW5kZXhFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBlZmYgPSBuZXcgTWFza0luZGV4RWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBlZmYgPSBuZXcgRWZmZWN0c01hbmFnZXIoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGNhc2UgNjpcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGVmZiA9IG5ldyBOb1ZhbHVlRWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWZmKSB7XG4gICAgICAgIHRoaXMuZWZmZWN0RWxlbWVudHMucHVzaChlZmYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBCYXNlRWxlbWVudCgpIHt9XG5cbiAgQmFzZUVsZW1lbnQucHJvdG90eXBlID0ge1xuICAgIGNoZWNrTWFza3M6IGZ1bmN0aW9uIGNoZWNrTWFza3MoKSB7XG4gICAgICBpZiAoIXRoaXMuZGF0YS5oYXNNYXNrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZGF0YS5tYXNrc1Byb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAodGhpcy5kYXRhLm1hc2tzUHJvcGVydGllc1tpXS5tb2RlICE9PSAnbicgJiYgdGhpcy5kYXRhLm1hc2tzUHJvcGVydGllc1tpXS5jbCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgaW5pdEV4cHJlc3Npb25zOiBmdW5jdGlvbiBpbml0RXhwcmVzc2lvbnMoKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbnNJbnRlcmZhY2VzID0gZ2V0RXhwcmVzc2lvbkludGVyZmFjZXMoKTtcblxuICAgICAgaWYgKCFleHByZXNzaW9uc0ludGVyZmFjZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgTGF5ZXJFeHByZXNzaW9uSW50ZXJmYWNlID0gZXhwcmVzc2lvbnNJbnRlcmZhY2VzKCdsYXllcicpO1xuICAgICAgdmFyIEVmZmVjdHNFeHByZXNzaW9uSW50ZXJmYWNlID0gZXhwcmVzc2lvbnNJbnRlcmZhY2VzKCdlZmZlY3RzJyk7XG4gICAgICB2YXIgU2hhcGVFeHByZXNzaW9uSW50ZXJmYWNlID0gZXhwcmVzc2lvbnNJbnRlcmZhY2VzKCdzaGFwZScpO1xuICAgICAgdmFyIFRleHRFeHByZXNzaW9uSW50ZXJmYWNlID0gZXhwcmVzc2lvbnNJbnRlcmZhY2VzKCd0ZXh0Jyk7XG4gICAgICB2YXIgQ29tcEV4cHJlc3Npb25JbnRlcmZhY2UgPSBleHByZXNzaW9uc0ludGVyZmFjZXMoJ2NvbXAnKTtcbiAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2UgPSBMYXllckV4cHJlc3Npb25JbnRlcmZhY2UodGhpcyk7XG5cbiAgICAgIGlmICh0aGlzLmRhdGEuaGFzTWFzayAmJiB0aGlzLm1hc2tNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2UucmVnaXN0ZXJNYXNrSW50ZXJmYWNlKHRoaXMubWFza01hbmFnZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWZmZWN0c0ludGVyZmFjZSA9IEVmZmVjdHNFeHByZXNzaW9uSW50ZXJmYWNlLmNyZWF0ZUVmZmVjdHNJbnRlcmZhY2UodGhpcywgdGhpcy5sYXllckludGVyZmFjZSk7XG4gICAgICB0aGlzLmxheWVySW50ZXJmYWNlLnJlZ2lzdGVyRWZmZWN0c0ludGVyZmFjZShlZmZlY3RzSW50ZXJmYWNlKTtcblxuICAgICAgaWYgKHRoaXMuZGF0YS50eSA9PT0gMCB8fCB0aGlzLmRhdGEueHQpIHtcbiAgICAgICAgdGhpcy5jb21wSW50ZXJmYWNlID0gQ29tcEV4cHJlc3Npb25JbnRlcmZhY2UodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS50eSA9PT0gNCkge1xuICAgICAgICB0aGlzLmxheWVySW50ZXJmYWNlLnNoYXBlSW50ZXJmYWNlID0gU2hhcGVFeHByZXNzaW9uSW50ZXJmYWNlKHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRoaXMubGF5ZXJJbnRlcmZhY2UpO1xuICAgICAgICB0aGlzLmxheWVySW50ZXJmYWNlLmNvbnRlbnQgPSB0aGlzLmxheWVySW50ZXJmYWNlLnNoYXBlSW50ZXJmYWNlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEudHkgPT09IDUpIHtcbiAgICAgICAgdGhpcy5sYXllckludGVyZmFjZS50ZXh0SW50ZXJmYWNlID0gVGV4dEV4cHJlc3Npb25JbnRlcmZhY2UodGhpcyk7XG4gICAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2UudGV4dCA9IHRoaXMubGF5ZXJJbnRlcmZhY2UudGV4dEludGVyZmFjZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldEJsZW5kTW9kZTogZnVuY3Rpb24gc2V0QmxlbmRNb2RlKCkge1xuICAgICAgdmFyIGJsZW5kTW9kZVZhbHVlID0gZ2V0QmxlbmRNb2RlKHRoaXMuZGF0YS5ibSk7XG4gICAgICB2YXIgZWxlbSA9IHRoaXMuYmFzZUVsZW1lbnQgfHwgdGhpcy5sYXllckVsZW1lbnQ7XG4gICAgICBlbGVtLnN0eWxlWydtaXgtYmxlbmQtbW9kZSddID0gYmxlbmRNb2RlVmFsdWU7XG4gICAgfSxcbiAgICBpbml0QmFzZURhdGE6IGZ1bmN0aW9uIGluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgICB0aGlzLmdsb2JhbERhdGEgPSBnbG9iYWxEYXRhO1xuICAgICAgdGhpcy5jb21wID0gY29tcDtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICB0aGlzLmxheWVySWQgPSBjcmVhdGVFbGVtZW50SUQoKTsgLy8gU3RyZXRjaCBmYWN0b3IgZm9yIG9sZCBhbmltYXRpb25zIG1pc3NpbmcgdGhpcyBwcm9wZXJ0eS5cblxuICAgICAgaWYgKCF0aGlzLmRhdGEuc3IpIHtcbiAgICAgICAgdGhpcy5kYXRhLnNyID0gMTtcbiAgICAgIH0gLy8gZWZmZWN0cyBtYW5hZ2VyXG5cblxuICAgICAgdGhpcy5lZmZlY3RzTWFuYWdlciA9IG5ldyBFZmZlY3RzTWFuYWdlcih0aGlzLmRhdGEsIHRoaXMsIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMpO1xuICAgIH0sXG4gICAgZ2V0VHlwZTogZnVuY3Rpb24gZ2V0VHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgfSxcbiAgICBzb3VyY2VSZWN0QXRUaW1lOiBmdW5jdGlvbiBzb3VyY2VSZWN0QXRUaW1lKCkge31cbiAgfTtcblxuICAvKipcclxuICAgKiBAZmlsZVxyXG4gICAqIEhhbmRsZXMgZWxlbWVudCdzIGxheWVyIGZyYW1lIHVwZGF0ZS5cclxuICAgKiBDaGVja3MgbGF5ZXIgaW4gcG9pbnQgYW5kIG91dCBwb2ludFxyXG4gICAqXHJcbiAgICovXG4gIGZ1bmN0aW9uIEZyYW1lRWxlbWVudCgpIHt9XG5cbiAgRnJhbWVFbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgICAvKipcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqIEluaXRpYWxpemVzIGZyYW1lIHJlbGF0ZWQgcHJvcGVydGllcy5cclxuICAgICAgICpcclxuICAgICAgICovXG4gICAgaW5pdEZyYW1lOiBmdW5jdGlvbiBpbml0RnJhbWUoKSB7XG4gICAgICAvLyBzZXQgdG8gdHJ1ZSB3aGVuIGlucG9pbnQgaXMgcmVuZGVyZWRcbiAgICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IGZhbHNlOyAvLyBsaXN0IG9mIGFuaW1hdGVkIHByb3BlcnRpZXNcblxuICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcyA9IFtdOyAvLyBJZiBsYXllciBoYXMgYmVlbiBtb2RpZmllZCBpbiBjdXJyZW50IHRpY2sgdGhpcyB3aWxsIGJlIHRydWVcblxuICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogQ2FsY3VsYXRlcyBhbGwgZHluYW1pYyB2YWx1ZXNcclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bVxyXG4gICAgICAgKiBjdXJyZW50IGZyYW1lIG51bWJlciBpbiBMYXllcidzIHRpbWVcclxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc1Zpc2libGVcclxuICAgICAgICogaWYgbGF5ZXJzIGlzIGN1cnJlbnRseSBpbiByYW5nZVxyXG4gICAgICAgKlxyXG4gICAgICAgKi9cbiAgICBwcmVwYXJlUHJvcGVydGllczogZnVuY3Rpb24gcHJlcGFyZVByb3BlcnRpZXMobnVtLCBpc1Zpc2libGUpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGlzVmlzaWJsZSB8fCB0aGlzLl9pc1BhcmVudCAmJiB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLnByb3BUeXBlID09PSAndHJhbnNmb3JtJykge1xuICAgICAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV0uZ2V0VmFsdWUoKTtcblxuICAgICAgICAgIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLl9tZGYpIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5fbWRmID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhZGREeW5hbWljUHJvcGVydHk6IGZ1bmN0aW9uIGFkZER5bmFtaWNQcm9wZXJ0eShwcm9wKSB7XG4gICAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEZvb3RhZ2VFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmluaXRGcmFtZSgpO1xuICAgIHRoaXMuaW5pdFJlbmRlcmFibGUoKTtcbiAgICB0aGlzLmFzc2V0RGF0YSA9IGdsb2JhbERhdGEuZ2V0QXNzZXREYXRhKGRhdGEucmVmSWQpO1xuICAgIHRoaXMuZm9vdGFnZURhdGEgPSBnbG9iYWxEYXRhLmltYWdlTG9hZGVyLmdldEFzc2V0KHRoaXMuYXNzZXREYXRhKTtcbiAgICB0aGlzLmluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgfVxuXG4gIEZvb3RhZ2VFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBleHRlbmRQcm90b3R5cGUoW1JlbmRlcmFibGVFbGVtZW50LCBCYXNlRWxlbWVudCwgRnJhbWVFbGVtZW50XSwgRm9vdGFnZUVsZW1lbnQpO1xuXG4gIEZvb3RhZ2VFbGVtZW50LnByb3RvdHlwZS5nZXRCYXNlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBGb290YWdlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBGb290YWdlRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIEZvb3RhZ2VFbGVtZW50LnByb3RvdHlwZS5pbml0RXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4cHJlc3Npb25zSW50ZXJmYWNlcyA9IGdldEV4cHJlc3Npb25JbnRlcmZhY2VzKCk7XG5cbiAgICBpZiAoIWV4cHJlc3Npb25zSW50ZXJmYWNlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBGb290YWdlSW50ZXJmYWNlID0gZXhwcmVzc2lvbnNJbnRlcmZhY2VzKCdmb290YWdlJyk7XG4gICAgdGhpcy5sYXllckludGVyZmFjZSA9IEZvb3RhZ2VJbnRlcmZhY2UodGhpcyk7XG4gIH07XG5cbiAgRm9vdGFnZUVsZW1lbnQucHJvdG90eXBlLmdldEZvb3RhZ2VEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmZvb3RhZ2VEYXRhO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEF1ZGlvRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5pbml0RnJhbWUoKTtcbiAgICB0aGlzLmluaXRSZW5kZXJhYmxlKCk7XG4gICAgdGhpcy5hc3NldERhdGEgPSBnbG9iYWxEYXRhLmdldEFzc2V0RGF0YShkYXRhLnJlZklkKTtcbiAgICB0aGlzLmluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9jYW5QbGF5ID0gZmFsc2U7XG4gICAgdmFyIGFzc2V0UGF0aCA9IHRoaXMuZ2xvYmFsRGF0YS5nZXRBc3NldHNQYXRoKHRoaXMuYXNzZXREYXRhKTtcbiAgICB0aGlzLmF1ZGlvID0gdGhpcy5nbG9iYWxEYXRhLmF1ZGlvQ29udHJvbGxlci5jcmVhdGVBdWRpbyhhc3NldFBhdGgpO1xuICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLmdsb2JhbERhdGEuYXVkaW9Db250cm9sbGVyLmFkZEF1ZGlvKHRoaXMpO1xuICAgIHRoaXMuX3ZvbHVtZU11bHRpcGxpZXIgPSAxO1xuICAgIHRoaXMuX3ZvbHVtZSA9IDE7XG4gICAgdGhpcy5fcHJldmlvdXNWb2x1bWUgPSBudWxsO1xuICAgIHRoaXMudG0gPSBkYXRhLnRtID8gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS50bSwgMCwgZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIHRoaXMpIDoge1xuICAgICAgX3BsYWNlaG9sZGVyOiB0cnVlXG4gICAgfTtcbiAgICB0aGlzLmx2ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS5hdSAmJiBkYXRhLmF1Lmx2ID8gZGF0YS5hdS5sdiA6IHtcbiAgICAgIGs6IFsxMDBdXG4gICAgfSwgMSwgMC4wMSwgdGhpcyk7XG4gIH1cblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB0aGlzLnByZXBhcmVSZW5kZXJhYmxlRnJhbWUobnVtLCB0cnVlKTtcbiAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdHJ1ZSk7XG5cbiAgICBpZiAoIXRoaXMudG0uX3BsYWNlaG9sZGVyKSB7XG4gICAgICB2YXIgdGltZVJlbWFwcGVkID0gdGhpcy50bS52O1xuICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSB0aW1lUmVtYXBwZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gbnVtIC8gdGhpcy5kYXRhLnNyO1xuICAgIH1cblxuICAgIHRoaXMuX3ZvbHVtZSA9IHRoaXMubHYudlswXTtcbiAgICB2YXIgdG90YWxWb2x1bWUgPSB0aGlzLl92b2x1bWUgKiB0aGlzLl92b2x1bWVNdWx0aXBsaWVyO1xuXG4gICAgaWYgKHRoaXMuX3ByZXZpb3VzVm9sdW1lICE9PSB0b3RhbFZvbHVtZSkge1xuICAgICAgdGhpcy5fcHJldmlvdXNWb2x1bWUgPSB0b3RhbFZvbHVtZTtcbiAgICAgIHRoaXMuYXVkaW8udm9sdW1lKHRvdGFsVm9sdW1lKTtcbiAgICB9XG4gIH07XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtSZW5kZXJhYmxlRWxlbWVudCwgQmFzZUVsZW1lbnQsIEZyYW1lRWxlbWVudF0sIEF1ZGlvRWxlbWVudCk7XG5cbiAgQXVkaW9FbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc0luUmFuZ2UgJiYgdGhpcy5fY2FuUGxheSkge1xuICAgICAgaWYgKCF0aGlzLl9pc1BsYXlpbmcpIHtcbiAgICAgICAgdGhpcy5hdWRpby5wbGF5KCk7XG4gICAgICAgIHRoaXMuYXVkaW8uc2Vlayh0aGlzLl9jdXJyZW50VGltZSAvIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZVJhdGUpO1xuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5hdWRpby5wbGF5aW5nKCkgfHwgTWF0aC5hYnModGhpcy5fY3VycmVudFRpbWUgLyB0aGlzLmdsb2JhbERhdGEuZnJhbWVSYXRlIC0gdGhpcy5hdWRpby5zZWVrKCkpID4gMC4xKSB7XG4gICAgICAgIHRoaXMuYXVkaW8uc2Vlayh0aGlzLl9jdXJyZW50VGltZSAvIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZVJhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7Ly8gdGhpcy5hdWRpby5wbGF5KClcbiAgfTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hdWRpby5wYXVzZSgpO1xuICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICB9O1xuXG4gIEF1ZGlvRWxlbWVudC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hdWRpby5wYXVzZSgpO1xuICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2NhblBsYXkgPSBmYWxzZTtcbiAgfTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jYW5QbGF5ID0gdHJ1ZTtcbiAgfTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLnNldFJhdGUgPSBmdW5jdGlvbiAocmF0ZVZhbHVlKSB7XG4gICAgdGhpcy5hdWRpby5yYXRlKHJhdGVWYWx1ZSk7XG4gIH07XG5cbiAgQXVkaW9FbGVtZW50LnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbiAodm9sdW1lVmFsdWUpIHtcbiAgICB0aGlzLl92b2x1bWVNdWx0aXBsaWVyID0gdm9sdW1lVmFsdWU7XG4gICAgdGhpcy5fcHJldmlvdXNWb2x1bWUgPSB2b2x1bWVWYWx1ZSAqIHRoaXMuX3ZvbHVtZTtcbiAgICB0aGlzLmF1ZGlvLnZvbHVtZSh0aGlzLl9wcmV2aW91c1ZvbHVtZSk7XG4gIH07XG5cbiAgQXVkaW9FbGVtZW50LnByb3RvdHlwZS5nZXRCYXNlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLnNvdXJjZVJlY3RBdFRpbWUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLmluaXRFeHByZXNzaW9ucyA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGZ1bmN0aW9uIEJhc2VSZW5kZXJlcigpIHt9XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jaGVja0xheWVycyA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuICAgIHZhciBkYXRhO1xuICAgIHRoaXMuY29tcGxldGVMYXllcnMgPSB0cnVlO1xuXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIGlmICghdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICBkYXRhID0gdGhpcy5sYXllcnNbaV07XG5cbiAgICAgICAgaWYgKGRhdGEuaXAgLSBkYXRhLnN0IDw9IG51bSAtIHRoaXMubGF5ZXJzW2ldLnN0ICYmIGRhdGEub3AgLSBkYXRhLnN0ID4gbnVtIC0gdGhpcy5sYXllcnNbaV0uc3QpIHtcbiAgICAgICAgICB0aGlzLmJ1aWxkSXRlbShpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbXBsZXRlTGF5ZXJzID0gdGhpcy5lbGVtZW50c1tpXSA/IHRoaXMuY29tcGxldGVMYXllcnMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmNoZWNrUGVuZGluZ0VsZW1lbnRzKCk7XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVJdGVtID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgc3dpdGNoIChsYXllci50eSkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbWFnZShsYXllcik7XG5cbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29tcChsYXllcik7XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU29saWQobGF5ZXIpO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU51bGwobGF5ZXIpO1xuXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNoYXBlKGxheWVyKTtcblxuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0KGxheWVyKTtcblxuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVBdWRpbyhsYXllcik7XG5cbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNhbWVyYShsYXllcik7XG5cbiAgICAgIGNhc2UgMTU6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUZvb3RhZ2UobGF5ZXIpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVOdWxsKGxheWVyKTtcbiAgICB9XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3VcXCdyZSB1c2luZyBhIDNkIGNhbWVyYS4gVHJ5IHRoZSBodG1sIHJlbmRlcmVyLicpO1xuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQXVkaW8gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQXVkaW9FbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVGb290YWdlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IEZvb3RhZ2VFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5idWlsZEFsbEl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuYnVpbGRJdGVtKGkpO1xuICAgIH1cblxuICAgIHRoaXMuY2hlY2tQZW5kaW5nRWxlbWVudHMoKTtcbiAgfTtcblxuICBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmluY2x1ZGVMYXllcnMgPSBmdW5jdGlvbiAobmV3TGF5ZXJzKSB7XG4gICAgdGhpcy5jb21wbGV0ZUxheWVycyA9IGZhbHNlO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBuZXdMYXllcnMubGVuZ3RoO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBqID0gMDtcblxuICAgICAgd2hpbGUgKGogPCBqTGVuKSB7XG4gICAgICAgIGlmICh0aGlzLmxheWVyc1tqXS5pZCA9PT0gbmV3TGF5ZXJzW2ldLmlkKSB7XG4gICAgICAgICAgdGhpcy5sYXllcnNbal0gPSBuZXdMYXllcnNbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBqICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuc2V0UHJvamVjdEludGVyZmFjZSA9IGZ1bmN0aW9uIChwSW50ZXJmYWNlKSB7XG4gICAgdGhpcy5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UgPSBwSW50ZXJmYWNlO1xuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuaW5pdEl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5nbG9iYWxEYXRhLnByb2dyZXNzaXZlTG9hZCkge1xuICAgICAgdGhpcy5idWlsZEFsbEl0ZW1zKCk7XG4gICAgfVxuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRFbGVtZW50UGFyZW50aW5nID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBhcmVudE5hbWUsIGhpZXJhcmNoeSkge1xuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgdmFyIGxheWVycyA9IHRoaXMubGF5ZXJzO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gbGF5ZXJzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAobGF5ZXJzW2ldLmluZCA9PSBwYXJlbnROYW1lKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICAgIGlmICghZWxlbWVudHNbaV0gfHwgZWxlbWVudHNbaV0gPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJ1aWxkSXRlbShpKTtcbiAgICAgICAgICB0aGlzLmFkZFBlbmRpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpZXJhcmNoeS5wdXNoKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgICBlbGVtZW50c1tpXS5zZXRBc1BhcmVudCgpO1xuXG4gICAgICAgICAgaWYgKGxheWVyc1tpXS5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5idWlsZEVsZW1lbnRQYXJlbnRpbmcoZWxlbWVudCwgbGF5ZXJzW2ldLnBhcmVudCwgaGllcmFyY2h5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRIaWVyYXJjaHkoaGllcmFyY2h5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cbiAgfTtcblxuICBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmFkZFBlbmRpbmdFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB0aGlzLnBlbmRpbmdFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuc2VhcmNoRXh0cmFDb21wb3NpdGlvbnMgPSBmdW5jdGlvbiAoYXNzZXRzKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGFzc2V0cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmIChhc3NldHNbaV0ueHQpIHtcbiAgICAgICAgdmFyIGNvbXAgPSB0aGlzLmNyZWF0ZUNvbXAoYXNzZXRzW2ldKTtcbiAgICAgICAgY29tcC5pbml0RXhwcmVzc2lvbnMoKTtcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UucmVnaXN0ZXJDb21wb3NpdGlvbihjb21wKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5nZXRFbGVtZW50QnlJZCA9IGZ1bmN0aW9uIChpbmQpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldLmRhdGEuaW5kID09PSBpbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5nZXRFbGVtZW50QnlQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgcGF0aFZhbHVlID0gcGF0aC5zaGlmdCgpO1xuICAgIHZhciBlbGVtZW50O1xuXG4gICAgaWYgKHR5cGVvZiBwYXRoVmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1twYXRoVmFsdWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldLmRhdGEubm0gPT09IHBhdGhWYWx1ZSkge1xuICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudC5nZXRFbGVtZW50QnlQYXRoKHBhdGgpO1xuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuc2V0dXBHbG9iYWxEYXRhID0gZnVuY3Rpb24gKGFuaW1EYXRhLCBmb250c0NvbnRhaW5lcikge1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlciA9IG5ldyBGb250TWFuYWdlcigpO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5zbG90TWFuYWdlciA9IHNsb3RGYWN0b3J5KGFuaW1EYXRhKTtcbiAgICB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuYWRkQ2hhcnMoYW5pbURhdGEuY2hhcnMpO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5hZGRGb250cyhhbmltRGF0YS5mb250cywgZm9udHNDb250YWluZXIpO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5nZXRBc3NldERhdGEgPSB0aGlzLmFuaW1hdGlvbkl0ZW0uZ2V0QXNzZXREYXRhLmJpbmQodGhpcy5hbmltYXRpb25JdGVtKTtcbiAgICB0aGlzLmdsb2JhbERhdGEuZ2V0QXNzZXRzUGF0aCA9IHRoaXMuYW5pbWF0aW9uSXRlbS5nZXRBc3NldHNQYXRoLmJpbmQodGhpcy5hbmltYXRpb25JdGVtKTtcbiAgICB0aGlzLmdsb2JhbERhdGEuaW1hZ2VMb2FkZXIgPSB0aGlzLmFuaW1hdGlvbkl0ZW0uaW1hZ2VQcmVsb2FkZXI7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmF1ZGlvQ29udHJvbGxlciA9IHRoaXMuYW5pbWF0aW9uSXRlbS5hdWRpb0NvbnRyb2xsZXI7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lSWQgPSAwO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZVJhdGUgPSBhbmltRGF0YS5mcjtcbiAgICB0aGlzLmdsb2JhbERhdGEubm0gPSBhbmltRGF0YS5ubTtcbiAgICB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUgPSB7XG4gICAgICB3OiBhbmltRGF0YS53LFxuICAgICAgaDogYW5pbURhdGEuaFxuICAgIH07XG4gIH07XG5cbiAgdmFyIGVmZmVjdFR5cGVzID0ge1xuICAgIFRSQU5TRk9STV9FRkZFQ1Q6ICd0cmFuc2Zvcm1FRmZlY3QnXG4gIH07XG5cbiAgZnVuY3Rpb24gVHJhbnNmb3JtRWxlbWVudCgpIHt9XG5cbiAgVHJhbnNmb3JtRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gICAgaW5pdFRyYW5zZm9ybTogZnVuY3Rpb24gaW5pdFRyYW5zZm9ybSgpIHtcbiAgICAgIHZhciBtYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgICB0aGlzLmZpbmFsVHJhbnNmb3JtID0ge1xuICAgICAgICBtUHJvcDogdGhpcy5kYXRhLmtzID8gVHJhbnNmb3JtUHJvcGVydHlGYWN0b3J5LmdldFRyYW5zZm9ybVByb3BlcnR5KHRoaXMsIHRoaXMuZGF0YS5rcywgdGhpcykgOiB7XG4gICAgICAgICAgbzogMFxuICAgICAgICB9LFxuICAgICAgICBfbWF0TWRmOiBmYWxzZSxcbiAgICAgICAgX2xvY2FsTWF0TWRmOiBmYWxzZSxcbiAgICAgICAgX29wTWRmOiBmYWxzZSxcbiAgICAgICAgbWF0OiBtYXQsXG4gICAgICAgIGxvY2FsTWF0OiBtYXQsXG4gICAgICAgIGxvY2FsT3BhY2l0eTogMVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuZGF0YS5hbykge1xuICAgICAgICB0aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLmF1dG9PcmllbnRlZCA9IHRydWU7XG4gICAgICB9IC8vIFRPRE86IGNoZWNrIFRZUEUgMTE6IEd1aWRlZCBlbGVtZW50c1xuXG5cbiAgICAgIGlmICh0aGlzLmRhdGEudHkgIT09IDExKSB7Ly8gdGhpcy5jcmVhdGVFbGVtZW50cygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyVHJhbnNmb3JtOiBmdW5jdGlvbiByZW5kZXJUcmFuc2Zvcm0oKSB7XG4gICAgICB0aGlzLmZpbmFsVHJhbnNmb3JtLl9vcE1kZiA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3Auby5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZTtcbiAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX21hdE1kZiA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3AuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWU7XG5cbiAgICAgIGlmICh0aGlzLmhpZXJhcmNoeSkge1xuICAgICAgICB2YXIgbWF0O1xuICAgICAgICB2YXIgZmluYWxNYXQgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1hdDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyAvLyBDaGVja2luZyBpZiBhbnkgb2YgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpY2VzIGluIHRoZSBoaWVyYXJjaHkgY2hhaW4gaGFzIGNoYW5nZWQuXG5cbiAgICAgICAgaWYgKCF0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGYpIHtcbiAgICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLl9tZGYpIHtcbiAgICAgICAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmKSB7XG4gICAgICAgICAgbWF0ID0gdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC52LnByb3BzO1xuICAgICAgICAgIGZpbmFsTWF0LmNsb25lRnJvbVByb3BzKG1hdCk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGZpbmFsTWF0Lm11bHRpcGx5KHRoaXMuaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLnYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmKSB7XG4gICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX2xvY2FsTWF0TWRmID0gdGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYpIHtcbiAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE9wYWNpdHkgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLm8udjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlckxvY2FsVHJhbnNmb3JtOiBmdW5jdGlvbiByZW5kZXJMb2NhbFRyYW5zZm9ybSgpIHtcbiAgICAgIGlmICh0aGlzLmxvY2FsVHJhbnNmb3Jtcykge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmxvY2FsVHJhbnNmb3Jtcy5sZW5ndGg7XG4gICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX2xvY2FsTWF0TWRmID0gdGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmO1xuXG4gICAgICAgIGlmICghdGhpcy5maW5hbFRyYW5zZm9ybS5fbG9jYWxNYXRNZGYgfHwgIXRoaXMuZmluYWxUcmFuc2Zvcm0uX29wTWRmKSB7XG4gICAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2FsVHJhbnNmb3Jtc1tpXS5fbWRmKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX2xvY2FsTWF0TWRmID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMubG9jYWxUcmFuc2Zvcm1zW2ldLl9vcE1kZiAmJiAhdGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYpIHtcbiAgICAgICAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE9wYWNpdHkgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLm8udjtcbiAgICAgICAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZmluYWxUcmFuc2Zvcm0uX2xvY2FsTWF0TWRmKSB7XG4gICAgICAgICAgdmFyIGxvY2FsTWF0ID0gdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE1hdDtcbiAgICAgICAgICB0aGlzLmxvY2FsVHJhbnNmb3Jtc1swXS5tYXRyaXguY2xvbmUobG9jYWxNYXQpO1xuXG4gICAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbG1hdCA9IHRoaXMubG9jYWxUcmFuc2Zvcm1zW2ldLm1hdHJpeDtcbiAgICAgICAgICAgIGxvY2FsTWF0Lm11bHRpcGx5KGxtYXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxvY2FsTWF0Lm11bHRpcGx5KHRoaXMuZmluYWxUcmFuc2Zvcm0ubWF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZpbmFsVHJhbnNmb3JtLl9vcE1kZikge1xuICAgICAgICAgIHZhciBsb2NhbE9wID0gdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE9wYWNpdHk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGxvY2FsT3AgKj0gdGhpcy5sb2NhbFRyYW5zZm9ybXNbaV0ub3BhY2l0eSAqIDAuMDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE9wYWNpdHkgPSBsb2NhbE9wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzZWFyY2hFZmZlY3RUcmFuc2Zvcm1zOiBmdW5jdGlvbiBzZWFyY2hFZmZlY3RUcmFuc2Zvcm1zKCkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyYWJsZUVmZmVjdHNNYW5hZ2VyKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1FZmZlY3RzID0gdGhpcy5yZW5kZXJhYmxlRWZmZWN0c01hbmFnZXIuZ2V0RWZmZWN0cyhlZmZlY3RUeXBlcy5UUkFOU0ZPUk1fRUZGRUNUKTtcblxuICAgICAgICBpZiAodHJhbnNmb3JtRWZmZWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmxvY2FsVHJhbnNmb3JtcyA9IFtdO1xuICAgICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0ubG9jYWxNYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1FZmZlY3RzLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbFRyYW5zZm9ybXMucHVzaCh0cmFuc2Zvcm1FZmZlY3RzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGdsb2JhbFRvTG9jYWw6IGZ1bmN0aW9uIGdsb2JhbFRvTG9jYWwocHQpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1zID0gW107XG4gICAgICB0cmFuc2Zvcm1zLnB1c2godGhpcy5maW5hbFRyYW5zZm9ybSk7XG4gICAgICB2YXIgZmxhZyA9IHRydWU7XG4gICAgICB2YXIgY29tcCA9IHRoaXMuY29tcDtcblxuICAgICAgd2hpbGUgKGZsYWcpIHtcbiAgICAgICAgaWYgKGNvbXAuZmluYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICBpZiAoY29tcC5kYXRhLmhhc01hc2spIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybXMuc3BsaWNlKDAsIDAsIGNvbXAuZmluYWxUcmFuc2Zvcm0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbXAgPSBjb21wLmNvbXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgdmFyIHB0TmV3O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcHROZXcgPSB0cmFuc2Zvcm1zW2ldLm1hdC5hcHBseVRvUG9pbnRBcnJheSgwLCAwLCAwKTsgLy8gcHROZXcgPSB0cmFuc2Zvcm1zW2ldLm1hdC5hcHBseVRvUG9pbnRBcnJheShwdFswXSxwdFsxXSxwdFsyXSk7XG5cbiAgICAgICAgcHQgPSBbcHRbMF0gLSBwdE5ld1swXSwgcHRbMV0gLSBwdE5ld1sxXSwgMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwdDtcbiAgICB9LFxuICAgIG1IZWxwZXI6IG5ldyBNYXRyaXgoKVxuICB9O1xuXG4gIGZ1bmN0aW9uIE1hc2tFbGVtZW50KGRhdGEsIGVsZW1lbnQsIGdsb2JhbERhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5nbG9iYWxEYXRhID0gZ2xvYmFsRGF0YTtcbiAgICB0aGlzLnN0b3JlZERhdGEgPSBbXTtcbiAgICB0aGlzLm1hc2tzUHJvcGVydGllcyA9IHRoaXMuZGF0YS5tYXNrc1Byb3BlcnRpZXMgfHwgW107XG4gICAgdGhpcy5tYXNrRWxlbWVudCA9IG51bGw7XG4gICAgdmFyIGRlZnMgPSB0aGlzLmdsb2JhbERhdGEuZGVmcztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5tYXNrc1Byb3BlcnRpZXMgPyB0aGlzLm1hc2tzUHJvcGVydGllcy5sZW5ndGggOiAwO1xuICAgIHRoaXMudmlld0RhdGEgPSBjcmVhdGVTaXplZEFycmF5KGxlbik7XG4gICAgdGhpcy5zb2xpZFBhdGggPSAnJztcbiAgICB2YXIgcGF0aDtcbiAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMubWFza3NQcm9wZXJ0aWVzO1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRNYXNrcyA9IFtdO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBsYXllcklkID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgdmFyIHJlY3Q7XG4gICAgdmFyIGV4cGFuc29yO1xuICAgIHZhciBmZU1vcnBoO1xuICAgIHZhciB4O1xuICAgIHZhciBtYXNrVHlwZSA9ICdjbGlwUGF0aCc7XG4gICAgdmFyIG1hc2tSZWYgPSAnY2xpcC1wYXRoJztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHByb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ2EnICYmIHByb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ24nIHx8IHByb3BlcnRpZXNbaV0uaW52IHx8IHByb3BlcnRpZXNbaV0uby5rICE9PSAxMDAgfHwgcHJvcGVydGllc1tpXS5vLngpIHtcbiAgICAgICAgbWFza1R5cGUgPSAnbWFzayc7XG4gICAgICAgIG1hc2tSZWYgPSAnbWFzayc7XG4gICAgICB9XG5cbiAgICAgIGlmICgocHJvcGVydGllc1tpXS5tb2RlID09PSAncycgfHwgcHJvcGVydGllc1tpXS5tb2RlID09PSAnaScpICYmIGNvdW50ID09PSAwKSB7XG4gICAgICAgIHJlY3QgPSBjcmVhdGVOUygncmVjdCcpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsICcjZmZmZmZmJyk7XG4gICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuZWxlbWVudC5jb21wLmRhdGEudyB8fCAwKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuZWxlbWVudC5jb21wLmRhdGEuaCB8fCAwKTtcbiAgICAgICAgY3VycmVudE1hc2tzLnB1c2gocmVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWN0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcGF0aCA9IGNyZWF0ZU5TKCdwYXRoJyk7XG5cbiAgICAgIGlmIChwcm9wZXJ0aWVzW2ldLm1vZGUgPT09ICduJykge1xuICAgICAgICAvLyBUT0RPIG1vdmUgdGhpcyB0byBhIGZhY3Rvcnkgb3IgdG8gYSBjb25zdHJ1Y3RvclxuICAgICAgICB0aGlzLnZpZXdEYXRhW2ldID0ge1xuICAgICAgICAgIG9wOiBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLmVsZW1lbnQsIHByb3BlcnRpZXNbaV0ubywgMCwgMC4wMSwgdGhpcy5lbGVtZW50KSxcbiAgICAgICAgICBwcm9wOiBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3AodGhpcy5lbGVtZW50LCBwcm9wZXJ0aWVzW2ldLCAzKSxcbiAgICAgICAgICBlbGVtOiBwYXRoLFxuICAgICAgICAgIGxhc3RQYXRoOiAnJ1xuICAgICAgICB9O1xuICAgICAgICBkZWZzLmFwcGVuZENoaWxkKHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBwcm9wZXJ0aWVzW2ldLm1vZGUgPT09ICdzJyA/ICcjMDAwMDAwJyA6ICcjZmZmZmZmJyk7XG4gICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdjbGlwLXJ1bGUnLCAnbm9uemVybycpO1xuICAgICAgICB2YXIgZmlsdGVySUQ7XG5cbiAgICAgICAgaWYgKHByb3BlcnRpZXNbaV0ueC5rICE9PSAwKSB7XG4gICAgICAgICAgbWFza1R5cGUgPSAnbWFzayc7XG4gICAgICAgICAgbWFza1JlZiA9ICdtYXNrJztcbiAgICAgICAgICB4ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcy5lbGVtZW50LCBwcm9wZXJ0aWVzW2ldLngsIDAsIG51bGwsIHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgZmlsdGVySUQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICAgICAgICBleHBhbnNvciA9IGNyZWF0ZU5TKCdmaWx0ZXInKTtcbiAgICAgICAgICBleHBhbnNvci5zZXRBdHRyaWJ1dGUoJ2lkJywgZmlsdGVySUQpO1xuICAgICAgICAgIGZlTW9ycGggPSBjcmVhdGVOUygnZmVNb3JwaG9sb2d5Jyk7XG4gICAgICAgICAgZmVNb3JwaC5zZXRBdHRyaWJ1dGUoJ29wZXJhdG9yJywgJ2Vyb2RlJyk7XG4gICAgICAgICAgZmVNb3JwaC5zZXRBdHRyaWJ1dGUoJ2luJywgJ1NvdXJjZUdyYXBoaWMnKTtcbiAgICAgICAgICBmZU1vcnBoLnNldEF0dHJpYnV0ZSgncmFkaXVzJywgJzAnKTtcbiAgICAgICAgICBleHBhbnNvci5hcHBlbmRDaGlsZChmZU1vcnBoKTtcbiAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKGV4cGFuc29yKTtcbiAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgcHJvcGVydGllc1tpXS5tb2RlID09PSAncycgPyAnIzAwMDAwMCcgOiAnI2ZmZmZmZicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZlTW9ycGggPSBudWxsO1xuICAgICAgICAgIHggPSBudWxsO1xuICAgICAgICB9IC8vIFRPRE8gbW92ZSB0aGlzIHRvIGEgZmFjdG9yeSBvciB0byBhIGNvbnN0cnVjdG9yXG5cblxuICAgICAgICB0aGlzLnN0b3JlZERhdGFbaV0gPSB7XG4gICAgICAgICAgZWxlbTogcGF0aCxcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIGV4cGFuOiBmZU1vcnBoLFxuICAgICAgICAgIGxhc3RQYXRoOiAnJyxcbiAgICAgICAgICBsYXN0T3BlcmF0b3I6ICcnLFxuICAgICAgICAgIGZpbHRlcklkOiBmaWx0ZXJJRCxcbiAgICAgICAgICBsYXN0UmFkaXVzOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHByb3BlcnRpZXNbaV0ubW9kZSA9PT0gJ2knKSB7XG4gICAgICAgICAgakxlbiA9IGN1cnJlbnRNYXNrcy5sZW5ndGg7XG4gICAgICAgICAgdmFyIGcgPSBjcmVhdGVOUygnZycpO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgZy5hcHBlbmRDaGlsZChjdXJyZW50TWFza3Nbal0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBtYXNrID0gY3JlYXRlTlMoJ21hc2snKTtcbiAgICAgICAgICBtYXNrLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2FscGhhJyk7XG4gICAgICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoJ2lkJywgbGF5ZXJJZCArICdfJyArIGNvdW50KTtcbiAgICAgICAgICBtYXNrLmFwcGVuZENoaWxkKHBhdGgpO1xuICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQobWFzayk7XG4gICAgICAgICAgZy5zZXRBdHRyaWJ1dGUoJ21hc2snLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGxheWVySWQgKyAnXycgKyBjb3VudCArICcpJyk7XG4gICAgICAgICAgY3VycmVudE1hc2tzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgY3VycmVudE1hc2tzLnB1c2goZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudE1hc2tzLnB1c2gocGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydGllc1tpXS5pbnYgJiYgIXRoaXMuc29saWRQYXRoKSB7XG4gICAgICAgICAgdGhpcy5zb2xpZFBhdGggPSB0aGlzLmNyZWF0ZUxheWVyU29saWRQYXRoKCk7XG4gICAgICAgIH0gLy8gVE9ETyBtb3ZlIHRoaXMgdG8gYSBmYWN0b3J5IG9yIHRvIGEgY29uc3RydWN0b3JcblxuXG4gICAgICAgIHRoaXMudmlld0RhdGFbaV0gPSB7XG4gICAgICAgICAgZWxlbTogcGF0aCxcbiAgICAgICAgICBsYXN0UGF0aDogJycsXG4gICAgICAgICAgb3A6IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMuZWxlbWVudCwgcHJvcGVydGllc1tpXS5vLCAwLCAwLjAxLCB0aGlzLmVsZW1lbnQpLFxuICAgICAgICAgIHByb3A6IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcCh0aGlzLmVsZW1lbnQsIHByb3BlcnRpZXNbaV0sIDMpLFxuICAgICAgICAgIGludlJlY3Q6IHJlY3RcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIXRoaXMudmlld0RhdGFbaV0ucHJvcC5rKSB7XG4gICAgICAgICAgdGhpcy5kcmF3UGF0aChwcm9wZXJ0aWVzW2ldLCB0aGlzLnZpZXdEYXRhW2ldLnByb3AudiwgdGhpcy52aWV3RGF0YVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1hc2tFbGVtZW50ID0gY3JlYXRlTlMobWFza1R5cGUpO1xuICAgIGxlbiA9IGN1cnJlbnRNYXNrcy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMubWFza0VsZW1lbnQuYXBwZW5kQ2hpbGQoY3VycmVudE1hc2tzW2ldKTtcbiAgICB9XG5cbiAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICB0aGlzLm1hc2tFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBsYXllcklkKTtcbiAgICAgIHRoaXMuZWxlbWVudC5tYXNrZWRFbGVtZW50LnNldEF0dHJpYnV0ZShtYXNrUmVmLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGxheWVySWQgKyAnKScpO1xuICAgICAgZGVmcy5hcHBlbmRDaGlsZCh0aGlzLm1hc2tFbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52aWV3RGF0YS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRSZW5kZXJhYmxlQ29tcG9uZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIE1hc2tFbGVtZW50LnByb3RvdHlwZS5nZXRNYXNrUHJvcGVydHkgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHRoaXMudmlld0RhdGFbcG9zXS5wcm9wO1xuICB9O1xuXG4gIE1hc2tFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChpc0ZpcnN0RnJhbWUpIHtcbiAgICB2YXIgZmluYWxNYXQgPSB0aGlzLmVsZW1lbnQuZmluYWxUcmFuc2Zvcm0ubWF0O1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLm1hc2tzUHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLnZpZXdEYXRhW2ldLnByb3AuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgdGhpcy5kcmF3UGF0aCh0aGlzLm1hc2tzUHJvcGVydGllc1tpXSwgdGhpcy52aWV3RGF0YVtpXS5wcm9wLnYsIHRoaXMudmlld0RhdGFbaV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy52aWV3RGF0YVtpXS5vcC5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICB0aGlzLnZpZXdEYXRhW2ldLmVsZW0uc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCB0aGlzLnZpZXdEYXRhW2ldLm9wLnYpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tYXNrc1Byb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ24nKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXdEYXRhW2ldLmludlJlY3QgJiYgKHRoaXMuZWxlbWVudC5maW5hbFRyYW5zZm9ybS5tUHJvcC5fbWRmIHx8IGlzRmlyc3RGcmFtZSkpIHtcbiAgICAgICAgICB0aGlzLnZpZXdEYXRhW2ldLmludlJlY3Quc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBmaW5hbE1hdC5nZXRJbnZlcnNlTWF0cml4KCkudG8yZENTUygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0b3JlZERhdGFbaV0ueCAmJiAodGhpcy5zdG9yZWREYXRhW2ldLnguX21kZiB8fCBpc0ZpcnN0RnJhbWUpKSB7XG4gICAgICAgICAgdmFyIGZlTW9ycGggPSB0aGlzLnN0b3JlZERhdGFbaV0uZXhwYW47XG5cbiAgICAgICAgICBpZiAodGhpcy5zdG9yZWREYXRhW2ldLngudiA8IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3JlZERhdGFbaV0ubGFzdE9wZXJhdG9yICE9PSAnZXJvZGUnKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RvcmVkRGF0YVtpXS5sYXN0T3BlcmF0b3IgPSAnZXJvZGUnO1xuICAgICAgICAgICAgICB0aGlzLnN0b3JlZERhdGFbaV0uZWxlbS5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgdGhpcy5zdG9yZWREYXRhW2ldLmZpbHRlcklkICsgJyknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmVNb3JwaC5zZXRBdHRyaWJ1dGUoJ3JhZGl1cycsIC10aGlzLnN0b3JlZERhdGFbaV0ueC52KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcmVkRGF0YVtpXS5sYXN0T3BlcmF0b3IgIT09ICdkaWxhdGUnKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RvcmVkRGF0YVtpXS5sYXN0T3BlcmF0b3IgPSAnZGlsYXRlJztcbiAgICAgICAgICAgICAgdGhpcy5zdG9yZWREYXRhW2ldLmVsZW0uc2V0QXR0cmlidXRlKCdmaWx0ZXInLCBudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdG9yZWREYXRhW2ldLmVsZW0uc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCB0aGlzLnN0b3JlZERhdGFbaV0ueC52ICogMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIE1hc2tFbGVtZW50LnByb3RvdHlwZS5nZXRNYXNrZWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXNrRWxlbWVudDtcbiAgfTtcblxuICBNYXNrRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlTGF5ZXJTb2xpZFBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhdGggPSAnTTAsMCAnO1xuICAgIHBhdGggKz0gJyBoJyArIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53O1xuICAgIHBhdGggKz0gJyB2JyArIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oO1xuICAgIHBhdGggKz0gJyBoLScgKyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudztcbiAgICBwYXRoICs9ICcgdi0nICsgdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmggKyAnICc7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgTWFza0VsZW1lbnQucHJvdG90eXBlLmRyYXdQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBwYXRoTm9kZXMsIHZpZXdEYXRhKSB7XG4gICAgdmFyIHBhdGhTdHJpbmcgPSAnIE0nICsgcGF0aE5vZGVzLnZbMF1bMF0gKyAnLCcgKyBwYXRoTm9kZXMudlswXVsxXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuICAgIGxlbiA9IHBhdGhOb2Rlcy5fbGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAvLyBwYXRoU3RyaW5nICs9IFwiIENcIitwYXRoTm9kZXMub1tpLTFdWzBdKycsJytwYXRoTm9kZXMub1tpLTFdWzFdICsgXCIgXCIrcGF0aE5vZGVzLmlbaV1bMF0rJywnK3BhdGhOb2Rlcy5pW2ldWzFdICsgXCIgXCIrcGF0aE5vZGVzLnZbaV1bMF0rJywnK3BhdGhOb2Rlcy52W2ldWzFdO1xuICAgICAgcGF0aFN0cmluZyArPSAnIEMnICsgcGF0aE5vZGVzLm9baSAtIDFdWzBdICsgJywnICsgcGF0aE5vZGVzLm9baSAtIDFdWzFdICsgJyAnICsgcGF0aE5vZGVzLmlbaV1bMF0gKyAnLCcgKyBwYXRoTm9kZXMuaVtpXVsxXSArICcgJyArIHBhdGhOb2Rlcy52W2ldWzBdICsgJywnICsgcGF0aE5vZGVzLnZbaV1bMV07XG4gICAgfSAvLyBwYXRoU3RyaW5nICs9IFwiIENcIitwYXRoTm9kZXMub1tpLTFdWzBdKycsJytwYXRoTm9kZXMub1tpLTFdWzFdICsgXCIgXCIrcGF0aE5vZGVzLmlbMF1bMF0rJywnK3BhdGhOb2Rlcy5pWzBdWzFdICsgXCIgXCIrcGF0aE5vZGVzLnZbMF1bMF0rJywnK3BhdGhOb2Rlcy52WzBdWzFdO1xuXG5cbiAgICBpZiAocGF0aE5vZGVzLmMgJiYgbGVuID4gMSkge1xuICAgICAgcGF0aFN0cmluZyArPSAnIEMnICsgcGF0aE5vZGVzLm9baSAtIDFdWzBdICsgJywnICsgcGF0aE5vZGVzLm9baSAtIDFdWzFdICsgJyAnICsgcGF0aE5vZGVzLmlbMF1bMF0gKyAnLCcgKyBwYXRoTm9kZXMuaVswXVsxXSArICcgJyArIHBhdGhOb2Rlcy52WzBdWzBdICsgJywnICsgcGF0aE5vZGVzLnZbMF1bMV07XG4gICAgfSAvLyBwYXRoTm9kZXMuX19yZW5kZXJlZFN0cmluZyA9IHBhdGhTdHJpbmc7XG5cblxuICAgIGlmICh2aWV3RGF0YS5sYXN0UGF0aCAhPT0gcGF0aFN0cmluZykge1xuICAgICAgdmFyIHBhdGhTaGFwZVZhbHVlID0gJyc7XG5cbiAgICAgIGlmICh2aWV3RGF0YS5lbGVtKSB7XG4gICAgICAgIGlmIChwYXRoTm9kZXMuYykge1xuICAgICAgICAgIHBhdGhTaGFwZVZhbHVlID0gcGF0aERhdGEuaW52ID8gdGhpcy5zb2xpZFBhdGggKyBwYXRoU3RyaW5nIDogcGF0aFN0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIHZpZXdEYXRhLmVsZW0uc2V0QXR0cmlidXRlKCdkJywgcGF0aFNoYXBlVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB2aWV3RGF0YS5sYXN0UGF0aCA9IHBhdGhTdHJpbmc7XG4gICAgfVxuICB9O1xuXG4gIE1hc2tFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5nbG9iYWxEYXRhID0gbnVsbDtcbiAgICB0aGlzLm1hc2tFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMubWFza3NQcm9wZXJ0aWVzID0gbnVsbDtcbiAgfTtcblxuICB2YXIgZmlsdGVyc0ZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iID0ge307XG4gICAgb2IuY3JlYXRlRmlsdGVyID0gY3JlYXRlRmlsdGVyO1xuICAgIG9iLmNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIgPSBjcmVhdGVBbHBoYVRvTHVtaW5hbmNlRmlsdGVyO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRmlsdGVyKGZpbElkLCBza2lwQ29vcmRpbmF0ZXMpIHtcbiAgICAgIHZhciBmaWwgPSBjcmVhdGVOUygnZmlsdGVyJyk7XG4gICAgICBmaWwuc2V0QXR0cmlidXRlKCdpZCcsIGZpbElkKTtcblxuICAgICAgaWYgKHNraXBDb29yZGluYXRlcyAhPT0gdHJ1ZSkge1xuICAgICAgICBmaWwuc2V0QXR0cmlidXRlKCdmaWx0ZXJVbml0cycsICdvYmplY3RCb3VuZGluZ0JveCcpO1xuICAgICAgICBmaWwuc2V0QXR0cmlidXRlKCd4JywgJzAlJyk7XG4gICAgICAgIGZpbC5zZXRBdHRyaWJ1dGUoJ3knLCAnMCUnKTtcbiAgICAgICAgZmlsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMTAwJScpO1xuICAgICAgICBmaWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnMTAwJScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmlsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIoKSB7XG4gICAgICB2YXIgZmVDb2xvck1hdHJpeCA9IGNyZWF0ZU5TKCdmZUNvbG9yTWF0cml4Jyk7XG4gICAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndHlwZScsICdtYXRyaXgnKTtcbiAgICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnc1JHQicpO1xuICAgICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsICcwIDAgMCAxIDAgIDAgMCAwIDEgMCAgMCAwIDAgMSAwICAwIDAgMCAxIDEnKTtcbiAgICAgIHJldHVybiBmZUNvbG9yTWF0cml4O1xuICAgIH1cblxuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIHZhciBmZWF0dXJlU3VwcG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2IgPSB7XG4gICAgICBtYXNrVHlwZTogdHJ1ZSxcbiAgICAgIHN2Z0x1bWFIaWRkZW46IHRydWUsXG4gICAgICBvZmZzY3JlZW5DYW52YXM6IHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnXG4gICAgfTtcblxuICAgIGlmICgvTVNJRSAxMC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgL01TSUUgOS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgL3J2OjExLjAvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IC9FZGdlXFwvXFxkLi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIG9iLm1hc2tUeXBlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKC9maXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgb2Iuc3ZnTHVtYUhpZGRlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIHZhciByZWdpc3RlcmVkRWZmZWN0cyQxID0ge307XG4gIHZhciBpZFByZWZpeCA9ICdmaWx0ZXJfcmVzdWx0Xyc7XG5cbiAgZnVuY3Rpb24gU1ZHRWZmZWN0cyhlbGVtKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHNvdXJjZSA9ICdTb3VyY2VHcmFwaGljJztcbiAgICB2YXIgbGVuID0gZWxlbS5kYXRhLmVmID8gZWxlbS5kYXRhLmVmLmxlbmd0aCA6IDA7XG4gICAgdmFyIGZpbElkID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgdmFyIGZpbCA9IGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUZpbHRlcihmaWxJZCwgdHJ1ZSk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICB2YXIgZmlsdGVyTWFuYWdlcjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgZmlsdGVyTWFuYWdlciA9IG51bGw7XG4gICAgICB2YXIgdHlwZSA9IGVsZW0uZGF0YS5lZltpXS50eTtcblxuICAgICAgaWYgKHJlZ2lzdGVyZWRFZmZlY3RzJDFbdHlwZV0pIHtcbiAgICAgICAgdmFyIEVmZmVjdCA9IHJlZ2lzdGVyZWRFZmZlY3RzJDFbdHlwZV0uZWZmZWN0O1xuICAgICAgICBmaWx0ZXJNYW5hZ2VyID0gbmV3IEVmZmVjdChmaWwsIGVsZW0uZWZmZWN0c01hbmFnZXIuZWZmZWN0RWxlbWVudHNbaV0sIGVsZW0sIGlkUHJlZml4ICsgY291bnQsIHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IGlkUHJlZml4ICsgY291bnQ7XG5cbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRFZmZlY3RzJDFbdHlwZV0uY291bnRzQXNFZmZlY3QpIHtcbiAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWx0ZXJNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuZmlsdGVycy5wdXNoKGZpbHRlck1hbmFnZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgZWxlbS5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoZmlsKTtcbiAgICAgIGVsZW0ubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsdGVyJywgJ3VybCgnICsgZ2V0TG9jYXRpb25IcmVmKCkgKyAnIycgKyBmaWxJZCArICcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgIGVsZW0uYWRkUmVuZGVyYWJsZUNvbXBvbmVudCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBTVkdFZmZlY3RzLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuZmlsdGVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuZmlsdGVyc1tpXS5yZW5kZXJGcmFtZShfaXNGaXJzdEZyYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgU1ZHRWZmZWN0cy5wcm90b3R5cGUuZ2V0RWZmZWN0cyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuZmlsdGVycy5sZW5ndGg7XG4gICAgdmFyIGVmZmVjdHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMuZmlsdGVyc1tpXS50eXBlID09PSB0eXBlKSB7XG4gICAgICAgIGVmZmVjdHMucHVzaCh0aGlzLmZpbHRlcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlZmZlY3RzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRWZmZWN0JDEoaWQsIGVmZmVjdCwgY291bnRzQXNFZmZlY3QpIHtcbiAgICByZWdpc3RlcmVkRWZmZWN0cyQxW2lkXSA9IHtcbiAgICAgIGVmZmVjdDogZWZmZWN0LFxuICAgICAgY291bnRzQXNFZmZlY3Q6IGNvdW50c0FzRWZmZWN0XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFNWR0Jhc2VFbGVtZW50KCkge31cblxuICBTVkdCYXNlRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gICAgaW5pdFJlbmRlcmVyRWxlbWVudDogZnVuY3Rpb24gaW5pdFJlbmRlcmVyRWxlbWVudCgpIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcbiAgICB9LFxuICAgIGNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzOiBmdW5jdGlvbiBjcmVhdGVDb250YWluZXJFbGVtZW50cygpIHtcbiAgICAgIHRoaXMubWF0dGVFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50ID0gdGhpcy5sYXllckVsZW1lbnQ7XG4gICAgICB0aGlzLm1hc2tlZEVsZW1lbnQgPSB0aGlzLmxheWVyRWxlbWVudDtcbiAgICAgIHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgbGF5ZXJFbGVtZW50UGFyZW50ID0gbnVsbDsgLy8gSWYgdGhpcyBsYXllciBhY3RzIGFzIGEgbWFzayBmb3IgdGhlIGZvbGxvd2luZyBsYXllclxuXG4gICAgICBpZiAodGhpcy5kYXRhLnRkKSB7XG4gICAgICAgIHRoaXMubWF0dGVNYXNrcyA9IHt9O1xuICAgICAgICB2YXIgZ2cgPSBjcmVhdGVOUygnZycpO1xuICAgICAgICBnZy5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5sYXllcklkKTtcbiAgICAgICAgZ2cuYXBwZW5kQ2hpbGQodGhpcy5sYXllckVsZW1lbnQpO1xuICAgICAgICBsYXllckVsZW1lbnRQYXJlbnQgPSBnZztcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoZ2cpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEudHQpIHtcbiAgICAgICAgdGhpcy5tYXR0ZUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5sYXllckVsZW1lbnQpO1xuICAgICAgICBsYXllckVsZW1lbnRQYXJlbnQgPSB0aGlzLm1hdHRlRWxlbWVudDtcbiAgICAgICAgdGhpcy5iYXNlRWxlbWVudCA9IHRoaXMubWF0dGVFbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iYXNlRWxlbWVudCA9IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kYXRhLmxuKSB7XG4gICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmRhdGEubG4pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kYXRhLmNsKSB7XG4gICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0aGlzLmRhdGEuY2wpO1xuICAgICAgfSAvLyBDbGlwcGluZyBjb21wb3NpdGlvbnMgdG8gaGlkZSBjb250ZW50IHRoYXQgZXhjZWVkcyBib3VuZGFyaWVzLiBJZiBjb2xsYXBzZWQgdHJhbnNmb3JtYXRpb25zIGlzIG9uLCBjb21wb25lbnQgc2hvdWxkIG5vdCBiZSBjbGlwcGVkXG5cblxuICAgICAgaWYgKHRoaXMuZGF0YS50eSA9PT0gMCAmJiAhdGhpcy5kYXRhLmhkKSB7XG4gICAgICAgIHZhciBjcCA9IGNyZWF0ZU5TKCdjbGlwUGF0aCcpO1xuICAgICAgICB2YXIgcHQgPSBjcmVhdGVOUygncGF0aCcpO1xuICAgICAgICBwdC5zZXRBdHRyaWJ1dGUoJ2QnLCAnTTAsMCBMJyArIHRoaXMuZGF0YS53ICsgJywwIEwnICsgdGhpcy5kYXRhLncgKyAnLCcgKyB0aGlzLmRhdGEuaCArICcgTDAsJyArIHRoaXMuZGF0YS5oICsgJ3onKTtcbiAgICAgICAgdmFyIGNsaXBJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgICBjcC5zZXRBdHRyaWJ1dGUoJ2lkJywgY2xpcElkKTtcbiAgICAgICAgY3AuYXBwZW5kQ2hpbGQocHQpO1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChjcCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY2hlY2tNYXNrcygpKSB7XG4gICAgICAgICAgdmFyIGNwR3JvdXAgPSBjcmVhdGVOUygnZycpO1xuICAgICAgICAgIGNwR3JvdXAuc2V0QXR0cmlidXRlKCdjbGlwLXBhdGgnLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGNsaXBJZCArICcpJyk7XG4gICAgICAgICAgY3BHcm91cC5hcHBlbmRDaGlsZCh0aGlzLmxheWVyRWxlbWVudCk7XG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPSBjcEdyb3VwO1xuXG4gICAgICAgICAgaWYgKGxheWVyRWxlbWVudFBhcmVudCkge1xuICAgICAgICAgICAgbGF5ZXJFbGVtZW50UGFyZW50LmFwcGVuZENoaWxkKHRoaXMudHJhbnNmb3JtZWRFbGVtZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iYXNlRWxlbWVudCA9IHRoaXMudHJhbnNmb3JtZWRFbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgY2xpcElkICsgJyknKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kYXRhLmJtICE9PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0QmxlbmRNb2RlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJFbGVtZW50OiBmdW5jdGlvbiByZW5kZXJFbGVtZW50KCkge1xuICAgICAgaWYgKHRoaXMuZmluYWxUcmFuc2Zvcm0uX2xvY2FsTWF0TWRmKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50LnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE1hdC50bzJkQ1NTKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQuc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE9wYWNpdHkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVzdHJveUJhc2VFbGVtZW50OiBmdW5jdGlvbiBkZXN0cm95QmFzZUVsZW1lbnQoKSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLm1hdHRlRWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLm1hc2tNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB9LFxuICAgIGdldEJhc2VFbGVtZW50OiBmdW5jdGlvbiBnZXRCYXNlRWxlbWVudCgpIHtcbiAgICAgIGlmICh0aGlzLmRhdGEuaGQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmJhc2VFbGVtZW50O1xuICAgIH0sXG4gICAgY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHM6IGZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzKCkge1xuICAgICAgdGhpcy5tYXNrTWFuYWdlciA9IG5ldyBNYXNrRWxlbWVudCh0aGlzLmRhdGEsIHRoaXMsIHRoaXMuZ2xvYmFsRGF0YSk7XG4gICAgICB0aGlzLnJlbmRlcmFibGVFZmZlY3RzTWFuYWdlciA9IG5ldyBTVkdFZmZlY3RzKHRoaXMpO1xuICAgICAgdGhpcy5zZWFyY2hFZmZlY3RUcmFuc2Zvcm1zKCk7XG4gICAgfSxcbiAgICBnZXRNYXR0ZTogZnVuY3Rpb24gZ2V0TWF0dGUobWF0dGVUeXBlKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBub3QgYmUgYSBjb21tb24gY2FzZS4gQnV0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB3ZSdsbCBjcmVhdGUgdGhlIG1hdHRlIG9iamVjdC5cbiAgICAgIC8vIEl0IHNvbHZlcyBhbmltYXRpb25zIHRoYXQgaGF2ZSB0d28gY29uc2VjdXRpdmUgbGF5ZXJzIG1hcmtlZCBhcyBtYXR0ZSBtYXNrcy5cbiAgICAgIC8vIFdoaWNoIGlzIGFuIHVuZGVmaW5lZCBiZWhhdmlvciBpbiBBRS5cbiAgICAgIGlmICghdGhpcy5tYXR0ZU1hc2tzKSB7XG4gICAgICAgIHRoaXMubWF0dGVNYXNrcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMubWF0dGVNYXNrc1ttYXR0ZVR5cGVdKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXMubGF5ZXJJZCArICdfJyArIG1hdHRlVHlwZTtcbiAgICAgICAgdmFyIGZpbElkO1xuICAgICAgICB2YXIgZmlsO1xuICAgICAgICB2YXIgdXNlRWxlbWVudDtcbiAgICAgICAgdmFyIGdnO1xuXG4gICAgICAgIGlmIChtYXR0ZVR5cGUgPT09IDEgfHwgbWF0dGVUeXBlID09PSAzKSB7XG4gICAgICAgICAgdmFyIG1hc2tlciA9IGNyZWF0ZU5TKCdtYXNrJyk7XG4gICAgICAgICAgbWFza2VyLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gICAgICAgICAgbWFza2VyLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgbWF0dGVUeXBlID09PSAzID8gJ2x1bWluYW5jZScgOiAnYWxwaGEnKTtcbiAgICAgICAgICB1c2VFbGVtZW50ID0gY3JlYXRlTlMoJ3VzZScpO1xuICAgICAgICAgIHVzZUVsZW1lbnQuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicsICcjJyArIHRoaXMubGF5ZXJJZCk7XG4gICAgICAgICAgbWFza2VyLmFwcGVuZENoaWxkKHVzZUVsZW1lbnQpO1xuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKG1hc2tlcik7XG5cbiAgICAgICAgICBpZiAoIWZlYXR1cmVTdXBwb3J0Lm1hc2tUeXBlICYmIG1hdHRlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgbWFza2VyLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2x1bWluYW5jZScpO1xuICAgICAgICAgICAgZmlsSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICAgICAgICAgIGZpbCA9IGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUZpbHRlcihmaWxJZCk7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChmaWwpO1xuICAgICAgICAgICAgZmlsLmFwcGVuZENoaWxkKGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIoKSk7XG4gICAgICAgICAgICBnZyA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICAgICAgICBnZy5hcHBlbmRDaGlsZCh1c2VFbGVtZW50KTtcbiAgICAgICAgICAgIG1hc2tlci5hcHBlbmRDaGlsZChnZyk7XG4gICAgICAgICAgICBnZy5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgZmlsSWQgKyAnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtYXR0ZVR5cGUgPT09IDIpIHtcbiAgICAgICAgICB2YXIgbWFza0dyb3VwID0gY3JlYXRlTlMoJ21hc2snKTtcbiAgICAgICAgICBtYXNrR3JvdXAuc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgICBtYXNrR3JvdXAuc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCAnYWxwaGEnKTtcbiAgICAgICAgICB2YXIgbWFza0dyb3VwZXIgPSBjcmVhdGVOUygnZycpO1xuICAgICAgICAgIG1hc2tHcm91cC5hcHBlbmRDaGlsZChtYXNrR3JvdXBlcik7XG4gICAgICAgICAgZmlsSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICAgICAgICBmaWwgPSBmaWx0ZXJzRmFjdG9yeS5jcmVhdGVGaWx0ZXIoZmlsSWQpOyAvLy8gL1xuXG4gICAgICAgICAgdmFyIGZlQ1RyID0gY3JlYXRlTlMoJ2ZlQ29tcG9uZW50VHJhbnNmZXInKTtcbiAgICAgICAgICBmZUNUci5zZXRBdHRyaWJ1dGUoJ2luJywgJ1NvdXJjZUdyYXBoaWMnKTtcbiAgICAgICAgICBmaWwuYXBwZW5kQ2hpbGQoZmVDVHIpO1xuICAgICAgICAgIHZhciBmZUZ1bmMgPSBjcmVhdGVOUygnZmVGdW5jQScpO1xuICAgICAgICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGFibGUnKTtcbiAgICAgICAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKCd0YWJsZVZhbHVlcycsICcxLjAgMC4wJyk7XG4gICAgICAgICAgZmVDVHIuYXBwZW5kQ2hpbGQoZmVGdW5jKTsgLy8vIC9cblxuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKGZpbCk7XG4gICAgICAgICAgdmFyIGFscGhhUmVjdCA9IGNyZWF0ZU5TKCdyZWN0Jyk7XG4gICAgICAgICAgYWxwaGFSZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmNvbXAuZGF0YS53KTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmNvbXAuZGF0YS5oKTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCd4JywgJzAnKTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCd5JywgJzAnKTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCdmaWxsJywgJyNmZmZmZmYnKTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgJzAnKTtcbiAgICAgICAgICBtYXNrR3JvdXBlci5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgZmlsSWQgKyAnKScpO1xuICAgICAgICAgIG1hc2tHcm91cGVyLmFwcGVuZENoaWxkKGFscGhhUmVjdCk7XG4gICAgICAgICAgdXNlRWxlbWVudCA9IGNyZWF0ZU5TKCd1c2UnKTtcbiAgICAgICAgICB1c2VFbGVtZW50LnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgJ2hyZWYnLCAnIycgKyB0aGlzLmxheWVySWQpO1xuICAgICAgICAgIG1hc2tHcm91cGVyLmFwcGVuZENoaWxkKHVzZUVsZW1lbnQpO1xuXG4gICAgICAgICAgaWYgKCFmZWF0dXJlU3VwcG9ydC5tYXNrVHlwZSkge1xuICAgICAgICAgICAgbWFza0dyb3VwLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2x1bWluYW5jZScpO1xuICAgICAgICAgICAgZmlsLmFwcGVuZENoaWxkKGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIoKSk7XG4gICAgICAgICAgICBnZyA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICAgICAgICBtYXNrR3JvdXBlci5hcHBlbmRDaGlsZChhbHBoYVJlY3QpO1xuICAgICAgICAgICAgZ2cuYXBwZW5kQ2hpbGQodGhpcy5sYXllckVsZW1lbnQpO1xuICAgICAgICAgICAgbWFza0dyb3VwZXIuYXBwZW5kQ2hpbGQoZ2cpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKG1hc2tHcm91cCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1hdHRlTWFza3NbbWF0dGVUeXBlXSA9IGlkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5tYXR0ZU1hc2tzW21hdHRlVHlwZV07XG4gICAgfSxcbiAgICBzZXRNYXR0ZTogZnVuY3Rpb24gc2V0TWF0dGUoaWQpIHtcbiAgICAgIGlmICghdGhpcy5tYXR0ZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1hdHRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21hc2snLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGlkICsgJyknKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXHJcbiAgICogQGZpbGVcclxuICAgKiBIYW5kbGVzIEFFJ3MgbGF5ZXIgcGFyZW50aW5nIHByb3BlcnR5LlxyXG4gICAqXHJcbiAgICovXG4gIGZ1bmN0aW9uIEhpZXJhcmNoeUVsZW1lbnQoKSB7fVxuXG4gIEhpZXJhcmNoeUVsZW1lbnQucHJvdG90eXBlID0ge1xuICAgIC8qKlxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogSW5pdGlhbGl6ZXMgaGllcmFyY2h5IHByb3BlcnRpZXNcclxuICAgICAgICpcclxuICAgICAgICovXG4gICAgaW5pdEhpZXJhcmNoeTogZnVuY3Rpb24gaW5pdEhpZXJhcmNoeSgpIHtcbiAgICAgIC8vIGVsZW1lbnQncyBwYXJlbnQgbGlzdFxuICAgICAgdGhpcy5oaWVyYXJjaHkgPSBbXTsgLy8gaWYgZWxlbWVudCBpcyBwYXJlbnQgb2YgYW5vdGhlciBsYXllciBfaXNQYXJlbnQgd2lsbCBiZSB0cnVlXG5cbiAgICAgIHRoaXMuX2lzUGFyZW50ID0gZmFsc2U7XG4gICAgICB0aGlzLmNoZWNrUGFyZW50aW5nKCk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogU2V0cyBsYXllcidzIGhpZXJhcmNoeS5cclxuICAgICAgICogQHBhcmFtIHthcnJheX0gaGllcmFyY2hcclxuICAgICAgICogbGF5ZXIncyBwYXJlbnQgbGlzdFxyXG4gICAgICAgKlxyXG4gICAgICAgKi9cbiAgICBzZXRIaWVyYXJjaHk6IGZ1bmN0aW9uIHNldEhpZXJhcmNoeShoaWVyYXJjaHkpIHtcbiAgICAgIHRoaXMuaGllcmFyY2h5ID0gaGllcmFyY2h5O1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqIFNldHMgbGF5ZXIgYXMgcGFyZW50LlxyXG4gICAgICAgKlxyXG4gICAgICAgKi9cbiAgICBzZXRBc1BhcmVudDogZnVuY3Rpb24gc2V0QXNQYXJlbnQoKSB7XG4gICAgICB0aGlzLl9pc1BhcmVudCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogU2VhcmNoZXMgbGF5ZXIncyBwYXJlbnRpbmcgY2hhaW5cclxuICAgICAgICpcclxuICAgICAgICovXG4gICAgY2hlY2tQYXJlbnRpbmc6IGZ1bmN0aW9uIGNoZWNrUGFyZW50aW5nKCkge1xuICAgICAgaWYgKHRoaXMuZGF0YS5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNvbXAuYnVpbGRFbGVtZW50UGFyZW50aW5nKHRoaXMsIHRoaXMuZGF0YS5wYXJlbnQsIFtdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gUmVuZGVyYWJsZURPTUVsZW1lbnQoKSB7fVxuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9wcm90b3R5cGUgPSB7XG4gICAgICBpbml0RWxlbWVudDogZnVuY3Rpb24gaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgICAgICB0aGlzLmluaXRGcmFtZSgpO1xuICAgICAgICB0aGlzLmluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICAgICAgdGhpcy5pbml0VHJhbnNmb3JtKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgICAgICB0aGlzLmluaXRIaWVyYXJjaHkoKTtcbiAgICAgICAgdGhpcy5pbml0UmVuZGVyYWJsZSgpO1xuICAgICAgICB0aGlzLmluaXRSZW5kZXJlckVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb250YWluZXJFbGVtZW50cygpO1xuICAgICAgICB0aGlzLmNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29udGVudCgpO1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH0sXG4gICAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnSElERScsIHRoaXMpO1xuICAgICAgICBpZiAoIXRoaXMuaGlkZGVuICYmICghdGhpcy5pc0luUmFuZ2UgfHwgdGhpcy5pc1RyYW5zcGFyZW50KSkge1xuICAgICAgICAgIHZhciBlbGVtID0gdGhpcy5iYXNlRWxlbWVudCB8fCB0aGlzLmxheWVyRWxlbWVudDtcbiAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgdGhpcy5oaWRkZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1NIT1cnLCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNJblJhbmdlICYmICF0aGlzLmlzVHJhbnNwYXJlbnQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuZGF0YS5oZCkge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzLmJhc2VFbGVtZW50IHx8IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW5kZXJGcmFtZTogZnVuY3Rpb24gcmVuZGVyRnJhbWUoKSB7XG4gICAgICAgIC8vIElmIGl0IGlzIGV4cG9ydGVkIGFzIGhpZGRlbiAoZGF0YS5oZCA9PT0gdHJ1ZSkgbm8gbmVlZCB0byByZW5kZXJcbiAgICAgICAgLy8gSWYgaXQgaXMgbm90IHZpc2libGUgbm8gbmVlZCB0byByZW5kZXJcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5oZCB8fCB0aGlzLmhpZGRlbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVuZGVyVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMucmVuZGVyUmVuZGVyYWJsZSgpO1xuICAgICAgICB0aGlzLnJlbmRlckxvY2FsVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMucmVuZGVyRWxlbWVudCgpO1xuICAgICAgICB0aGlzLnJlbmRlcklubmVyQ29udGVudCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlbmRlcklubmVyQ29udGVudDogZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KCkge30sXG4gICAgICBwcmVwYXJlRnJhbWU6IGZ1bmN0aW9uIHByZXBhcmVGcmFtZShudW0pIHtcbiAgICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJlcGFyZVJlbmRlcmFibGVGcmFtZShudW0pO1xuICAgICAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdGhpcy5pc0luUmFuZ2UpO1xuICAgICAgICB0aGlzLmNoZWNrVHJhbnNwYXJlbmN5KCk7XG4gICAgICB9LFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5pbm5lckVsZW0gPSBudWxsO1xuICAgICAgICB0aGlzLmRlc3Ryb3lCYXNlRWxlbWVudCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXh0ZW5kUHJvdG90eXBlKFtSZW5kZXJhYmxlRWxlbWVudCwgY3JlYXRlUHJveHlGdW5jdGlvbihfcHJvdG90eXBlKV0sIFJlbmRlcmFibGVET01FbGVtZW50KTtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBJSW1hZ2VFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmFzc2V0RGF0YSA9IGdsb2JhbERhdGEuZ2V0QXNzZXREYXRhKGRhdGEucmVmSWQpO1xuXG4gICAgaWYgKHRoaXMuYXNzZXREYXRhICYmIHRoaXMuYXNzZXREYXRhLnNpZCkge1xuICAgICAgdGhpcy5hc3NldERhdGEgPSBnbG9iYWxEYXRhLnNsb3RNYW5hZ2VyLmdldFByb3AodGhpcy5hc3NldERhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy5zb3VyY2VSZWN0ID0ge1xuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHdpZHRoOiB0aGlzLmFzc2V0RGF0YS53LFxuICAgICAgaGVpZ2h0OiB0aGlzLmFzc2V0RGF0YS5oXG4gICAgfTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIFNWR0Jhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50XSwgSUltYWdlRWxlbWVudCk7XG5cbiAgSUltYWdlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXNzZXRQYXRoID0gdGhpcy5nbG9iYWxEYXRhLmdldEFzc2V0c1BhdGgodGhpcy5hc3NldERhdGEpO1xuICAgIHRoaXMuaW5uZXJFbGVtID0gY3JlYXRlTlMoJ2ltYWdlJyk7XG4gICAgdGhpcy5pbm5lckVsZW0uc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuYXNzZXREYXRhLncgKyAncHgnKTtcbiAgICB0aGlzLmlubmVyRWxlbS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuYXNzZXREYXRhLmggKyAncHgnKTtcbiAgICB0aGlzLmlubmVyRWxlbS5zZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCB0aGlzLmFzc2V0RGF0YS5wciB8fCB0aGlzLmdsb2JhbERhdGEucmVuZGVyQ29uZmlnLmltYWdlUHJlc2VydmVBc3BlY3RSYXRpbyk7XG4gICAgdGhpcy5pbm5lckVsZW0uc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicsIGFzc2V0UGF0aCk7XG4gICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5pbm5lckVsZW0pO1xuICB9O1xuXG4gIElJbWFnZUVsZW1lbnQucHJvdG90eXBlLnNvdXJjZVJlY3RBdFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlUmVjdDtcbiAgfTtcblxuICBmdW5jdGlvbiBQcm9jZXNzZWRFbGVtZW50KGVsZW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5lbGVtID0gZWxlbWVudDtcbiAgICB0aGlzLnBvcyA9IHBvc2l0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gSVNoYXBlRWxlbWVudCgpIHt9XG5cbiAgSVNoYXBlRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gICAgYWRkU2hhcGVUb01vZGlmaWVyczogZnVuY3Rpb24gYWRkU2hhcGVUb01vZGlmaWVycyhkYXRhKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLnNoYXBlTW9kaWZpZXJzLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMuc2hhcGVNb2RpZmllcnNbaV0uYWRkU2hhcGUoZGF0YSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc1NoYXBlSW5BbmltYXRlZE1vZGlmaWVyczogZnVuY3Rpb24gaXNTaGFwZUluQW5pbWF0ZWRNb2RpZmllcnMoZGF0YSkge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuc2hhcGVNb2RpZmllcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAodGhpcy5zaGFwZU1vZGlmaWVyc1tpXS5pc0FuaW1hdGVkV2l0aFNoYXBlKGRhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgcmVuZGVyTW9kaWZpZXJzOiBmdW5jdGlvbiByZW5kZXJNb2RpZmllcnMoKSB7XG4gICAgICBpZiAoIXRoaXMuc2hhcGVNb2RpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gdGhpcy5zaGFwZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5zaGFwZXNbaV0uc2gucmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgbGVuID0gdGhpcy5zaGFwZU1vZGlmaWVycy5sZW5ndGg7XG4gICAgICB2YXIgc2hvdWxkQnJlYWtQcm9jZXNzO1xuXG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBzaG91bGRCcmVha1Byb2Nlc3MgPSB0aGlzLnNoYXBlTW9kaWZpZXJzW2ldLnByb2Nlc3NTaGFwZXModGhpcy5faXNGaXJzdEZyYW1lKTsgLy8gd29ya2Fyb3VuZCB0byBmaXggY2FzZXMgd2hlcmUgYSByZXBlYXRlciByZXNldHMgdGhlIHNoYXBlIHNvIHRoZSBmb2xsb3dpbmcgcHJvY2Vzc2VzIGdldCBjYWxsZWQgdHdpY2VcbiAgICAgICAgLy8gVE9ETzogZmluZCBhIGJldHRlciBzb2x1dGlvbiBmb3IgdGhpc1xuXG4gICAgICAgIGlmIChzaG91bGRCcmVha1Byb2Nlc3MpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2VhcmNoUHJvY2Vzc2VkRWxlbWVudDogZnVuY3Rpb24gc2VhcmNoUHJvY2Vzc2VkRWxlbWVudChlbGVtKSB7XG4gICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnByb2Nlc3NlZEVsZW1lbnRzO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgaWYgKGVsZW1lbnRzW2ldLmVsZW0gPT09IGVsZW0pIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudHNbaV0ucG9zO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIGFkZFByb2Nlc3NlZEVsZW1lbnQ6IGZ1bmN0aW9uIGFkZFByb2Nlc3NlZEVsZW1lbnQoZWxlbSwgcG9zKSB7XG4gICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnByb2Nlc3NlZEVsZW1lbnRzO1xuICAgICAgdmFyIGkgPSBlbGVtZW50cy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpKSB7XG4gICAgICAgIGkgLT0gMTtcblxuICAgICAgICBpZiAoZWxlbWVudHNbaV0uZWxlbSA9PT0gZWxlbSkge1xuICAgICAgICAgIGVsZW1lbnRzW2ldLnBvcyA9IHBvcztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWxlbWVudHMucHVzaChuZXcgUHJvY2Vzc2VkRWxlbWVudChlbGVtLCBwb3MpKTtcbiAgICB9LFxuICAgIHByZXBhcmVGcmFtZTogZnVuY3Rpb24gcHJlcGFyZUZyYW1lKG51bSkge1xuICAgICAgdGhpcy5wcmVwYXJlUmVuZGVyYWJsZUZyYW1lKG51bSk7XG4gICAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdGhpcy5pc0luUmFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbGluZUNhcEVudW0gPSB7XG4gICAgMTogJ2J1dHQnLFxuICAgIDI6ICdyb3VuZCcsXG4gICAgMzogJ3NxdWFyZSdcbiAgfTtcbiAgdmFyIGxpbmVKb2luRW51bSA9IHtcbiAgICAxOiAnbWl0ZXInLFxuICAgIDI6ICdyb3VuZCcsXG4gICAgMzogJ2JldmVsJ1xuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR1NoYXBlRGF0YSh0cmFuc2Zvcm1lcnMsIGxldmVsLCBzaGFwZSkge1xuICAgIHRoaXMuY2FjaGVzID0gW107XG4gICAgdGhpcy5zdHlsZXMgPSBbXTtcbiAgICB0aGlzLnRyYW5zZm9ybWVycyA9IHRyYW5zZm9ybWVycztcbiAgICB0aGlzLmxTdHIgPSAnJztcbiAgICB0aGlzLnNoID0gc2hhcGU7XG4gICAgdGhpcy5sdmwgPSBsZXZlbDsgLy8gVE9ETyBmaW5kIGlmIHRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZXJlIF9pc0FuaW1hdGVkIGNhbiBiZSBmYWxzZS5cbiAgICAvLyBGb3Igbm93LCBzaW5jZSBzaGFwZXMgYWRkIHVwIHdpdGggb3RoZXIgc2hhcGVzLiBUaGV5IGhhdmUgdG8gYmUgY2FsY3VsYXRlZCBldmVyeSB0aW1lLlxuICAgIC8vIE9uZSB3YXkgb2YgZmluZGluZyBvdXQgaXMgY2hlY2tpbmcgaWYgYWxsIHN0eWxlcyBhc3NvY2lhdGVkIHRvIHRoaXMgc2hhcGUgZGVwZW5kIG9ubHkgb2YgdGhpcyBzaGFwZVxuXG4gICAgdGhpcy5faXNBbmltYXRlZCA9ICEhc2hhcGUuazsgLy8gVE9ETzogY29tbWVudGluZyB0aGlzIGZvciBub3cgc2luY2UgYWxsIHNoYXBlcyBhcmUgYW5pbWF0ZWRcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdHJhbnNmb3JtZXJzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAodHJhbnNmb3JtZXJzW2ldLm1Qcm9wcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5faXNBbmltYXRlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuICB9XG5cbiAgU1ZHU2hhcGVEYXRhLnByb3RvdHlwZS5zZXRBc0FuaW1hdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSB0cnVlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR1N0eWxlRGF0YShkYXRhLCBsZXZlbCkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy50eXBlID0gZGF0YS50eTtcbiAgICB0aGlzLmQgPSAnJztcbiAgICB0aGlzLmx2bCA9IGxldmVsO1xuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIHRoaXMuY2xvc2VkID0gZGF0YS5oZCA9PT0gdHJ1ZTtcbiAgICB0aGlzLnBFbGVtID0gY3JlYXRlTlMoJ3BhdGgnKTtcbiAgICB0aGlzLm1zRWxlbSA9IG51bGw7XG4gIH1cblxuICBTVkdTdHlsZURhdGEucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZCA9ICcnO1xuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIERhc2hQcm9wZXJ0eShlbGVtLCBkYXRhLCByZW5kZXJlciwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICB0aGlzLmZyYW1lSWQgPSAtMTtcbiAgICB0aGlzLmRhdGFQcm9wcyA9IGNyZWF0ZVNpemVkQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICB0aGlzLmRhc2hTdHIgPSAnJztcbiAgICB0aGlzLmRhc2hBcnJheSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBkYXRhLmxlbmd0aCA/IGRhdGEubGVuZ3RoIC0gMSA6IDApO1xuICAgIHRoaXMuZGFzaG9mZnNldCA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCAxKTtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGggfHwgMDtcbiAgICB2YXIgcHJvcDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgcHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGFbaV0udiwgMCwgMCwgdGhpcyk7XG4gICAgICB0aGlzLmsgPSBwcm9wLmsgfHwgdGhpcy5rO1xuICAgICAgdGhpcy5kYXRhUHJvcHNbaV0gPSB7XG4gICAgICAgIG46IGRhdGFbaV0ubixcbiAgICAgICAgcDogcHJvcFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaykge1xuICAgICAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gdGhpcy5rO1xuICB9XG5cbiAgRGFzaFByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xuICAgIGlmICh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQgJiYgIWZvcmNlUmVuZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcbiAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xuICAgIHRoaXMuX21kZiA9IHRoaXMuX21kZiB8fCBmb3JjZVJlbmRlcjtcblxuICAgIGlmICh0aGlzLl9tZGYpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmRhdGFQcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmICh0aGlzLnJlbmRlcmVyID09PSAnc3ZnJykge1xuICAgICAgICB0aGlzLmRhc2hTdHIgPSAnJztcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFQcm9wc1tpXS5uICE9PSAnbycpIHtcbiAgICAgICAgICBpZiAodGhpcy5yZW5kZXJlciA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgIHRoaXMuZGFzaFN0ciArPSAnICcgKyB0aGlzLmRhdGFQcm9wc1tpXS5wLnY7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGFzaEFycmF5W2ldID0gdGhpcy5kYXRhUHJvcHNbaV0ucC52O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRhc2hvZmZzZXRbMF0gPSB0aGlzLmRhdGFQcm9wc1tpXS5wLnY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBEYXNoUHJvcGVydHkpO1xuXG4gIGZ1bmN0aW9uIFNWR1N0cm9rZVN0eWxlRGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKSB7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcztcbiAgICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm8sIDAsIDAuMDEsIHRoaXMpO1xuICAgIHRoaXMudyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudywgMCwgbnVsbCwgdGhpcyk7XG4gICAgdGhpcy5kID0gbmV3IERhc2hQcm9wZXJ0eShlbGVtLCBkYXRhLmQgfHwge30sICdzdmcnLCB0aGlzKTtcbiAgICB0aGlzLmMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmMsIDEsIDI1NSwgdGhpcyk7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlT2I7XG4gICAgdGhpcy5faXNBbmltYXRlZCA9ICEhdGhpcy5faXNBbmltYXRlZDtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU1ZHU3Ryb2tlU3R5bGVEYXRhKTtcblxuICBmdW5jdGlvbiBTVkdGaWxsU3R5bGVEYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpIHtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzO1xuICAgIHRoaXMubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubywgMCwgMC4wMSwgdGhpcyk7XG4gICAgdGhpcy5jID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5jLCAxLCAyNTUsIHRoaXMpO1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZU9iO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBTVkdGaWxsU3R5bGVEYXRhKTtcblxuICBmdW5jdGlvbiBTVkdOb1N0eWxlRGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKSB7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcztcbiAgICB0aGlzLnN0eWxlID0gc3R5bGVPYjtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU1ZHTm9TdHlsZURhdGEpO1xuXG4gIGZ1bmN0aW9uIEdyYWRpZW50UHJvcGVydHkoZWxlbSwgZGF0YSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmMgPSBjcmVhdGVUeXBlZEFycmF5KCd1aW50OGMnLCBkYXRhLnAgKiA0KTtcbiAgICB2YXIgY0xlbmd0aCA9IGRhdGEuay5rWzBdLnMgPyBkYXRhLmsua1swXS5zLmxlbmd0aCAtIGRhdGEucCAqIDQgOiBkYXRhLmsuay5sZW5ndGggLSBkYXRhLnAgKiA0O1xuICAgIHRoaXMubyA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBjTGVuZ3RoKTtcbiAgICB0aGlzLl9jbWRmID0gZmFsc2U7XG4gICAgdGhpcy5fb21kZiA9IGZhbHNlO1xuICAgIHRoaXMuX2NvbGxhcHNhYmxlID0gdGhpcy5jaGVja0NvbGxhcHNhYmxlKCk7XG4gICAgdGhpcy5faGFzT3BhY2l0eSA9IGNMZW5ndGg7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdGhpcy5wcm9wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5rLCAxLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLmsgPSB0aGlzLnByb3AuaztcbiAgICB0aGlzLmdldFZhbHVlKHRydWUpO1xuICB9XG5cbiAgR3JhZGllbnRQcm9wZXJ0eS5wcm90b3R5cGUuY29tcGFyZVBvaW50cyA9IGZ1bmN0aW9uICh2YWx1ZXMsIHBvaW50cykge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGhpcy5vLmxlbmd0aCAvIDI7XG4gICAgdmFyIGRpZmY7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgZGlmZiA9IE1hdGguYWJzKHZhbHVlc1tpICogNF0gLSB2YWx1ZXNbcG9pbnRzICogNCArIGkgKiAyXSk7XG5cbiAgICAgIGlmIChkaWZmID4gMC4wMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBHcmFkaWVudFByb3BlcnR5LnByb3RvdHlwZS5jaGVja0NvbGxhcHNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm8ubGVuZ3RoIC8gMiAhPT0gdGhpcy5jLmxlbmd0aCAvIDQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kYXRhLmsua1swXS5zKSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gdGhpcy5kYXRhLmsuay5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGlmICghdGhpcy5jb21wYXJlUG9pbnRzKHRoaXMuZGF0YS5rLmtbaV0ucywgdGhpcy5kYXRhLnApKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuY29tcGFyZVBvaW50cyh0aGlzLmRhdGEuay5rLCB0aGlzLmRhdGEucCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBHcmFkaWVudFByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xuICAgIHRoaXMucHJvcC5nZXRWYWx1ZSgpO1xuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIHRoaXMuX2NtZGYgPSBmYWxzZTtcbiAgICB0aGlzLl9vbWRmID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5wcm9wLl9tZGYgfHwgZm9yY2VSZW5kZXIpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZGF0YS5wICogNDtcbiAgICAgIHZhciBtdWx0O1xuICAgICAgdmFyIHZhbDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIG11bHQgPSBpICUgNCA9PT0gMCA/IDEwMCA6IDI1NTtcbiAgICAgICAgdmFsID0gTWF0aC5yb3VuZCh0aGlzLnByb3AudltpXSAqIG11bHQpO1xuXG4gICAgICAgIGlmICh0aGlzLmNbaV0gIT09IHZhbCkge1xuICAgICAgICAgIHRoaXMuY1tpXSA9IHZhbDtcbiAgICAgICAgICB0aGlzLl9jbWRmID0gIWZvcmNlUmVuZGVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm8ubGVuZ3RoKSB7XG4gICAgICAgIGxlbiA9IHRoaXMucHJvcC52Lmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSB0aGlzLmRhdGEucCAqIDQ7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIG11bHQgPSBpICUgMiA9PT0gMCA/IDEwMCA6IDE7XG4gICAgICAgICAgdmFsID0gaSAlIDIgPT09IDAgPyBNYXRoLnJvdW5kKHRoaXMucHJvcC52W2ldICogMTAwKSA6IHRoaXMucHJvcC52W2ldO1xuXG4gICAgICAgICAgaWYgKHRoaXMub1tpIC0gdGhpcy5kYXRhLnAgKiA0XSAhPT0gdmFsKSB7XG4gICAgICAgICAgICB0aGlzLm9baSAtIHRoaXMuZGF0YS5wICogNF0gPSB2YWw7XG4gICAgICAgICAgICB0aGlzLl9vbWRmID0gIWZvcmNlUmVuZGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9tZGYgPSAhZm9yY2VSZW5kZXI7XG4gICAgfVxuICB9O1xuXG4gIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgR3JhZGllbnRQcm9wZXJ0eSk7XG5cbiAgZnVuY3Rpb24gU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpIHtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzO1xuICAgIHRoaXMuaW5pdEdyYWRpZW50RGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKTtcbiAgfVxuXG4gIFNWR0dyYWRpZW50RmlsbFN0eWxlRGF0YS5wcm90b3R5cGUuaW5pdEdyYWRpZW50RGF0YSA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhLCBzdHlsZU9iKSB7XG4gICAgdGhpcy5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5vLCAwLCAwLjAxLCB0aGlzKTtcbiAgICB0aGlzLnMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnMsIDEsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMuZSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuZSwgMSwgbnVsbCwgdGhpcyk7XG4gICAgdGhpcy5oID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5oIHx8IHtcbiAgICAgIGs6IDBcbiAgICB9LCAwLCAwLjAxLCB0aGlzKTtcbiAgICB0aGlzLmEgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmEgfHwge1xuICAgICAgazogMFxuICAgIH0sIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgdGhpcy5nID0gbmV3IEdyYWRpZW50UHJvcGVydHkoZWxlbSwgZGF0YS5nLCB0aGlzKTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGVPYjtcbiAgICB0aGlzLnN0b3BzID0gW107XG4gICAgdGhpcy5zZXRHcmFkaWVudERhdGEoc3R5bGVPYi5wRWxlbSwgZGF0YSk7XG4gICAgdGhpcy5zZXRHcmFkaWVudE9wYWNpdHkoZGF0YSwgc3R5bGVPYik7XG4gICAgdGhpcy5faXNBbmltYXRlZCA9ICEhdGhpcy5faXNBbmltYXRlZDtcbiAgfTtcblxuICBTVkdHcmFkaWVudEZpbGxTdHlsZURhdGEucHJvdG90eXBlLnNldEdyYWRpZW50RGF0YSA9IGZ1bmN0aW9uIChwYXRoRWxlbWVudCwgZGF0YSkge1xuICAgIHZhciBncmFkaWVudElkID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgdmFyIGdmaWxsID0gY3JlYXRlTlMoZGF0YS50ID09PSAxID8gJ2xpbmVhckdyYWRpZW50JyA6ICdyYWRpYWxHcmFkaWVudCcpO1xuICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgnaWQnLCBncmFkaWVudElkKTtcbiAgICBnZmlsbC5zZXRBdHRyaWJ1dGUoJ3NwcmVhZE1ldGhvZCcsICdwYWQnKTtcbiAgICBnZmlsbC5zZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKTtcbiAgICB2YXIgc3RvcHMgPSBbXTtcbiAgICB2YXIgc3RvcDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICBqTGVuID0gZGF0YS5nLnAgKiA0O1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gNCkge1xuICAgICAgc3RvcCA9IGNyZWF0ZU5TKCdzdG9wJyk7XG4gICAgICBnZmlsbC5hcHBlbmRDaGlsZChzdG9wKTtcbiAgICAgIHN0b3BzLnB1c2goc3RvcCk7XG4gICAgfVxuXG4gICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKGRhdGEudHkgPT09ICdnZicgPyAnZmlsbCcgOiAnc3Ryb2tlJywgJ3VybCgnICsgZ2V0TG9jYXRpb25IcmVmKCkgKyAnIycgKyBncmFkaWVudElkICsgJyknKTtcbiAgICB0aGlzLmdmID0gZ2ZpbGw7XG4gICAgdGhpcy5jc3QgPSBzdG9wcztcbiAgfTtcblxuICBTVkdHcmFkaWVudEZpbGxTdHlsZURhdGEucHJvdG90eXBlLnNldEdyYWRpZW50T3BhY2l0eSA9IGZ1bmN0aW9uIChkYXRhLCBzdHlsZU9iKSB7XG4gICAgaWYgKHRoaXMuZy5faGFzT3BhY2l0eSAmJiAhdGhpcy5nLl9jb2xsYXBzYWJsZSkge1xuICAgICAgdmFyIHN0b3A7XG4gICAgICB2YXIgajtcbiAgICAgIHZhciBqTGVuO1xuICAgICAgdmFyIG1hc2sgPSBjcmVhdGVOUygnbWFzaycpO1xuICAgICAgdmFyIG1hc2tFbGVtZW50ID0gY3JlYXRlTlMoJ3BhdGgnKTtcbiAgICAgIG1hc2suYXBwZW5kQ2hpbGQobWFza0VsZW1lbnQpO1xuICAgICAgdmFyIG9wYWNpdHlJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgdmFyIG1hc2tJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoJ2lkJywgbWFza0lkKTtcbiAgICAgIHZhciBvcEZpbGwgPSBjcmVhdGVOUyhkYXRhLnQgPT09IDEgPyAnbGluZWFyR3JhZGllbnQnIDogJ3JhZGlhbEdyYWRpZW50Jyk7XG4gICAgICBvcEZpbGwuc2V0QXR0cmlidXRlKCdpZCcsIG9wYWNpdHlJZCk7XG4gICAgICBvcEZpbGwuc2V0QXR0cmlidXRlKCdzcHJlYWRNZXRob2QnLCAncGFkJyk7XG4gICAgICBvcEZpbGwuc2V0QXR0cmlidXRlKCdncmFkaWVudFVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJyk7XG4gICAgICBqTGVuID0gZGF0YS5nLmsua1swXS5zID8gZGF0YS5nLmsua1swXS5zLmxlbmd0aCA6IGRhdGEuZy5rLmsubGVuZ3RoO1xuICAgICAgdmFyIHN0b3BzID0gdGhpcy5zdG9wcztcblxuICAgICAgZm9yIChqID0gZGF0YS5nLnAgKiA0OyBqIDwgakxlbjsgaiArPSAyKSB7XG4gICAgICAgIHN0b3AgPSBjcmVhdGVOUygnc3RvcCcpO1xuICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicsICdyZ2IoMjU1LDI1NSwyNTUpJyk7XG4gICAgICAgIG9wRmlsbC5hcHBlbmRDaGlsZChzdG9wKTtcbiAgICAgICAgc3RvcHMucHVzaChzdG9wKTtcbiAgICAgIH1cblxuICAgICAgbWFza0VsZW1lbnQuc2V0QXR0cmlidXRlKGRhdGEudHkgPT09ICdnZicgPyAnZmlsbCcgOiAnc3Ryb2tlJywgJ3VybCgnICsgZ2V0TG9jYXRpb25IcmVmKCkgKyAnIycgKyBvcGFjaXR5SWQgKyAnKScpO1xuXG4gICAgICBpZiAoZGF0YS50eSA9PT0gJ2dzJykge1xuICAgICAgICBtYXNrRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgbGluZUNhcEVudW1bZGF0YS5sYyB8fCAyXSk7XG4gICAgICAgIG1hc2tFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgbGluZUpvaW5FbnVtW2RhdGEubGogfHwgMl0pO1xuXG4gICAgICAgIGlmIChkYXRhLmxqID09PSAxKSB7XG4gICAgICAgICAgbWFza0VsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHJva2UtbWl0ZXJsaW1pdCcsIGRhdGEubWwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMub2YgPSBvcEZpbGw7XG4gICAgICB0aGlzLm1zID0gbWFzaztcbiAgICAgIHRoaXMub3N0ID0gc3RvcHM7XG4gICAgICB0aGlzLm1hc2tJZCA9IG1hc2tJZDtcbiAgICAgIHN0eWxlT2IubXNFbGVtID0gbWFza0VsZW1lbnQ7XG4gICAgfVxuICB9O1xuXG4gIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhKTtcblxuICBmdW5jdGlvbiBTVkdHcmFkaWVudFN0cm9rZVN0eWxlRGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKSB7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcztcbiAgICB0aGlzLncgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLncsIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMuZCA9IG5ldyBEYXNoUHJvcGVydHkoZWxlbSwgZGF0YS5kIHx8IHt9LCAnc3ZnJywgdGhpcyk7XG4gICAgdGhpcy5pbml0R3JhZGllbnREYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpO1xuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMuX2lzQW5pbWF0ZWQ7XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW1NWR0dyYWRpZW50RmlsbFN0eWxlRGF0YSwgRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU1ZHR3JhZGllbnRTdHJva2VTdHlsZURhdGEpO1xuXG4gIGZ1bmN0aW9uIFNoYXBlR3JvdXBEYXRhKCkge1xuICAgIHRoaXMuaXQgPSBbXTtcbiAgICB0aGlzLnByZXZWaWV3RGF0YSA9IFtdO1xuICAgIHRoaXMuZ3IgPSBjcmVhdGVOUygnZycpO1xuICB9XG5cbiAgZnVuY3Rpb24gU1ZHVHJhbnNmb3JtRGF0YShtUHJvcHMsIG9wLCBjb250YWluZXIpIHtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHtcbiAgICAgIG1Qcm9wczogbVByb3BzLFxuICAgICAgb3A6IG9wLFxuICAgICAgY29udGFpbmVyOiBjb250YWluZXJcbiAgICB9O1xuICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gdGhpcy50cmFuc2Zvcm0ubVByb3BzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCB8fCB0aGlzLnRyYW5zZm9ybS5vcC5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoO1xuICB9XG5cbiAgdmFyIGJ1aWxkU2hhcGVTdHJpbmcgPSBmdW5jdGlvbiBidWlsZFNoYXBlU3RyaW5nKHBhdGhOb2RlcywgbGVuZ3RoLCBjbG9zZWQsIG1hdCkge1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgX28gPSBwYXRoTm9kZXMubztcbiAgICB2YXIgX2kgPSBwYXRoTm9kZXMuaTtcbiAgICB2YXIgX3YgPSBwYXRoTm9kZXMudjtcbiAgICB2YXIgaTtcbiAgICB2YXIgc2hhcGVTdHJpbmcgPSAnIE0nICsgbWF0LmFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKF92WzBdWzBdLCBfdlswXVsxXSk7XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHNoYXBlU3RyaW5nICs9ICcgQycgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX29baSAtIDFdWzBdLCBfb1tpIC0gMV1bMV0pICsgJyAnICsgbWF0LmFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKF9pW2ldWzBdLCBfaVtpXVsxXSkgKyAnICcgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX3ZbaV1bMF0sIF92W2ldWzFdKTtcbiAgICB9XG5cbiAgICBpZiAoY2xvc2VkICYmIGxlbmd0aCkge1xuICAgICAgc2hhcGVTdHJpbmcgKz0gJyBDJyArIG1hdC5hcHBseVRvUG9pbnRTdHJpbmdpZmllZChfb1tpIC0gMV1bMF0sIF9vW2kgLSAxXVsxXSkgKyAnICcgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX2lbMF1bMF0sIF9pWzBdWzFdKSArICcgJyArIG1hdC5hcHBseVRvUG9pbnRTdHJpbmdpZmllZChfdlswXVswXSwgX3ZbMF1bMV0pO1xuICAgICAgc2hhcGVTdHJpbmcgKz0gJ3onO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFwZVN0cmluZztcbiAgfTtcblxuICB2YXIgU1ZHRWxlbWVudHNSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2lkZW50aXR5TWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuXG4gICAgdmFyIF9tYXRyaXhIZWxwZXIgPSBuZXcgTWF0cml4KCk7XG5cbiAgICB2YXIgb2IgPSB7XG4gICAgICBjcmVhdGVSZW5kZXJGdW5jdGlvbjogY3JlYXRlUmVuZGVyRnVuY3Rpb25cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVuZGVyRnVuY3Rpb24oZGF0YSkge1xuICAgICAgc3dpdGNoIChkYXRhLnR5KSB7XG4gICAgICAgIGNhc2UgJ2ZsJzpcbiAgICAgICAgICByZXR1cm4gcmVuZGVyRmlsbDtcblxuICAgICAgICBjYXNlICdnZic6XG4gICAgICAgICAgcmV0dXJuIHJlbmRlckdyYWRpZW50O1xuXG4gICAgICAgIGNhc2UgJ2dzJzpcbiAgICAgICAgICByZXR1cm4gcmVuZGVyR3JhZGllbnRTdHJva2U7XG5cbiAgICAgICAgY2FzZSAnc3QnOlxuICAgICAgICAgIHJldHVybiByZW5kZXJTdHJva2U7XG5cbiAgICAgICAgY2FzZSAnc2gnOlxuICAgICAgICBjYXNlICdlbCc6XG4gICAgICAgIGNhc2UgJ3JjJzpcbiAgICAgICAgY2FzZSAnc3InOlxuICAgICAgICAgIHJldHVybiByZW5kZXJQYXRoO1xuXG4gICAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgICByZXR1cm4gcmVuZGVyQ29udGVudFRyYW5zZm9ybTtcblxuICAgICAgICBjYXNlICdubyc6XG4gICAgICAgICAgcmV0dXJuIHJlbmRlck5vb3A7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJDb250ZW50VHJhbnNmb3JtKHN0eWxlRGF0YSwgaXRlbURhdGEsIGlzRmlyc3RGcmFtZSkge1xuICAgICAgaWYgKGlzRmlyc3RGcmFtZSB8fCBpdGVtRGF0YS50cmFuc2Zvcm0ub3AuX21kZikge1xuICAgICAgICBpdGVtRGF0YS50cmFuc2Zvcm0uY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsIGl0ZW1EYXRhLnRyYW5zZm9ybS5vcC52KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRmlyc3RGcmFtZSB8fCBpdGVtRGF0YS50cmFuc2Zvcm0ubVByb3BzLl9tZGYpIHtcbiAgICAgICAgaXRlbURhdGEudHJhbnNmb3JtLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIGl0ZW1EYXRhLnRyYW5zZm9ybS5tUHJvcHMudi50bzJkQ1NTKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlck5vb3AoKSB7fVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyUGF0aChzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBqO1xuICAgICAgdmFyIGpMZW47XG4gICAgICB2YXIgcGF0aFN0cmluZ1RyYW5zZm9ybWVkO1xuICAgICAgdmFyIHJlZHJhdztcbiAgICAgIHZhciBwYXRoTm9kZXM7XG4gICAgICB2YXIgbDtcbiAgICAgIHZhciBsTGVuID0gaXRlbURhdGEuc3R5bGVzLmxlbmd0aDtcbiAgICAgIHZhciBsdmwgPSBpdGVtRGF0YS5sdmw7XG4gICAgICB2YXIgcGF0aHM7XG4gICAgICB2YXIgbWF0O1xuICAgICAgdmFyIGl0ZXJhdGlvbnM7XG4gICAgICB2YXIgaztcblxuICAgICAgZm9yIChsID0gMDsgbCA8IGxMZW47IGwgKz0gMSkge1xuICAgICAgICByZWRyYXcgPSBpdGVtRGF0YS5zaC5fbWRmIHx8IGlzRmlyc3RGcmFtZTtcblxuICAgICAgICBpZiAoaXRlbURhdGEuc3R5bGVzW2xdLmx2bCA8IGx2bCkge1xuICAgICAgICAgIG1hdCA9IF9tYXRyaXhIZWxwZXIucmVzZXQoKTtcbiAgICAgICAgICBpdGVyYXRpb25zID0gbHZsIC0gaXRlbURhdGEuc3R5bGVzW2xdLmx2bDtcbiAgICAgICAgICBrID0gaXRlbURhdGEudHJhbnNmb3JtZXJzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICB3aGlsZSAoIXJlZHJhdyAmJiBpdGVyYXRpb25zID4gMCkge1xuICAgICAgICAgICAgcmVkcmF3ID0gaXRlbURhdGEudHJhbnNmb3JtZXJzW2tdLm1Qcm9wcy5fbWRmIHx8IHJlZHJhdztcbiAgICAgICAgICAgIGl0ZXJhdGlvbnMgLT0gMTtcbiAgICAgICAgICAgIGsgLT0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVkcmF3KSB7XG4gICAgICAgICAgICBpdGVyYXRpb25zID0gbHZsIC0gaXRlbURhdGEuc3R5bGVzW2xdLmx2bDtcbiAgICAgICAgICAgIGsgPSBpdGVtRGF0YS50cmFuc2Zvcm1lcnMubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgd2hpbGUgKGl0ZXJhdGlvbnMgPiAwKSB7XG4gICAgICAgICAgICAgIG1hdC5tdWx0aXBseShpdGVtRGF0YS50cmFuc2Zvcm1lcnNba10ubVByb3BzLnYpO1xuICAgICAgICAgICAgICBpdGVyYXRpb25zIC09IDE7XG4gICAgICAgICAgICAgIGsgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0ID0gX2lkZW50aXR5TWF0cml4O1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aHMgPSBpdGVtRGF0YS5zaC5wYXRocztcbiAgICAgICAgakxlbiA9IHBhdGhzLl9sZW5ndGg7XG5cbiAgICAgICAgaWYgKHJlZHJhdykge1xuICAgICAgICAgIHBhdGhTdHJpbmdUcmFuc2Zvcm1lZCA9ICcnO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgcGF0aE5vZGVzID0gcGF0aHMuc2hhcGVzW2pdO1xuXG4gICAgICAgICAgICBpZiAocGF0aE5vZGVzICYmIHBhdGhOb2Rlcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHBhdGhTdHJpbmdUcmFuc2Zvcm1lZCArPSBidWlsZFNoYXBlU3RyaW5nKHBhdGhOb2RlcywgcGF0aE5vZGVzLl9sZW5ndGgsIHBhdGhOb2Rlcy5jLCBtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGl0ZW1EYXRhLmNhY2hlc1tsXSA9IHBhdGhTdHJpbmdUcmFuc2Zvcm1lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoU3RyaW5nVHJhbnNmb3JtZWQgPSBpdGVtRGF0YS5jYWNoZXNbbF07XG4gICAgICAgIH1cblxuICAgICAgICBpdGVtRGF0YS5zdHlsZXNbbF0uZCArPSBzdHlsZURhdGEuaGQgPT09IHRydWUgPyAnJyA6IHBhdGhTdHJpbmdUcmFuc2Zvcm1lZDtcbiAgICAgICAgaXRlbURhdGEuc3R5bGVzW2xdLl9tZGYgPSByZWRyYXcgfHwgaXRlbURhdGEuc3R5bGVzW2xdLl9tZGY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyRmlsbChzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBzdHlsZUVsZW0gPSBpdGVtRGF0YS5zdHlsZTtcblxuICAgICAgaWYgKGl0ZW1EYXRhLmMuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdyZ2IoJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzBdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzFdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzJdKSArICcpJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtRGF0YS5vLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIGl0ZW1EYXRhLm8udik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyR3JhZGllbnRTdHJva2Uoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICByZW5kZXJHcmFkaWVudChzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpO1xuICAgICAgcmVuZGVyU3Ryb2tlKHN0eWxlRGF0YSwgaXRlbURhdGEsIGlzRmlyc3RGcmFtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyR3JhZGllbnQoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICB2YXIgZ2ZpbGwgPSBpdGVtRGF0YS5nZjtcbiAgICAgIHZhciBoYXNPcGFjaXR5ID0gaXRlbURhdGEuZy5faGFzT3BhY2l0eTtcbiAgICAgIHZhciBwdDEgPSBpdGVtRGF0YS5zLnY7XG4gICAgICB2YXIgcHQyID0gaXRlbURhdGEuZS52O1xuXG4gICAgICBpZiAoaXRlbURhdGEuby5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICB2YXIgYXR0ciA9IHN0eWxlRGF0YS50eSA9PT0gJ2dmJyA/ICdmaWxsLW9wYWNpdHknIDogJ3N0cm9rZS1vcGFjaXR5JztcbiAgICAgICAgaXRlbURhdGEuc3R5bGUucEVsZW0uc2V0QXR0cmlidXRlKGF0dHIsIGl0ZW1EYXRhLm8udik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtRGF0YS5zLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIHZhciBhdHRyMSA9IHN0eWxlRGF0YS50ID09PSAxID8gJ3gxJyA6ICdjeCc7XG4gICAgICAgIHZhciBhdHRyMiA9IGF0dHIxID09PSAneDEnID8gJ3kxJyA6ICdjeSc7XG4gICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZShhdHRyMSwgcHQxWzBdKTtcbiAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKGF0dHIyLCBwdDFbMV0pO1xuXG4gICAgICAgIGlmIChoYXNPcGFjaXR5ICYmICFpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xuICAgICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZShhdHRyMSwgcHQxWzBdKTtcbiAgICAgICAgICBpdGVtRGF0YS5vZi5zZXRBdHRyaWJ1dGUoYXR0cjIsIHB0MVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN0b3BzO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuO1xuICAgICAgdmFyIHN0b3A7XG5cbiAgICAgIGlmIChpdGVtRGF0YS5nLl9jbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICBzdG9wcyA9IGl0ZW1EYXRhLmNzdDtcbiAgICAgICAgdmFyIGNWYWx1ZXMgPSBpdGVtRGF0YS5nLmM7XG4gICAgICAgIGxlbiA9IHN0b3BzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBzdG9wID0gc3RvcHNbaV07XG4gICAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGUoJ29mZnNldCcsIGNWYWx1ZXNbaSAqIDRdICsgJyUnKTtcbiAgICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicsICdyZ2IoJyArIGNWYWx1ZXNbaSAqIDQgKyAxXSArICcsJyArIGNWYWx1ZXNbaSAqIDQgKyAyXSArICcsJyArIGNWYWx1ZXNbaSAqIDQgKyAzXSArICcpJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc09wYWNpdHkgJiYgKGl0ZW1EYXRhLmcuX29tZGYgfHwgaXNGaXJzdEZyYW1lKSkge1xuICAgICAgICB2YXIgb1ZhbHVlcyA9IGl0ZW1EYXRhLmcubztcblxuICAgICAgICBpZiAoaXRlbURhdGEuZy5fY29sbGFwc2FibGUpIHtcbiAgICAgICAgICBzdG9wcyA9IGl0ZW1EYXRhLmNzdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdG9wcyA9IGl0ZW1EYXRhLm9zdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbiA9IHN0b3BzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBzdG9wID0gc3RvcHNbaV07XG5cbiAgICAgICAgICBpZiAoIWl0ZW1EYXRhLmcuX2NvbGxhcHNhYmxlKSB7XG4gICAgICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZSgnb2Zmc2V0Jywgb1ZhbHVlc1tpICogMl0gKyAnJScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0b3Auc2V0QXR0cmlidXRlKCdzdG9wLW9wYWNpdHknLCBvVmFsdWVzW2kgKiAyICsgMV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZURhdGEudCA9PT0gMSkge1xuICAgICAgICBpZiAoaXRlbURhdGEuZS5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgneDInLCBwdDJbMF0pO1xuICAgICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgneTInLCBwdDJbMV0pO1xuXG4gICAgICAgICAgaWYgKGhhc09wYWNpdHkgJiYgIWl0ZW1EYXRhLmcuX2NvbGxhcHNhYmxlKSB7XG4gICAgICAgICAgICBpdGVtRGF0YS5vZi5zZXRBdHRyaWJ1dGUoJ3gyJywgcHQyWzBdKTtcbiAgICAgICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZSgneTInLCBwdDJbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJhZDtcblxuICAgICAgICBpZiAoaXRlbURhdGEucy5fbWRmIHx8IGl0ZW1EYXRhLmUuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgICByYWQgPSBNYXRoLnNxcnQoTWF0aC5wb3cocHQxWzBdIC0gcHQyWzBdLCAyKSArIE1hdGgucG93KHB0MVsxXSAtIHB0MlsxXSwgMikpO1xuICAgICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgncicsIHJhZCk7XG5cbiAgICAgICAgICBpZiAoaGFzT3BhY2l0eSAmJiAhaXRlbURhdGEuZy5fY29sbGFwc2FibGUpIHtcbiAgICAgICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZSgncicsIHJhZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW1EYXRhLmUuX21kZiB8fCBpdGVtRGF0YS5oLl9tZGYgfHwgaXRlbURhdGEuYS5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICAgIGlmICghcmFkKSB7XG4gICAgICAgICAgICByYWQgPSBNYXRoLnNxcnQoTWF0aC5wb3cocHQxWzBdIC0gcHQyWzBdLCAyKSArIE1hdGgucG93KHB0MVsxXSAtIHB0MlsxXSwgMikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBhbmcgPSBNYXRoLmF0YW4yKHB0MlsxXSAtIHB0MVsxXSwgcHQyWzBdIC0gcHQxWzBdKTtcbiAgICAgICAgICB2YXIgcGVyY2VudCA9IGl0ZW1EYXRhLmgudjtcblxuICAgICAgICAgIGlmIChwZXJjZW50ID49IDEpIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAwLjk5O1xuICAgICAgICAgIH0gZWxzZSBpZiAocGVyY2VudCA8PSAtMSkge1xuICAgICAgICAgICAgcGVyY2VudCA9IC0wLjk5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkaXN0ID0gcmFkICogcGVyY2VudDtcbiAgICAgICAgICB2YXIgeCA9IE1hdGguY29zKGFuZyArIGl0ZW1EYXRhLmEudikgKiBkaXN0ICsgcHQxWzBdO1xuICAgICAgICAgIHZhciB5ID0gTWF0aC5zaW4oYW5nICsgaXRlbURhdGEuYS52KSAqIGRpc3QgKyBwdDFbMV07XG4gICAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKCdmeCcsIHgpO1xuICAgICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgnZnknLCB5KTtcblxuICAgICAgICAgIGlmIChoYXNPcGFjaXR5ICYmICFpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xuICAgICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKCdmeCcsIHgpO1xuICAgICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKCdmeScsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBnZmlsbC5zZXRBdHRyaWJ1dGUoJ2Z5JywnMjAwJyk7XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJTdHJva2Uoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICB2YXIgc3R5bGVFbGVtID0gaXRlbURhdGEuc3R5bGU7XG4gICAgICB2YXIgZCA9IGl0ZW1EYXRhLmQ7XG5cbiAgICAgIGlmIChkICYmIChkLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSAmJiBkLmRhc2hTdHIpIHtcbiAgICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIGQuZGFzaFN0cik7XG4gICAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0JywgZC5kYXNob2Zmc2V0WzBdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1EYXRhLmMgJiYgKGl0ZW1EYXRhLmMuX21kZiB8fCBpc0ZpcnN0RnJhbWUpKSB7XG4gICAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdyZ2IoJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzBdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzFdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzJdKSArICcpJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtRGF0YS5vLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1vcGFjaXR5JywgaXRlbURhdGEuby52KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1EYXRhLncuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgaXRlbURhdGEudy52KTtcblxuICAgICAgICBpZiAoc3R5bGVFbGVtLm1zRWxlbSkge1xuICAgICAgICAgIHN0eWxlRWxlbS5tc0VsZW0uc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBpdGVtRGF0YS53LnYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gU1ZHU2hhcGVFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICAvLyBMaXN0IG9mIGRyYXdhYmxlIGVsZW1lbnRzXG4gICAgdGhpcy5zaGFwZXMgPSBbXTsgLy8gRnVsbCBzaGFwZSBkYXRhXG5cbiAgICB0aGlzLnNoYXBlc0RhdGEgPSBkYXRhLnNoYXBlczsgLy8gTGlzdCBvZiBzdHlsZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gc2hhcGVzXG5cbiAgICB0aGlzLnN0eWxlc0xpc3QgPSBbXTsgLy8gTGlzdCBvZiBtb2RpZmllcnMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gc2hhcGVzXG5cbiAgICB0aGlzLnNoYXBlTW9kaWZpZXJzID0gW107IC8vIExpc3Qgb2YgaXRlbXMgaW4gc2hhcGUgdHJlZVxuXG4gICAgdGhpcy5pdGVtc0RhdGEgPSBbXTsgLy8gTGlzdCBvZiBpdGVtcyBpbiBwcmV2aW91cyBzaGFwZSB0cmVlXG5cbiAgICB0aGlzLnByb2Nlc3NlZEVsZW1lbnRzID0gW107IC8vIExpc3Qgb2YgYW5pbWF0ZWQgY29tcG9uZW50c1xuXG4gICAgdGhpcy5hbmltYXRlZENvbnRlbnRzID0gW107XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTsgLy8gTW92aW5nIGFueSBwcm9wZXJ0eSB0aGF0IGRvZXNuJ3QgZ2V0IHRvbyBtdWNoIGFjY2VzcyBhZnRlciBpbml0aWFsaXphdGlvbiBiZWNhdXNlIG9mIHY4IHdheSBvZiBoYW5kbGluZyBtb3JlIHRoYW4gMTAgcHJvcGVydGllcy5cbiAgICAvLyBMaXN0IG9mIGVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIGNyZWF0ZWRcblxuICAgIHRoaXMucHJldlZpZXdEYXRhID0gW107IC8vIE1vdmluZyBhbnkgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGdldCB0b28gbXVjaCBhY2Nlc3MgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gYmVjYXVzZSBvZiB2OCB3YXkgb2YgaGFuZGxpbmcgbW9yZSB0aGFuIDEwIHByb3BlcnRpZXMuXG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBTVkdCYXNlRWxlbWVudCwgSVNoYXBlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRE9NRWxlbWVudF0sIFNWR1NoYXBlRWxlbWVudCk7XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5pbml0U2Vjb25kYXJ5RWxlbWVudCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuaWRlbnRpdHlNYXRyaXggPSBuZXcgTWF0cml4KCk7XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5idWlsZEV4cHJlc3Npb25JbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZWFyY2hTaGFwZXModGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdGhpcy5wcmV2Vmlld0RhdGEsIHRoaXMubGF5ZXJFbGVtZW50LCAwLCBbXSwgdHJ1ZSk7XG4gICAgdGhpcy5maWx0ZXJVbmlxdWVTaGFwZXMoKTtcbiAgfTtcbiAgLypcclxuICBUaGlzIG1ldGhvZCBzZWFyY2hlcyBmb3IgbXVsdGlwbGUgc2hhcGVzIHRoYXQgYWZmZWN0IGEgc2luZ2xlIGVsZW1lbnQgYW5kIG9uZSBvZiB0aGVtIGlzIGFuaW1hdGVkXHJcbiAgKi9cblxuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuZmlsdGVyVW5pcXVlU2hhcGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLnNoYXBlcy5sZW5ndGg7XG4gICAgdmFyIHNoYXBlO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuID0gdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aDtcbiAgICB2YXIgc3R5bGU7XG4gICAgdmFyIHRlbXBTaGFwZXMgPSBbXTtcbiAgICB2YXIgYXJlQW5pbWF0ZWQgPSBmYWxzZTtcblxuICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgIHN0eWxlID0gdGhpcy5zdHlsZXNMaXN0W2pdO1xuICAgICAgYXJlQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICAgIHRlbXBTaGFwZXMubGVuZ3RoID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHNoYXBlID0gdGhpcy5zaGFwZXNbaV07XG5cbiAgICAgICAgaWYgKHNoYXBlLnN0eWxlcy5pbmRleE9mKHN0eWxlKSAhPT0gLTEpIHtcbiAgICAgICAgICB0ZW1wU2hhcGVzLnB1c2goc2hhcGUpO1xuICAgICAgICAgIGFyZUFuaW1hdGVkID0gc2hhcGUuX2lzQW5pbWF0ZWQgfHwgYXJlQW5pbWF0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRlbXBTaGFwZXMubGVuZ3RoID4gMSAmJiBhcmVBbmltYXRlZCkge1xuICAgICAgICB0aGlzLnNldFNoYXBlc0FzQW5pbWF0ZWQodGVtcFNoYXBlcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuc2V0U2hhcGVzQXNBbmltYXRlZCA9IGZ1bmN0aW9uIChzaGFwZXMpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gc2hhcGVzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgc2hhcGVzW2ldLnNldEFzQW5pbWF0ZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTdHlsZUVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSwgbGV2ZWwpIHtcbiAgICAvLyBUT0RPOiBwcmV2ZW50IGRyYXdpbmcgb2YgaGlkZGVuIHN0eWxlc1xuICAgIHZhciBlbGVtZW50RGF0YTtcbiAgICB2YXIgc3R5bGVPYiA9IG5ldyBTVkdTdHlsZURhdGEoZGF0YSwgbGV2ZWwpO1xuICAgIHZhciBwYXRoRWxlbWVudCA9IHN0eWxlT2IucEVsZW07XG5cbiAgICBpZiAoZGF0YS50eSA9PT0gJ3N0Jykge1xuICAgICAgZWxlbWVudERhdGEgPSBuZXcgU1ZHU3Ryb2tlU3R5bGVEYXRhKHRoaXMsIGRhdGEsIHN0eWxlT2IpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS50eSA9PT0gJ2ZsJykge1xuICAgICAgZWxlbWVudERhdGEgPSBuZXcgU1ZHRmlsbFN0eWxlRGF0YSh0aGlzLCBkYXRhLCBzdHlsZU9iKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdnZicgfHwgZGF0YS50eSA9PT0gJ2dzJykge1xuICAgICAgdmFyIEdyYWRpZW50Q29uc3RydWN0b3IgPSBkYXRhLnR5ID09PSAnZ2YnID8gU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhIDogU1ZHR3JhZGllbnRTdHJva2VTdHlsZURhdGE7XG4gICAgICBlbGVtZW50RGF0YSA9IG5ldyBHcmFkaWVudENvbnN0cnVjdG9yKHRoaXMsIGRhdGEsIHN0eWxlT2IpO1xuICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoZWxlbWVudERhdGEuZ2YpO1xuXG4gICAgICBpZiAoZWxlbWVudERhdGEubWFza0lkKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKGVsZW1lbnREYXRhLm1zKTtcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoZWxlbWVudERhdGEub2YpO1xuICAgICAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21hc2snLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGVsZW1lbnREYXRhLm1hc2tJZCArICcpJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5ID09PSAnbm8nKSB7XG4gICAgICBlbGVtZW50RGF0YSA9IG5ldyBTVkdOb1N0eWxlRGF0YSh0aGlzLCBkYXRhLCBzdHlsZU9iKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS50eSA9PT0gJ3N0JyB8fCBkYXRhLnR5ID09PSAnZ3MnKSB7XG4gICAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgbGluZUNhcEVudW1bZGF0YS5sYyB8fCAyXSk7XG4gICAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsIGxpbmVKb2luRW51bVtkYXRhLmxqIHx8IDJdKTtcbiAgICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsbC1vcGFjaXR5JywgJzAnKTtcblxuICAgICAgaWYgKGRhdGEubGogPT09IDEpIHtcbiAgICAgICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHJva2UtbWl0ZXJsaW1pdCcsIGRhdGEubWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkYXRhLnIgPT09IDIpIHtcbiAgICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsbC1ydWxlJywgJ2V2ZW5vZGQnKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sbikge1xuICAgICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIGRhdGEubG4pO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmNsKSB7XG4gICAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgZGF0YS5jbCk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuYm0pIHtcbiAgICAgIHBhdGhFbGVtZW50LnN0eWxlWydtaXgtYmxlbmQtbW9kZSddID0gZ2V0QmxlbmRNb2RlKGRhdGEuYm0pO1xuICAgIH1cblxuICAgIHRoaXMuc3R5bGVzTGlzdC5wdXNoKHN0eWxlT2IpO1xuICAgIHRoaXMuYWRkVG9BbmltYXRlZENvbnRlbnRzKGRhdGEsIGVsZW1lbnREYXRhKTtcbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVHcm91cEVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBlbGVtZW50RGF0YSA9IG5ldyBTaGFwZUdyb3VwRGF0YSgpO1xuXG4gICAgaWYgKGRhdGEubG4pIHtcbiAgICAgIGVsZW1lbnREYXRhLmdyLnNldEF0dHJpYnV0ZSgnaWQnLCBkYXRhLmxuKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5jbCkge1xuICAgICAgZWxlbWVudERhdGEuZ3Iuc2V0QXR0cmlidXRlKCdjbGFzcycsIGRhdGEuY2wpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmJtKSB7XG4gICAgICBlbGVtZW50RGF0YS5nci5zdHlsZVsnbWl4LWJsZW5kLW1vZGUnXSA9IGdldEJsZW5kTW9kZShkYXRhLmJtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVUcmFuc2Zvcm1FbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEsIGNvbnRhaW5lcikge1xuICAgIHZhciB0cmFuc2Zvcm1Qcm9wZXJ0eSA9IFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeS5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eSh0aGlzLCBkYXRhLCB0aGlzKTtcbiAgICB2YXIgZWxlbWVudERhdGEgPSBuZXcgU1ZHVHJhbnNmb3JtRGF0YSh0cmFuc2Zvcm1Qcm9wZXJ0eSwgdHJhbnNmb3JtUHJvcGVydHkubywgY29udGFpbmVyKTtcbiAgICB0aGlzLmFkZFRvQW5pbWF0ZWRDb250ZW50cyhkYXRhLCBlbGVtZW50RGF0YSk7XG4gICAgcmV0dXJuIGVsZW1lbnREYXRhO1xuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlU2hhcGVFbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEsIG93blRyYW5zZm9ybWVycywgbGV2ZWwpIHtcbiAgICB2YXIgdHkgPSA0O1xuXG4gICAgaWYgKGRhdGEudHkgPT09ICdyYycpIHtcbiAgICAgIHR5ID0gNTtcbiAgICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdlbCcpIHtcbiAgICAgIHR5ID0gNjtcbiAgICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdzcicpIHtcbiAgICAgIHR5ID0gNztcbiAgICB9XG5cbiAgICB2YXIgc2hhcGVQcm9wZXJ0eSA9IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcCh0aGlzLCBkYXRhLCB0eSwgdGhpcyk7XG4gICAgdmFyIGVsZW1lbnREYXRhID0gbmV3IFNWR1NoYXBlRGF0YShvd25UcmFuc2Zvcm1lcnMsIGxldmVsLCBzaGFwZVByb3BlcnR5KTtcbiAgICB0aGlzLnNoYXBlcy5wdXNoKGVsZW1lbnREYXRhKTtcbiAgICB0aGlzLmFkZFNoYXBlVG9Nb2RpZmllcnMoZWxlbWVudERhdGEpO1xuICAgIHRoaXMuYWRkVG9BbmltYXRlZENvbnRlbnRzKGRhdGEsIGVsZW1lbnREYXRhKTtcbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5hZGRUb0FuaW1hdGVkQ29udGVudHMgPSBmdW5jdGlvbiAoZGF0YSwgZWxlbWVudCkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGhpcy5hbmltYXRlZENvbnRlbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAodGhpcy5hbmltYXRlZENvbnRlbnRzW2ldLmVsZW1lbnQgPT09IGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5hbmltYXRlZENvbnRlbnRzLnB1c2goe1xuICAgICAgZm46IFNWR0VsZW1lbnRzUmVuZGVyZXIuY3JlYXRlUmVuZGVyRnVuY3Rpb24oZGF0YSksXG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuc2V0RWxlbWVudFN0eWxlcyA9IGZ1bmN0aW9uIChlbGVtZW50RGF0YSkge1xuICAgIHZhciBhcnIgPSBlbGVtZW50RGF0YS5zdHlsZXM7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW4gPSB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlc0xpc3Rbal0uY2xvc2VkKSB7XG4gICAgICAgIGFyci5wdXNoKHRoaXMuc3R5bGVzTGlzdFtqXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUucmVsb2FkU2hhcGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuaXRlbXNEYXRhLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy5wcmV2Vmlld0RhdGFbaV0gPSB0aGlzLml0ZW1zRGF0YVtpXTtcbiAgICB9XG5cbiAgICB0aGlzLnNlYXJjaFNoYXBlcyh0aGlzLnNoYXBlc0RhdGEsIHRoaXMuaXRlbXNEYXRhLCB0aGlzLnByZXZWaWV3RGF0YSwgdGhpcy5sYXllckVsZW1lbnQsIDAsIFtdLCB0cnVlKTtcbiAgICB0aGlzLmZpbHRlclVuaXF1ZVNoYXBlcygpO1xuICAgIGxlbiA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLmdldFZhbHVlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJNb2RpZmllcnMoKTtcbiAgfTtcblxuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLnNlYXJjaFNoYXBlcyA9IGZ1bmN0aW9uIChhcnIsIGl0ZW1zRGF0YSwgcHJldlZpZXdEYXRhLCBjb250YWluZXIsIGxldmVsLCB0cmFuc2Zvcm1lcnMsIHJlbmRlcikge1xuICAgIHZhciBvd25UcmFuc2Zvcm1lcnMgPSBbXS5jb25jYXQodHJhbnNmb3JtZXJzKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIG93blN0eWxlcyA9IFtdO1xuICAgIHZhciBvd25Nb2RpZmllcnMgPSBbXTtcbiAgICB2YXIgY3VycmVudFRyYW5zZm9ybTtcbiAgICB2YXIgbW9kaWZpZXI7XG4gICAgdmFyIHByb2Nlc3NlZFBvcztcblxuICAgIGZvciAoaSA9IGxlbjsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIHByb2Nlc3NlZFBvcyA9IHRoaXMuc2VhcmNoUHJvY2Vzc2VkRWxlbWVudChhcnJbaV0pO1xuXG4gICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICBhcnJbaV0uX3JlbmRlciA9IHJlbmRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zRGF0YVtpXSA9IHByZXZWaWV3RGF0YVtwcm9jZXNzZWRQb3MgLSAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFycltpXS50eSA9PT0gJ2ZsJyB8fCBhcnJbaV0udHkgPT09ICdzdCcgfHwgYXJyW2ldLnR5ID09PSAnZ2YnIHx8IGFycltpXS50eSA9PT0gJ2dzJyB8fCBhcnJbaV0udHkgPT09ICdubycpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSB0aGlzLmNyZWF0ZVN0eWxlRWxlbWVudChhcnJbaV0sIGxldmVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0uc3R5bGUuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJyW2ldLl9yZW5kZXIpIHtcbiAgICAgICAgICBpZiAoaXRlbXNEYXRhW2ldLnN0eWxlLnBFbGVtLnBhcmVudE5vZGUgIT09IGNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGl0ZW1zRGF0YVtpXS5zdHlsZS5wRWxlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3duU3R5bGVzLnB1c2goaXRlbXNEYXRhW2ldLnN0eWxlKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVHcm91cEVsZW1lbnQoYXJyW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqTGVuID0gaXRlbXNEYXRhW2ldLml0Lmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGl0ZW1zRGF0YVtpXS5wcmV2Vmlld0RhdGFbal0gPSBpdGVtc0RhdGFbaV0uaXRbal07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWFyY2hTaGFwZXMoYXJyW2ldLml0LCBpdGVtc0RhdGFbaV0uaXQsIGl0ZW1zRGF0YVtpXS5wcmV2Vmlld0RhdGEsIGl0ZW1zRGF0YVtpXS5nciwgbGV2ZWwgKyAxLCBvd25UcmFuc2Zvcm1lcnMsIHJlbmRlcik7XG5cbiAgICAgICAgaWYgKGFycltpXS5fcmVuZGVyKSB7XG4gICAgICAgICAgaWYgKGl0ZW1zRGF0YVtpXS5nci5wYXJlbnROb2RlICE9PSBjb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpdGVtc0RhdGFbaV0uZ3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICd0cicpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSB0aGlzLmNyZWF0ZVRyYW5zZm9ybUVsZW1lbnQoYXJyW2ldLCBjb250YWluZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFRyYW5zZm9ybSA9IGl0ZW1zRGF0YVtpXS50cmFuc2Zvcm07XG4gICAgICAgIG93blRyYW5zZm9ybWVycy5wdXNoKGN1cnJlbnRUcmFuc2Zvcm0pO1xuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdzaCcgfHwgYXJyW2ldLnR5ID09PSAncmMnIHx8IGFycltpXS50eSA9PT0gJ2VsJyB8fCBhcnJbaV0udHkgPT09ICdzcicpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSB0aGlzLmNyZWF0ZVNoYXBlRWxlbWVudChhcnJbaV0sIG93blRyYW5zZm9ybWVycywgbGV2ZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRFbGVtZW50U3R5bGVzKGl0ZW1zRGF0YVtpXSk7XG4gICAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ3RtJyB8fCBhcnJbaV0udHkgPT09ICdyZCcgfHwgYXJyW2ldLnR5ID09PSAnbXMnIHx8IGFycltpXS50eSA9PT0gJ3BiJyB8fCBhcnJbaV0udHkgPT09ICd6eicgfHwgYXJyW2ldLnR5ID09PSAnb3AnKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgbW9kaWZpZXIgPSBTaGFwZU1vZGlmaWVycy5nZXRNb2RpZmllcihhcnJbaV0udHkpO1xuICAgICAgICAgIG1vZGlmaWVyLmluaXQodGhpcywgYXJyW2ldKTtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSBtb2RpZmllcjtcbiAgICAgICAgICB0aGlzLnNoYXBlTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGlmaWVyID0gaXRlbXNEYXRhW2ldO1xuICAgICAgICAgIG1vZGlmaWVyLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3duTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdycCcpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBtb2RpZmllciA9IFNoYXBlTW9kaWZpZXJzLmdldE1vZGlmaWVyKGFycltpXS50eSk7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gbW9kaWZpZXI7XG4gICAgICAgICAgbW9kaWZpZXIuaW5pdCh0aGlzLCBhcnIsIGksIGl0ZW1zRGF0YSk7XG4gICAgICAgICAgdGhpcy5zaGFwZU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgICAgICByZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RpZmllciA9IGl0ZW1zRGF0YVtpXTtcbiAgICAgICAgICBtb2RpZmllci5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3duTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZFByb2Nlc3NlZEVsZW1lbnQoYXJyW2ldLCBpICsgMSk7XG4gICAgfVxuXG4gICAgbGVuID0gb3duU3R5bGVzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgb3duU3R5bGVzW2ldLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgbGVuID0gb3duTW9kaWZpZXJzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgb3duTW9kaWZpZXJzW2ldLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVuZGVyTW9kaWZpZXJzKCk7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc3R5bGVzTGlzdC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS5yZXNldCgpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyU2hhcGUoKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMuc3R5bGVzTGlzdFtpXS5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZXNMaXN0W2ldLm1zRWxlbSkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS5tc0VsZW0uc2V0QXR0cmlidXRlKCdkJywgdGhpcy5zdHlsZXNMaXN0W2ldLmQpOyAvLyBBZGRpbmcgTTAgMCBmaXhlcyBzYW1lIG1hc2sgYnVnIG9uIGFsbCBicm93c2Vyc1xuXG4gICAgICAgICAgdGhpcy5zdHlsZXNMaXN0W2ldLmQgPSAnTTAgMCcgKyB0aGlzLnN0eWxlc0xpc3RbaV0uZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLnN0eWxlc0xpc3RbaV0uZCB8fCAnTTAgMCcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlclNoYXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmFuaW1hdGVkQ29udGVudHMubGVuZ3RoO1xuICAgIHZhciBhbmltYXRlZENvbnRlbnQ7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGFuaW1hdGVkQ29udGVudCA9IHRoaXMuYW5pbWF0ZWRDb250ZW50c1tpXTtcblxuICAgICAgaWYgKCh0aGlzLl9pc0ZpcnN0RnJhbWUgfHwgYW5pbWF0ZWRDb250ZW50LmVsZW1lbnQuX2lzQW5pbWF0ZWQpICYmIGFuaW1hdGVkQ29udGVudC5kYXRhICE9PSB0cnVlKSB7XG4gICAgICAgIGFuaW1hdGVkQ29udGVudC5mbihhbmltYXRlZENvbnRlbnQuZGF0YSwgYW5pbWF0ZWRDb250ZW50LmVsZW1lbnQsIHRoaXMuX2lzRmlyc3RGcmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlc3Ryb3lCYXNlRWxlbWVudCgpO1xuICAgIHRoaXMuc2hhcGVzRGF0YSA9IG51bGw7XG4gICAgdGhpcy5pdGVtc0RhdGEgPSBudWxsO1xuICB9O1xuXG4gIGZ1bmN0aW9uIExldHRlclByb3BzKG8sIHN3LCBzYywgZmMsIG0sIHApIHtcbiAgICB0aGlzLm8gPSBvO1xuICAgIHRoaXMuc3cgPSBzdztcbiAgICB0aGlzLnNjID0gc2M7XG4gICAgdGhpcy5mYyA9IGZjO1xuICAgIHRoaXMubSA9IG07XG4gICAgdGhpcy5wID0gcDtcbiAgICB0aGlzLl9tZGYgPSB7XG4gICAgICBvOiB0cnVlLFxuICAgICAgc3c6ICEhc3csXG4gICAgICBzYzogISFzYyxcbiAgICAgIGZjOiAhIWZjLFxuICAgICAgbTogdHJ1ZSxcbiAgICAgIHA6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgTGV0dGVyUHJvcHMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChvLCBzdywgc2MsIGZjLCBtLCBwKSB7XG4gICAgdGhpcy5fbWRmLm8gPSBmYWxzZTtcbiAgICB0aGlzLl9tZGYuc3cgPSBmYWxzZTtcbiAgICB0aGlzLl9tZGYuc2MgPSBmYWxzZTtcbiAgICB0aGlzLl9tZGYuZmMgPSBmYWxzZTtcbiAgICB0aGlzLl9tZGYubSA9IGZhbHNlO1xuICAgIHRoaXMuX21kZi5wID0gZmFsc2U7XG4gICAgdmFyIHVwZGF0ZWQgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLm8gIT09IG8pIHtcbiAgICAgIHRoaXMubyA9IG87XG4gICAgICB0aGlzLl9tZGYubyA9IHRydWU7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdyAhPT0gc3cpIHtcbiAgICAgIHRoaXMuc3cgPSBzdztcbiAgICAgIHRoaXMuX21kZi5zdyA9IHRydWU7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zYyAhPT0gc2MpIHtcbiAgICAgIHRoaXMuc2MgPSBzYztcbiAgICAgIHRoaXMuX21kZi5zYyA9IHRydWU7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mYyAhPT0gZmMpIHtcbiAgICAgIHRoaXMuZmMgPSBmYztcbiAgICAgIHRoaXMuX21kZi5mYyA9IHRydWU7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tICE9PSBtKSB7XG4gICAgICB0aGlzLm0gPSBtO1xuICAgICAgdGhpcy5fbWRmLm0gPSB0cnVlO1xuICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHAubGVuZ3RoICYmICh0aGlzLnBbMF0gIT09IHBbMF0gfHwgdGhpcy5wWzFdICE9PSBwWzFdIHx8IHRoaXMucFs0XSAhPT0gcFs0XSB8fCB0aGlzLnBbNV0gIT09IHBbNV0gfHwgdGhpcy5wWzEyXSAhPT0gcFsxMl0gfHwgdGhpcy5wWzEzXSAhPT0gcFsxM10pKSB7XG4gICAgICB0aGlzLnAgPSBwO1xuICAgICAgdGhpcy5fbWRmLnAgPSB0cnVlO1xuICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gVGV4dFByb3BlcnR5KGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLl9mcmFtZUlkID0gaW5pdGlhbERlZmF1bHRGcmFtZTtcbiAgICB0aGlzLnB2ID0gJyc7XG4gICAgdGhpcy52ID0gJyc7XG4gICAgdGhpcy5rZiA9IGZhbHNlO1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG5cbiAgICBpZiAoZGF0YS5kICYmIGRhdGEuZC5zaWQpIHtcbiAgICAgIGRhdGEuZCA9IGVsZW0uZ2xvYmFsRGF0YS5zbG90TWFuYWdlci5nZXRQcm9wKGRhdGEuZCk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMuY29tcCA9IHRoaXMuZWxlbS5jb21wO1xuICAgIHRoaXMua2V5c0luZGV4ID0gMDtcbiAgICB0aGlzLmNhblJlc2l6ZSA9IGZhbHNlO1xuICAgIHRoaXMubWluaW11bUZvbnRTaXplID0gMTtcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtdO1xuICAgIHRoaXMuY3VycmVudERhdGEgPSB7XG4gICAgICBhc2NlbnQ6IDAsXG4gICAgICBib3hXaWR0aDogdGhpcy5kZWZhdWx0Qm94V2lkdGgsXG4gICAgICBmOiAnJyxcbiAgICAgIGZTdHlsZTogJycsXG4gICAgICBmV2VpZ2h0OiAnJyxcbiAgICAgIGZjOiAnJyxcbiAgICAgIGo6ICcnLFxuICAgICAganVzdGlmeU9mZnNldDogJycsXG4gICAgICBsOiBbXSxcbiAgICAgIGxoOiAwLFxuICAgICAgbGluZVdpZHRoczogW10sXG4gICAgICBsczogJycsXG4gICAgICBvZjogJycsXG4gICAgICBzOiAnJyxcbiAgICAgIHNjOiAnJyxcbiAgICAgIHN3OiAwLFxuICAgICAgdDogMCxcbiAgICAgIHRyOiAwLFxuICAgICAgc3o6IDAsXG4gICAgICBwczogbnVsbCxcbiAgICAgIGZpbGxDb2xvckFuaW06IGZhbHNlLFxuICAgICAgc3Ryb2tlQ29sb3JBbmltOiBmYWxzZSxcbiAgICAgIHN0cm9rZVdpZHRoQW5pbTogZmFsc2UsXG4gICAgICB5T2Zmc2V0OiAwLFxuICAgICAgZmluYWxTaXplOiAwLFxuICAgICAgZmluYWxUZXh0OiBbXSxcbiAgICAgIGZpbmFsTGluZUhlaWdodDogMCxcbiAgICAgIF9fY29tcGxldGU6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLmNvcHlEYXRhKHRoaXMuY3VycmVudERhdGEsIHRoaXMuZGF0YS5kLmtbMF0ucyk7XG5cbiAgICBpZiAoIXRoaXMuc2VhcmNoUHJvcGVydHkoKSkge1xuICAgICAgdGhpcy5jb21wbGV0ZVRleHREYXRhKHRoaXMuY3VycmVudERhdGEpO1xuICAgIH1cbiAgfVxuXG4gIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuZGVmYXVsdEJveFdpZHRoID0gWzAsIDBdO1xuXG4gIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuY29weURhdGEgPSBmdW5jdGlvbiAob2JqLCBkYXRhKSB7XG4gICAgZm9yICh2YXIgcyBpbiBkYXRhKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIHMpKSB7XG4gICAgICAgIG9ialtzXSA9IGRhdGFbc107XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLnNldEN1cnJlbnREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEuX19jb21wbGV0ZSkge1xuICAgICAgdGhpcy5jb21wbGV0ZVRleHREYXRhKGRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudERhdGEgPSBkYXRhO1xuICAgIHRoaXMuY3VycmVudERhdGEuYm94V2lkdGggPSB0aGlzLmN1cnJlbnREYXRhLmJveFdpZHRoIHx8IHRoaXMuZGVmYXVsdEJveFdpZHRoO1xuICAgIHRoaXMuX21kZiA9IHRydWU7XG4gIH07XG5cbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5zZWFyY2hQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWFyY2hLZXlmcmFtZXMoKTtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLnNlYXJjaEtleWZyYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmtmID0gdGhpcy5kYXRhLmQuay5sZW5ndGggPiAxO1xuXG4gICAgaWYgKHRoaXMua2YpIHtcbiAgICAgIHRoaXMuYWRkRWZmZWN0KHRoaXMuZ2V0S2V5ZnJhbWVWYWx1ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5rZjtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLmFkZEVmZmVjdCA9IGZ1bmN0aW9uIChlZmZlY3RGdW5jdGlvbikge1xuICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlLnB1c2goZWZmZWN0RnVuY3Rpb24pO1xuICAgIHRoaXMuZWxlbS5hZGREeW5hbWljUHJvcGVydHkodGhpcyk7XG4gIH07XG5cbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChfZmluYWxWYWx1ZSkge1xuICAgIGlmICgodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkIHx8ICF0aGlzLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGgpICYmICFfZmluYWxWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudERhdGEudCA9IHRoaXMuZGF0YS5kLmtbdGhpcy5rZXlzSW5kZXhdLnMudDtcbiAgICB2YXIgY3VycmVudFZhbHVlID0gdGhpcy5jdXJyZW50RGF0YTtcbiAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5rZXlzSW5kZXg7XG5cbiAgICBpZiAodGhpcy5sb2NrKSB7XG4gICAgICB0aGlzLnNldEN1cnJlbnREYXRhKHRoaXMuY3VycmVudERhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubG9jayA9IHRydWU7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcbiAgICB2YXIgZmluYWxWYWx1ZSA9IF9maW5hbFZhbHVlIHx8IHRoaXMuZGF0YS5kLmtbdGhpcy5rZXlzSW5kZXhdLnM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIC8vIENoZWNraW5nIGlmIGluZGV4IGNoYW5nZWQgdG8gcHJldmVudCBjcmVhdGluZyBhIG5ldyBvYmplY3QgZXZlcnkgdGltZSB0aGUgZXhwcmVzc2lvbiB1cGRhdGVzLlxuICAgICAgaWYgKGN1cnJlbnRJbmRleCAhPT0gdGhpcy5rZXlzSW5kZXgpIHtcbiAgICAgICAgZmluYWxWYWx1ZSA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlW2ldKGZpbmFsVmFsdWUsIGZpbmFsVmFsdWUudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5hbFZhbHVlID0gdGhpcy5lZmZlY3RzU2VxdWVuY2VbaV0odGhpcy5jdXJyZW50RGF0YSwgZmluYWxWYWx1ZS50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFZhbHVlICE9PSBmaW5hbFZhbHVlKSB7XG4gICAgICB0aGlzLnNldEN1cnJlbnREYXRhKGZpbmFsVmFsdWUpO1xuICAgIH1cblxuICAgIHRoaXMudiA9IHRoaXMuY3VycmVudERhdGE7XG4gICAgdGhpcy5wdiA9IHRoaXMudjtcbiAgICB0aGlzLmxvY2sgPSBmYWxzZTtcbiAgICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xuICB9O1xuXG4gIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0S2V5ZnJhbWVWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGV4dEtleXMgPSB0aGlzLmRhdGEuZC5rO1xuICAgIHZhciBmcmFtZU51bSA9IHRoaXMuZWxlbS5jb21wLnJlbmRlcmVkRnJhbWU7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0ZXh0S2V5cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA8PSBsZW4gLSAxKSB7XG4gICAgICBpZiAoaSA9PT0gbGVuIC0gMSB8fCB0ZXh0S2V5c1tpICsgMV0udCA+IGZyYW1lTnVtKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMua2V5c0luZGV4ICE9PSBpKSB7XG4gICAgICB0aGlzLmtleXNJbmRleCA9IGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kLmtbdGhpcy5rZXlzSW5kZXhdLnM7XG4gIH07XG5cbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5idWlsZEZpbmFsVGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdmFyIGNoYXJhY3RlcnNBcnJheSA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGV4dC5sZW5ndGg7XG4gICAgdmFyIGNoYXJDb2RlO1xuICAgIHZhciBzZWNvbmRDaGFyQ29kZTtcbiAgICB2YXIgc2hvdWxkQ29tYmluZSA9IGZhbHNlO1xuICAgIHZhciBzaG91bGRDb21iaW5lTmV4dCA9IGZhbHNlO1xuICAgIHZhciBjdXJyZW50Q2hhcnMgPSAnJztcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBzaG91bGRDb21iaW5lID0gc2hvdWxkQ29tYmluZU5leHQ7XG4gICAgICBzaG91bGRDb21iaW5lTmV4dCA9IGZhbHNlO1xuICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICBjdXJyZW50Q2hhcnMgPSB0ZXh0LmNoYXJBdChpKTtcblxuICAgICAgaWYgKEZvbnRNYW5hZ2VyLmlzQ29tYmluZWRDaGFyYWN0ZXIoY2hhckNvZGUpKSB7XG4gICAgICAgIHNob3VsZENvbWJpbmUgPSB0cnVlOyAvLyBJdCdzIGEgcG90ZW50aWFsIHN1cnJvZ2F0ZSBwYWlyICh0aGlzIGlzIHRoZSBIaWdoIHN1cnJvZ2F0ZSlcbiAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgICBpZiAoRm9udE1hbmFnZXIuaXNSZWdpb25hbEZsYWcodGV4dCwgaSkpIHtcbiAgICAgICAgICBjdXJyZW50Q2hhcnMgPSB0ZXh0LnN1YnN0cihpLCAxNCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2Vjb25kQ2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpOyAvLyBJdCdzIGEgc3Vycm9nYXRlIHBhaXIgKHRoaXMgaXMgdGhlIExvdyBzdXJyb2dhdGUpXG5cbiAgICAgICAgICBpZiAoc2Vjb25kQ2hhckNvZGUgPj0gMHhEQzAwICYmIHNlY29uZENoYXJDb2RlIDw9IDB4REZGRikge1xuICAgICAgICAgICAgaWYgKEZvbnRNYW5hZ2VyLmlzTW9kaWZpZXIoY2hhckNvZGUsIHNlY29uZENoYXJDb2RlKSkge1xuICAgICAgICAgICAgICBjdXJyZW50Q2hhcnMgPSB0ZXh0LnN1YnN0cihpLCAyKTtcbiAgICAgICAgICAgICAgc2hvdWxkQ29tYmluZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEZvbnRNYW5hZ2VyLmlzRmxhZ0Vtb2ppKHRleHQuc3Vic3RyKGksIDQpKSkge1xuICAgICAgICAgICAgICBjdXJyZW50Q2hhcnMgPSB0ZXh0LnN1YnN0cihpLCA0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRDaGFycyA9IHRleHQuc3Vic3RyKGksIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA+IDB4REJGRikge1xuICAgICAgICBzZWNvbmRDaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpICsgMSk7XG5cbiAgICAgICAgaWYgKEZvbnRNYW5hZ2VyLmlzVmFyaWF0aW9uU2VsZWN0b3IoY2hhckNvZGUpKSB7XG4gICAgICAgICAgc2hvdWxkQ29tYmluZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoRm9udE1hbmFnZXIuaXNaZXJvV2lkdGhKb2luZXIoY2hhckNvZGUpKSB7XG4gICAgICAgIHNob3VsZENvbWJpbmUgPSB0cnVlO1xuICAgICAgICBzaG91bGRDb21iaW5lTmV4dCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRDb21iaW5lKSB7XG4gICAgICAgIGNoYXJhY3RlcnNBcnJheVtjaGFyYWN0ZXJzQXJyYXkubGVuZ3RoIC0gMV0gKz0gY3VycmVudENoYXJzO1xuICAgICAgICBzaG91bGRDb21iaW5lID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGFyYWN0ZXJzQXJyYXkucHVzaChjdXJyZW50Q2hhcnMpO1xuICAgICAgfVxuXG4gICAgICBpICs9IGN1cnJlbnRDaGFycy5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYXJhY3RlcnNBcnJheTtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLmNvbXBsZXRlVGV4dERhdGEgPSBmdW5jdGlvbiAoZG9jdW1lbnREYXRhKSB7XG4gICAgZG9jdW1lbnREYXRhLl9fY29tcGxldGUgPSB0cnVlO1xuICAgIHZhciBmb250TWFuYWdlciA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBsZXR0ZXJzID0gW107XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcbiAgICB2YXIgbmV3TGluZUZsYWc7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgdmFsO1xuICAgIHZhciBhbmNob3JHcm91cGluZyA9IGRhdGEubS5nO1xuICAgIHZhciBjdXJyZW50U2l6ZSA9IDA7XG4gICAgdmFyIGN1cnJlbnRQb3MgPSAwO1xuICAgIHZhciBjdXJyZW50TGluZSA9IDA7XG4gICAgdmFyIGxpbmVXaWR0aHMgPSBbXTtcbiAgICB2YXIgbGluZVdpZHRoID0gMDtcbiAgICB2YXIgbWF4TGluZVdpZHRoID0gMDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgZm9udERhdGEgPSBmb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKTtcbiAgICB2YXIgY2hhckRhdGE7XG4gICAgdmFyIGNMZW5ndGggPSAwO1xuICAgIHZhciBmb250UHJvcHMgPSBnZXRGb250UHJvcGVydGllcyhmb250RGF0YSk7XG4gICAgZG9jdW1lbnREYXRhLmZXZWlnaHQgPSBmb250UHJvcHMud2VpZ2h0O1xuICAgIGRvY3VtZW50RGF0YS5mU3R5bGUgPSBmb250UHJvcHMuc3R5bGU7XG4gICAgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSA9IGRvY3VtZW50RGF0YS5zO1xuICAgIGRvY3VtZW50RGF0YS5maW5hbFRleHQgPSB0aGlzLmJ1aWxkRmluYWxUZXh0KGRvY3VtZW50RGF0YS50KTtcbiAgICBsZW4gPSBkb2N1bWVudERhdGEuZmluYWxUZXh0Lmxlbmd0aDtcbiAgICBkb2N1bWVudERhdGEuZmluYWxMaW5lSGVpZ2h0ID0gZG9jdW1lbnREYXRhLmxoO1xuICAgIHZhciB0cmFja2luZ09mZnNldCA9IGRvY3VtZW50RGF0YS50ciAvIDEwMDAgKiBkb2N1bWVudERhdGEuZmluYWxTaXplO1xuICAgIHZhciBjaGFyQ29kZTtcblxuICAgIGlmIChkb2N1bWVudERhdGEuc3opIHtcbiAgICAgIHZhciBmbGFnID0gdHJ1ZTtcbiAgICAgIHZhciBib3hXaWR0aCA9IGRvY3VtZW50RGF0YS5zelswXTtcbiAgICAgIHZhciBib3hIZWlnaHQgPSBkb2N1bWVudERhdGEuc3pbMV07XG4gICAgICB2YXIgY3VycmVudEhlaWdodDtcbiAgICAgIHZhciBmaW5hbFRleHQ7XG5cbiAgICAgIHdoaWxlIChmbGFnKSB7XG4gICAgICAgIGZpbmFsVGV4dCA9IHRoaXMuYnVpbGRGaW5hbFRleHQoZG9jdW1lbnREYXRhLnQpO1xuICAgICAgICBjdXJyZW50SGVpZ2h0ID0gMDtcbiAgICAgICAgbGluZVdpZHRoID0gMDtcbiAgICAgICAgbGVuID0gZmluYWxUZXh0Lmxlbmd0aDtcbiAgICAgICAgdHJhY2tpbmdPZmZzZXQgPSBkb2N1bWVudERhdGEudHIgLyAxMDAwICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcbiAgICAgICAgdmFyIGxhc3RTcGFjZUluZGV4ID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgY2hhckNvZGUgPSBmaW5hbFRleHRbaV0uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBuZXdMaW5lRmxhZyA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKGZpbmFsVGV4dFtpXSA9PT0gJyAnKSB7XG4gICAgICAgICAgICBsYXN0U3BhY2VJbmRleCA9IGk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PT0gMTMgfHwgY2hhckNvZGUgPT09IDMpIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IDA7XG4gICAgICAgICAgICBuZXdMaW5lRmxhZyA9IHRydWU7XG4gICAgICAgICAgICBjdXJyZW50SGVpZ2h0ICs9IGRvY3VtZW50RGF0YS5maW5hbExpbmVIZWlnaHQgfHwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAqIDEuMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZm9udE1hbmFnZXIuY2hhcnMpIHtcbiAgICAgICAgICAgIGNoYXJEYXRhID0gZm9udE1hbmFnZXIuZ2V0Q2hhckRhdGEoZmluYWxUZXh0W2ldLCBmb250RGF0YS5mU3R5bGUsIGZvbnREYXRhLmZGYW1pbHkpO1xuICAgICAgICAgICAgY0xlbmd0aCA9IG5ld0xpbmVGbGFnID8gMCA6IGNoYXJEYXRhLncgKiBkb2N1bWVudERhdGEuZmluYWxTaXplIC8gMTAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0Q2FudmFzSGVscGVyLmZvbnQgPSBkb2N1bWVudERhdGEucyArICdweCAnKyBmb250RGF0YS5mRmFtaWx5O1xuICAgICAgICAgICAgY0xlbmd0aCA9IGZvbnRNYW5hZ2VyLm1lYXN1cmVUZXh0KGZpbmFsVGV4dFtpXSwgZG9jdW1lbnREYXRhLmYsIGRvY3VtZW50RGF0YS5maW5hbFNpemUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsaW5lV2lkdGggKyBjTGVuZ3RoID4gYm94V2lkdGggJiYgZmluYWxUZXh0W2ldICE9PSAnICcpIHtcbiAgICAgICAgICAgIGlmIChsYXN0U3BhY2VJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgbGVuICs9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpID0gbGFzdFNwYWNlSW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRIZWlnaHQgKz0gZG9jdW1lbnREYXRhLmZpbmFsTGluZUhlaWdodCB8fCBkb2N1bWVudERhdGEuZmluYWxTaXplICogMS4yO1xuICAgICAgICAgICAgZmluYWxUZXh0LnNwbGljZShpLCBsYXN0U3BhY2VJbmRleCA9PT0gaSA/IDEgOiAwLCAnXFxyJyk7IC8vIGZpbmFsVGV4dCA9IGZpbmFsVGV4dC5zdWJzdHIoMCxpKSArIFwiXFxyXCIgKyBmaW5hbFRleHQuc3Vic3RyKGkgPT09IGxhc3RTcGFjZUluZGV4ID8gaSArIDEgOiBpKTtcblxuICAgICAgICAgICAgbGFzdFNwYWNlSW5kZXggPSAtMTtcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aCArPSBjTGVuZ3RoO1xuICAgICAgICAgICAgbGluZVdpZHRoICs9IHRyYWNraW5nT2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRIZWlnaHQgKz0gZm9udERhdGEuYXNjZW50ICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMDtcblxuICAgICAgICBpZiAodGhpcy5jYW5SZXNpemUgJiYgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSA+IHRoaXMubWluaW11bUZvbnRTaXplICYmIGJveEhlaWdodCA8IGN1cnJlbnRIZWlnaHQpIHtcbiAgICAgICAgICBkb2N1bWVudERhdGEuZmluYWxTaXplIC09IDE7XG4gICAgICAgICAgZG9jdW1lbnREYXRhLmZpbmFsTGluZUhlaWdodCA9IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKiBkb2N1bWVudERhdGEubGggLyBkb2N1bWVudERhdGEucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb2N1bWVudERhdGEuZmluYWxUZXh0ID0gZmluYWxUZXh0O1xuICAgICAgICAgIGxlbiA9IGRvY3VtZW50RGF0YS5maW5hbFRleHQubGVuZ3RoO1xuICAgICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxpbmVXaWR0aCA9IC10cmFja2luZ09mZnNldDtcbiAgICBjTGVuZ3RoID0gMDtcbiAgICB2YXIgdW5jb2xsYXBzZWRTcGFjZXMgPSAwO1xuICAgIHZhciBjdXJyZW50Q2hhcjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgbmV3TGluZUZsYWcgPSBmYWxzZTtcbiAgICAgIGN1cnJlbnRDaGFyID0gZG9jdW1lbnREYXRhLmZpbmFsVGV4dFtpXTtcbiAgICAgIGNoYXJDb2RlID0gY3VycmVudENoYXIuY2hhckNvZGVBdCgwKTtcblxuICAgICAgaWYgKGNoYXJDb2RlID09PSAxMyB8fCBjaGFyQ29kZSA9PT0gMykge1xuICAgICAgICB1bmNvbGxhcHNlZFNwYWNlcyA9IDA7XG4gICAgICAgIGxpbmVXaWR0aHMucHVzaChsaW5lV2lkdGgpO1xuICAgICAgICBtYXhMaW5lV2lkdGggPSBsaW5lV2lkdGggPiBtYXhMaW5lV2lkdGggPyBsaW5lV2lkdGggOiBtYXhMaW5lV2lkdGg7XG4gICAgICAgIGxpbmVXaWR0aCA9IC0yICogdHJhY2tpbmdPZmZzZXQ7XG4gICAgICAgIHZhbCA9ICcnO1xuICAgICAgICBuZXdMaW5lRmxhZyA9IHRydWU7XG4gICAgICAgIGN1cnJlbnRMaW5lICs9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBjdXJyZW50Q2hhcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvbnRNYW5hZ2VyLmNoYXJzKSB7XG4gICAgICAgIGNoYXJEYXRhID0gZm9udE1hbmFnZXIuZ2V0Q2hhckRhdGEoY3VycmVudENoYXIsIGZvbnREYXRhLmZTdHlsZSwgZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZikuZkZhbWlseSk7XG4gICAgICAgIGNMZW5ndGggPSBuZXdMaW5lRmxhZyA/IDAgOiBjaGFyRGF0YS53ICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHZhciBjaGFyV2lkdGggPSBmb250TWFuYWdlci5tZWFzdXJlVGV4dCh2YWwsIGRvY3VtZW50RGF0YS5mLCBkb2N1bWVudERhdGEuZmluYWxTaXplKTtcbiAgICAgICAgLy8gdENhbnZhc0hlbHBlci5mb250ID0gZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSArICdweCAnKyBmb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5O1xuICAgICAgICBjTGVuZ3RoID0gZm9udE1hbmFnZXIubWVhc3VyZVRleHQodmFsLCBkb2N1bWVudERhdGEuZiwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSk7XG4gICAgICB9IC8vXG5cblxuICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnICcpIHtcbiAgICAgICAgdW5jb2xsYXBzZWRTcGFjZXMgKz0gY0xlbmd0aCArIHRyYWNraW5nT2Zmc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZVdpZHRoICs9IGNMZW5ndGggKyB0cmFja2luZ09mZnNldCArIHVuY29sbGFwc2VkU3BhY2VzO1xuICAgICAgICB1bmNvbGxhcHNlZFNwYWNlcyA9IDA7XG4gICAgICB9XG5cbiAgICAgIGxldHRlcnMucHVzaCh7XG4gICAgICAgIGw6IGNMZW5ndGgsXG4gICAgICAgIGFuOiBjTGVuZ3RoLFxuICAgICAgICBhZGQ6IGN1cnJlbnRTaXplLFxuICAgICAgICBuOiBuZXdMaW5lRmxhZyxcbiAgICAgICAgYW5JbmRleGVzOiBbXSxcbiAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgIGxpbmU6IGN1cnJlbnRMaW5lLFxuICAgICAgICBhbmltYXRvckp1c3RpZnlPZmZzZXQ6IDBcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYW5jaG9yR3JvdXBpbmcgPT0gMikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgICBjdXJyZW50U2l6ZSArPSBjTGVuZ3RoO1xuXG4gICAgICAgIGlmICh2YWwgPT09ICcnIHx8IHZhbCA9PT0gJyAnIHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICBpZiAodmFsID09PSAnJyB8fCB2YWwgPT09ICcgJykge1xuICAgICAgICAgICAgY3VycmVudFNpemUgLT0gY0xlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAoY3VycmVudFBvcyA8PSBpKSB7XG4gICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmFuID0gY3VycmVudFNpemU7XG4gICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmluZCA9IGluZGV4O1xuICAgICAgICAgICAgbGV0dGVyc1tjdXJyZW50UG9zXS5leHRyYSA9IGNMZW5ndGg7XG4gICAgICAgICAgICBjdXJyZW50UG9zICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICBjdXJyZW50U2l6ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYW5jaG9yR3JvdXBpbmcgPT0gMykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgICBjdXJyZW50U2l6ZSArPSBjTGVuZ3RoO1xuXG4gICAgICAgIGlmICh2YWwgPT09ICcnIHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICBpZiAodmFsID09PSAnJykge1xuICAgICAgICAgICAgY3VycmVudFNpemUgLT0gY0xlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAoY3VycmVudFBvcyA8PSBpKSB7XG4gICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmFuID0gY3VycmVudFNpemU7XG4gICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmluZCA9IGluZGV4O1xuICAgICAgICAgICAgbGV0dGVyc1tjdXJyZW50UG9zXS5leHRyYSA9IGNMZW5ndGg7XG4gICAgICAgICAgICBjdXJyZW50UG9zICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFNpemUgPSAwO1xuICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldHRlcnNbaW5kZXhdLmluZCA9IGluZGV4O1xuICAgICAgICBsZXR0ZXJzW2luZGV4XS5leHRyYSA9IDA7XG4gICAgICAgIGluZGV4ICs9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZG9jdW1lbnREYXRhLmwgPSBsZXR0ZXJzO1xuICAgIG1heExpbmVXaWR0aCA9IGxpbmVXaWR0aCA+IG1heExpbmVXaWR0aCA/IGxpbmVXaWR0aCA6IG1heExpbmVXaWR0aDtcbiAgICBsaW5lV2lkdGhzLnB1c2gobGluZVdpZHRoKTtcblxuICAgIGlmIChkb2N1bWVudERhdGEuc3opIHtcbiAgICAgIGRvY3VtZW50RGF0YS5ib3hXaWR0aCA9IGRvY3VtZW50RGF0YS5zelswXTtcbiAgICAgIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnREYXRhLmJveFdpZHRoID0gbWF4TGluZVdpZHRoO1xuXG4gICAgICBzd2l0Y2ggKGRvY3VtZW50RGF0YS5qKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCA9IC1kb2N1bWVudERhdGEuYm94V2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ID0gLWRvY3VtZW50RGF0YS5ib3hXaWR0aCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZG9jdW1lbnREYXRhLmxpbmVXaWR0aHMgPSBsaW5lV2lkdGhzO1xuICAgIHZhciBhbmltYXRvcnMgPSBkYXRhLmE7XG4gICAgdmFyIGFuaW1hdG9yRGF0YTtcbiAgICB2YXIgbGV0dGVyRGF0YTtcbiAgICBqTGVuID0gYW5pbWF0b3JzLmxlbmd0aDtcbiAgICB2YXIgYmFzZWQ7XG4gICAgdmFyIGluZDtcbiAgICB2YXIgaW5kZXhlcyA9IFtdO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgYW5pbWF0b3JEYXRhID0gYW5pbWF0b3JzW2pdO1xuXG4gICAgICBpZiAoYW5pbWF0b3JEYXRhLmEuc2MpIHtcbiAgICAgICAgZG9jdW1lbnREYXRhLnN0cm9rZUNvbG9yQW5pbSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmltYXRvckRhdGEuYS5zdykge1xuICAgICAgICBkb2N1bWVudERhdGEuc3Ryb2tlV2lkdGhBbmltID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFuaW1hdG9yRGF0YS5hLmZjIHx8IGFuaW1hdG9yRGF0YS5hLmZoIHx8IGFuaW1hdG9yRGF0YS5hLmZzIHx8IGFuaW1hdG9yRGF0YS5hLmZiKSB7XG4gICAgICAgIGRvY3VtZW50RGF0YS5maWxsQ29sb3JBbmltID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaW5kID0gMDtcbiAgICAgIGJhc2VkID0gYW5pbWF0b3JEYXRhLnMuYjtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGxldHRlckRhdGEgPSBsZXR0ZXJzW2ldO1xuICAgICAgICBsZXR0ZXJEYXRhLmFuSW5kZXhlc1tqXSA9IGluZDtcblxuICAgICAgICBpZiAoYmFzZWQgPT0gMSAmJiBsZXR0ZXJEYXRhLnZhbCAhPT0gJycgfHwgYmFzZWQgPT0gMiAmJiBsZXR0ZXJEYXRhLnZhbCAhPT0gJycgJiYgbGV0dGVyRGF0YS52YWwgIT09ICcgJyB8fCBiYXNlZCA9PSAzICYmIChsZXR0ZXJEYXRhLm4gfHwgbGV0dGVyRGF0YS52YWwgPT0gJyAnIHx8IGkgPT0gbGVuIC0gMSkgfHwgYmFzZWQgPT0gNCAmJiAobGV0dGVyRGF0YS5uIHx8IGkgPT0gbGVuIC0gMSkpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgICAgIGlmIChhbmltYXRvckRhdGEucy5ybiA9PT0gMSkge1xuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGluZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5kICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGF0YS5hW2pdLnMudG90YWxDaGFycyA9IGluZDtcbiAgICAgIHZhciBjdXJyZW50SW5kID0gLTE7XG4gICAgICB2YXIgbmV3SW5kO1xuXG4gICAgICBpZiAoYW5pbWF0b3JEYXRhLnMucm4gPT09IDEpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgbGV0dGVyRGF0YSA9IGxldHRlcnNbaV07XG5cbiAgICAgICAgICBpZiAoY3VycmVudEluZCAhPSBsZXR0ZXJEYXRhLmFuSW5kZXhlc1tqXSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgICAgIGN1cnJlbnRJbmQgPSBsZXR0ZXJEYXRhLmFuSW5kZXhlc1tqXTtcbiAgICAgICAgICAgIG5ld0luZCA9IGluZGV4ZXMuc3BsaWNlKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGluZGV4ZXMubGVuZ3RoKSwgMSlbMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0dGVyRGF0YS5hbkluZGV4ZXNbal0gPSBuZXdJbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBkb2N1bWVudERhdGEueU9mZnNldCA9IGRvY3VtZW50RGF0YS5maW5hbExpbmVIZWlnaHQgfHwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAqIDEuMjtcbiAgICBkb2N1bWVudERhdGEubHMgPSBkb2N1bWVudERhdGEubHMgfHwgMDtcbiAgICBkb2N1bWVudERhdGEuYXNjZW50ID0gZm9udERhdGEuYXNjZW50ICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMDtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50RGF0YSA9IGZ1bmN0aW9uIChuZXdEYXRhLCBpbmRleCkge1xuICAgIGluZGV4ID0gaW5kZXggPT09IHVuZGVmaW5lZCA/IHRoaXMua2V5c0luZGV4IDogaW5kZXg7XG4gICAgdmFyIGREYXRhID0gdGhpcy5jb3B5RGF0YSh7fSwgdGhpcy5kYXRhLmQua1tpbmRleF0ucyk7XG4gICAgZERhdGEgPSB0aGlzLmNvcHlEYXRhKGREYXRhLCBuZXdEYXRhKTtcbiAgICB0aGlzLmRhdGEuZC5rW2luZGV4XS5zID0gZERhdGE7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZShpbmRleCk7XG4gICAgdGhpcy5zZXRDdXJyZW50RGF0YShkRGF0YSk7XG4gICAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLnJlY2FsY3VsYXRlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIGREYXRhID0gdGhpcy5kYXRhLmQua1tpbmRleF0ucztcbiAgICBkRGF0YS5fX2NvbXBsZXRlID0gZmFsc2U7XG4gICAgdGhpcy5rZXlzSW5kZXggPSAwO1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgdGhpcy5nZXRWYWx1ZShkRGF0YSk7XG4gIH07XG5cbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5jYW5SZXNpemVGb250ID0gZnVuY3Rpb24gKF9jYW5SZXNpemUpIHtcbiAgICB0aGlzLmNhblJlc2l6ZSA9IF9jYW5SZXNpemU7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZSh0aGlzLmtleXNJbmRleCk7XG4gICAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLnNldE1pbmltdW1Gb250U2l6ZSA9IGZ1bmN0aW9uIChfZm9udFZhbHVlKSB7XG4gICAgdGhpcy5taW5pbXVtRm9udFNpemUgPSBNYXRoLmZsb29yKF9mb250VmFsdWUpIHx8IDE7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZSh0aGlzLmtleXNJbmRleCk7XG4gICAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcbiAgfTtcblxuICB2YXIgVGV4dFNlbGVjdG9yUHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluO1xuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbiAgICBmdW5jdGlvbiBUZXh0U2VsZWN0b3JQcm9wRmFjdG9yeShlbGVtLCBkYXRhKSB7XG4gICAgICB0aGlzLl9jdXJyZW50VGV4dExlbmd0aCA9IC0xO1xuICAgICAgdGhpcy5rID0gZmFsc2U7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICAgIHRoaXMuZmluYWxTID0gMDtcbiAgICAgIHRoaXMuZmluYWxFID0gMDtcbiAgICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcbiAgICAgIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucyB8fCB7XG4gICAgICAgIGs6IDBcbiAgICAgIH0sIDAsIDAsIHRoaXMpO1xuXG4gICAgICBpZiAoJ2UnIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5lID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5lLCAwLCAwLCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZSA9IHtcbiAgICAgICAgICB2OiAxMDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5vIHx8IHtcbiAgICAgICAgazogMFxuICAgICAgfSwgMCwgMCwgdGhpcyk7XG4gICAgICB0aGlzLnhlID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS54ZSB8fCB7XG4gICAgICAgIGs6IDBcbiAgICAgIH0sIDAsIDAsIHRoaXMpO1xuICAgICAgdGhpcy5uZSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubmUgfHwge1xuICAgICAgICBrOiAwXG4gICAgICB9LCAwLCAwLCB0aGlzKTtcbiAgICAgIHRoaXMuc20gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnNtIHx8IHtcbiAgICAgICAgazogMTAwXG4gICAgICB9LCAwLCAwLCB0aGlzKTtcbiAgICAgIHRoaXMuYSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuYSwgMCwgMC4wMSwgdGhpcyk7XG5cbiAgICAgIGlmICghdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFRleHRTZWxlY3RvclByb3BGYWN0b3J5LnByb3RvdHlwZSA9IHtcbiAgICAgIGdldE11bHQ6IGZ1bmN0aW9uIGdldE11bHQoaW5kKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50VGV4dExlbmd0aCAhPT0gdGhpcy5lbGVtLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YS5sLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4MSA9IDA7XG4gICAgICAgIHZhciB5MSA9IDA7XG4gICAgICAgIHZhciB4MiA9IDE7XG4gICAgICAgIHZhciB5MiA9IDE7XG5cbiAgICAgICAgaWYgKHRoaXMubmUudiA+IDApIHtcbiAgICAgICAgICB4MSA9IHRoaXMubmUudiAvIDEwMC4wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHkxID0gLXRoaXMubmUudiAvIDEwMC4wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMueGUudiA+IDApIHtcbiAgICAgICAgICB4MiA9IDEuMCAtIHRoaXMueGUudiAvIDEwMC4wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHkyID0gMS4wICsgdGhpcy54ZS52IC8gMTAwLjA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWFzZXIgPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZyh4MSwgeTEsIHgyLCB5MikuZ2V0O1xuICAgICAgICB2YXIgbXVsdCA9IDA7XG4gICAgICAgIHZhciBzID0gdGhpcy5maW5hbFM7XG4gICAgICAgIHZhciBlID0gdGhpcy5maW5hbEU7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5kYXRhLnNoO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAyKSB7XG4gICAgICAgICAgaWYgKGUgPT09IHMpIHtcbiAgICAgICAgICAgIG11bHQgPSBpbmQgPj0gZSA/IDEgOiAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtdWx0ID0gbWF4KDAsIG1pbigwLjUgLyAoZSAtIHMpICsgKGluZCAtIHMpIC8gKGUgLSBzKSwgMSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG11bHQgPSBlYXNlcihtdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAzKSB7XG4gICAgICAgICAgaWYgKGUgPT09IHMpIHtcbiAgICAgICAgICAgIG11bHQgPSBpbmQgPj0gZSA/IDAgOiAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtdWx0ID0gMSAtIG1heCgwLCBtaW4oMC41IC8gKGUgLSBzKSArIChpbmQgLSBzKSAvIChlIC0gcyksIDEpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtdWx0ID0gZWFzZXIobXVsdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNCkge1xuICAgICAgICAgIGlmIChlID09PSBzKSB7XG4gICAgICAgICAgICBtdWx0ID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXVsdCA9IG1heCgwLCBtaW4oMC41IC8gKGUgLSBzKSArIChpbmQgLSBzKSAvIChlIC0gcyksIDEpKTtcblxuICAgICAgICAgICAgaWYgKG11bHQgPCAwLjUpIHtcbiAgICAgICAgICAgICAgbXVsdCAqPSAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbXVsdCA9IDEgLSAyICogKG11bHQgLSAwLjUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG11bHQgPSBlYXNlcihtdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA1KSB7XG4gICAgICAgICAgaWYgKGUgPT09IHMpIHtcbiAgICAgICAgICAgIG11bHQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdG90ID0gZSAtIHM7XG4gICAgICAgICAgICAvKiBpbmQgKz0gMC41O1xyXG4gICAgICAgICAgICAgICAgICAgICAgbXVsdCA9IC00Lyh0b3QqdG90KSooaW5kKmluZCkrKDQvdG90KSppbmQ7ICovXG5cbiAgICAgICAgICAgIGluZCA9IG1pbihtYXgoMCwgaW5kICsgMC41IC0gcyksIGUgLSBzKTtcbiAgICAgICAgICAgIHZhciB4ID0gLXRvdCAvIDIgKyBpbmQ7XG4gICAgICAgICAgICB2YXIgYSA9IHRvdCAvIDI7XG4gICAgICAgICAgICBtdWx0ID0gTWF0aC5zcXJ0KDEgLSB4ICogeCAvIChhICogYSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG11bHQgPSBlYXNlcihtdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA2KSB7XG4gICAgICAgICAgaWYgKGUgPT09IHMpIHtcbiAgICAgICAgICAgIG11bHQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmQgPSBtaW4obWF4KDAsIGluZCArIDAuNSAtIHMpLCBlIC0gcyk7XG4gICAgICAgICAgICBtdWx0ID0gKDEgKyBNYXRoLmNvcyhNYXRoLlBJICsgTWF0aC5QSSAqIDIgKiBpbmQgLyAoZSAtIHMpKSkgLyAyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbXVsdCA9IGVhc2VyKG11bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpbmQgPj0gZmxvb3IocykpIHtcbiAgICAgICAgICAgIGlmIChpbmQgLSBzIDwgMCkge1xuICAgICAgICAgICAgICBtdWx0ID0gbWF4KDAsIG1pbihtaW4oZSwgMSkgLSAocyAtIGluZCksIDEpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG11bHQgPSBtYXgoMCwgbWluKGUgLSBpbmQsIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtdWx0ID0gZWFzZXIobXVsdCk7XG4gICAgICAgIH0gLy8gU21vb3RobmVzcyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgLy8gVGhlIHNtb290aG5lc3MgcmVwcmVzZW50cyBhIHJlZHVjZWQgcmFuZ2Ugb2YgdGhlIG9yaWdpbmFsIFswOyAxXSByYW5nZS5cbiAgICAgICAgLy8gaWYgc21vb3RobmVzcyBpcyAyNSUsIHRoZSBuZXcgcmFuZ2Ugd2lsbCBiZSBbMC4zNzU7IDAuNjI1XVxuICAgICAgICAvLyBTdGVwcyBhcmU6XG4gICAgICAgIC8vIC0gZmluZCB0aGUgbG93ZXIgdmFsdWUgb2YgdGhlIG5ldyByYW5nZSAodGhyZXNob2xkKVxuICAgICAgICAvLyAtIGlmIG11bHRpcGxpZXIgaXMgc21hbGxlciB0aGFuIHRoYXQgdmFsdWUsIGZsb29yIGl0IHRvIDBcbiAgICAgICAgLy8gLSBpZiBpdCBpcyBsYXJnZXIsXG4gICAgICAgIC8vICAgICAtIHN1YnRyYWN0IHRoZSB0aHJlc2hvbGRcbiAgICAgICAgLy8gICAgIC0gZGl2aWRlIGl0IGJ5IHRoZSBzbW9vdGhuZXNzICh0aGlzIHdpbGwgcmV0dXJuIHRoZSByYW5nZSB0byBbMDsgMV0pXG4gICAgICAgIC8vIE5vdGU6IElmIGl0IGRvZXNuJ3Qgd29yayBvbiBzb21lIHNjZW5hcmlvcywgY29uc2lkZXIgYXBwbHlpbmcgaXQgYmVmb3JlIHRoZSBlYXNlci5cblxuXG4gICAgICAgIGlmICh0aGlzLnNtLnYgIT09IDEwMCkge1xuICAgICAgICAgIHZhciBzbW9vdGhuZXNzID0gdGhpcy5zbS52ICogMC4wMTtcblxuICAgICAgICAgIGlmIChzbW9vdGhuZXNzID09PSAwKSB7XG4gICAgICAgICAgICBzbW9vdGhuZXNzID0gMC4wMDAwMDAwMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdGhyZXNob2xkID0gMC41IC0gc21vb3RobmVzcyAqIDAuNTtcblxuICAgICAgICAgIGlmIChtdWx0IDwgdGhyZXNob2xkKSB7XG4gICAgICAgICAgICBtdWx0ID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXVsdCA9IChtdWx0IC0gdGhyZXNob2xkKSAvIHNtb290aG5lc3M7XG5cbiAgICAgICAgICAgIGlmIChtdWx0ID4gMSkge1xuICAgICAgICAgICAgICBtdWx0ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbXVsdCAqIHRoaXMuYS52O1xuICAgICAgfSxcbiAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZShuZXdDaGFyc0ZsYWcpIHtcbiAgICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcbiAgICAgICAgdGhpcy5fbWRmID0gbmV3Q2hhcnNGbGFnIHx8IHRoaXMuX21kZjtcbiAgICAgICAgdGhpcy5fY3VycmVudFRleHRMZW5ndGggPSB0aGlzLmVsZW0udGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLmwubGVuZ3RoIHx8IDA7XG5cbiAgICAgICAgaWYgKG5ld0NoYXJzRmxhZyAmJiB0aGlzLmRhdGEuciA9PT0gMikge1xuICAgICAgICAgIHRoaXMuZS52ID0gdGhpcy5fY3VycmVudFRleHRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGl2aXNvciA9IHRoaXMuZGF0YS5yID09PSAyID8gMSA6IDEwMCAvIHRoaXMuZGF0YS50b3RhbENoYXJzO1xuICAgICAgICB2YXIgbyA9IHRoaXMuby52IC8gZGl2aXNvcjtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnMudiAvIGRpdmlzb3IgKyBvO1xuICAgICAgICB2YXIgZSA9IHRoaXMuZS52IC8gZGl2aXNvciArIG87XG5cbiAgICAgICAgaWYgKHMgPiBlKSB7XG4gICAgICAgICAgdmFyIF9zID0gcztcbiAgICAgICAgICBzID0gZTtcbiAgICAgICAgICBlID0gX3M7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpbmFsUyA9IHM7XG4gICAgICAgIHRoaXMuZmluYWxFID0gZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgVGV4dFNlbGVjdG9yUHJvcEZhY3RvcnkpO1xuXG4gICAgZnVuY3Rpb24gZ2V0VGV4dFNlbGVjdG9yUHJvcChlbGVtLCBkYXRhLCBhcnIpIHtcbiAgICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdG9yUHJvcEZhY3RvcnkoZWxlbSwgZGF0YSwgYXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0VGV4dFNlbGVjdG9yUHJvcDogZ2V0VGV4dFNlbGVjdG9yUHJvcFxuICAgIH07XG4gIH0oKTtcblxuICBmdW5jdGlvbiBUZXh0QW5pbWF0b3JEYXRhUHJvcGVydHkoZWxlbSwgYW5pbWF0b3JQcm9wcywgY29udGFpbmVyKSB7XG4gICAgdmFyIGRlZmF1bHREYXRhID0ge1xuICAgICAgcHJvcFR5cGU6IGZhbHNlXG4gICAgfTtcbiAgICB2YXIgZ2V0UHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wO1xuICAgIHZhciB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcyA9IGFuaW1hdG9yUHJvcHMuYTtcbiAgICB0aGlzLmEgPSB7XG4gICAgICByOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5yID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5yLCAwLCBkZWdUb1JhZHMsIGNvbnRhaW5lcikgOiBkZWZhdWx0RGF0YSxcbiAgICAgIHJ4OiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5yeCA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucngsIDAsIGRlZ1RvUmFkcywgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgcnk6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnJ5ID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5yeSwgMCwgZGVnVG9SYWRzLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBzazogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuc2sgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLnNrLCAwLCBkZWdUb1JhZHMsIGNvbnRhaW5lcikgOiBkZWZhdWx0RGF0YSxcbiAgICAgIHNhOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zYSA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuc2EsIDAsIGRlZ1RvUmFkcywgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgczogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucyA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucywgMSwgMC4wMSwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgYTogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuYSA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuYSwgMSwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgbzogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMubyA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMubywgMCwgMC4wMSwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgcDogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucCA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucCwgMSwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgc3c6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnN3ID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zdywgMCwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgc2M6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnNjID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zYywgMSwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgZmM6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZjID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5mYywgMSwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgZmg6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZoID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5maCwgMCwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgZnM6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZzID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5mcywgMCwgMC4wMSwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgZmI6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZiID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5mYiwgMCwgMC4wMSwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgdDogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMudCA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMudCwgMCwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhXG4gICAgfTtcbiAgICB0aGlzLnMgPSBUZXh0U2VsZWN0b3JQcm9wLmdldFRleHRTZWxlY3RvclByb3AoZWxlbSwgYW5pbWF0b3JQcm9wcy5zLCBjb250YWluZXIpO1xuICAgIHRoaXMucy50ID0gYW5pbWF0b3JQcm9wcy5zLnQ7XG4gIH1cblxuICBmdW5jdGlvbiBUZXh0QW5pbWF0b3JQcm9wZXJ0eSh0ZXh0RGF0YSwgcmVuZGVyVHlwZSwgZWxlbSkge1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgdGhpcy5faGFzTWFza2VkUGF0aCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZyYW1lSWQgPSAtMTtcbiAgICB0aGlzLl90ZXh0RGF0YSA9IHRleHREYXRhO1xuICAgIHRoaXMuX3JlbmRlclR5cGUgPSByZW5kZXJUeXBlO1xuICAgIHRoaXMuX2VsZW0gPSBlbGVtO1xuICAgIHRoaXMuX2FuaW1hdG9yc0RhdGEgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMuX3RleHREYXRhLmEubGVuZ3RoKTtcbiAgICB0aGlzLl9wYXRoRGF0YSA9IHt9O1xuICAgIHRoaXMuX21vcmVPcHRpb25zID0ge1xuICAgICAgYWxpZ25tZW50OiB7fVxuICAgIH07XG4gICAgdGhpcy5yZW5kZXJlZExldHRlcnMgPSBbXTtcbiAgICB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyA9IGZhbHNlO1xuICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcbiAgfVxuXG4gIFRleHRBbmltYXRvclByb3BlcnR5LnByb3RvdHlwZS5zZWFyY2hQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLl90ZXh0RGF0YS5hLmxlbmd0aDtcbiAgICB2YXIgYW5pbWF0b3JQcm9wcztcbiAgICB2YXIgZ2V0UHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBhbmltYXRvclByb3BzID0gdGhpcy5fdGV4dERhdGEuYVtpXTtcbiAgICAgIHRoaXMuX2FuaW1hdG9yc0RhdGFbaV0gPSBuZXcgVGV4dEFuaW1hdG9yRGF0YVByb3BlcnR5KHRoaXMuX2VsZW0sIGFuaW1hdG9yUHJvcHMsIHRoaXMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl90ZXh0RGF0YS5wICYmICdtJyBpbiB0aGlzLl90ZXh0RGF0YS5wKSB7XG4gICAgICB0aGlzLl9wYXRoRGF0YSA9IHtcbiAgICAgICAgYTogZ2V0UHJvcCh0aGlzLl9lbGVtLCB0aGlzLl90ZXh0RGF0YS5wLmEsIDAsIDAsIHRoaXMpLFxuICAgICAgICBmOiBnZXRQcm9wKHRoaXMuX2VsZW0sIHRoaXMuX3RleHREYXRhLnAuZiwgMCwgMCwgdGhpcyksXG4gICAgICAgIGw6IGdldFByb3AodGhpcy5fZWxlbSwgdGhpcy5fdGV4dERhdGEucC5sLCAwLCAwLCB0aGlzKSxcbiAgICAgICAgcjogZ2V0UHJvcCh0aGlzLl9lbGVtLCB0aGlzLl90ZXh0RGF0YS5wLnIsIDAsIDAsIHRoaXMpLFxuICAgICAgICBwOiBnZXRQcm9wKHRoaXMuX2VsZW0sIHRoaXMuX3RleHREYXRhLnAucCwgMCwgMCwgdGhpcyksXG4gICAgICAgIG06IHRoaXMuX2VsZW0ubWFza01hbmFnZXIuZ2V0TWFza1Byb3BlcnR5KHRoaXMuX3RleHREYXRhLnAubSlcbiAgICAgIH07XG4gICAgICB0aGlzLl9oYXNNYXNrZWRQYXRoID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGFzTWFza2VkUGF0aCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX21vcmVPcHRpb25zLmFsaWdubWVudCA9IGdldFByb3AodGhpcy5fZWxlbSwgdGhpcy5fdGV4dERhdGEubS5hLCAxLCAwLCB0aGlzKTtcbiAgfTtcblxuICBUZXh0QW5pbWF0b3JQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0TWVhc3VyZXMgPSBmdW5jdGlvbiAoZG9jdW1lbnREYXRhLCBsZXR0ZXJzQ2hhbmdlZEZsYWcpIHtcbiAgICB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyA9IGxldHRlcnNDaGFuZ2VkRmxhZztcblxuICAgIGlmICghdGhpcy5fbWRmICYmICF0aGlzLl9pc0ZpcnN0RnJhbWUgJiYgIWxldHRlcnNDaGFuZ2VkRmxhZyAmJiAoIXRoaXMuX2hhc01hc2tlZFBhdGggfHwgIXRoaXMuX3BhdGhEYXRhLm0uX21kZikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcbiAgICB2YXIgYWxpZ25tZW50ID0gdGhpcy5fbW9yZU9wdGlvbnMuYWxpZ25tZW50LnY7XG4gICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuX2FuaW1hdG9yc0RhdGE7XG4gICAgdmFyIHRleHREYXRhID0gdGhpcy5fdGV4dERhdGE7XG4gICAgdmFyIG1hdHJpeEhlbHBlciA9IHRoaXMubUhlbHBlcjtcbiAgICB2YXIgcmVuZGVyVHlwZSA9IHRoaXMuX3JlbmRlclR5cGU7XG4gICAgdmFyIHJlbmRlcmVkTGV0dGVyc0NvdW50ID0gdGhpcy5yZW5kZXJlZExldHRlcnMubGVuZ3RoO1xuICAgIHZhciB4UG9zO1xuICAgIHZhciB5UG9zO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgdmFyIGxldHRlcnMgPSBkb2N1bWVudERhdGEubDtcbiAgICB2YXIgcGF0aEluZm87XG4gICAgdmFyIGN1cnJlbnRMZW5ndGg7XG4gICAgdmFyIGN1cnJlbnRQb2ludDtcbiAgICB2YXIgc2VnbWVudExlbmd0aDtcbiAgICB2YXIgZmxhZztcbiAgICB2YXIgcG9pbnRJbmQ7XG4gICAgdmFyIHNlZ21lbnRJbmQ7XG4gICAgdmFyIHByZXZQb2ludDtcbiAgICB2YXIgcG9pbnRzO1xuICAgIHZhciBzZWdtZW50cztcbiAgICB2YXIgcGFydGlhbExlbmd0aDtcbiAgICB2YXIgdG90YWxMZW5ndGg7XG4gICAgdmFyIHBlcmM7XG4gICAgdmFyIHRhbkFuZ2xlO1xuICAgIHZhciBtYXNrO1xuXG4gICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcbiAgICAgIG1hc2sgPSB0aGlzLl9wYXRoRGF0YS5tO1xuXG4gICAgICBpZiAoIXRoaXMuX3BhdGhEYXRhLm4gfHwgdGhpcy5fcGF0aERhdGEuX21kZikge1xuICAgICAgICB2YXIgcGF0aHMgPSBtYXNrLnY7XG5cbiAgICAgICAgaWYgKHRoaXMuX3BhdGhEYXRhLnIudikge1xuICAgICAgICAgIHBhdGhzID0gcGF0aHMucmV2ZXJzZSgpO1xuICAgICAgICB9IC8vIFRPRE86IHJlbGVhc2UgYmV6aWVyIGRhdGEgY2FjaGVkIGZyb20gcHJldmlvdXMgcGF0aEluZm86IHRoaXMuX3BhdGhEYXRhLnBpXG5cblxuICAgICAgICBwYXRoSW5mbyA9IHtcbiAgICAgICAgICB0TGVuZ3RoOiAwLFxuICAgICAgICAgIHNlZ21lbnRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBsZW4gPSBwYXRocy5fbGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGJlemllckRhdGE7XG4gICAgICAgIHRvdGFsTGVuZ3RoID0gMDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBiZXppZXJEYXRhID0gYmV6LmJ1aWxkQmV6aWVyRGF0YShwYXRocy52W2ldLCBwYXRocy52W2kgKyAxXSwgW3BhdGhzLm9baV1bMF0gLSBwYXRocy52W2ldWzBdLCBwYXRocy5vW2ldWzFdIC0gcGF0aHMudltpXVsxXV0sIFtwYXRocy5pW2kgKyAxXVswXSAtIHBhdGhzLnZbaSArIDFdWzBdLCBwYXRocy5pW2kgKyAxXVsxXSAtIHBhdGhzLnZbaSArIDFdWzFdXSk7XG4gICAgICAgICAgcGF0aEluZm8udExlbmd0aCArPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGg7XG4gICAgICAgICAgcGF0aEluZm8uc2VnbWVudHMucHVzaChiZXppZXJEYXRhKTtcbiAgICAgICAgICB0b3RhbExlbmd0aCArPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpID0gbGVuO1xuXG4gICAgICAgIGlmIChtYXNrLnYuYykge1xuICAgICAgICAgIGJlemllckRhdGEgPSBiZXouYnVpbGRCZXppZXJEYXRhKHBhdGhzLnZbaV0sIHBhdGhzLnZbMF0sIFtwYXRocy5vW2ldWzBdIC0gcGF0aHMudltpXVswXSwgcGF0aHMub1tpXVsxXSAtIHBhdGhzLnZbaV1bMV1dLCBbcGF0aHMuaVswXVswXSAtIHBhdGhzLnZbMF1bMF0sIHBhdGhzLmlbMF1bMV0gLSBwYXRocy52WzBdWzFdXSk7XG4gICAgICAgICAgcGF0aEluZm8udExlbmd0aCArPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGg7XG4gICAgICAgICAgcGF0aEluZm8uc2VnbWVudHMucHVzaChiZXppZXJEYXRhKTtcbiAgICAgICAgICB0b3RhbExlbmd0aCArPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wYXRoRGF0YS5waSA9IHBhdGhJbmZvO1xuICAgICAgfVxuXG4gICAgICBwYXRoSW5mbyA9IHRoaXMuX3BhdGhEYXRhLnBpO1xuICAgICAgY3VycmVudExlbmd0aCA9IHRoaXMuX3BhdGhEYXRhLmYudjtcbiAgICAgIHNlZ21lbnRJbmQgPSAwO1xuICAgICAgcG9pbnRJbmQgPSAxO1xuICAgICAgc2VnbWVudExlbmd0aCA9IDA7XG4gICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgIHNlZ21lbnRzID0gcGF0aEluZm8uc2VnbWVudHM7XG5cbiAgICAgIGlmIChjdXJyZW50TGVuZ3RoIDwgMCAmJiBtYXNrLnYuYykge1xuICAgICAgICBpZiAocGF0aEluZm8udExlbmd0aCA8IE1hdGguYWJzKGN1cnJlbnRMZW5ndGgpKSB7XG4gICAgICAgICAgY3VycmVudExlbmd0aCA9IC1NYXRoLmFicyhjdXJyZW50TGVuZ3RoKSAlIHBhdGhJbmZvLnRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBzZWdtZW50SW5kID0gc2VnbWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0ucG9pbnRzO1xuICAgICAgICBwb2ludEluZCA9IHBvaW50cy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChjdXJyZW50TGVuZ3RoIDwgMCkge1xuICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gcG9pbnRzW3BvaW50SW5kXS5wYXJ0aWFsTGVuZ3RoO1xuICAgICAgICAgIHBvaW50SW5kIC09IDE7XG5cbiAgICAgICAgICBpZiAocG9pbnRJbmQgPCAwKSB7XG4gICAgICAgICAgICBzZWdtZW50SW5kIC09IDE7XG4gICAgICAgICAgICBwb2ludHMgPSBzZWdtZW50c1tzZWdtZW50SW5kXS5wb2ludHM7XG4gICAgICAgICAgICBwb2ludEluZCA9IHBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwb2ludHMgPSBzZWdtZW50c1tzZWdtZW50SW5kXS5wb2ludHM7XG4gICAgICBwcmV2UG9pbnQgPSBwb2ludHNbcG9pbnRJbmQgLSAxXTtcbiAgICAgIGN1cnJlbnRQb2ludCA9IHBvaW50c1twb2ludEluZF07XG4gICAgICBwYXJ0aWFsTGVuZ3RoID0gY3VycmVudFBvaW50LnBhcnRpYWxMZW5ndGg7XG4gICAgfVxuXG4gICAgbGVuID0gbGV0dGVycy5sZW5ndGg7XG4gICAgeFBvcyA9IDA7XG4gICAgeVBvcyA9IDA7XG4gICAgdmFyIHlPZmYgPSBkb2N1bWVudERhdGEuZmluYWxTaXplICogMS4yICogMC43MTQ7XG4gICAgdmFyIGZpcnN0TGluZSA9IHRydWU7XG4gICAgdmFyIGFuaW1hdG9yUHJvcHM7XG4gICAgdmFyIGFuaW1hdG9yU2VsZWN0b3I7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIGxldHRlclZhbHVlO1xuICAgIGpMZW4gPSBhbmltYXRvcnMubGVuZ3RoO1xuICAgIHZhciBtdWx0O1xuICAgIHZhciBpbmQgPSAtMTtcbiAgICB2YXIgb2ZmZjtcbiAgICB2YXIgeFBhdGhQb3M7XG4gICAgdmFyIHlQYXRoUG9zO1xuICAgIHZhciBpbml0UGF0aFBvcyA9IGN1cnJlbnRMZW5ndGg7XG4gICAgdmFyIGluaXRTZWdtZW50SW5kID0gc2VnbWVudEluZDtcbiAgICB2YXIgaW5pdFBvaW50SW5kID0gcG9pbnRJbmQ7XG4gICAgdmFyIGN1cnJlbnRMaW5lID0gLTE7XG4gICAgdmFyIGVsZW1PcGFjaXR5O1xuICAgIHZhciBzYztcbiAgICB2YXIgc3c7XG4gICAgdmFyIGZjO1xuICAgIHZhciBrO1xuICAgIHZhciBsZXR0ZXJTdztcbiAgICB2YXIgbGV0dGVyU2M7XG4gICAgdmFyIGxldHRlckZjO1xuICAgIHZhciBsZXR0ZXJNID0gJyc7XG4gICAgdmFyIGxldHRlclAgPSB0aGlzLmRlZmF1bHRQcm9wc0FycmF5O1xuICAgIHZhciBsZXR0ZXJPOyAvL1xuXG4gICAgaWYgKGRvY3VtZW50RGF0YS5qID09PSAyIHx8IGRvY3VtZW50RGF0YS5qID09PSAxKSB7XG4gICAgICB2YXIgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ID0gMDtcbiAgICAgIHZhciBhbmltYXRvckZpcnN0Q2hhck9mZnNldCA9IDA7XG4gICAgICB2YXIganVzdGlmeU9mZnNldE11bHQgPSBkb2N1bWVudERhdGEuaiA9PT0gMiA/IC0wLjUgOiAtMTtcbiAgICAgIHZhciBsYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIGlzTmV3TGluZSA9IHRydWU7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAobGV0dGVyc1tpXS5uKSB7XG4gICAgICAgICAgaWYgKGFuaW1hdG9ySnVzdGlmeU9mZnNldCkge1xuICAgICAgICAgICAgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ICs9IGFuaW1hdG9yRmlyc3RDaGFyT2Zmc2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdoaWxlIChsYXN0SW5kZXggPCBpKSB7XG4gICAgICAgICAgICBsZXR0ZXJzW2xhc3RJbmRleF0uYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ID0gYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0O1xuICAgICAgICAgICAgbGFzdEluZGV4ICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ID0gMDtcbiAgICAgICAgICBpc05ld0xpbmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcblxuICAgICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMudC5wcm9wVHlwZSkge1xuICAgICAgICAgICAgICBpZiAoaXNOZXdMaW5lICYmIGRvY3VtZW50RGF0YS5qID09PSAyKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3JGaXJzdENoYXJPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBqdXN0aWZ5T2Zmc2V0TXVsdDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcbiAgICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSwgdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpO1xuXG4gICAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9ySnVzdGlmeU9mZnNldCArPSBhbmltYXRvclByb3BzLnQudiAqIG11bHRbMF0gKiBqdXN0aWZ5T2Zmc2V0TXVsdDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltYXRvckp1c3RpZnlPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBtdWx0ICoganVzdGlmeU9mZnNldE11bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpc05ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0KSB7XG4gICAgICAgIGFuaW1hdG9ySnVzdGlmeU9mZnNldCArPSBhbmltYXRvckZpcnN0Q2hhck9mZnNldDtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGxhc3RJbmRleCA8IGkpIHtcbiAgICAgICAgbGV0dGVyc1tsYXN0SW5kZXhdLmFuaW1hdG9ySnVzdGlmeU9mZnNldCA9IGFuaW1hdG9ySnVzdGlmeU9mZnNldDtcbiAgICAgICAgbGFzdEluZGV4ICs9IDE7XG4gICAgICB9XG4gICAgfSAvL1xuXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIG1hdHJpeEhlbHBlci5yZXNldCgpO1xuICAgICAgZWxlbU9wYWNpdHkgPSAxO1xuXG4gICAgICBpZiAobGV0dGVyc1tpXS5uKSB7XG4gICAgICAgIHhQb3MgPSAwO1xuICAgICAgICB5UG9zICs9IGRvY3VtZW50RGF0YS55T2Zmc2V0O1xuICAgICAgICB5UG9zICs9IGZpcnN0TGluZSA/IDEgOiAwO1xuICAgICAgICBjdXJyZW50TGVuZ3RoID0gaW5pdFBhdGhQb3M7XG4gICAgICAgIGZpcnN0TGluZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLl9oYXNNYXNrZWRQYXRoKSB7XG4gICAgICAgICAgc2VnbWVudEluZCA9IGluaXRTZWdtZW50SW5kO1xuICAgICAgICAgIHBvaW50SW5kID0gaW5pdFBvaW50SW5kO1xuICAgICAgICAgIHBvaW50cyA9IHNlZ21lbnRzW3NlZ21lbnRJbmRdLnBvaW50cztcbiAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludHNbcG9pbnRJbmQgLSAxXTtcbiAgICAgICAgICBjdXJyZW50UG9pbnQgPSBwb2ludHNbcG9pbnRJbmRdO1xuICAgICAgICAgIHBhcnRpYWxMZW5ndGggPSBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcbiAgICAgICAgICBzZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldHRlck0gPSAnJztcbiAgICAgICAgbGV0dGVyRmMgPSAnJztcbiAgICAgICAgbGV0dGVyU3cgPSAnJztcbiAgICAgICAgbGV0dGVyTyA9ICcnO1xuICAgICAgICBsZXR0ZXJQID0gdGhpcy5kZWZhdWx0UHJvcHNBcnJheTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNNYXNrZWRQYXRoKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRMaW5lICE9PSBsZXR0ZXJzW2ldLmxpbmUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZG9jdW1lbnREYXRhLmopIHtcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gdG90YWxMZW5ndGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsZXR0ZXJzW2ldLmxpbmVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9ICh0b3RhbExlbmd0aCAtIGRvY3VtZW50RGF0YS5saW5lV2lkdGhzW2xldHRlcnNbaV0ubGluZV0pIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50TGluZSA9IGxldHRlcnNbaV0ubGluZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW5kICE9PSBsZXR0ZXJzW2ldLmluZCkge1xuICAgICAgICAgICAgaWYgKGxldHRlcnNbaW5kXSkge1xuICAgICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IGxldHRlcnNbaW5kXS5leHRyYTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSBsZXR0ZXJzW2ldLmFuIC8gMjtcbiAgICAgICAgICAgIGluZCA9IGxldHRlcnNbaV0uaW5kO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gYWxpZ25tZW50WzBdICogbGV0dGVyc1tpXS5hbiAqIDAuMDA1O1xuICAgICAgICAgIHZhciBhbmltYXRvck9mZnNldCA9IDA7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBhbmltYXRvclByb3BzID0gYW5pbWF0b3JzW2pdLmE7XG5cbiAgICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLnAucHJvcFR5cGUpIHtcbiAgICAgICAgICAgICAgYW5pbWF0b3JTZWxlY3RvciA9IGFuaW1hdG9yc1tqXS5zO1xuICAgICAgICAgICAgICBtdWx0ID0gYW5pbWF0b3JTZWxlY3Rvci5nZXRNdWx0KGxldHRlcnNbaV0uYW5JbmRleGVzW2pdLCB0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XG5cbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3JPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy5wLnZbMF0gKiBtdWx0WzBdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yT2Zmc2V0ICs9IGFuaW1hdG9yUHJvcHMucC52WzBdICogbXVsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5hLnByb3BUeXBlKSB7XG4gICAgICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcbiAgICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSwgdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpO1xuXG4gICAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yT2Zmc2V0ICs9IGFuaW1hdG9yUHJvcHMuYS52WzBdICogbXVsdFswXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltYXRvck9mZnNldCArPSBhbmltYXRvclByb3BzLmEudlswXSAqIG11bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbGFnID0gdHJ1ZTsgLy8gRm9yY2UgYWxpZ25tZW50IG9ubHkgd29ya3Mgd2l0aCBhIHNpbmdsZSBsaW5lIGZvciBub3dcblxuICAgICAgICAgIGlmICh0aGlzLl9wYXRoRGF0YS5hLnYpIHtcbiAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggPSBsZXR0ZXJzWzBdLmFuICogMC41ICsgKHRvdGFsTGVuZ3RoIC0gdGhpcy5fcGF0aERhdGEuZi52IC0gbGV0dGVyc1swXS5hbiAqIDAuNSAtIGxldHRlcnNbbGV0dGVycy5sZW5ndGggLSAxXS5hbiAqIDAuNSkgKiBpbmQgLyAobGVuIC0gMSk7XG4gICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IHRoaXMuX3BhdGhEYXRhLmYudjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAoZmxhZykge1xuICAgICAgICAgICAgaWYgKHNlZ21lbnRMZW5ndGggKyBwYXJ0aWFsTGVuZ3RoID49IGN1cnJlbnRMZW5ndGggKyBhbmltYXRvck9mZnNldCB8fCAhcG9pbnRzKSB7XG4gICAgICAgICAgICAgIHBlcmMgPSAoY3VycmVudExlbmd0aCArIGFuaW1hdG9yT2Zmc2V0IC0gc2VnbWVudExlbmd0aCkgLyBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcbiAgICAgICAgICAgICAgeFBhdGhQb3MgPSBwcmV2UG9pbnQucG9pbnRbMF0gKyAoY3VycmVudFBvaW50LnBvaW50WzBdIC0gcHJldlBvaW50LnBvaW50WzBdKSAqIHBlcmM7XG4gICAgICAgICAgICAgIHlQYXRoUG9zID0gcHJldlBvaW50LnBvaW50WzFdICsgKGN1cnJlbnRQb2ludC5wb2ludFsxXSAtIHByZXZQb2ludC5wb2ludFsxXSkgKiBwZXJjO1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1hbGlnbm1lbnRbMF0gKiBsZXR0ZXJzW2ldLmFuICogMC4wMDUsIC0oYWxpZ25tZW50WzFdICogeU9mZikgKiAwLjAxKTtcbiAgICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludHMpIHtcbiAgICAgICAgICAgICAgc2VnbWVudExlbmd0aCArPSBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcbiAgICAgICAgICAgICAgcG9pbnRJbmQgKz0gMTtcblxuICAgICAgICAgICAgICBpZiAocG9pbnRJbmQgPj0gcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBvaW50SW5kID0gMDtcbiAgICAgICAgICAgICAgICBzZWdtZW50SW5kICs9IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNlZ21lbnRzW3NlZ21lbnRJbmRdKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobWFzay52LmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50SW5kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0ucG9pbnRzO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudExlbmd0aCAtPSBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0ucG9pbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChwb2ludHMpIHtcbiAgICAgICAgICAgICAgICBwcmV2UG9pbnQgPSBjdXJyZW50UG9pbnQ7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvaW50ID0gcG9pbnRzW3BvaW50SW5kXTtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsTGVuZ3RoID0gY3VycmVudFBvaW50LnBhcnRpYWxMZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvZmZmID0gbGV0dGVyc1tpXS5hbiAvIDIgLSBsZXR0ZXJzW2ldLmFkZDtcbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1vZmZmLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZmID0gbGV0dGVyc1tpXS5hbiAvIDIgLSBsZXR0ZXJzW2ldLmFkZDtcbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1vZmZmLCAwLCAwKTsgLy8gR3JvdXBpbmcgYWxpZ25tZW50XG5cbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1hbGlnbm1lbnRbMF0gKiBsZXR0ZXJzW2ldLmFuICogMC4wMDUsIC1hbGlnbm1lbnRbMV0gKiB5T2ZmICogMC4wMSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgYW5pbWF0b3JQcm9wcyA9IGFuaW1hdG9yc1tqXS5hO1xuXG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMudC5wcm9wVHlwZSkge1xuICAgICAgICAgICAgYW5pbWF0b3JTZWxlY3RvciA9IGFuaW1hdG9yc1tqXS5zO1xuICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSwgdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpOyAvLyBUaGlzIGNvbmRpdGlvbiBpcyB0byBwcmV2ZW50IGFwcGx5aW5nIHRyYWNraW5nIHRvIGZpcnN0IGNoYXJhY3RlciBpbiBlYWNoIGxpbmUuIE1pZ2h0IGJlIGJldHRlciB0byB1c2UgYSBib29sZWFuIFwiaXNOZXdMaW5lXCJcblxuICAgICAgICAgICAgaWYgKHhQb3MgIT09IDAgfHwgZG9jdW1lbnREYXRhLmogIT09IDApIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBtdWx0WzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IGFuaW1hdG9yUHJvcHMudC52ICogbXVsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB4UG9zICs9IGFuaW1hdG9yUHJvcHMudC52ICogbXVsdFswXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4UG9zICs9IGFuaW1hdG9yUHJvcHMudC52ICogbXVsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2N1bWVudERhdGEuc3Ryb2tlV2lkdGhBbmltKSB7XG4gICAgICAgICAgc3cgPSBkb2N1bWVudERhdGEuc3cgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2N1bWVudERhdGEuc3Ryb2tlQ29sb3JBbmltKSB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5zYykge1xuICAgICAgICAgICAgc2MgPSBbZG9jdW1lbnREYXRhLnNjWzBdLCBkb2N1bWVudERhdGEuc2NbMV0sIGRvY3VtZW50RGF0YS5zY1syXV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjID0gWzAsIDAsIDBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2N1bWVudERhdGEuZmlsbENvbG9yQW5pbSAmJiBkb2N1bWVudERhdGEuZmMpIHtcbiAgICAgICAgICBmYyA9IFtkb2N1bWVudERhdGEuZmNbMF0sIGRvY3VtZW50RGF0YS5mY1sxXSwgZG9jdW1lbnREYXRhLmZjWzJdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICBhbmltYXRvclByb3BzID0gYW5pbWF0b3JzW2pdLmE7XG5cbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5hLnByb3BUeXBlKSB7XG4gICAgICAgICAgICBhbmltYXRvclNlbGVjdG9yID0gYW5pbWF0b3JzW2pdLnM7XG4gICAgICAgICAgICBtdWx0ID0gYW5pbWF0b3JTZWxlY3Rvci5nZXRNdWx0KGxldHRlcnNbaV0uYW5JbmRleGVzW2pdLCB0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XG5cbiAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1hbmltYXRvclByb3BzLmEudlswXSAqIG11bHRbMF0sIC1hbmltYXRvclByb3BzLmEudlsxXSAqIG11bHRbMV0sIGFuaW1hdG9yUHJvcHMuYS52WzJdICogbXVsdFsyXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1hbmltYXRvclByb3BzLmEudlswXSAqIG11bHQsIC1hbmltYXRvclByb3BzLmEudlsxXSAqIG11bHQsIGFuaW1hdG9yUHJvcHMuYS52WzJdICogbXVsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcblxuICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLnMucHJvcFR5cGUpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcbiAgICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcblxuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5zY2FsZSgxICsgKGFuaW1hdG9yUHJvcHMucy52WzBdIC0gMSkgKiBtdWx0WzBdLCAxICsgKGFuaW1hdG9yUHJvcHMucy52WzFdIC0gMSkgKiBtdWx0WzFdLCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5zY2FsZSgxICsgKGFuaW1hdG9yUHJvcHMucy52WzBdIC0gMSkgKiBtdWx0LCAxICsgKGFuaW1hdG9yUHJvcHMucy52WzFdIC0gMSkgKiBtdWx0LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgYW5pbWF0b3JQcm9wcyA9IGFuaW1hdG9yc1tqXS5hO1xuICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcbiAgICAgICAgICBtdWx0ID0gYW5pbWF0b3JTZWxlY3Rvci5nZXRNdWx0KGxldHRlcnNbaV0uYW5JbmRleGVzW2pdLCB0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XG5cbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5zay5wcm9wVHlwZSkge1xuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5za2V3RnJvbUF4aXMoLWFuaW1hdG9yUHJvcHMuc2sudiAqIG11bHRbMF0sIGFuaW1hdG9yUHJvcHMuc2EudiAqIG11bHRbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnNrZXdGcm9tQXhpcygtYW5pbWF0b3JQcm9wcy5zay52ICogbXVsdCwgYW5pbWF0b3JQcm9wcy5zYS52ICogbXVsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuci5wcm9wVHlwZSkge1xuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5yb3RhdGVaKC1hbmltYXRvclByb3BzLnIudiAqIG11bHRbMl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZVooLWFuaW1hdG9yUHJvcHMuci52ICogbXVsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMucnkucHJvcFR5cGUpIHtcbiAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlWShhbmltYXRvclByb3BzLnJ5LnYgKiBtdWx0WzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5yb3RhdGVZKGFuaW1hdG9yUHJvcHMucnkudiAqIG11bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLnJ4LnByb3BUeXBlKSB7XG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZVgoYW5pbWF0b3JQcm9wcy5yeC52ICogbXVsdFswXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlWChhbmltYXRvclByb3BzLnJ4LnYgKiBtdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5vLnByb3BUeXBlKSB7XG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgZWxlbU9wYWNpdHkgKz0gKGFuaW1hdG9yUHJvcHMuby52ICogbXVsdFswXSAtIGVsZW1PcGFjaXR5KSAqIG11bHRbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtT3BhY2l0eSArPSAoYW5pbWF0b3JQcm9wcy5vLnYgKiBtdWx0IC0gZWxlbU9wYWNpdHkpICogbXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZG9jdW1lbnREYXRhLnN0cm9rZVdpZHRoQW5pbSAmJiBhbmltYXRvclByb3BzLnN3LnByb3BUeXBlKSB7XG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgc3cgKz0gYW5pbWF0b3JQcm9wcy5zdy52ICogbXVsdFswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN3ICs9IGFuaW1hdG9yUHJvcHMuc3cudiAqIG11bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5zdHJva2VDb2xvckFuaW0gJiYgYW5pbWF0b3JQcm9wcy5zYy5wcm9wVHlwZSkge1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IDM7IGsgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzY1trXSArPSAoYW5pbWF0b3JQcm9wcy5zYy52W2tdIC0gc2Nba10pICogbXVsdFswXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY1trXSArPSAoYW5pbWF0b3JQcm9wcy5zYy52W2tdIC0gc2Nba10pICogbXVsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkb2N1bWVudERhdGEuZmlsbENvbG9yQW5pbSAmJiBkb2N1bWVudERhdGEuZmMpIHtcbiAgICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLmZjLnByb3BUeXBlKSB7XG4gICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCAzOyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGZjW2tdICs9IChhbmltYXRvclByb3BzLmZjLnZba10gLSBmY1trXSkgKiBtdWx0WzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmY1trXSArPSAoYW5pbWF0b3JQcm9wcy5mYy52W2tdIC0gZmNba10pICogbXVsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuZmgucHJvcFR5cGUpIHtcbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZmMgPSBhZGRIdWVUb1JHQihmYywgYW5pbWF0b3JQcm9wcy5maC52ICogbXVsdFswXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmMgPSBhZGRIdWVUb1JHQihmYywgYW5pbWF0b3JQcm9wcy5maC52ICogbXVsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuZnMucHJvcFR5cGUpIHtcbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZmMgPSBhZGRTYXR1cmF0aW9uVG9SR0IoZmMsIGFuaW1hdG9yUHJvcHMuZnMudiAqIG11bHRbMF0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZjID0gYWRkU2F0dXJhdGlvblRvUkdCKGZjLCBhbmltYXRvclByb3BzLmZzLnYgKiBtdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5mYi5wcm9wVHlwZSkge1xuICAgICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmYyA9IGFkZEJyaWdodG5lc3NUb1JHQihmYywgYW5pbWF0b3JQcm9wcy5mYi52ICogbXVsdFswXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmMgPSBhZGRCcmlnaHRuZXNzVG9SR0IoZmMsIGFuaW1hdG9yUHJvcHMuZmIudiAqIG11bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcblxuICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLnAucHJvcFR5cGUpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcbiAgICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgwLCBhbmltYXRvclByb3BzLnAudlsxXSAqIG11bHRbMF0sIC1hbmltYXRvclByb3BzLnAudlsyXSAqIG11bHRbMV0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgYW5pbWF0b3JQcm9wcy5wLnZbMV0gKiBtdWx0LCAtYW5pbWF0b3JQcm9wcy5wLnZbMl0gKiBtdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKGFuaW1hdG9yUHJvcHMucC52WzBdICogbXVsdFswXSwgYW5pbWF0b3JQcm9wcy5wLnZbMV0gKiBtdWx0WzFdLCAtYW5pbWF0b3JQcm9wcy5wLnZbMl0gKiBtdWx0WzJdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoYW5pbWF0b3JQcm9wcy5wLnZbMF0gKiBtdWx0LCBhbmltYXRvclByb3BzLnAudlsxXSAqIG11bHQsIC1hbmltYXRvclByb3BzLnAudlsyXSAqIG11bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2N1bWVudERhdGEuc3Ryb2tlV2lkdGhBbmltKSB7XG4gICAgICAgICAgbGV0dGVyU3cgPSBzdyA8IDAgPyAwIDogc3c7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9jdW1lbnREYXRhLnN0cm9rZUNvbG9yQW5pbSkge1xuICAgICAgICAgIGxldHRlclNjID0gJ3JnYignICsgTWF0aC5yb3VuZChzY1swXSAqIDI1NSkgKyAnLCcgKyBNYXRoLnJvdW5kKHNjWzFdICogMjU1KSArICcsJyArIE1hdGgucm91bmQoc2NbMl0gKiAyNTUpICsgJyknO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5maWxsQ29sb3JBbmltICYmIGRvY3VtZW50RGF0YS5mYykge1xuICAgICAgICAgIGxldHRlckZjID0gJ3JnYignICsgTWF0aC5yb3VuZChmY1swXSAqIDI1NSkgKyAnLCcgKyBNYXRoLnJvdW5kKGZjWzFdICogMjU1KSArICcsJyArIE1hdGgucm91bmQoZmNbMl0gKiAyNTUpICsgJyknO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKDAsIC1kb2N1bWVudERhdGEubHMpO1xuICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgYWxpZ25tZW50WzFdICogeU9mZiAqIDAuMDEgKyB5UG9zLCAwKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9wYXRoRGF0YS5wLnYpIHtcbiAgICAgICAgICAgIHRhbkFuZ2xlID0gKGN1cnJlbnRQb2ludC5wb2ludFsxXSAtIHByZXZQb2ludC5wb2ludFsxXSkgLyAoY3VycmVudFBvaW50LnBvaW50WzBdIC0gcHJldlBvaW50LnBvaW50WzBdKTtcbiAgICAgICAgICAgIHZhciByb3QgPSBNYXRoLmF0YW4odGFuQW5nbGUpICogMTgwIC8gTWF0aC5QSTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQb2ludC5wb2ludFswXSA8IHByZXZQb2ludC5wb2ludFswXSkge1xuICAgICAgICAgICAgICByb3QgKz0gMTgwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlKC1yb3QgKiBNYXRoLlBJIC8gMTgwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKHhQYXRoUG9zLCB5UGF0aFBvcywgMCk7XG4gICAgICAgICAgY3VycmVudExlbmd0aCAtPSBhbGlnbm1lbnRbMF0gKiBsZXR0ZXJzW2ldLmFuICogMC4wMDU7XG5cbiAgICAgICAgICBpZiAobGV0dGVyc1tpICsgMV0gJiYgaW5kICE9PSBsZXR0ZXJzW2kgKyAxXS5pbmQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gbGV0dGVyc1tpXS5hbiAvIDI7XG4gICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IGRvY3VtZW50RGF0YS50ciAqIDAuMDAxICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSh4UG9zLCB5UG9zLCAwKTtcblxuICAgICAgICAgIGlmIChkb2N1bWVudERhdGEucHMpIHtcbiAgICAgICAgICAgIC8vIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLnBzWzBdLGRvY3VtZW50RGF0YS5wc1sxXSwwKTtcbiAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLnBzWzBdLCBkb2N1bWVudERhdGEucHNbMV0gKyBkb2N1bWVudERhdGEuYXNjZW50LCAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2l0Y2ggKGRvY3VtZW50RGF0YS5qKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUobGV0dGVyc1tpXS5hbmltYXRvckp1c3RpZnlPZmZzZXQgKyBkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCArIChkb2N1bWVudERhdGEuYm94V2lkdGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsZXR0ZXJzW2ldLmxpbmVdKSwgMCwgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUobGV0dGVyc1tpXS5hbmltYXRvckp1c3RpZnlPZmZzZXQgKyBkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCArIChkb2N1bWVudERhdGEuYm94V2lkdGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsZXR0ZXJzW2ldLmxpbmVdKSAvIDIsIDAsIDApO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgwLCAtZG9jdW1lbnREYXRhLmxzKTtcbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKG9mZmYsIDAsIDApO1xuICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoYWxpZ25tZW50WzBdICogbGV0dGVyc1tpXS5hbiAqIDAuMDA1LCBhbGlnbm1lbnRbMV0gKiB5T2ZmICogMC4wMSwgMCk7XG4gICAgICAgICAgeFBvcyArPSBsZXR0ZXJzW2ldLmwgKyBkb2N1bWVudERhdGEudHIgKiAwLjAwMSAqIGRvY3VtZW50RGF0YS5maW5hbFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyVHlwZSA9PT0gJ2h0bWwnKSB7XG4gICAgICAgICAgbGV0dGVyTSA9IG1hdHJpeEhlbHBlci50b0NTUygpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlbmRlclR5cGUgPT09ICdzdmcnKSB7XG4gICAgICAgICAgbGV0dGVyTSA9IG1hdHJpeEhlbHBlci50bzJkQ1NTKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0dGVyUCA9IFttYXRyaXhIZWxwZXIucHJvcHNbMF0sIG1hdHJpeEhlbHBlci5wcm9wc1sxXSwgbWF0cml4SGVscGVyLnByb3BzWzJdLCBtYXRyaXhIZWxwZXIucHJvcHNbM10sIG1hdHJpeEhlbHBlci5wcm9wc1s0XSwgbWF0cml4SGVscGVyLnByb3BzWzVdLCBtYXRyaXhIZWxwZXIucHJvcHNbNl0sIG1hdHJpeEhlbHBlci5wcm9wc1s3XSwgbWF0cml4SGVscGVyLnByb3BzWzhdLCBtYXRyaXhIZWxwZXIucHJvcHNbOV0sIG1hdHJpeEhlbHBlci5wcm9wc1sxMF0sIG1hdHJpeEhlbHBlci5wcm9wc1sxMV0sIG1hdHJpeEhlbHBlci5wcm9wc1sxMl0sIG1hdHJpeEhlbHBlci5wcm9wc1sxM10sIG1hdHJpeEhlbHBlci5wcm9wc1sxNF0sIG1hdHJpeEhlbHBlci5wcm9wc1sxNV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0dGVyTyA9IGVsZW1PcGFjaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAocmVuZGVyZWRMZXR0ZXJzQ291bnQgPD0gaSkge1xuICAgICAgICBsZXR0ZXJWYWx1ZSA9IG5ldyBMZXR0ZXJQcm9wcyhsZXR0ZXJPLCBsZXR0ZXJTdywgbGV0dGVyU2MsIGxldHRlckZjLCBsZXR0ZXJNLCBsZXR0ZXJQKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlZExldHRlcnMucHVzaChsZXR0ZXJWYWx1ZSk7XG4gICAgICAgIHJlbmRlcmVkTGV0dGVyc0NvdW50ICs9IDE7XG4gICAgICAgIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldHRlclZhbHVlID0gdGhpcy5yZW5kZXJlZExldHRlcnNbaV07XG4gICAgICAgIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnID0gbGV0dGVyVmFsdWUudXBkYXRlKGxldHRlck8sIGxldHRlclN3LCBsZXR0ZXJTYywgbGV0dGVyRmMsIGxldHRlck0sIGxldHRlclApIHx8IHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBUZXh0QW5pbWF0b3JQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2VsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLl9mcmFtZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZnJhbWVJZCA9IHRoaXMuX2VsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xuICAgIHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCk7XG4gIH07XG5cbiAgVGV4dEFuaW1hdG9yUHJvcGVydHkucHJvdG90eXBlLm1IZWxwZXIgPSBuZXcgTWF0cml4KCk7XG4gIFRleHRBbmltYXRvclByb3BlcnR5LnByb3RvdHlwZS5kZWZhdWx0UHJvcHNBcnJheSA9IFtdO1xuICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFRleHRBbmltYXRvclByb3BlcnR5KTtcblxuICBmdW5jdGlvbiBJVGV4dEVsZW1lbnQoKSB7fVxuXG4gIElUZXh0RWxlbWVudC5wcm90b3R5cGUuaW5pdEVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnID0gdHJ1ZTtcbiAgICB0aGlzLmluaXRGcmFtZSgpO1xuICAgIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMudGV4dFByb3BlcnR5ID0gbmV3IFRleHRQcm9wZXJ0eSh0aGlzLCBkYXRhLnQsIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMpO1xuICAgIHRoaXMudGV4dEFuaW1hdG9yID0gbmV3IFRleHRBbmltYXRvclByb3BlcnR5KGRhdGEudCwgdGhpcy5yZW5kZXJUeXBlLCB0aGlzKTtcbiAgICB0aGlzLmluaXRUcmFuc2Zvcm0oZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy5pbml0SGllcmFyY2h5KCk7XG4gICAgdGhpcy5pbml0UmVuZGVyYWJsZSgpO1xuICAgIHRoaXMuaW5pdFJlbmRlcmVyRWxlbWVudCgpO1xuICAgIHRoaXMuY3JlYXRlQ29udGFpbmVyRWxlbWVudHMoKTtcbiAgICB0aGlzLmNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzKCk7XG4gICAgdGhpcy5jcmVhdGVDb250ZW50KCk7XG4gICAgdGhpcy5oaWRlKCk7XG4gICAgdGhpcy50ZXh0QW5pbWF0b3Iuc2VhcmNoUHJvcGVydGllcyh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzKTtcbiAgfTtcblxuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB0aGlzLnByZXBhcmVSZW5kZXJhYmxlRnJhbWUobnVtKTtcbiAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdGhpcy5pc0luUmFuZ2UpO1xuICB9O1xuXG4gIElUZXh0RWxlbWVudC5wcm90b3R5cGUuY3JlYXRlUGF0aFNoYXBlID0gZnVuY3Rpb24gKG1hdHJpeEhlbHBlciwgc2hhcGVzKSB7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW4gPSBzaGFwZXMubGVuZ3RoO1xuICAgIHZhciBwYXRoTm9kZXM7XG4gICAgdmFyIHNoYXBlU3RyID0gJyc7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICBpZiAoc2hhcGVzW2pdLnR5ID09PSAnc2gnKSB7XG4gICAgICAgIHBhdGhOb2RlcyA9IHNoYXBlc1tqXS5rcy5rO1xuICAgICAgICBzaGFwZVN0ciArPSBidWlsZFNoYXBlU3RyaW5nKHBhdGhOb2RlcywgcGF0aE5vZGVzLmkubGVuZ3RoLCB0cnVlLCBtYXRyaXhIZWxwZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaGFwZVN0cjtcbiAgfTtcblxuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50RGF0YSA9IGZ1bmN0aW9uIChuZXdEYXRhLCBpbmRleCkge1xuICAgIHRoaXMudGV4dFByb3BlcnR5LnVwZGF0ZURvY3VtZW50RGF0YShuZXdEYXRhLCBpbmRleCk7XG4gIH07XG5cbiAgSVRleHRFbGVtZW50LnByb3RvdHlwZS5jYW5SZXNpemVGb250ID0gZnVuY3Rpb24gKF9jYW5SZXNpemUpIHtcbiAgICB0aGlzLnRleHRQcm9wZXJ0eS5jYW5SZXNpemVGb250KF9jYW5SZXNpemUpO1xuICB9O1xuXG4gIElUZXh0RWxlbWVudC5wcm90b3R5cGUuc2V0TWluaW11bUZvbnRTaXplID0gZnVuY3Rpb24gKF9mb250U2l6ZSkge1xuICAgIHRoaXMudGV4dFByb3BlcnR5LnNldE1pbmltdW1Gb250U2l6ZShfZm9udFNpemUpO1xuICB9O1xuXG4gIElUZXh0RWxlbWVudC5wcm90b3R5cGUuYXBwbHlUZXh0UHJvcGVydGllc1RvTWF0cml4ID0gZnVuY3Rpb24gKGRvY3VtZW50RGF0YSwgbWF0cml4SGVscGVyLCBsaW5lTnVtYmVyLCB4UG9zLCB5UG9zKSB7XG4gICAgaWYgKGRvY3VtZW50RGF0YS5wcykge1xuICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShkb2N1bWVudERhdGEucHNbMF0sIGRvY3VtZW50RGF0YS5wc1sxXSArIGRvY3VtZW50RGF0YS5hc2NlbnQsIDApO1xuICAgIH1cblxuICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgLWRvY3VtZW50RGF0YS5scywgMCk7XG5cbiAgICBzd2l0Y2ggKGRvY3VtZW50RGF0YS5qKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLmp1c3RpZnlPZmZzZXQgKyAoZG9jdW1lbnREYXRhLmJveFdpZHRoIC0gZG9jdW1lbnREYXRhLmxpbmVXaWR0aHNbbGluZU51bWJlcl0pLCAwLCAwKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCArIChkb2N1bWVudERhdGEuYm94V2lkdGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsaW5lTnVtYmVyXSkgLyAyLCAwLCAwKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoeFBvcywgeVBvcywgMCk7XG4gIH07XG5cbiAgSVRleHRFbGVtZW50LnByb3RvdHlwZS5idWlsZENvbG9yID0gZnVuY3Rpb24gKGNvbG9yRGF0YSkge1xuICAgIHJldHVybiAncmdiKCcgKyBNYXRoLnJvdW5kKGNvbG9yRGF0YVswXSAqIDI1NSkgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yRGF0YVsxXSAqIDI1NSkgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yRGF0YVsyXSAqIDI1NSkgKyAnKSc7XG4gIH07XG5cbiAgSVRleHRFbGVtZW50LnByb3RvdHlwZS5lbXB0eVByb3AgPSBuZXcgTGV0dGVyUHJvcHMoKTtcblxuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLnZhbGlkYXRlVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50ZXh0UHJvcGVydHkuX21kZiB8fCB0aGlzLnRleHRQcm9wZXJ0eS5faXNGaXJzdEZyYW1lKSB7XG4gICAgICB0aGlzLmJ1aWxkTmV3VGV4dCgpO1xuICAgICAgdGhpcy50ZXh0UHJvcGVydHkuX2lzRmlyc3RGcmFtZSA9IGZhbHNlO1xuICAgICAgdGhpcy50ZXh0UHJvcGVydHkuX21kZiA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZW1wdHlTaGFwZURhdGEgPSB7XG4gICAgc2hhcGVzOiBbXVxuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR1RleHRMb3R0aWVFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLnRleHRTcGFucyA9IFtdO1xuICAgIHRoaXMucmVuZGVyVHlwZSA9ICdzdmcnO1xuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBTVkdCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRE9NRWxlbWVudCwgSVRleHRFbGVtZW50XSwgU1ZHVGV4dExvdHRpZUVsZW1lbnQpO1xuXG4gIFNWR1RleHRMb3R0aWVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmRhdGEuc2luZ2xlU2hhcGUgJiYgIXRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5jaGFycykge1xuICAgICAgdGhpcy50ZXh0Q29udGFpbmVyID0gY3JlYXRlTlMoJ3RleHQnKTtcbiAgICB9XG4gIH07XG5cbiAgU1ZHVGV4dExvdHRpZUVsZW1lbnQucHJvdG90eXBlLmJ1aWxkVGV4dENvbnRlbnRzID0gZnVuY3Rpb24gKHRleHRBcnJheSkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGV4dEFycmF5Lmxlbmd0aDtcbiAgICB2YXIgdGV4dENvbnRlbnRzID0gW107XG4gICAgdmFyIGN1cnJlbnRUZXh0Q29udGVudCA9ICcnO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGlmICh0ZXh0QXJyYXlbaV0gPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMTMpIHx8IHRleHRBcnJheVtpXSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgzKSkge1xuICAgICAgICB0ZXh0Q29udGVudHMucHVzaChjdXJyZW50VGV4dENvbnRlbnQpO1xuICAgICAgICBjdXJyZW50VGV4dENvbnRlbnQgPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRUZXh0Q29udGVudCArPSB0ZXh0QXJyYXlbaV07XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICB0ZXh0Q29udGVudHMucHVzaChjdXJyZW50VGV4dENvbnRlbnQpO1xuICAgIHJldHVybiB0ZXh0Q29udGVudHM7XG4gIH07XG5cbiAgU1ZHVGV4dExvdHRpZUVsZW1lbnQucHJvdG90eXBlLmJ1aWxkU2hhcGVEYXRhID0gZnVuY3Rpb24gKGRhdGEsIHNjYWxlKSB7XG4gICAgLy8gZGF0YSBzaG91bGQgcHJvYmFibHkgYmUgY2xvbmVkIHRvIGFwcGx5IHNjYWxlIHNlcGFyYXRlbHkgdG8gZWFjaCBpbnN0YW5jZSBvZiBhIHRleHQgb24gZGlmZmVyZW50IGxheWVyc1xuICAgIC8vIGJ1dCBzaW5jZSB0ZXh0IGludGVybmFsIGNvbnRlbnQgZ2V0cyBvbmx5IHJlbmRlcmVkIG9uY2UgYW5kIHRoZW4gaXQncyBuZXZlciByZXJlbmRlcmVkLFxuICAgIC8vIGl0J3MgcHJvYmFibHkgc2FmZSBub3QgdG8gY2xvbmUgZGF0YSBhbmQgcmV1c2UgYWx3YXlzIHRoZSBzYW1lIGluc3RhbmNlIGV2ZW4gaWYgdGhlIG9iamVjdCBpcyBtdXRhdGVkLlxuICAgIC8vIEF2b2lkaW5nIGNsb25pbmcgaXMgcHJlZmVycmVkIHNpbmNlIGNsb25pbmcgZWFjaCBjaGFyYWN0ZXIgc2hhcGUgZGF0YSBpcyBleHBlbnNpdmVcbiAgICBpZiAoZGF0YS5zaGFwZXMgJiYgZGF0YS5zaGFwZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgc2hhcGUgPSBkYXRhLnNoYXBlc1swXTtcblxuICAgICAgaWYgKHNoYXBlLml0KSB7XG4gICAgICAgIHZhciBzaGFwZUl0ZW0gPSBzaGFwZS5pdFtzaGFwZS5pdC5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoc2hhcGVJdGVtLnMpIHtcbiAgICAgICAgICBzaGFwZUl0ZW0ucy5rWzBdID0gc2NhbGU7XG4gICAgICAgICAgc2hhcGVJdGVtLnMua1sxXSA9IHNjYWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgU1ZHVGV4dExvdHRpZUVsZW1lbnQucHJvdG90eXBlLmJ1aWxkTmV3VGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuICAgIHZhciBkb2N1bWVudERhdGEgPSB0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YTtcbiAgICB0aGlzLnJlbmRlcmVkTGV0dGVycyA9IGNyZWF0ZVNpemVkQXJyYXkoZG9jdW1lbnREYXRhID8gZG9jdW1lbnREYXRhLmwubGVuZ3RoIDogMCk7XG5cbiAgICBpZiAoZG9jdW1lbnREYXRhLmZjKSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLmZjKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsbCcsICdyZ2JhKDAsMCwwLDApJyk7XG4gICAgfVxuXG4gICAgaWYgKGRvY3VtZW50RGF0YS5zYykge1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHJva2UnLCB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLnNjKSk7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIGRvY3VtZW50RGF0YS5zdyk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmb250LXNpemUnLCBkb2N1bWVudERhdGEuZmluYWxTaXplKTtcbiAgICB2YXIgZm9udERhdGEgPSB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZik7XG5cbiAgICBpZiAoZm9udERhdGEuZkNsYXNzKSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgZm9udERhdGEuZkNsYXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmb250LWZhbWlseScsIGZvbnREYXRhLmZGYW1pbHkpO1xuICAgICAgdmFyIGZXZWlnaHQgPSBkb2N1bWVudERhdGEuZldlaWdodDtcbiAgICAgIHZhciBmU3R5bGUgPSBkb2N1bWVudERhdGEuZlN0eWxlO1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmb250LXN0eWxlJywgZlN0eWxlKTtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZm9udC13ZWlnaHQnLCBmV2VpZ2h0KTtcbiAgICB9XG5cbiAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBkb2N1bWVudERhdGEudCk7XG4gICAgdmFyIGxldHRlcnMgPSBkb2N1bWVudERhdGEubCB8fCBbXTtcbiAgICB2YXIgdXNlc0dseXBocyA9ICEhdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmNoYXJzO1xuICAgIGxlbiA9IGxldHRlcnMubGVuZ3RoO1xuICAgIHZhciB0U3BhbjtcbiAgICB2YXIgbWF0cml4SGVscGVyID0gdGhpcy5tSGVscGVyO1xuICAgIHZhciBzaGFwZVN0ciA9ICcnO1xuICAgIHZhciBzaW5nbGVTaGFwZSA9IHRoaXMuZGF0YS5zaW5nbGVTaGFwZTtcbiAgICB2YXIgeFBvcyA9IDA7XG4gICAgdmFyIHlQb3MgPSAwO1xuICAgIHZhciBmaXJzdExpbmUgPSB0cnVlO1xuICAgIHZhciB0cmFja2luZ09mZnNldCA9IGRvY3VtZW50RGF0YS50ciAqIDAuMDAxICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcblxuICAgIGlmIChzaW5nbGVTaGFwZSAmJiAhdXNlc0dseXBocyAmJiAhZG9jdW1lbnREYXRhLnN6KSB7XG4gICAgICB2YXIgdEVsZW1lbnQgPSB0aGlzLnRleHRDb250YWluZXI7XG4gICAgICB2YXIganVzdGlmeSA9ICdzdGFydCc7XG5cbiAgICAgIHN3aXRjaCAoZG9jdW1lbnREYXRhLmopIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGp1c3RpZnkgPSAnZW5kJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAganVzdGlmeSA9ICdtaWRkbGUnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAganVzdGlmeSA9ICdzdGFydCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRFbGVtZW50LnNldEF0dHJpYnV0ZSgndGV4dC1hbmNob3InLCBqdXN0aWZ5KTtcbiAgICAgIHRFbGVtZW50LnNldEF0dHJpYnV0ZSgnbGV0dGVyLXNwYWNpbmcnLCB0cmFja2luZ09mZnNldCk7XG4gICAgICB2YXIgdGV4dENvbnRlbnQgPSB0aGlzLmJ1aWxkVGV4dENvbnRlbnRzKGRvY3VtZW50RGF0YS5maW5hbFRleHQpO1xuICAgICAgbGVuID0gdGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgeVBvcyA9IGRvY3VtZW50RGF0YS5wcyA/IGRvY3VtZW50RGF0YS5wc1sxXSArIGRvY3VtZW50RGF0YS5hc2NlbnQgOiAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdFNwYW4gPSB0aGlzLnRleHRTcGFuc1tpXS5zcGFuIHx8IGNyZWF0ZU5TKCd0c3BhbicpO1xuICAgICAgICB0U3Bhbi50ZXh0Q29udGVudCA9IHRleHRDb250ZW50W2ldO1xuICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3gnLCAwKTtcbiAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCd5JywgeVBvcyk7XG4gICAgICAgIHRTcGFuLnN0eWxlLmRpc3BsYXkgPSAnaW5oZXJpdCc7XG4gICAgICAgIHRFbGVtZW50LmFwcGVuZENoaWxkKHRTcGFuKTtcblxuICAgICAgICBpZiAoIXRoaXMudGV4dFNwYW5zW2ldKSB7XG4gICAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0gPSB7XG4gICAgICAgICAgICBzcGFuOiBudWxsLFxuICAgICAgICAgICAgZ2x5cGg6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0uc3BhbiA9IHRTcGFuO1xuICAgICAgICB5UG9zICs9IGRvY3VtZW50RGF0YS5maW5hbExpbmVIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHRFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNhY2hlZFNwYW5zTGVuZ3RoID0gdGhpcy50ZXh0U3BhbnMubGVuZ3RoO1xuICAgICAgdmFyIGNoYXJEYXRhO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRleHRTcGFuc1tpXSkge1xuICAgICAgICAgIHRoaXMudGV4dFNwYW5zW2ldID0ge1xuICAgICAgICAgICAgc3BhbjogbnVsbCxcbiAgICAgICAgICAgIGNoaWxkU3BhbjogbnVsbCxcbiAgICAgICAgICAgIGdseXBoOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXNlc0dseXBocyB8fCAhc2luZ2xlU2hhcGUgfHwgaSA9PT0gMCkge1xuICAgICAgICAgIHRTcGFuID0gY2FjaGVkU3BhbnNMZW5ndGggPiBpID8gdGhpcy50ZXh0U3BhbnNbaV0uc3BhbiA6IGNyZWF0ZU5TKHVzZXNHbHlwaHMgPyAnZycgOiAndGV4dCcpO1xuXG4gICAgICAgICAgaWYgKGNhY2hlZFNwYW5zTGVuZ3RoIDw9IGkpIHtcbiAgICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCAnYnV0dCcpO1xuICAgICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCAncm91bmQnKTtcbiAgICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW1pdGVybGltaXQnLCAnNCcpO1xuICAgICAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0uc3BhbiA9IHRTcGFuO1xuXG4gICAgICAgICAgICBpZiAodXNlc0dseXBocykge1xuICAgICAgICAgICAgICB2YXIgY2hpbGRTcGFuID0gY3JlYXRlTlMoJ2cnKTtcbiAgICAgICAgICAgICAgdFNwYW4uYXBwZW5kQ2hpbGQoY2hpbGRTcGFuKTtcbiAgICAgICAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0uY2hpbGRTcGFuID0gY2hpbGRTcGFuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRleHRTcGFuc1tpXS5zcGFuID0gdFNwYW47XG4gICAgICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZCh0U3Bhbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdFNwYW4uc3R5bGUuZGlzcGxheSA9ICdpbmhlcml0JztcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdHJpeEhlbHBlci5yZXNldCgpO1xuXG4gICAgICAgIGlmIChzaW5nbGVTaGFwZSkge1xuICAgICAgICAgIGlmIChsZXR0ZXJzW2ldLm4pIHtcbiAgICAgICAgICAgIHhQb3MgPSAtdHJhY2tpbmdPZmZzZXQ7XG4gICAgICAgICAgICB5UG9zICs9IGRvY3VtZW50RGF0YS55T2Zmc2V0O1xuICAgICAgICAgICAgeVBvcyArPSBmaXJzdExpbmUgPyAxIDogMDtcbiAgICAgICAgICAgIGZpcnN0TGluZSA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYXBwbHlUZXh0UHJvcGVydGllc1RvTWF0cml4KGRvY3VtZW50RGF0YSwgbWF0cml4SGVscGVyLCBsZXR0ZXJzW2ldLmxpbmUsIHhQb3MsIHlQb3MpO1xuICAgICAgICAgIHhQb3MgKz0gbGV0dGVyc1tpXS5sIHx8IDA7IC8vIHhQb3MgKz0gbGV0dGVyc1tpXS52YWwgPT09ICcgJyA/IDAgOiB0cmFja2luZ09mZnNldDtcblxuICAgICAgICAgIHhQb3MgKz0gdHJhY2tpbmdPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXNlc0dseXBocykge1xuICAgICAgICAgIGNoYXJEYXRhID0gdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldENoYXJEYXRhKGRvY3VtZW50RGF0YS5maW5hbFRleHRbaV0sIGZvbnREYXRhLmZTdHlsZSwgdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpLmZGYW1pbHkpO1xuICAgICAgICAgIHZhciBnbHlwaEVsZW1lbnQ7IC8vIHQgPT09IDEgbWVhbnMgdGhlIGNoYXJhY3RlciBoYXMgYmVlbiByZXBsYWNlZCB3aXRoIGFuIGFuaW1hdGVkIHNoYXBlZFxuXG4gICAgICAgICAgaWYgKGNoYXJEYXRhLnQgPT09IDEpIHtcbiAgICAgICAgICAgIGdseXBoRWxlbWVudCA9IG5ldyBTVkdDb21wRWxlbWVudChjaGFyRGF0YS5kYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGVtcHR5U2hhcGVEYXRhO1xuXG4gICAgICAgICAgICBpZiAoY2hhckRhdGEuZGF0YSAmJiBjaGFyRGF0YS5kYXRhLnNoYXBlcykge1xuICAgICAgICAgICAgICBkYXRhID0gdGhpcy5idWlsZFNoYXBlRGF0YShjaGFyRGF0YS5kYXRhLCBkb2N1bWVudERhdGEuZmluYWxTaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2x5cGhFbGVtZW50ID0gbmV3IFNWR1NoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnRleHRTcGFuc1tpXS5nbHlwaCkge1xuICAgICAgICAgICAgdmFyIGdseXBoID0gdGhpcy50ZXh0U3BhbnNbaV0uZ2x5cGg7XG4gICAgICAgICAgICB0aGlzLnRleHRTcGFuc1tpXS5jaGlsZFNwYW4ucmVtb3ZlQ2hpbGQoZ2x5cGgubGF5ZXJFbGVtZW50KTtcbiAgICAgICAgICAgIGdseXBoLmRlc3Ryb3koKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnRleHRTcGFuc1tpXS5nbHlwaCA9IGdseXBoRWxlbWVudDtcbiAgICAgICAgICBnbHlwaEVsZW1lbnQuX2RlYnVnID0gdHJ1ZTtcbiAgICAgICAgICBnbHlwaEVsZW1lbnQucHJlcGFyZUZyYW1lKDApO1xuICAgICAgICAgIGdseXBoRWxlbWVudC5yZW5kZXJGcmFtZSgpO1xuICAgICAgICAgIHRoaXMudGV4dFNwYW5zW2ldLmNoaWxkU3Bhbi5hcHBlbmRDaGlsZChnbHlwaEVsZW1lbnQubGF5ZXJFbGVtZW50KTsgLy8gd2hlbiB1c2luZyBhbmltYXRlZCBzaGFwZXMsIHRoZSBsYXllciB3aWxsIGJlIHNjYWxlZCBpbnN0ZWFkIG9mIHJlcGxhY2luZyB0aGUgaW50ZXJuYWwgc2NhbGVcbiAgICAgICAgICAvLyB0aGlzIG1pZ2h0IGhhdmUgaXNzdWVzIHdpdGggc3Ryb2tlcyBhbmQgbWlnaHQgbmVlZCBhIGRpZmZlcmVudCBzb2x1dGlvblxuXG4gICAgICAgICAgaWYgKGNoYXJEYXRhLnQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dFNwYW5zW2ldLmNoaWxkU3Bhbi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsICdzY2FsZSgnICsgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMCArICcsJyArIGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDAgKyAnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2luZ2xlU2hhcGUpIHtcbiAgICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWF0cml4SGVscGVyLnByb3BzWzEyXSArICcsJyArIG1hdHJpeEhlbHBlci5wcm9wc1sxM10gKyAnKScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRTcGFuLnRleHRDb250ZW50ID0gbGV0dGVyc1tpXS52YWw7XG4gICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsICd4bWw6c3BhY2UnLCAncHJlc2VydmUnKTtcbiAgICAgICAgfSAvL1xuXG4gICAgICB9XG5cbiAgICAgIGlmIChzaW5nbGVTaGFwZSAmJiB0U3Bhbikge1xuICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ2QnLCBzaGFwZVN0cik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKGkgPCB0aGlzLnRleHRTcGFucy5sZW5ndGgpIHtcbiAgICAgIHRoaXMudGV4dFNwYW5zW2ldLnNwYW4uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICB0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XG4gIH07XG5cbiAgU1ZHVGV4dExvdHRpZUVsZW1lbnQucHJvdG90eXBlLnNvdXJjZVJlY3RBdFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcmVwYXJlRnJhbWUodGhpcy5jb21wLnJlbmRlcmVkRnJhbWUgLSB0aGlzLmRhdGEuc3QpO1xuICAgIHRoaXMucmVuZGVySW5uZXJDb250ZW50KCk7XG5cbiAgICBpZiAodGhpcy5fc2l6ZUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgdGV4dEJveCA9IHRoaXMubGF5ZXJFbGVtZW50LmdldEJCb3goKTtcbiAgICAgIHRoaXMuYmJveCA9IHtcbiAgICAgICAgdG9wOiB0ZXh0Qm94LnksXG4gICAgICAgIGxlZnQ6IHRleHRCb3gueCxcbiAgICAgICAgd2lkdGg6IHRleHRCb3gud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGV4dEJveC5oZWlnaHRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYmJveDtcbiAgfTtcblxuICBTVkdUZXh0TG90dGllRWxlbWVudC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMudGV4dFNwYW5zLmxlbmd0aDtcbiAgICB2YXIgZ2x5cGhFbGVtZW50O1xuICAgIHRoaXMucmVuZGVyZWRGcmFtZSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBnbHlwaEVsZW1lbnQgPSB0aGlzLnRleHRTcGFuc1tpXS5nbHlwaDtcblxuICAgICAgaWYgKGdseXBoRWxlbWVudCkge1xuICAgICAgICBnbHlwaEVsZW1lbnQucHJlcGFyZUZyYW1lKHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lIC0gdGhpcy5kYXRhLnN0KTtcblxuICAgICAgICBpZiAoZ2x5cGhFbGVtZW50Ll9tZGYpIHtcbiAgICAgICAgICB0aGlzLl9tZGYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNWR1RleHRMb3R0aWVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy52YWxpZGF0ZVRleHQoKTtcblxuICAgIGlmICghdGhpcy5kYXRhLnNpbmdsZVNoYXBlIHx8IHRoaXMuX21kZikge1xuICAgICAgdGhpcy50ZXh0QW5pbWF0b3IuZ2V0TWVhc3VyZXModGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEsIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnKTtcblxuICAgICAgaWYgKHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnIHx8IHRoaXMudGV4dEFuaW1hdG9yLmxldHRlcnNDaGFuZ2VkRmxhZykge1xuICAgICAgICB0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuO1xuICAgICAgICB2YXIgcmVuZGVyZWRMZXR0ZXJzID0gdGhpcy50ZXh0QW5pbWF0b3IucmVuZGVyZWRMZXR0ZXJzO1xuICAgICAgICB2YXIgbGV0dGVycyA9IHRoaXMudGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLmw7XG4gICAgICAgIGxlbiA9IGxldHRlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgcmVuZGVyZWRMZXR0ZXI7XG4gICAgICAgIHZhciB0ZXh0U3BhbjtcbiAgICAgICAgdmFyIGdseXBoRWxlbWVudDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoIWxldHRlcnNbaV0ubikge1xuICAgICAgICAgICAgcmVuZGVyZWRMZXR0ZXIgPSByZW5kZXJlZExldHRlcnNbaV07XG4gICAgICAgICAgICB0ZXh0U3BhbiA9IHRoaXMudGV4dFNwYW5zW2ldLnNwYW47XG4gICAgICAgICAgICBnbHlwaEVsZW1lbnQgPSB0aGlzLnRleHRTcGFuc1tpXS5nbHlwaDtcblxuICAgICAgICAgICAgaWYgKGdseXBoRWxlbWVudCkge1xuICAgICAgICAgICAgICBnbHlwaEVsZW1lbnQucmVuZGVyRnJhbWUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLl9tZGYubSkge1xuICAgICAgICAgICAgICB0ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIHJlbmRlcmVkTGV0dGVyLm0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuX21kZi5vKSB7XG4gICAgICAgICAgICAgIHRleHRTcGFuLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsIHJlbmRlcmVkTGV0dGVyLm8pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuX21kZi5zdykge1xuICAgICAgICAgICAgICB0ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIHJlbmRlcmVkTGV0dGVyLnN3KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLl9tZGYuc2MpIHtcbiAgICAgICAgICAgICAgdGV4dFNwYW4uc2V0QXR0cmlidXRlKCdzdHJva2UnLCByZW5kZXJlZExldHRlci5zYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZW5kZXJlZExldHRlci5fbWRmLmZjKSB7XG4gICAgICAgICAgICAgIHRleHRTcGFuLnNldEF0dHJpYnV0ZSgnZmlsbCcsIHJlbmRlcmVkTGV0dGVyLmZjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gSVNvbGlkRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbSUltYWdlRWxlbWVudF0sIElTb2xpZEVsZW1lbnQpO1xuXG4gIElTb2xpZEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlY3QgPSBjcmVhdGVOUygncmVjdCcpOyAvLy8gL3JlY3Quc3R5bGUud2lkdGggPSB0aGlzLmRhdGEuc3c7XG4gICAgLy8vIC9yZWN0LnN0eWxlLmhlaWdodCA9IHRoaXMuZGF0YS5zaDtcbiAgICAvLy8gL3JlY3Quc3R5bGUuZmlsbCA9IHRoaXMuZGF0YS5zYztcblxuICAgIHJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuZGF0YS5zdyk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuZGF0YS5zaCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCB0aGlzLmRhdGEuc2MpO1xuICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHJlY3QpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIE51bGxFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmluaXRGcmFtZSgpO1xuICAgIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMuaW5pdEZyYW1lKCk7XG4gICAgdGhpcy5pbml0VHJhbnNmb3JtKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMuaW5pdEhpZXJhcmNoeSgpO1xuICB9XG5cbiAgTnVsbEVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdHJ1ZSk7XG4gIH07XG5cbiAgTnVsbEVsZW1lbnQucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKCkge307XG5cbiAgTnVsbEVsZW1lbnQucHJvdG90eXBlLmdldEJhc2VFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIE51bGxFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge307XG5cbiAgTnVsbEVsZW1lbnQucHJvdG90eXBlLnNvdXJjZVJlY3RBdFRpbWUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBOdWxsRWxlbWVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudF0sIE51bGxFbGVtZW50KTtcblxuICBmdW5jdGlvbiBTVkdSZW5kZXJlckJhc2UoKSB7fVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZVJlbmRlcmVyXSwgU1ZHUmVuZGVyZXJCYXNlKTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZU51bGwgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgTnVsbEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZVNoYXBlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFNWR1NoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBTVkdUZXh0TG90dGllRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlSW1hZ2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgSUltYWdlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlU29saWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgSVNvbGlkRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY29uZmlnQW5pbWF0aW9uID0gZnVuY3Rpb24gKGFuaW1EYXRhKSB7XG4gICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnKTtcbiAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd4bWxuczp4bGluaycsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyk7XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcudmlld0JveFNpemUpIHtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCB0aGlzLnJlbmRlckNvbmZpZy52aWV3Qm94U2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCAnMCAwICcgKyBhbmltRGF0YS53ICsgJyAnICsgYW5pbURhdGEuaCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnJlbmRlckNvbmZpZy52aWV3Qm94T25seSkge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBhbmltRGF0YS53KTtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGFuaW1EYXRhLmgpO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMCwwLDApJztcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zdHlsZS5jb250ZW50VmlzaWJpbGl0eSA9IHRoaXMucmVuZGVyQ29uZmlnLmNvbnRlbnRWaXNpYmlsaXR5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy53aWR0aCkge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLnJlbmRlckNvbmZpZy53aWR0aCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmhlaWdodCkge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5yZW5kZXJDb25maWcuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKSB7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIHRoaXMucmVuZGVyQ29uZmlnLmNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmlkKSB7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMucmVuZGVyQ29uZmlnLmlkKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuZm9jdXNhYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScsIHRoaXMucmVuZGVyQ29uZmlnLmZvY3VzYWJsZSk7XG4gICAgfVxuXG4gICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsIHRoaXMucmVuZGVyQ29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8pOyAvLyB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMCwwLDApJztcbiAgICAvLyB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS5tb3pUcmFuc2Zvcm1PcmlnaW4gPSB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSB0aGlzLmxheWVyRWxlbWVudC5zdHlsZVsnLXdlYmtpdC10cmFuc2Zvcm0nXSA9IFwiMHB4IDBweCAwcHhcIjtcblxuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuc3ZnRWxlbWVudCk7IC8vIE1hc2sgYW5pbWF0aW9uXG5cbiAgICB2YXIgZGVmcyA9IHRoaXMuZ2xvYmFsRGF0YS5kZWZzO1xuICAgIHRoaXMuc2V0dXBHbG9iYWxEYXRhKGFuaW1EYXRhLCBkZWZzKTtcbiAgICB0aGlzLmdsb2JhbERhdGEucHJvZ3Jlc3NpdmVMb2FkID0gdGhpcy5yZW5kZXJDb25maWcucHJvZ3Jlc3NpdmVMb2FkO1xuICAgIHRoaXMuZGF0YSA9IGFuaW1EYXRhO1xuICAgIHZhciBtYXNrRWxlbWVudCA9IGNyZWF0ZU5TKCdjbGlwUGF0aCcpO1xuICAgIHZhciByZWN0ID0gY3JlYXRlTlMoJ3JlY3QnKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBhbmltRGF0YS53KTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYW5pbURhdGEuaCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3gnLCAwKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgneScsIDApO1xuICAgIHZhciBtYXNrSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICBtYXNrRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgbWFza0lkKTtcbiAgICBtYXNrRWxlbWVudC5hcHBlbmRDaGlsZChyZWN0KTtcbiAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgbWFza0lkICsgJyknKTtcbiAgICBkZWZzLmFwcGVuZENoaWxkKG1hc2tFbGVtZW50KTtcbiAgICB0aGlzLmxheWVycyA9IGFuaW1EYXRhLmxheWVycztcbiAgICB0aGlzLmVsZW1lbnRzID0gY3JlYXRlU2l6ZWRBcnJheShhbmltRGF0YS5sYXllcnMubGVuZ3RoKTtcbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5pbm5lclRleHQgPSAnJztcbiAgICB9XG5cbiAgICB0aGlzLmxheWVyRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMgPSBudWxsO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycyA/IHRoaXMubGF5ZXJzLmxlbmd0aCA6IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldICYmIHRoaXMuZWxlbWVudHNbaV0uZGVzdHJveSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbSA9IG51bGw7XG4gIH07XG5cbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS51cGRhdGVDb250YWluZXJTaXplID0gZnVuY3Rpb24gKCkge307XG5cbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5maW5kSW5kZXhCeUluZCA9IGZ1bmN0aW9uIChpbmQpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMubGF5ZXJzW2ldLmluZCA9PT0gaW5kKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmJ1aWxkSXRlbSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgaWYgKGVsZW1lbnRzW3Bvc10gfHwgdGhpcy5sYXllcnNbcG9zXS50eSA9PT0gOTkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50c1twb3NdID0gdHJ1ZTtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuY3JlYXRlSXRlbSh0aGlzLmxheWVyc1twb3NdKTtcbiAgICBlbGVtZW50c1twb3NdID0gZWxlbWVudDtcblxuICAgIGlmIChnZXRFeHByZXNzaW9uc1BsdWdpbigpKSB7XG4gICAgICBpZiAodGhpcy5sYXllcnNbcG9zXS50eSA9PT0gMCkge1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5yZWdpc3RlckNvbXBvc2l0aW9uKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmluaXRFeHByZXNzaW9ucygpO1xuICAgIH1cblxuICAgIHRoaXMuYXBwZW5kRWxlbWVudEluUG9zKGVsZW1lbnQsIHBvcyk7XG5cbiAgICBpZiAodGhpcy5sYXllcnNbcG9zXS50dCkge1xuICAgICAgdmFyIGVsZW1lbnRJbmRleCA9ICd0cCcgaW4gdGhpcy5sYXllcnNbcG9zXSA/IHRoaXMuZmluZEluZGV4QnlJbmQodGhpcy5sYXllcnNbcG9zXS50cCkgOiBwb3MgLSAxO1xuXG4gICAgICBpZiAoZWxlbWVudEluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5lbGVtZW50c1tlbGVtZW50SW5kZXhdIHx8IHRoaXMuZWxlbWVudHNbZWxlbWVudEluZGV4XSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJ1aWxkSXRlbShlbGVtZW50SW5kZXgpO1xuICAgICAgICB0aGlzLmFkZFBlbmRpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1hdHRlRWxlbWVudCA9IGVsZW1lbnRzW2VsZW1lbnRJbmRleF07XG4gICAgICAgIHZhciBtYXR0ZU1hc2sgPSBtYXR0ZUVsZW1lbnQuZ2V0TWF0dGUodGhpcy5sYXllcnNbcG9zXS50dCk7XG4gICAgICAgIGVsZW1lbnQuc2V0TWF0dGUobWF0dGVNYXNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jaGVja1BlbmRpbmdFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB3aGlsZSAodGhpcy5wZW5kaW5nRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGVuZGluZ0VsZW1lbnRzLnBvcCgpO1xuICAgICAgZWxlbWVudC5jaGVja1BhcmVudGluZygpO1xuXG4gICAgICBpZiAoZWxlbWVudC5kYXRhLnR0KSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0gPT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50SW5kZXggPSAndHAnIGluIGVsZW1lbnQuZGF0YSA/IHRoaXMuZmluZEluZGV4QnlJbmQoZWxlbWVudC5kYXRhLnRwKSA6IGkgLSAxO1xuICAgICAgICAgICAgdmFyIG1hdHRlRWxlbWVudCA9IHRoaXMuZWxlbWVudHNbZWxlbWVudEluZGV4XTtcbiAgICAgICAgICAgIHZhciBtYXR0ZU1hc2sgPSBtYXR0ZUVsZW1lbnQuZ2V0TWF0dGUodGhpcy5sYXllcnNbaV0udHQpO1xuICAgICAgICAgICAgZWxlbWVudC5zZXRNYXR0ZShtYXR0ZU1hc2spO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZWRGcmFtZSA9PT0gbnVtIHx8IHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG51bSA9PT0gbnVsbCkge1xuICAgICAgbnVtID0gdGhpcy5yZW5kZXJlZEZyYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSBudW07XG4gICAgfSAvLyBjb25zb2xlLmxvZygnLS0tLS0tLScpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdGUkFNRSAnLG51bSk7XG5cblxuICAgIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZU51bSA9IG51bTtcbiAgICB0aGlzLmdsb2JhbERhdGEuZnJhbWVJZCArPSAxO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5wcm9qZWN0SW50ZXJmYWNlLmN1cnJlbnRGcmFtZSA9IG51bTtcbiAgICB0aGlzLmdsb2JhbERhdGEuX21kZiA9IGZhbHNlO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG5cbiAgICBpZiAoIXRoaXMuY29tcGxldGVMYXllcnMpIHtcbiAgICAgIHRoaXMuY2hlY2tMYXllcnMobnVtKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnByZXBhcmVGcmFtZShudW0gLSB0aGlzLmxheWVyc1tpXS5zdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ2xvYmFsRGF0YS5fbWRmKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudHNbaV0ucmVuZGVyRnJhbWUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmFwcGVuZEVsZW1lbnRJblBvcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBwb3MpIHtcbiAgICB2YXIgbmV3RWxlbWVudCA9IGVsZW1lbnQuZ2V0QmFzZUVsZW1lbnQoKTtcblxuICAgIGlmICghbmV3RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbmV4dEVsZW1lbnQ7XG5cbiAgICB3aGlsZSAoaSA8IHBvcykge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0gJiYgdGhpcy5lbGVtZW50c1tpXSAhPT0gdHJ1ZSAmJiB0aGlzLmVsZW1lbnRzW2ldLmdldEJhc2VFbGVtZW50KCkpIHtcbiAgICAgICAgbmV4dEVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2ldLmdldEJhc2VFbGVtZW50KCk7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICBpZiAobmV4dEVsZW1lbnQpIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50Lmluc2VydEJlZm9yZShuZXdFbGVtZW50LCBuZXh0RWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKG5ld0VsZW1lbnQpO1xuICAgIH1cbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5sYXllckVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5sYXllckVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gIH07XG5cbiAgZnVuY3Rpb24gSUNvbXBFbGVtZW50KCkge31cblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50XSwgSUNvbXBFbGVtZW50KTtcblxuICBJQ29tcEVsZW1lbnQucHJvdG90eXBlLmluaXRFbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmluaXRGcmFtZSgpO1xuICAgIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMuaW5pdFRyYW5zZm9ybShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICB0aGlzLmluaXRSZW5kZXJhYmxlKCk7XG4gICAgdGhpcy5pbml0SGllcmFyY2h5KCk7XG4gICAgdGhpcy5pbml0UmVuZGVyZXJFbGVtZW50KCk7XG4gICAgdGhpcy5jcmVhdGVDb250YWluZXJFbGVtZW50cygpO1xuICAgIHRoaXMuY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHMoKTtcblxuICAgIGlmICh0aGlzLmRhdGEueHQgfHwgIWdsb2JhbERhdGEucHJvZ3Jlc3NpdmVMb2FkKSB7XG4gICAgICB0aGlzLmJ1aWxkQWxsSXRlbXMoKTtcbiAgICB9XG5cbiAgICB0aGlzLmhpZGUoKTtcbiAgfTtcbiAgLyogSUNvbXBFbGVtZW50LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKXtcclxuICAgICAgaWYoIXRoaXMuaGlkZGVuKXtcclxuICAgICAgICAgIHRoaXMuaGlkZUVsZW1lbnQoKTtcclxuICAgICAgICAgIHZhciBpLGxlbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICAgICAgZm9yKCBpID0gMDsgaSA8IGxlbjsgaSs9MSApe1xyXG4gICAgICAgICAgICAgIGlmKHRoaXMuZWxlbWVudHNbaV0pe1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmhpZGUoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICB9OyAqL1xuXG5cbiAgSUNvbXBFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgdGhpcy5wcmVwYXJlUmVuZGVyYWJsZUZyYW1lKG51bSk7XG4gICAgdGhpcy5wcmVwYXJlUHJvcGVydGllcyhudW0sIHRoaXMuaXNJblJhbmdlKTtcblxuICAgIGlmICghdGhpcy5pc0luUmFuZ2UgJiYgIXRoaXMuZGF0YS54dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy50bS5fcGxhY2Vob2xkZXIpIHtcbiAgICAgIHZhciB0aW1lUmVtYXBwZWQgPSB0aGlzLnRtLnY7XG5cbiAgICAgIGlmICh0aW1lUmVtYXBwZWQgPT09IHRoaXMuZGF0YS5vcCkge1xuICAgICAgICB0aW1lUmVtYXBwZWQgPSB0aGlzLmRhdGEub3AgLSAxO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSB0aW1lUmVtYXBwZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZWRGcmFtZSA9IG51bSAvIHRoaXMuZGF0YS5zcjtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG5cbiAgICBpZiAoIXRoaXMuY29tcGxldGVMYXllcnMpIHtcbiAgICAgIHRoaXMuY2hlY2tMYXllcnModGhpcy5yZW5kZXJlZEZyYW1lKTtcbiAgICB9IC8vIFRoaXMgaXRlcmF0aW9uIG5lZWRzIHRvIGJlIGJhY2t3YXJkcyBiZWNhdXNlIG9mIGhvdyBleHByZXNzaW9ucyBjb25uZWN0IGJldHdlZW4gZWFjaCBvdGhlclxuXG5cbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnByZXBhcmVGcmFtZSh0aGlzLnJlbmRlcmVkRnJhbWUgLSB0aGlzLmxheWVyc1tpXS5zdCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0uX21kZikge1xuICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSUNvbXBFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnJlbmRlckZyYW1lKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIElDb21wRWxlbWVudC5wcm90b3R5cGUuc2V0RWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlbXMpIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbXM7XG4gIH07XG5cbiAgSUNvbXBFbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50cztcbiAgfTtcblxuICBJQ29tcEVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3lFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSUNvbXBFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVzdHJveUVsZW1lbnRzKCk7XG4gICAgdGhpcy5kZXN0cm95QmFzZUVsZW1lbnQoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBTVkdDb21wRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5sYXllcnMgPSBkYXRhLmxheWVycztcbiAgICB0aGlzLnN1cHBvcnRzM2QgPSB0cnVlO1xuICAgIHRoaXMuY29tcGxldGVMYXllcnMgPSBmYWxzZTtcbiAgICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuZWxlbWVudHMgPSB0aGlzLmxheWVycyA/IGNyZWF0ZVNpemVkQXJyYXkodGhpcy5sYXllcnMubGVuZ3RoKSA6IFtdO1xuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy50bSA9IGRhdGEudG0gPyBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLnRtLCAwLCBnbG9iYWxEYXRhLmZyYW1lUmF0ZSwgdGhpcykgOiB7XG4gICAgICBfcGxhY2Vob2xkZXI6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtTVkdSZW5kZXJlckJhc2UsIElDb21wRWxlbWVudCwgU1ZHQmFzZUVsZW1lbnRdLCBTVkdDb21wRWxlbWVudCk7XG5cbiAgU1ZHQ29tcEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgU1ZHQ29tcEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBmdW5jdGlvbiBTVkdSZW5kZXJlcihhbmltYXRpb25JdGVtLCBjb25maWcpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0gPSBhbmltYXRpb25JdGVtO1xuICAgIHRoaXMubGF5ZXJzID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSAtMTtcbiAgICB0aGlzLnN2Z0VsZW1lbnQgPSBjcmVhdGVOUygnc3ZnJyk7XG4gICAgdmFyIGFyaWFMYWJlbCA9ICcnO1xuXG4gICAgaWYgKGNvbmZpZyAmJiBjb25maWcudGl0bGUpIHtcbiAgICAgIHZhciB0aXRsZUVsZW1lbnQgPSBjcmVhdGVOUygndGl0bGUnKTtcbiAgICAgIHZhciB0aXRsZUlkID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgICB0aXRsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRpdGxlSWQpO1xuICAgICAgdGl0bGVFbGVtZW50LnRleHRDb250ZW50ID0gY29uZmlnLnRpdGxlO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LmFwcGVuZENoaWxkKHRpdGxlRWxlbWVudCk7XG4gICAgICBhcmlhTGFiZWwgKz0gdGl0bGVJZDtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5kZXNjcmlwdGlvbikge1xuICAgICAgdmFyIGRlc2NFbGVtZW50ID0gY3JlYXRlTlMoJ2Rlc2MnKTtcbiAgICAgIHZhciBkZXNjSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICAgIGRlc2NFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBkZXNjSWQpO1xuICAgICAgZGVzY0VsZW1lbnQudGV4dENvbnRlbnQgPSBjb25maWcuZGVzY3JpcHRpb247XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQoZGVzY0VsZW1lbnQpO1xuICAgICAgYXJpYUxhYmVsICs9ICcgJyArIGRlc2NJZDtcbiAgICB9XG5cbiAgICBpZiAoYXJpYUxhYmVsKSB7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsbGVkYnknLCBhcmlhTGFiZWwpO1xuICAgIH1cblxuICAgIHZhciBkZWZzID0gY3JlYXRlTlMoJ2RlZnMnKTtcbiAgICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQoZGVmcyk7XG4gICAgdmFyIG1hc2tFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcbiAgICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQobWFza0VsZW1lbnQpO1xuICAgIHRoaXMubGF5ZXJFbGVtZW50ID0gbWFza0VsZW1lbnQ7XG4gICAgdGhpcy5yZW5kZXJDb25maWcgPSB7XG4gICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBjb25maWcgJiYgY29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8gfHwgJ3hNaWRZTWlkIG1lZXQnLFxuICAgICAgaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvOiBjb25maWcgJiYgY29uZmlnLmltYWdlUHJlc2VydmVBc3BlY3RSYXRpbyB8fCAneE1pZFlNaWQgc2xpY2UnLFxuICAgICAgY29udGVudFZpc2liaWxpdHk6IGNvbmZpZyAmJiBjb25maWcuY29udGVudFZpc2liaWxpdHkgfHwgJ3Zpc2libGUnLFxuICAgICAgcHJvZ3Jlc3NpdmVMb2FkOiBjb25maWcgJiYgY29uZmlnLnByb2dyZXNzaXZlTG9hZCB8fCBmYWxzZSxcbiAgICAgIGhpZGVPblRyYW5zcGFyZW50OiAhKGNvbmZpZyAmJiBjb25maWcuaGlkZU9uVHJhbnNwYXJlbnQgPT09IGZhbHNlKSxcbiAgICAgIHZpZXdCb3hPbmx5OiBjb25maWcgJiYgY29uZmlnLnZpZXdCb3hPbmx5IHx8IGZhbHNlLFxuICAgICAgdmlld0JveFNpemU6IGNvbmZpZyAmJiBjb25maWcudmlld0JveFNpemUgfHwgZmFsc2UsXG4gICAgICBjbGFzc05hbWU6IGNvbmZpZyAmJiBjb25maWcuY2xhc3NOYW1lIHx8ICcnLFxuICAgICAgaWQ6IGNvbmZpZyAmJiBjb25maWcuaWQgfHwgJycsXG4gICAgICBmb2N1c2FibGU6IGNvbmZpZyAmJiBjb25maWcuZm9jdXNhYmxlLFxuICAgICAgZmlsdGVyU2l6ZToge1xuICAgICAgICB3aWR0aDogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLndpZHRoIHx8ICcxMDAlJyxcbiAgICAgICAgaGVpZ2h0OiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUuaGVpZ2h0IHx8ICcxMDAlJyxcbiAgICAgICAgeDogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLnggfHwgJzAlJyxcbiAgICAgICAgeTogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLnkgfHwgJzAlJ1xuICAgICAgfSxcbiAgICAgIHdpZHRoOiBjb25maWcgJiYgY29uZmlnLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjb25maWcgJiYgY29uZmlnLmhlaWdodCxcbiAgICAgIHJ1bkV4cHJlc3Npb25zOiAhY29uZmlnIHx8IGNvbmZpZy5ydW5FeHByZXNzaW9ucyA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5ydW5FeHByZXNzaW9uc1xuICAgIH07XG4gICAgdGhpcy5nbG9iYWxEYXRhID0ge1xuICAgICAgX21kZjogZmFsc2UsXG4gICAgICBmcmFtZU51bTogLTEsXG4gICAgICBkZWZzOiBkZWZzLFxuICAgICAgcmVuZGVyQ29uZmlnOiB0aGlzLnJlbmRlckNvbmZpZ1xuICAgIH07XG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICAgIHRoaXMucGVuZGluZ0VsZW1lbnRzID0gW107XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmVyVHlwZSA9ICdzdmcnO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtTVkdSZW5kZXJlckJhc2VdLCBTVkdSZW5kZXJlcik7XG5cbiAgU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNvbXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgU1ZHQ29tcEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBmdW5jdGlvbiBTaGFwZVRyYW5zZm9ybU1hbmFnZXIoKSB7XG4gICAgdGhpcy5zZXF1ZW5jZXMgPSB7fTtcbiAgICB0aGlzLnNlcXVlbmNlTGlzdCA9IFtdO1xuICAgIHRoaXMudHJhbnNmb3JtX2tleV9jb3VudCA9IDA7XG4gIH1cblxuICBTaGFwZVRyYW5zZm9ybU1hbmFnZXIucHJvdG90eXBlID0ge1xuICAgIGFkZFRyYW5zZm9ybVNlcXVlbmNlOiBmdW5jdGlvbiBhZGRUcmFuc2Zvcm1TZXF1ZW5jZSh0cmFuc2Zvcm1zKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgIHZhciBrZXkgPSAnXyc7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBrZXkgKz0gdHJhbnNmb3Jtc1tpXS50cmFuc2Zvcm0ua2V5ICsgJ18nO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VxdWVuY2UgPSB0aGlzLnNlcXVlbmNlc1trZXldO1xuXG4gICAgICBpZiAoIXNlcXVlbmNlKSB7XG4gICAgICAgIHNlcXVlbmNlID0ge1xuICAgICAgICAgIHRyYW5zZm9ybXM6IFtdLmNvbmNhdCh0cmFuc2Zvcm1zKSxcbiAgICAgICAgICBmaW5hbFRyYW5zZm9ybTogbmV3IE1hdHJpeCgpLFxuICAgICAgICAgIF9tZGY6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VxdWVuY2VzW2tleV0gPSBzZXF1ZW5jZTtcbiAgICAgICAgdGhpcy5zZXF1ZW5jZUxpc3QucHVzaChzZXF1ZW5jZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXF1ZW5jZTtcbiAgICB9LFxuICAgIHByb2Nlc3NTZXF1ZW5jZTogZnVuY3Rpb24gcHJvY2Vzc1NlcXVlbmNlKHNlcXVlbmNlLCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSBzZXF1ZW5jZS50cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgIHZhciBfbWRmID0gaXNGaXJzdEZyYW1lO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbiAmJiAhaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIGlmIChzZXF1ZW5jZS50cmFuc2Zvcm1zW2ldLnRyYW5zZm9ybS5tUHJvcHMuX21kZikge1xuICAgICAgICAgIF9tZGYgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoX21kZikge1xuICAgICAgICBzZXF1ZW5jZS5maW5hbFRyYW5zZm9ybS5yZXNldCgpO1xuXG4gICAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgc2VxdWVuY2UuZmluYWxUcmFuc2Zvcm0ubXVsdGlwbHkoc2VxdWVuY2UudHJhbnNmb3Jtc1tpXS50cmFuc2Zvcm0ubVByb3BzLnYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlcXVlbmNlLl9tZGYgPSBfbWRmO1xuICAgIH0sXG4gICAgcHJvY2Vzc1NlcXVlbmNlczogZnVuY3Rpb24gcHJvY2Vzc1NlcXVlbmNlcyhpc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuc2VxdWVuY2VMaXN0Lmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1NlcXVlbmNlKHRoaXMuc2VxdWVuY2VMaXN0W2ldLCBpc0ZpcnN0RnJhbWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0TmV3S2V5OiBmdW5jdGlvbiBnZXROZXdLZXkoKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybV9rZXlfY291bnQgKz0gMTtcbiAgICAgIHJldHVybiAnXycgKyB0aGlzLnRyYW5zZm9ybV9rZXlfY291bnQ7XG4gICAgfVxuICB9O1xuXG4gIHZhciBsdW1hTG9hZGVyID0gZnVuY3Rpb24gbHVtYUxvYWRlcigpIHtcbiAgICB2YXIgaWQgPSAnX19sb3R0aWVfZWxlbWVudF9sdW1hX2J1ZmZlcic7XG4gICAgdmFyIGx1bWFCdWZmZXIgPSBudWxsO1xuICAgIHZhciBsdW1hQnVmZmVyQ3R4ID0gbnVsbDtcbiAgICB2YXIgc3ZnID0gbnVsbDsgLy8gVGhpcyBhbHRlcm5hdGUgc29sdXRpb24gaGFzIGEgc2xpZ2h0IGRlbGF5IGJlZm9yZSB0aGUgZmlsdGVyIGlzIGFwcGxpZWQsIHJlc3VsdGluZyBpbiBhIGZsaWNrZXIgb24gdGhlIGZpcnN0IGZyYW1lLlxuICAgIC8vIEtlZXBpbmcgdGhpcyBoZXJlIGZvciByZWZlcmVuY2UsIGFuZCBpbiB0aGUgZnV0dXJlLCBpZiBvZmZzY3JlZW4gY2FudmFzIHN1cHBvcnRzIHVybCBmaWx0ZXJzLCB0aGlzIGNhbiBiZSB1c2VkLlxuICAgIC8vIEZvciBub3csIG5laXRoZXIgb2YgdGhlbSB3b3JrIGZvciBvZmZzY3JlZW4gY2FudmFzLCBzbyBjYW52YXMgd29ya2VycyBjYW4ndCBzdXBwb3J0IHRoZSBsdW1hIHRyYWNrIG1hdHRlIG1hc2suXG4gICAgLy8gTmFtaW5nIGl0IHNvbHV0aW9uIDIgdG8gbWFyayB0aGUgZXh0cmEgY29tbWVudCBsaW5lcy5cblxuICAgIC8qXHJcbiAgICB2YXIgc3ZnU3RyaW5nID0gW1xyXG4gICAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+JyxcclxuICAgICAgJzxmaWx0ZXIgaWQ9XCInICsgaWQgKyAnXCI+JyxcclxuICAgICAgJzxmZUNvbG9yTWF0cml4IHR5cGU9XCJtYXRyaXhcIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9XCJzUkdCXCIgdmFsdWVzPVwiJyxcclxuICAgICAgJzAuMywgMC4zLCAwLjMsIDAsIDAsICcsXHJcbiAgICAgICcwLjMsIDAuMywgMC4zLCAwLCAwLCAnLFxyXG4gICAgICAnMC4zLCAwLjMsIDAuMywgMCwgMCwgJyxcclxuICAgICAgJzAuMywgMC4zLCAwLjMsIDAsIDAnLFxyXG4gICAgICAnXCIvPicsXHJcbiAgICAgICc8L2ZpbHRlcj4nLFxyXG4gICAgICAnPC9zdmc+JyxcclxuICAgIF0uam9pbignJyk7XHJcbiAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtzdmdTdHJpbmddLCB7IHR5cGU6ICdpbWFnZS9zdmcreG1sJyB9KTtcclxuICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUx1bWFTdmdGaWx0ZXIoKSB7XG4gICAgICB2YXIgX3N2ZyA9IGNyZWF0ZU5TKCdzdmcnKTtcblxuICAgICAgdmFyIGZpbCA9IGNyZWF0ZU5TKCdmaWx0ZXInKTtcbiAgICAgIHZhciBtYXRyaXggPSBjcmVhdGVOUygnZmVDb2xvck1hdHJpeCcpO1xuICAgICAgZmlsLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gICAgICBtYXRyaXguc2V0QXR0cmlidXRlKCd0eXBlJywgJ21hdHJpeCcpO1xuICAgICAgbWF0cml4LnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ3NSR0InKTtcbiAgICAgIG1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsICcwLjMsIDAuMywgMC4zLCAwLCAwLCAwLjMsIDAuMywgMC4zLCAwLCAwLCAwLjMsIDAuMywgMC4zLCAwLCAwLCAwLjMsIDAuMywgMC4zLCAwLCAwJyk7XG4gICAgICBmaWwuYXBwZW5kQ2hpbGQobWF0cml4KTtcblxuICAgICAgX3N2Zy5hcHBlbmRDaGlsZChmaWwpO1xuXG4gICAgICBfc3ZnLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCArICdfc3ZnJyk7XG5cbiAgICAgIGlmIChmZWF0dXJlU3VwcG9ydC5zdmdMdW1hSGlkZGVuKSB7XG4gICAgICAgIF9zdmcuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9zdmc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZEx1bWEoKSB7XG4gICAgICBpZiAoIWx1bWFCdWZmZXIpIHtcbiAgICAgICAgc3ZnID0gY3JlYXRlTHVtYVN2Z0ZpbHRlcigpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN2Zyk7XG4gICAgICAgIGx1bWFCdWZmZXIgPSBjcmVhdGVUYWcoJ2NhbnZhcycpO1xuICAgICAgICBsdW1hQnVmZmVyQ3R4ID0gbHVtYUJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpOyAvLyBsdW1hQnVmZmVyQ3R4LmZpbHRlciA9IGB1cmwoJyR7dXJsfSNfX2xvdHRpZV9lbGVtZW50X2x1bWFfYnVmZmVyJylgOyAvLyBwYXJ0IG9mIHNvbHV0aW9uIDJcblxuICAgICAgICBsdW1hQnVmZmVyQ3R4LmZpbHRlciA9ICd1cmwoIycgKyBpZCArICcpJztcbiAgICAgICAgbHVtYUJ1ZmZlckN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgIGx1bWFCdWZmZXJDdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0THVtYShjYW52YXMpIHtcbiAgICAgIGlmICghbHVtYUJ1ZmZlcikge1xuICAgICAgICBsb2FkTHVtYSgpO1xuICAgICAgfVxuXG4gICAgICBsdW1hQnVmZmVyLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgbHVtYUJ1ZmZlci5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0OyAvLyBsdW1hQnVmZmVyQ3R4LmZpbHRlciA9IGB1cmwoJyR7dXJsfSNfX2xvdHRpZV9lbGVtZW50X2x1bWFfYnVmZmVyJylgOyAvLyBwYXJ0IG9mIHNvbHV0aW9uIDJcblxuICAgICAgbHVtYUJ1ZmZlckN0eC5maWx0ZXIgPSAndXJsKCMnICsgaWQgKyAnKSc7XG4gICAgICByZXR1cm4gbHVtYUJ1ZmZlcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbG9hZDogbG9hZEx1bWEsXG4gICAgICBnZXQ6IGdldEx1bWFcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKGZlYXR1cmVTdXBwb3J0Lm9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgdmFyIGNhbnZhcyA9IGNyZWF0ZVRhZygnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG5cbiAgdmFyIGFzc2V0TG9hZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2FkTHVtYUNhbnZhczogbHVtYUxvYWRlci5sb2FkLFxuICAgICAgZ2V0THVtYUNhbnZhczogbHVtYUxvYWRlci5nZXQsXG4gICAgICBjcmVhdGVDYW52YXM6IGNyZWF0ZUNhbnZhc1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgcmVnaXN0ZXJlZEVmZmVjdHMgPSB7fTtcblxuICBmdW5jdGlvbiBDVkVmZmVjdHMoZWxlbSkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBlbGVtLmRhdGEuZWYgPyBlbGVtLmRhdGEuZWYubGVuZ3RoIDogMDtcbiAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICB2YXIgZmlsdGVyTWFuYWdlcjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgZmlsdGVyTWFuYWdlciA9IG51bGw7XG4gICAgICB2YXIgdHlwZSA9IGVsZW0uZGF0YS5lZltpXS50eTtcblxuICAgICAgaWYgKHJlZ2lzdGVyZWRFZmZlY3RzW3R5cGVdKSB7XG4gICAgICAgIHZhciBFZmZlY3QgPSByZWdpc3RlcmVkRWZmZWN0c1t0eXBlXS5lZmZlY3Q7XG4gICAgICAgIGZpbHRlck1hbmFnZXIgPSBuZXcgRWZmZWN0KGVsZW0uZWZmZWN0c01hbmFnZXIuZWZmZWN0RWxlbWVudHNbaV0sIGVsZW0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlsdGVyTWFuYWdlcikge1xuICAgICAgICB0aGlzLmZpbHRlcnMucHVzaChmaWx0ZXJNYW5hZ2VyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgZWxlbS5hZGRSZW5kZXJhYmxlQ29tcG9uZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIENWRWZmZWN0cy5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoX2lzRmlyc3RGcmFtZSkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmZpbHRlcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICB0aGlzLmZpbHRlcnNbaV0ucmVuZGVyRnJhbWUoX2lzRmlyc3RGcmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIENWRWZmZWN0cy5wcm90b3R5cGUuZ2V0RWZmZWN0cyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuZmlsdGVycy5sZW5ndGg7XG4gICAgdmFyIGVmZmVjdHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMuZmlsdGVyc1tpXS50eXBlID09PSB0eXBlKSB7XG4gICAgICAgIGVmZmVjdHMucHVzaCh0aGlzLmZpbHRlcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlZmZlY3RzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRWZmZWN0KGlkLCBlZmZlY3QpIHtcbiAgICByZWdpc3RlcmVkRWZmZWN0c1tpZF0gPSB7XG4gICAgICBlZmZlY3Q6IGVmZmVjdFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBDVk1hc2tFbGVtZW50KGRhdGEsIGVsZW1lbnQpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5tYXNrc1Byb3BlcnRpZXMgPSB0aGlzLmRhdGEubWFza3NQcm9wZXJ0aWVzIHx8IFtdO1xuICAgIHRoaXMudmlld0RhdGEgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMubWFza3NQcm9wZXJ0aWVzLmxlbmd0aCk7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubWFza3NQcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICB2YXIgaGFzTWFza3MgPSBmYWxzZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMubWFza3NQcm9wZXJ0aWVzW2ldLm1vZGUgIT09ICduJykge1xuICAgICAgICBoYXNNYXNrcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmlld0RhdGFbaV0gPSBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3AodGhpcy5lbGVtZW50LCB0aGlzLm1hc2tzUHJvcGVydGllc1tpXSwgMyk7XG4gICAgfVxuXG4gICAgdGhpcy5oYXNNYXNrcyA9IGhhc01hc2tzO1xuXG4gICAgaWYgKGhhc01hc2tzKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuYWRkUmVuZGVyYWJsZUNvbXBvbmVudCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBDVk1hc2tFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaGFzTWFza3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5lbGVtZW50LmZpbmFsVHJhbnNmb3JtLm1hdDtcbiAgICB2YXIgY3R4ID0gdGhpcy5lbGVtZW50LmNhbnZhc0NvbnRleHQ7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubWFza3NQcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICB2YXIgcHQ7XG4gICAgdmFyIHB0cztcbiAgICB2YXIgZGF0YTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLm1hc2tzUHJvcGVydGllc1tpXS5tb2RlICE9PSAnbicpIHtcbiAgICAgICAgaWYgKHRoaXMubWFza3NQcm9wZXJ0aWVzW2ldLmludikge1xuICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLmVsZW1lbnQuZ2xvYmFsRGF0YS5jb21wU2l6ZS53LCAwKTtcbiAgICAgICAgICBjdHgubGluZVRvKHRoaXMuZWxlbWVudC5nbG9iYWxEYXRhLmNvbXBTaXplLncsIHRoaXMuZWxlbWVudC5nbG9iYWxEYXRhLmNvbXBTaXplLmgpO1xuICAgICAgICAgIGN0eC5saW5lVG8oMCwgdGhpcy5lbGVtZW50Lmdsb2JhbERhdGEuY29tcFNpemUuaCk7XG4gICAgICAgICAgY3R4LmxpbmVUbygwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEgPSB0aGlzLnZpZXdEYXRhW2ldLnY7XG4gICAgICAgIHB0ID0gdHJhbnNmb3JtLmFwcGx5VG9Qb2ludEFycmF5KGRhdGEudlswXVswXSwgZGF0YS52WzBdWzFdLCAwKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhwdFswXSwgcHRbMV0pO1xuICAgICAgICB2YXIgajtcbiAgICAgICAgdmFyIGpMZW4gPSBkYXRhLl9sZW5ndGg7XG5cbiAgICAgICAgZm9yIChqID0gMTsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgIHB0cyA9IHRyYW5zZm9ybS5hcHBseVRvVHJpcGxlUG9pbnRzKGRhdGEub1tqIC0gMV0sIGRhdGEuaVtqXSwgZGF0YS52W2pdKTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhwdHNbMF0sIHB0c1sxXSwgcHRzWzJdLCBwdHNbM10sIHB0c1s0XSwgcHRzWzVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB0cyA9IHRyYW5zZm9ybS5hcHBseVRvVHJpcGxlUG9pbnRzKGRhdGEub1tqIC0gMV0sIGRhdGEuaVswXSwgZGF0YS52WzBdKTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8ocHRzWzBdLCBwdHNbMV0sIHB0c1syXSwgcHRzWzNdLCBwdHNbNF0sIHB0c1s1XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50Lmdsb2JhbERhdGEucmVuZGVyZXIuc2F2ZSh0cnVlKTtcbiAgICBjdHguY2xpcCgpO1xuICB9O1xuXG4gIENWTWFza0VsZW1lbnQucHJvdG90eXBlLmdldE1hc2tQcm9wZXJ0eSA9IE1hc2tFbGVtZW50LnByb3RvdHlwZS5nZXRNYXNrUHJvcGVydHk7XG5cbiAgQ1ZNYXNrRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICB9O1xuXG4gIGZ1bmN0aW9uIENWQmFzZUVsZW1lbnQoKSB7fVxuXG4gIHZhciBvcGVyYXRpb25zTWFwID0ge1xuICAgIDE6ICdzb3VyY2UtaW4nLFxuICAgIDI6ICdzb3VyY2Utb3V0JyxcbiAgICAzOiAnc291cmNlLWluJyxcbiAgICA0OiAnc291cmNlLW91dCdcbiAgfTtcbiAgQ1ZCYXNlRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gICAgY3JlYXRlRWxlbWVudHM6IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRzKCkge30sXG4gICAgaW5pdFJlbmRlcmVyRWxlbWVudDogZnVuY3Rpb24gaW5pdFJlbmRlcmVyRWxlbWVudCgpIHt9LFxuICAgIGNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzOiBmdW5jdGlvbiBjcmVhdGVDb250YWluZXJFbGVtZW50cygpIHtcbiAgICAgIC8vIElmIHRoZSBsYXllciBpcyBtYXNrZWQgd2Ugd2lsbCB1c2UgdHdvIGJ1ZmZlcnMgdG8gc3RvcmUgZWFjaCBkaWZmZXJlbnQgc3RhdGVzIG9mIHRoZSBkcmF3aW5nXG4gICAgICAvLyBUaGlzIHNvbHV0aW9uIGlzIG5vdCBpZGVhbCBmb3Igc2V2ZXJhbCByZWFzb24uIEJ1dCB1bmZvcnR1bmF0ZWx5LCBiZWNhdXNlIG9mIHRoZSByZWN1cnNpdmVcbiAgICAgIC8vIG5hdHVyZSBvZiB0aGUgcmVuZGVyIHRyZWUsIGl0J3MgdGhlIG9ubHkgc2ltcGxlIHdheSB0byBtYWtlIHN1cmUgb25lIGlubmVyIG1hc2sgZG9lc24ndCBvdmVycmlkZSBhbiBvdXRlciBtYXNrLlxuICAgICAgLy8gVE9ETzogdHJ5IHRvIHJlZHVjZSB0aGUgc2l6ZSBvZiB0aGVzZSBidWZmZXJzIHRvIHRoZSBzaXplIG9mIHRoZSBjb21wb3NpdGlvbiBjb250YW5pbmcgdGhlIGxheWVyXG4gICAgICAvLyBJdCBtaWdodCBiZSBjaGFsbGVuZ2luZyBiZWNhdXNlIHRoZSBsYXllciBtb3N0IGxpa2VseSBpcyB0cmFuc2Zvcm1lZCBpbiBzb21lIHdheVxuICAgICAgaWYgKHRoaXMuZGF0YS50dCA+PSAxKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgICAgICB2YXIgY2FudmFzQ29udGV4dCA9IHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0O1xuICAgICAgICB2YXIgYnVmZmVyQ2FudmFzID0gYXNzZXRMb2FkZXIuY3JlYXRlQ2FudmFzKGNhbnZhc0NvbnRleHQuY2FudmFzLndpZHRoLCBjYW52YXNDb250ZXh0LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChidWZmZXJDYW52YXMpO1xuICAgICAgICB2YXIgYnVmZmVyQ2FudmFzMiA9IGFzc2V0TG9hZGVyLmNyZWF0ZUNhbnZhcyhjYW52YXNDb250ZXh0LmNhbnZhcy53aWR0aCwgY2FudmFzQ29udGV4dC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5idWZmZXJzLnB1c2goYnVmZmVyQ2FudmFzMik7XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS50dCA+PSAzICYmICFkb2N1bWVudC5faXNQcm94eSkge1xuICAgICAgICAgIGFzc2V0TG9hZGVyLmxvYWRMdW1hQ2FudmFzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jYW52YXNDb250ZXh0ID0gdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQ7XG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcyA9IHRoaXMuZ2xvYmFsRGF0YS50cmFuc2Zvcm1DYW52YXM7XG4gICAgICB0aGlzLnJlbmRlcmFibGVFZmZlY3RzTWFuYWdlciA9IG5ldyBDVkVmZmVjdHModGhpcyk7XG4gICAgICB0aGlzLnNlYXJjaEVmZmVjdFRyYW5zZm9ybXMoKTtcbiAgICB9LFxuICAgIGNyZWF0ZUNvbnRlbnQ6IGZ1bmN0aW9uIGNyZWF0ZUNvbnRlbnQoKSB7fSxcbiAgICBzZXRCbGVuZE1vZGU6IGZ1bmN0aW9uIHNldEJsZW5kTW9kZSgpIHtcbiAgICAgIHZhciBnbG9iYWxEYXRhID0gdGhpcy5nbG9iYWxEYXRhO1xuXG4gICAgICBpZiAoZ2xvYmFsRGF0YS5ibGVuZE1vZGUgIT09IHRoaXMuZGF0YS5ibSkge1xuICAgICAgICBnbG9iYWxEYXRhLmJsZW5kTW9kZSA9IHRoaXMuZGF0YS5ibTtcbiAgICAgICAgdmFyIGJsZW5kTW9kZVZhbHVlID0gZ2V0QmxlbmRNb2RlKHRoaXMuZGF0YS5ibSk7XG4gICAgICAgIGdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBibGVuZE1vZGVWYWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzOiBmdW5jdGlvbiBjcmVhdGVSZW5kZXJhYmxlQ29tcG9uZW50cygpIHtcbiAgICAgIHRoaXMubWFza01hbmFnZXIgPSBuZXcgQ1ZNYXNrRWxlbWVudCh0aGlzLmRhdGEsIHRoaXMpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1FZmZlY3RzID0gdGhpcy5yZW5kZXJhYmxlRWZmZWN0c01hbmFnZXIuZ2V0RWZmZWN0cyhlZmZlY3RUeXBlcy5UUkFOU0ZPUk1fRUZGRUNUKTtcbiAgICB9LFxuICAgIGhpZGVFbGVtZW50OiBmdW5jdGlvbiBoaWRlRWxlbWVudCgpIHtcbiAgICAgIGlmICghdGhpcy5oaWRkZW4gJiYgKCF0aGlzLmlzSW5SYW5nZSB8fCB0aGlzLmlzVHJhbnNwYXJlbnQpKSB7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3dFbGVtZW50OiBmdW5jdGlvbiBzaG93RWxlbWVudCgpIHtcbiAgICAgIGlmICh0aGlzLmlzSW5SYW5nZSAmJiAhdGhpcy5pc1RyYW5zcGFyZW50KSB7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgICAgIHRoaXMubWFza01hbmFnZXIuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGVhckNhbnZhczogZnVuY3Rpb24gY2xlYXJDYW52YXMoY2FudmFzQ29udGV4dCkge1xuICAgICAgY2FudmFzQ29udGV4dC5jbGVhclJlY3QodGhpcy50cmFuc2Zvcm1DYW52YXMudHgsIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR5LCB0aGlzLnRyYW5zZm9ybUNhbnZhcy53ICogdGhpcy50cmFuc2Zvcm1DYW52YXMuc3gsIHRoaXMudHJhbnNmb3JtQ2FudmFzLmggKiB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSk7XG4gICAgfSxcbiAgICBwcmVwYXJlTGF5ZXI6IGZ1bmN0aW9uIHByZXBhcmVMYXllcigpIHtcbiAgICAgIGlmICh0aGlzLmRhdGEudHQgPj0gMSkge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXJzWzBdO1xuICAgICAgICB2YXIgYnVmZmVyQ3R4ID0gYnVmZmVyLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRoaXMuY2xlYXJDYW52YXMoYnVmZmVyQ3R4KTsgLy8gb24gdGhlIGZpcnN0IGJ1ZmZlciB3ZSBzdG9yZSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZ2xvYmFsIGRyYXdpbmdcblxuICAgICAgICBidWZmZXJDdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMsIDAsIDApOyAvLyBUaGUgbmV4dCBmb3VyIGxpbmVzIGFyZSB0byBjbGVhciB0aGUgY2FudmFzXG4gICAgICAgIC8vIFRPRE86IENoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIGNsZWFyIHRoZSBjYW52YXMgd2l0aG91dCByZXNldHRpbmcgdGhlIHRyYW5zZm9ybVxuXG4gICAgICAgIHRoaXMuY3VycmVudFRyYW5zZm9ybSA9IHRoaXMuY2FudmFzQ29udGV4dC5nZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgdGhpcy5jbGVhckNhbnZhcyh0aGlzLmNhbnZhc0NvbnRleHQpO1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuc2V0VHJhbnNmb3JtKHRoaXMuY3VycmVudFRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBleGl0TGF5ZXI6IGZ1bmN0aW9uIGV4aXRMYXllcigpIHtcbiAgICAgIGlmICh0aGlzLmRhdGEudHQgPj0gMSkge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXJzWzFdOyAvLyBPbiB0aGUgc2Vjb25kIGJ1ZmZlciB3ZSBzdG9yZSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZ2xvYmFsIGRyYXdpbmdcbiAgICAgICAgLy8gdGhhdCBvbmx5IGNvbnRhaW5zIHRoZSBjb250ZW50IG9mIHRoaXMgbGF5ZXJcbiAgICAgICAgLy8gKGlmIGl0IGlzIGEgY29tcG9zaXRpb24sIGl0IGFsc28gaW5jbHVkZXMgdGhlIG5lc3RlZCBsYXllcnMpXG5cbiAgICAgICAgdmFyIGJ1ZmZlckN0eCA9IGJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLmNsZWFyQ2FudmFzKGJ1ZmZlckN0eCk7XG4gICAgICAgIGJ1ZmZlckN0eC5kcmF3SW1hZ2UodGhpcy5jYW52YXNDb250ZXh0LmNhbnZhcywgMCwgMCk7IC8vIFdlIGNsZWFyIHRoZSBjYW52YXMgYWdhaW5cblxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICB0aGlzLmNsZWFyQ2FudmFzKHRoaXMuY2FudmFzQ29udGV4dCk7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5zZXRUcmFuc2Zvcm0odGhpcy5jdXJyZW50VHJhbnNmb3JtKTsgLy8gV2UgZHJhdyB0aGUgbWFza1xuXG4gICAgICAgIHZhciBtYXNrID0gdGhpcy5jb21wLmdldEVsZW1lbnRCeUlkKCd0cCcgaW4gdGhpcy5kYXRhID8gdGhpcy5kYXRhLnRwIDogdGhpcy5kYXRhLmluZCAtIDEpO1xuICAgICAgICBtYXNrLnJlbmRlckZyYW1lKHRydWUpOyAvLyBXZSBkcmF3IHRoZSBzZWNvbmQgYnVmZmVyICh0aGF0IGNvbnRhaW5zIHRoZSBjb250ZW50IG9mIHRoaXMgbGF5ZXIpXG5cbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTsgLy8gSWYgdGhlIG1hc2sgaXMgYSBMdW1hIG1hdHRlLCB3ZSBuZWVkIHRvIGRvIHR3byBleHRyYSBwYWludGluZyBvcGVyYXRpb25zXG4gICAgICAgIC8vIHRoZSBfaXNQcm94eSBjaGVjayBpcyB0byBhdm9pZCBkcmF3aW5nIGEgZmFrZSBjYW52YXMgaW4gd29ya2VycyB0aGF0IHdpbGwgdGhyb3cgYW4gZXJyb3JcblxuICAgICAgICBpZiAodGhpcy5kYXRhLnR0ID49IDMgJiYgIWRvY3VtZW50Ll9pc1Byb3h5KSB7XG4gICAgICAgICAgLy8gV2UgY29weSB0aGUgcGFpbnRlZCBtYXNrIHRvIGEgYnVmZmVyIHRoYXQgaGFzIGEgY29sb3IgbWF0cml4IGZpbHRlciBhcHBsaWVkIHRvIGl0XG4gICAgICAgICAgLy8gdGhhdCBhcHBsaWVzIHRoZSByZ2IgdmFsdWVzIHRvIHRoZSBhbHBoYSBjaGFubmVsXG4gICAgICAgICAgdmFyIGx1bWFCdWZmZXIgPSBhc3NldExvYWRlci5nZXRMdW1hQ2FudmFzKHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMpO1xuICAgICAgICAgIHZhciBsdW1hQnVmZmVyQ3R4ID0gbHVtYUJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgIGx1bWFCdWZmZXJDdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMsIDAsIDApO1xuICAgICAgICAgIHRoaXMuY2xlYXJDYW52YXModGhpcy5jYW52YXNDb250ZXh0KTsgLy8gd2UgcmVwYWludCB0aGUgY29udGV4dCB3aXRoIHRoZSBtYXNrIGFwcGxpZWQgdG8gaXRcblxuICAgICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5kcmF3SW1hZ2UobHVtYUJ1ZmZlciwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gb3BlcmF0aW9uc01hcFt0aGlzLmRhdGEudHRdO1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZHJhd0ltYWdlKGJ1ZmZlciwgMCwgMCk7IC8vIFdlIGZpbmFsbHkgZHJhdyB0aGUgZmlyc3QgYnVmZmVyICh0aGF0IGNvbnRhaW5zIHRoZSBjb250ZW50IG9mIHRoZSBnbG9iYWwgZHJhd2luZylcbiAgICAgICAgLy8gV2UgdXNlIGRlc3RpbmF0aW9uLW92ZXIgdG8gZHJhdyB0aGUgZ2xvYmFsIGRyYXdpbmcgYmVsb3cgdGhlIGN1cnJlbnQgbGF5ZXJcblxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW92ZXInO1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZHJhd0ltYWdlKHRoaXMuYnVmZmVyc1swXSwgMCwgMCk7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5zZXRUcmFuc2Zvcm0odGhpcy5jdXJyZW50VHJhbnNmb3JtKTsgLy8gV2UgcmVzZXQgdGhlIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiB0byBzb3VyY2Utb3ZlciwgdGhlIHN0YW5kYXJkIHR5cGUgb2Ygb3BlcmF0aW9uXG5cbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJGcmFtZTogZnVuY3Rpb24gcmVuZGVyRnJhbWUoZm9yY2VSZW5kZXIpIHtcbiAgICAgIGlmICh0aGlzLmhpZGRlbiB8fCB0aGlzLmRhdGEuaGQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kYXRhLnRkID09PSAxICYmICFmb3JjZVJlbmRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyVHJhbnNmb3JtKCk7XG4gICAgICB0aGlzLnJlbmRlclJlbmRlcmFibGUoKTtcbiAgICAgIHRoaXMucmVuZGVyTG9jYWxUcmFuc2Zvcm0oKTtcbiAgICAgIHRoaXMuc2V0QmxlbmRNb2RlKCk7XG4gICAgICB2YXIgZm9yY2VSZWFsU3RhY2sgPSB0aGlzLmRhdGEudHkgPT09IDA7XG4gICAgICB0aGlzLnByZXBhcmVMYXllcigpO1xuICAgICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLnNhdmUoZm9yY2VSZWFsU3RhY2spO1xuICAgICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eFRyYW5zZm9ybSh0aGlzLmZpbmFsVHJhbnNmb3JtLmxvY2FsTWF0LnByb3BzKTtcbiAgICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5jdHhPcGFjaXR5KHRoaXMuZmluYWxUcmFuc2Zvcm0ubG9jYWxPcGFjaXR5KTtcbiAgICAgIHRoaXMucmVuZGVySW5uZXJDb250ZW50KCk7XG4gICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIucmVzdG9yZShmb3JjZVJlYWxTdGFjayk7XG4gICAgICB0aGlzLmV4aXRMYXllcigpO1xuXG4gICAgICBpZiAodGhpcy5tYXNrTWFuYWdlci5oYXNNYXNrcykge1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIucmVzdG9yZSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQgPSBudWxsO1xuICAgICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICAgIHRoaXMuZ2xvYmFsRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLm1hc2tNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB9LFxuICAgIG1IZWxwZXI6IG5ldyBNYXRyaXgoKVxuICB9O1xuICBDVkJhc2VFbGVtZW50LnByb3RvdHlwZS5oaWRlID0gQ1ZCYXNlRWxlbWVudC5wcm90b3R5cGUuaGlkZUVsZW1lbnQ7XG4gIENWQmFzZUVsZW1lbnQucHJvdG90eXBlLnNob3cgPSBDVkJhc2VFbGVtZW50LnByb3RvdHlwZS5zaG93RWxlbWVudDtcblxuICBmdW5jdGlvbiBDVlNoYXBlRGF0YShlbGVtZW50LCBkYXRhLCBzdHlsZXMsIHRyYW5zZm9ybXNNYW5hZ2VyKSB7XG4gICAgdGhpcy5zdHlsZWRTaGFwZXMgPSBbXTtcbiAgICB0aGlzLnRyID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIHZhciB0eSA9IDQ7XG5cbiAgICBpZiAoZGF0YS50eSA9PT0gJ3JjJykge1xuICAgICAgdHkgPSA1O1xuICAgIH0gZWxzZSBpZiAoZGF0YS50eSA9PT0gJ2VsJykge1xuICAgICAgdHkgPSA2O1xuICAgIH0gZWxzZSBpZiAoZGF0YS50eSA9PT0gJ3NyJykge1xuICAgICAgdHkgPSA3O1xuICAgIH1cblxuICAgIHRoaXMuc2ggPSBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3AoZWxlbWVudCwgZGF0YSwgdHksIGVsZW1lbnQpO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBzdHlsZXMubGVuZ3RoO1xuICAgIHZhciBzdHlsZWRTaGFwZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKCFzdHlsZXNbaV0uY2xvc2VkKSB7XG4gICAgICAgIHN0eWxlZFNoYXBlID0ge1xuICAgICAgICAgIHRyYW5zZm9ybXM6IHRyYW5zZm9ybXNNYW5hZ2VyLmFkZFRyYW5zZm9ybVNlcXVlbmNlKHN0eWxlc1tpXS50cmFuc2Zvcm1zKSxcbiAgICAgICAgICB0ck5vZGVzOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0eWxlZFNoYXBlcy5wdXNoKHN0eWxlZFNoYXBlKTtcbiAgICAgICAgc3R5bGVzW2ldLmVsZW1lbnRzLnB1c2goc3R5bGVkU2hhcGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIENWU2hhcGVEYXRhLnByb3RvdHlwZS5zZXRBc0FuaW1hdGVkID0gU1ZHU2hhcGVEYXRhLnByb3RvdHlwZS5zZXRBc0FuaW1hdGVkO1xuXG4gIGZ1bmN0aW9uIENWU2hhcGVFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLnNoYXBlcyA9IFtdO1xuICAgIHRoaXMuc2hhcGVzRGF0YSA9IGRhdGEuc2hhcGVzO1xuICAgIHRoaXMuc3R5bGVzTGlzdCA9IFtdO1xuICAgIHRoaXMuaXRlbXNEYXRhID0gW107XG4gICAgdGhpcy5wcmV2Vmlld0RhdGEgPSBbXTtcbiAgICB0aGlzLnNoYXBlTW9kaWZpZXJzID0gW107XG4gICAgdGhpcy5wcm9jZXNzZWRFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMudHJhbnNmb3Jtc01hbmFnZXIgPSBuZXcgU2hhcGVUcmFuc2Zvcm1NYW5hZ2VyKCk7XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIENWQmFzZUVsZW1lbnQsIElTaGFwZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZUVsZW1lbnRdLCBDVlNoYXBlRWxlbWVudCk7XG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudCA9IFJlbmRlcmFibGVET01FbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudDtcbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnRyYW5zZm9ybUhlbHBlciA9IHtcbiAgICBvcGFjaXR5OiAxLFxuICAgIF9vcE1kZjogZmFsc2VcbiAgfTtcbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmRhc2hSZXNldHRlciA9IFtdO1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2VhcmNoU2hhcGVzKHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRoaXMucHJldlZpZXdEYXRhLCB0cnVlLCBbXSk7XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVN0eWxlRWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhLCB0cmFuc2Zvcm1zKSB7XG4gICAgdmFyIHN0eWxlRWxlbSA9IHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICB0eXBlOiBkYXRhLnR5LFxuICAgICAgcHJlVHJhbnNmb3JtczogdGhpcy50cmFuc2Zvcm1zTWFuYWdlci5hZGRUcmFuc2Zvcm1TZXF1ZW5jZSh0cmFuc2Zvcm1zKSxcbiAgICAgIHRyYW5zZm9ybXM6IFtdLFxuICAgICAgZWxlbWVudHM6IFtdLFxuICAgICAgY2xvc2VkOiBkYXRhLmhkID09PSB0cnVlXG4gICAgfTtcbiAgICB2YXIgZWxlbWVudERhdGEgPSB7fTtcblxuICAgIGlmIChkYXRhLnR5ID09PSAnZmwnIHx8IGRhdGEudHkgPT09ICdzdCcpIHtcbiAgICAgIGVsZW1lbnREYXRhLmMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLmMsIDEsIDI1NSwgdGhpcyk7XG5cbiAgICAgIGlmICghZWxlbWVudERhdGEuYy5rKSB7XG4gICAgICAgIHN0eWxlRWxlbS5jbyA9ICdyZ2IoJyArIGJtRmxvb3IoZWxlbWVudERhdGEuYy52WzBdKSArICcsJyArIGJtRmxvb3IoZWxlbWVudERhdGEuYy52WzFdKSArICcsJyArIGJtRmxvb3IoZWxlbWVudERhdGEuYy52WzJdKSArICcpJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdnZicgfHwgZGF0YS50eSA9PT0gJ2dzJykge1xuICAgICAgZWxlbWVudERhdGEucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEucywgMSwgbnVsbCwgdGhpcyk7XG4gICAgICBlbGVtZW50RGF0YS5lID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS5lLCAxLCBudWxsLCB0aGlzKTtcbiAgICAgIGVsZW1lbnREYXRhLmggPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLmggfHwge1xuICAgICAgICBrOiAwXG4gICAgICB9LCAwLCAwLjAxLCB0aGlzKTtcbiAgICAgIGVsZW1lbnREYXRhLmEgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLmEgfHwge1xuICAgICAgICBrOiAwXG4gICAgICB9LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgICAgZWxlbWVudERhdGEuZyA9IG5ldyBHcmFkaWVudFByb3BlcnR5KHRoaXMsIGRhdGEuZywgdGhpcyk7XG4gICAgfVxuXG4gICAgZWxlbWVudERhdGEubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEubywgMCwgMC4wMSwgdGhpcyk7XG5cbiAgICBpZiAoZGF0YS50eSA9PT0gJ3N0JyB8fCBkYXRhLnR5ID09PSAnZ3MnKSB7XG4gICAgICBzdHlsZUVsZW0ubGMgPSBsaW5lQ2FwRW51bVtkYXRhLmxjIHx8IDJdO1xuICAgICAgc3R5bGVFbGVtLmxqID0gbGluZUpvaW5FbnVtW2RhdGEubGogfHwgMl07XG5cbiAgICAgIGlmIChkYXRhLmxqID09IDEpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgc3R5bGVFbGVtLm1sID0gZGF0YS5tbDtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudERhdGEudyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEudywgMCwgbnVsbCwgdGhpcyk7XG5cbiAgICAgIGlmICghZWxlbWVudERhdGEudy5rKSB7XG4gICAgICAgIHN0eWxlRWxlbS53aSA9IGVsZW1lbnREYXRhLncudjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuZCkge1xuICAgICAgICB2YXIgZCA9IG5ldyBEYXNoUHJvcGVydHkodGhpcywgZGF0YS5kLCAnY2FudmFzJywgdGhpcyk7XG4gICAgICAgIGVsZW1lbnREYXRhLmQgPSBkO1xuXG4gICAgICAgIGlmICghZWxlbWVudERhdGEuZC5rKSB7XG4gICAgICAgICAgc3R5bGVFbGVtLmRhID0gZWxlbWVudERhdGEuZC5kYXNoQXJyYXk7XG4gICAgICAgICAgc3R5bGVFbGVtW1wiZG9cIl0gPSBlbGVtZW50RGF0YS5kLmRhc2hvZmZzZXRbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVFbGVtLnIgPSBkYXRhLnIgPT09IDIgPyAnZXZlbm9kZCcgOiAnbm9uemVybyc7XG4gICAgfVxuXG4gICAgdGhpcy5zdHlsZXNMaXN0LnB1c2goc3R5bGVFbGVtKTtcbiAgICBlbGVtZW50RGF0YS5zdHlsZSA9IHN0eWxlRWxlbTtcbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUdyb3VwRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbWVudERhdGEgPSB7XG4gICAgICBpdDogW10sXG4gICAgICBwcmV2Vmlld0RhdGE6IFtdXG4gICAgfTtcbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVRyYW5zZm9ybUVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBlbGVtZW50RGF0YSA9IHtcbiAgICAgIHRyYW5zZm9ybToge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBfb3BNZGY6IGZhbHNlLFxuICAgICAgICBrZXk6IHRoaXMudHJhbnNmb3Jtc01hbmFnZXIuZ2V0TmV3S2V5KCksXG4gICAgICAgIG9wOiBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLm8sIDAsIDAuMDEsIHRoaXMpLFxuICAgICAgICBtUHJvcHM6IFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeS5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eSh0aGlzLCBkYXRhLCB0aGlzKVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGVsZW1lbnREYXRhO1xuICB9O1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTaGFwZUVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBlbGVtZW50RGF0YSA9IG5ldyBDVlNoYXBlRGF0YSh0aGlzLCBkYXRhLCB0aGlzLnN0eWxlc0xpc3QsIHRoaXMudHJhbnNmb3Jtc01hbmFnZXIpO1xuICAgIHRoaXMuc2hhcGVzLnB1c2goZWxlbWVudERhdGEpO1xuICAgIHRoaXMuYWRkU2hhcGVUb01vZGlmaWVycyhlbGVtZW50RGF0YSk7XG4gICAgcmV0dXJuIGVsZW1lbnREYXRhO1xuICB9O1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZWxvYWRTaGFwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5pdGVtc0RhdGEubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICB0aGlzLnByZXZWaWV3RGF0YVtpXSA9IHRoaXMuaXRlbXNEYXRhW2ldO1xuICAgIH1cblxuICAgIHRoaXMuc2VhcmNoU2hhcGVzKHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRoaXMucHJldlZpZXdEYXRhLCB0cnVlLCBbXSk7XG4gICAgbGVuID0gdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV0uZ2V0VmFsdWUoKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlck1vZGlmaWVycygpO1xuICAgIHRoaXMudHJhbnNmb3Jtc01hbmFnZXIucHJvY2Vzc1NlcXVlbmNlcyh0aGlzLl9pc0ZpcnN0RnJhbWUpO1xuICB9O1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5hZGRUcmFuc2Zvcm1Ub1N0eWxlTGlzdCA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlc0xpc3RbaV0uY2xvc2VkKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS50cmFuc2Zvcm1zLnB1c2godHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbW92ZVRyYW5zZm9ybUZyb21TdHlsZUxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc3R5bGVzTGlzdC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXNMaXN0W2ldLmNsb3NlZCkge1xuICAgICAgICB0aGlzLnN0eWxlc0xpc3RbaV0udHJhbnNmb3Jtcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNsb3NlU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBzdHlsZXMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBzdHlsZXNbaV0uY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnNlYXJjaFNoYXBlcyA9IGZ1bmN0aW9uIChhcnIsIGl0ZW1zRGF0YSwgcHJldlZpZXdEYXRhLCBzaG91bGRSZW5kZXIsIHRyYW5zZm9ybXMpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIG93blN0eWxlcyA9IFtdO1xuICAgIHZhciBvd25Nb2RpZmllcnMgPSBbXTtcbiAgICB2YXIgcHJvY2Vzc2VkUG9zO1xuICAgIHZhciBtb2RpZmllcjtcbiAgICB2YXIgY3VycmVudFRyYW5zZm9ybTtcbiAgICB2YXIgb3duVHJhbnNmb3JtcyA9IFtdLmNvbmNhdCh0cmFuc2Zvcm1zKTtcblxuICAgIGZvciAoaSA9IGxlbjsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIHByb2Nlc3NlZFBvcyA9IHRoaXMuc2VhcmNoUHJvY2Vzc2VkRWxlbWVudChhcnJbaV0pO1xuXG4gICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICBhcnJbaV0uX3Nob3VsZFJlbmRlciA9IHNob3VsZFJlbmRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zRGF0YVtpXSA9IHByZXZWaWV3RGF0YVtwcm9jZXNzZWRQb3MgLSAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFycltpXS50eSA9PT0gJ2ZsJyB8fCBhcnJbaV0udHkgPT09ICdzdCcgfHwgYXJyW2ldLnR5ID09PSAnZ2YnIHx8IGFycltpXS50eSA9PT0gJ2dzJykge1xuICAgICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICAgIGl0ZW1zRGF0YVtpXSA9IHRoaXMuY3JlYXRlU3R5bGVFbGVtZW50KGFycltpXSwgb3duVHJhbnNmb3Jtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldLnN0eWxlLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3duU3R5bGVzLnB1c2goaXRlbXNEYXRhW2ldLnN0eWxlKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVHcm91cEVsZW1lbnQoYXJyW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqTGVuID0gaXRlbXNEYXRhW2ldLml0Lmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGl0ZW1zRGF0YVtpXS5wcmV2Vmlld0RhdGFbal0gPSBpdGVtc0RhdGFbaV0uaXRbal07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWFyY2hTaGFwZXMoYXJyW2ldLml0LCBpdGVtc0RhdGFbaV0uaXQsIGl0ZW1zRGF0YVtpXS5wcmV2Vmlld0RhdGEsIHNob3VsZFJlbmRlciwgb3duVHJhbnNmb3Jtcyk7XG4gICAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ3RyJykge1xuICAgICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0gPSB0aGlzLmNyZWF0ZVRyYW5zZm9ybUVsZW1lbnQoYXJyW2ldKTtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSBjdXJyZW50VHJhbnNmb3JtO1xuICAgICAgICB9XG5cbiAgICAgICAgb3duVHJhbnNmb3Jtcy5wdXNoKGl0ZW1zRGF0YVtpXSk7XG4gICAgICAgIHRoaXMuYWRkVHJhbnNmb3JtVG9TdHlsZUxpc3QoaXRlbXNEYXRhW2ldKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAnc2gnIHx8IGFycltpXS50eSA9PT0gJ3JjJyB8fCBhcnJbaV0udHkgPT09ICdlbCcgfHwgYXJyW2ldLnR5ID09PSAnc3InKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVTaGFwZUVsZW1lbnQoYXJyW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICd0bScgfHwgYXJyW2ldLnR5ID09PSAncmQnIHx8IGFycltpXS50eSA9PT0gJ3BiJyB8fCBhcnJbaV0udHkgPT09ICd6eicgfHwgYXJyW2ldLnR5ID09PSAnb3AnKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgbW9kaWZpZXIgPSBTaGFwZU1vZGlmaWVycy5nZXRNb2RpZmllcihhcnJbaV0udHkpO1xuICAgICAgICAgIG1vZGlmaWVyLmluaXQodGhpcywgYXJyW2ldKTtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSBtb2RpZmllcjtcbiAgICAgICAgICB0aGlzLnNoYXBlTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGlmaWVyID0gaXRlbXNEYXRhW2ldO1xuICAgICAgICAgIG1vZGlmaWVyLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3duTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdycCcpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBtb2RpZmllciA9IFNoYXBlTW9kaWZpZXJzLmdldE1vZGlmaWVyKGFycltpXS50eSk7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gbW9kaWZpZXI7XG4gICAgICAgICAgbW9kaWZpZXIuaW5pdCh0aGlzLCBhcnIsIGksIGl0ZW1zRGF0YSk7XG4gICAgICAgICAgdGhpcy5zaGFwZU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgICAgICBzaG91bGRSZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RpZmllciA9IGl0ZW1zRGF0YVtpXTtcbiAgICAgICAgICBtb2RpZmllci5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3duTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZFByb2Nlc3NlZEVsZW1lbnQoYXJyW2ldLCBpICsgMSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVUcmFuc2Zvcm1Gcm9tU3R5bGVMaXN0KCk7XG4gICAgdGhpcy5jbG9zZVN0eWxlcyhvd25TdHlsZXMpO1xuICAgIGxlbiA9IG93bk1vZGlmaWVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIG93bk1vZGlmaWVyc1tpXS5jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHJhbnNmb3JtSGVscGVyLm9wYWNpdHkgPSAxO1xuICAgIHRoaXMudHJhbnNmb3JtSGVscGVyLl9vcE1kZiA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyTW9kaWZpZXJzKCk7XG4gICAgdGhpcy50cmFuc2Zvcm1zTWFuYWdlci5wcm9jZXNzU2VxdWVuY2VzKHRoaXMuX2lzRmlyc3RGcmFtZSk7XG4gICAgdGhpcy5yZW5kZXJTaGFwZSh0aGlzLnRyYW5zZm9ybUhlbHBlciwgdGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdHJ1ZSk7XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlclNoYXBlVHJhbnNmb3JtID0gZnVuY3Rpb24gKHBhcmVudFRyYW5zZm9ybSwgZ3JvdXBUcmFuc2Zvcm0pIHtcbiAgICBpZiAocGFyZW50VHJhbnNmb3JtLl9vcE1kZiB8fCBncm91cFRyYW5zZm9ybS5vcC5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgZ3JvdXBUcmFuc2Zvcm0ub3BhY2l0eSA9IHBhcmVudFRyYW5zZm9ybS5vcGFjaXR5O1xuICAgICAgZ3JvdXBUcmFuc2Zvcm0ub3BhY2l0eSAqPSBncm91cFRyYW5zZm9ybS5vcC52O1xuICAgICAgZ3JvdXBUcmFuc2Zvcm0uX29wTWRmID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmRyYXdMYXllciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgaztcbiAgICB2YXIga0xlbjtcbiAgICB2YXIgZWxlbXM7XG4gICAgdmFyIG5vZGVzO1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlcjtcbiAgICB2YXIgY3R4ID0gdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQ7XG4gICAgdmFyIHR5cGU7XG4gICAgdmFyIGN1cnJlbnRTdHlsZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgY3VycmVudFN0eWxlID0gdGhpcy5zdHlsZXNMaXN0W2ldO1xuICAgICAgdHlwZSA9IGN1cnJlbnRTdHlsZS50eXBlOyAvLyBTa2lwcGluZyBzdHlsZSB3aGVuXG4gICAgICAvLyBTdHJva2Ugd2lkdGggZXF1YWxzIDBcbiAgICAgIC8vIHN0eWxlIHNob3VsZCBub3QgYmUgcmVuZGVyZWQgKGV4dHJhIHVudXNlZCByZXBlYXRlcnMpXG4gICAgICAvLyBjdXJyZW50IG9wYWNpdHkgZXF1YWxzIDBcbiAgICAgIC8vIGdsb2JhbCBvcGFjaXR5IGVxdWFscyAwXG5cbiAgICAgIGlmICghKCh0eXBlID09PSAnc3QnIHx8IHR5cGUgPT09ICdncycpICYmIGN1cnJlbnRTdHlsZS53aSA9PT0gMCB8fCAhY3VycmVudFN0eWxlLmRhdGEuX3Nob3VsZFJlbmRlciB8fCBjdXJyZW50U3R5bGUuY29PcCA9PT0gMCB8fCB0aGlzLmdsb2JhbERhdGEuY3VycmVudEdsb2JhbEFscGhhID09PSAwKSkge1xuICAgICAgICByZW5kZXJlci5zYXZlKCk7XG4gICAgICAgIGVsZW1zID0gY3VycmVudFN0eWxlLmVsZW1lbnRzO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnc3QnIHx8IHR5cGUgPT09ICdncycpIHtcbiAgICAgICAgICByZW5kZXJlci5jdHhTdHJva2VTdHlsZSh0eXBlID09PSAnc3QnID8gY3VycmVudFN0eWxlLmNvIDogY3VycmVudFN0eWxlLmdyZCk7IC8vIGN0eC5zdHJva2VTdHlsZSA9IHR5cGUgPT09ICdzdCcgPyBjdXJyZW50U3R5bGUuY28gOiBjdXJyZW50U3R5bGUuZ3JkO1xuXG4gICAgICAgICAgcmVuZGVyZXIuY3R4TGluZVdpZHRoKGN1cnJlbnRTdHlsZS53aSk7IC8vIGN0eC5saW5lV2lkdGggPSBjdXJyZW50U3R5bGUud2k7XG5cbiAgICAgICAgICByZW5kZXJlci5jdHhMaW5lQ2FwKGN1cnJlbnRTdHlsZS5sYyk7IC8vIGN0eC5saW5lQ2FwID0gY3VycmVudFN0eWxlLmxjO1xuXG4gICAgICAgICAgcmVuZGVyZXIuY3R4TGluZUpvaW4oY3VycmVudFN0eWxlLmxqKTsgLy8gY3R4LmxpbmVKb2luID0gY3VycmVudFN0eWxlLmxqO1xuXG4gICAgICAgICAgcmVuZGVyZXIuY3R4TWl0ZXJMaW1pdChjdXJyZW50U3R5bGUubWwgfHwgMCk7IC8vIGN0eC5taXRlckxpbWl0ID0gY3VycmVudFN0eWxlLm1sIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVuZGVyZXIuY3R4RmlsbFN0eWxlKHR5cGUgPT09ICdmbCcgPyBjdXJyZW50U3R5bGUuY28gOiBjdXJyZW50U3R5bGUuZ3JkKTsgLy8gY3R4LmZpbGxTdHlsZSA9IHR5cGUgPT09ICdmbCcgPyBjdXJyZW50U3R5bGUuY28gOiBjdXJyZW50U3R5bGUuZ3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIuY3R4T3BhY2l0eShjdXJyZW50U3R5bGUuY29PcCk7XG5cbiAgICAgICAgaWYgKHR5cGUgIT09ICdzdCcgJiYgdHlwZSAhPT0gJ2dzJykge1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcmVyLmN0eFRyYW5zZm9ybShjdXJyZW50U3R5bGUucHJlVHJhbnNmb3Jtcy5maW5hbFRyYW5zZm9ybS5wcm9wcyk7XG4gICAgICAgIGpMZW4gPSBlbGVtcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnc3QnIHx8IHR5cGUgPT09ICdncycpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdHlsZS5kYSkge1xuICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2goY3VycmVudFN0eWxlLmRhKTtcbiAgICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gY3VycmVudFN0eWxlW1wiZG9cIl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZXMgPSBlbGVtc1tqXS50ck5vZGVzO1xuICAgICAgICAgIGtMZW4gPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwga0xlbjsgayArPSAxKSB7XG4gICAgICAgICAgICBpZiAobm9kZXNba10udCA9PT0gJ20nKSB7XG4gICAgICAgICAgICAgIGN0eC5tb3ZlVG8obm9kZXNba10ucFswXSwgbm9kZXNba10ucFsxXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGVzW2tdLnQgPT09ICdjJykge1xuICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhub2Rlc1trXS5wdHNbMF0sIG5vZGVzW2tdLnB0c1sxXSwgbm9kZXNba10ucHRzWzJdLCBub2Rlc1trXS5wdHNbM10sIG5vZGVzW2tdLnB0c1s0XSwgbm9kZXNba10ucHRzWzVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ3N0JyB8fCB0eXBlID09PSAnZ3MnKSB7XG4gICAgICAgICAgICAvLyBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICByZW5kZXJlci5jdHhTdHJva2UoKTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdHlsZS5kYSkge1xuICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2godGhpcy5kYXNoUmVzZXR0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlICE9PSAnc3QnICYmIHR5cGUgIT09ICdncycpIHtcbiAgICAgICAgICAvLyBjdHguZmlsbChjdXJyZW50U3R5bGUucik7XG4gICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eEZpbGwoY3VycmVudFN0eWxlLnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyU2hhcGUgPSBmdW5jdGlvbiAocGFyZW50VHJhbnNmb3JtLCBpdGVtcywgZGF0YSwgaXNNYWluKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgdmFyIGdyb3VwVHJhbnNmb3JtO1xuICAgIGdyb3VwVHJhbnNmb3JtID0gcGFyZW50VHJhbnNmb3JtO1xuXG4gICAgZm9yIChpID0gbGVuOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKGl0ZW1zW2ldLnR5ID09PSAndHInKSB7XG4gICAgICAgIGdyb3VwVHJhbnNmb3JtID0gZGF0YVtpXS50cmFuc2Zvcm07XG4gICAgICAgIHRoaXMucmVuZGVyU2hhcGVUcmFuc2Zvcm0ocGFyZW50VHJhbnNmb3JtLCBncm91cFRyYW5zZm9ybSk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1zW2ldLnR5ID09PSAnc2gnIHx8IGl0ZW1zW2ldLnR5ID09PSAnZWwnIHx8IGl0ZW1zW2ldLnR5ID09PSAncmMnIHx8IGl0ZW1zW2ldLnR5ID09PSAnc3InKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUGF0aChpdGVtc1tpXSwgZGF0YVtpXSk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1zW2ldLnR5ID09PSAnZmwnKSB7XG4gICAgICAgIHRoaXMucmVuZGVyRmlsbChpdGVtc1tpXSwgZGF0YVtpXSwgZ3JvdXBUcmFuc2Zvcm0pO1xuICAgICAgfSBlbHNlIGlmIChpdGVtc1tpXS50eSA9PT0gJ3N0Jykge1xuICAgICAgICB0aGlzLnJlbmRlclN0cm9rZShpdGVtc1tpXSwgZGF0YVtpXSwgZ3JvdXBUcmFuc2Zvcm0pO1xuICAgICAgfSBlbHNlIGlmIChpdGVtc1tpXS50eSA9PT0gJ2dmJyB8fCBpdGVtc1tpXS50eSA9PT0gJ2dzJykge1xuICAgICAgICB0aGlzLnJlbmRlckdyYWRpZW50RmlsbChpdGVtc1tpXSwgZGF0YVtpXSwgZ3JvdXBUcmFuc2Zvcm0pO1xuICAgICAgfSBlbHNlIGlmIChpdGVtc1tpXS50eSA9PT0gJ2dyJykge1xuICAgICAgICB0aGlzLnJlbmRlclNoYXBlKGdyb3VwVHJhbnNmb3JtLCBpdGVtc1tpXS5pdCwgZGF0YVtpXS5pdCk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1zW2ldLnR5ID09PSAndG0nKSB7Ly9cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNNYWluKSB7XG4gICAgICB0aGlzLmRyYXdMYXllcigpO1xuICAgIH1cbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyU3R5bGVkU2hhcGUgPSBmdW5jdGlvbiAoc3R5bGVkU2hhcGUsIHNoYXBlKSB7XG4gICAgaWYgKHRoaXMuX2lzRmlyc3RGcmFtZSB8fCBzaGFwZS5fbWRmIHx8IHN0eWxlZFNoYXBlLnRyYW5zZm9ybXMuX21kZikge1xuICAgICAgdmFyIHNoYXBlTm9kZXMgPSBzdHlsZWRTaGFwZS50ck5vZGVzO1xuICAgICAgdmFyIHBhdGhzID0gc2hhcGUucGF0aHM7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW47XG4gICAgICB2YXIgajtcbiAgICAgIHZhciBqTGVuID0gcGF0aHMuX2xlbmd0aDtcbiAgICAgIHNoYXBlTm9kZXMubGVuZ3RoID0gMDtcbiAgICAgIHZhciBncm91cFRyYW5zZm9ybU1hdCA9IHN0eWxlZFNoYXBlLnRyYW5zZm9ybXMuZmluYWxUcmFuc2Zvcm07XG5cbiAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgdmFyIHBhdGhOb2RlcyA9IHBhdGhzLnNoYXBlc1tqXTtcblxuICAgICAgICBpZiAocGF0aE5vZGVzICYmIHBhdGhOb2Rlcy52KSB7XG4gICAgICAgICAgbGVuID0gcGF0aE5vZGVzLl9sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChpID09PSAxKSB7XG4gICAgICAgICAgICAgIHNoYXBlTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdDogJ20nLFxuICAgICAgICAgICAgICAgIHA6IGdyb3VwVHJhbnNmb3JtTWF0LmFwcGx5VG9Qb2ludEFycmF5KHBhdGhOb2Rlcy52WzBdWzBdLCBwYXRoTm9kZXMudlswXVsxXSwgMClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNoYXBlTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgIHQ6ICdjJyxcbiAgICAgICAgICAgICAgcHRzOiBncm91cFRyYW5zZm9ybU1hdC5hcHBseVRvVHJpcGxlUG9pbnRzKHBhdGhOb2Rlcy5vW2kgLSAxXSwgcGF0aE5vZGVzLmlbaV0sIHBhdGhOb2Rlcy52W2ldKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgc2hhcGVOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdDogJ20nLFxuICAgICAgICAgICAgICBwOiBncm91cFRyYW5zZm9ybU1hdC5hcHBseVRvUG9pbnRBcnJheShwYXRoTm9kZXMudlswXVswXSwgcGF0aE5vZGVzLnZbMF1bMV0sIDApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aE5vZGVzLmMgJiYgbGVuKSB7XG4gICAgICAgICAgICBzaGFwZU5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICB0OiAnYycsXG4gICAgICAgICAgICAgIHB0czogZ3JvdXBUcmFuc2Zvcm1NYXQuYXBwbHlUb1RyaXBsZVBvaW50cyhwYXRoTm9kZXMub1tpIC0gMV0sIHBhdGhOb2Rlcy5pWzBdLCBwYXRoTm9kZXMudlswXSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2hhcGVOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdDogJ3onXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3R5bGVkU2hhcGUudHJOb2RlcyA9IHNoYXBlTm9kZXM7XG4gICAgfVxuICB9O1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBpdGVtRGF0YSkge1xuICAgIGlmIChwYXRoRGF0YS5oZCAhPT0gdHJ1ZSAmJiBwYXRoRGF0YS5fc2hvdWxkUmVuZGVyKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBpdGVtRGF0YS5zdHlsZWRTaGFwZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJTdHlsZWRTaGFwZShpdGVtRGF0YS5zdHlsZWRTaGFwZXNbaV0sIGl0ZW1EYXRhLnNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlckZpbGwgPSBmdW5jdGlvbiAoc3R5bGVEYXRhLCBpdGVtRGF0YSwgZ3JvdXBUcmFuc2Zvcm0pIHtcbiAgICB2YXIgc3R5bGVFbGVtID0gaXRlbURhdGEuc3R5bGU7XG5cbiAgICBpZiAoaXRlbURhdGEuYy5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgc3R5bGVFbGVtLmNvID0gJ3JnYignICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMF0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMV0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMl0pICsgJyknO1xuICAgIH1cblxuICAgIGlmIChpdGVtRGF0YS5vLl9tZGYgfHwgZ3JvdXBUcmFuc2Zvcm0uX29wTWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgc3R5bGVFbGVtLmNvT3AgPSBpdGVtRGF0YS5vLnYgKiBncm91cFRyYW5zZm9ybS5vcGFjaXR5O1xuICAgIH1cbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyR3JhZGllbnRGaWxsID0gZnVuY3Rpb24gKHN0eWxlRGF0YSwgaXRlbURhdGEsIGdyb3VwVHJhbnNmb3JtKSB7XG4gICAgdmFyIHN0eWxlRWxlbSA9IGl0ZW1EYXRhLnN0eWxlO1xuICAgIHZhciBncmQ7XG5cbiAgICBpZiAoIXN0eWxlRWxlbS5ncmQgfHwgaXRlbURhdGEuZy5fbWRmIHx8IGl0ZW1EYXRhLnMuX21kZiB8fCBpdGVtRGF0YS5lLl9tZGYgfHwgc3R5bGVEYXRhLnQgIT09IDEgJiYgKGl0ZW1EYXRhLmguX21kZiB8fCBpdGVtRGF0YS5hLl9tZGYpKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQ7XG4gICAgICB2YXIgcHQxID0gaXRlbURhdGEucy52O1xuICAgICAgdmFyIHB0MiA9IGl0ZW1EYXRhLmUudjtcblxuICAgICAgaWYgKHN0eWxlRGF0YS50ID09PSAxKSB7XG4gICAgICAgIGdyZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChwdDFbMF0sIHB0MVsxXSwgcHQyWzBdLCBwdDJbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJhZCA9IE1hdGguc3FydChNYXRoLnBvdyhwdDFbMF0gLSBwdDJbMF0sIDIpICsgTWF0aC5wb3cocHQxWzFdIC0gcHQyWzFdLCAyKSk7XG4gICAgICAgIHZhciBhbmcgPSBNYXRoLmF0YW4yKHB0MlsxXSAtIHB0MVsxXSwgcHQyWzBdIC0gcHQxWzBdKTtcbiAgICAgICAgdmFyIHBlcmNlbnQgPSBpdGVtRGF0YS5oLnY7XG5cbiAgICAgICAgaWYgKHBlcmNlbnQgPj0gMSkge1xuICAgICAgICAgIHBlcmNlbnQgPSAwLjk5O1xuICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnQgPD0gLTEpIHtcbiAgICAgICAgICBwZXJjZW50ID0gLTAuOTk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlzdCA9IHJhZCAqIHBlcmNlbnQ7XG4gICAgICAgIHZhciB4ID0gTWF0aC5jb3MoYW5nICsgaXRlbURhdGEuYS52KSAqIGRpc3QgKyBwdDFbMF07XG4gICAgICAgIHZhciB5ID0gTWF0aC5zaW4oYW5nICsgaXRlbURhdGEuYS52KSAqIGRpc3QgKyBwdDFbMV07XG4gICAgICAgIGdyZCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4LCB5LCAwLCBwdDFbMF0sIHB0MVsxXSwgcmFkKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc3R5bGVEYXRhLmcucDtcbiAgICAgIHZhciBjVmFsdWVzID0gaXRlbURhdGEuZy5jO1xuICAgICAgdmFyIG9wYWNpdHkgPSAxO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGl0ZW1EYXRhLmcuX2hhc09wYWNpdHkgJiYgaXRlbURhdGEuZy5fY29sbGFwc2FibGUpIHtcbiAgICAgICAgICBvcGFjaXR5ID0gaXRlbURhdGEuZy5vW2kgKiAyICsgMV07XG4gICAgICAgIH1cblxuICAgICAgICBncmQuYWRkQ29sb3JTdG9wKGNWYWx1ZXNbaSAqIDRdIC8gMTAwLCAncmdiYSgnICsgY1ZhbHVlc1tpICogNCArIDFdICsgJywnICsgY1ZhbHVlc1tpICogNCArIDJdICsgJywnICsgY1ZhbHVlc1tpICogNCArIDNdICsgJywnICsgb3BhY2l0eSArICcpJyk7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlRWxlbS5ncmQgPSBncmQ7XG4gICAgfVxuXG4gICAgc3R5bGVFbGVtLmNvT3AgPSBpdGVtRGF0YS5vLnYgKiBncm91cFRyYW5zZm9ybS5vcGFjaXR5O1xuICB9O1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJTdHJva2UgPSBmdW5jdGlvbiAoc3R5bGVEYXRhLCBpdGVtRGF0YSwgZ3JvdXBUcmFuc2Zvcm0pIHtcbiAgICB2YXIgc3R5bGVFbGVtID0gaXRlbURhdGEuc3R5bGU7XG4gICAgdmFyIGQgPSBpdGVtRGF0YS5kO1xuXG4gICAgaWYgKGQgJiYgKGQuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpKSB7XG4gICAgICBzdHlsZUVsZW0uZGEgPSBkLmRhc2hBcnJheTtcbiAgICAgIHN0eWxlRWxlbVtcImRvXCJdID0gZC5kYXNob2Zmc2V0WzBdO1xuICAgIH1cblxuICAgIGlmIChpdGVtRGF0YS5jLl9tZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKSB7XG4gICAgICBzdHlsZUVsZW0uY28gPSAncmdiKCcgKyBibUZsb29yKGl0ZW1EYXRhLmMudlswXSkgKyAnLCcgKyBibUZsb29yKGl0ZW1EYXRhLmMudlsxXSkgKyAnLCcgKyBibUZsb29yKGl0ZW1EYXRhLmMudlsyXSkgKyAnKSc7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW1EYXRhLm8uX21kZiB8fCBncm91cFRyYW5zZm9ybS5fb3BNZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKSB7XG4gICAgICBzdHlsZUVsZW0uY29PcCA9IGl0ZW1EYXRhLm8udiAqIGdyb3VwVHJhbnNmb3JtLm9wYWNpdHk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW1EYXRhLncuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHN0eWxlRWxlbS53aSA9IGl0ZW1EYXRhLncudjtcbiAgICB9XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zaGFwZXNEYXRhID0gbnVsbDtcbiAgICB0aGlzLmdsb2JhbERhdGEgPSBudWxsO1xuICAgIHRoaXMuY2FudmFzQ29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aCA9IDA7XG4gICAgdGhpcy5pdGVtc0RhdGEubGVuZ3RoID0gMDtcbiAgfTtcblxuICBmdW5jdGlvbiBDVlRleHRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLnRleHRTcGFucyA9IFtdO1xuICAgIHRoaXMueU9mZnNldCA9IDA7XG4gICAgdGhpcy5maWxsQ29sb3JBbmltID0gZmFsc2U7XG4gICAgdGhpcy5zdHJva2VDb2xvckFuaW0gPSBmYWxzZTtcbiAgICB0aGlzLnN0cm9rZVdpZHRoQW5pbSA9IGZhbHNlO1xuICAgIHRoaXMuc3Ryb2tlID0gZmFsc2U7XG4gICAgdGhpcy5maWxsID0gZmFsc2U7XG4gICAgdGhpcy5qdXN0aWZ5T2Zmc2V0ID0gMDtcbiAgICB0aGlzLmN1cnJlbnRSZW5kZXIgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyVHlwZSA9ICdjYW52YXMnO1xuICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgZmlsbDogJ3JnYmEoMCwwLDAsMCknLFxuICAgICAgc3Ryb2tlOiAncmdiYSgwLDAsMCwwKScsXG4gICAgICBzV2lkdGg6IDAsXG4gICAgICBmVmFsdWU6ICcnXG4gICAgfTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgQ1ZCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRWxlbWVudCwgSVRleHRFbGVtZW50XSwgQ1ZUZXh0RWxlbWVudCk7XG4gIENWVGV4dEVsZW1lbnQucHJvdG90eXBlLnRIZWxwZXIgPSBjcmVhdGVUYWcoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG5cbiAgQ1ZUZXh0RWxlbWVudC5wcm90b3R5cGUuYnVpbGROZXdUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkb2N1bWVudERhdGEgPSB0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YTtcbiAgICB0aGlzLnJlbmRlcmVkTGV0dGVycyA9IGNyZWF0ZVNpemVkQXJyYXkoZG9jdW1lbnREYXRhLmwgPyBkb2N1bWVudERhdGEubC5sZW5ndGggOiAwKTtcbiAgICB2YXIgaGFzRmlsbCA9IGZhbHNlO1xuXG4gICAgaWYgKGRvY3VtZW50RGF0YS5mYykge1xuICAgICAgaGFzRmlsbCA9IHRydWU7XG4gICAgICB0aGlzLnZhbHVlcy5maWxsID0gdGhpcy5idWlsZENvbG9yKGRvY3VtZW50RGF0YS5mYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsdWVzLmZpbGwgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgfVxuXG4gICAgdGhpcy5maWxsID0gaGFzRmlsbDtcbiAgICB2YXIgaGFzU3Ryb2tlID0gZmFsc2U7XG5cbiAgICBpZiAoZG9jdW1lbnREYXRhLnNjKSB7XG4gICAgICBoYXNTdHJva2UgPSB0cnVlO1xuICAgICAgdGhpcy52YWx1ZXMuc3Ryb2tlID0gdGhpcy5idWlsZENvbG9yKGRvY3VtZW50RGF0YS5zYyk7XG4gICAgICB0aGlzLnZhbHVlcy5zV2lkdGggPSBkb2N1bWVudERhdGEuc3c7XG4gICAgfVxuXG4gICAgdmFyIGZvbnREYXRhID0gdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgdmFyIGxldHRlcnMgPSBkb2N1bWVudERhdGEubDtcbiAgICB2YXIgbWF0cml4SGVscGVyID0gdGhpcy5tSGVscGVyO1xuICAgIHRoaXMuc3Ryb2tlID0gaGFzU3Ryb2tlO1xuICAgIHRoaXMudmFsdWVzLmZWYWx1ZSA9IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKyAncHggJyArIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5O1xuICAgIGxlbiA9IGRvY3VtZW50RGF0YS5maW5hbFRleHQubGVuZ3RoOyAvLyB0aGlzLnRIZWxwZXIuZm9udCA9IHRoaXMudmFsdWVzLmZWYWx1ZTtcblxuICAgIHZhciBjaGFyRGF0YTtcbiAgICB2YXIgc2hhcGVEYXRhO1xuICAgIHZhciBrO1xuICAgIHZhciBrTGVuO1xuICAgIHZhciBzaGFwZXM7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIHBhdGhOb2RlcztcbiAgICB2YXIgY29tbWFuZHM7XG4gICAgdmFyIHBhdGhBcnI7XG4gICAgdmFyIHNpbmdsZVNoYXBlID0gdGhpcy5kYXRhLnNpbmdsZVNoYXBlO1xuICAgIHZhciB0cmFja2luZ09mZnNldCA9IGRvY3VtZW50RGF0YS50ciAqIDAuMDAxICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcbiAgICB2YXIgeFBvcyA9IDA7XG4gICAgdmFyIHlQb3MgPSAwO1xuICAgIHZhciBmaXJzdExpbmUgPSB0cnVlO1xuICAgIHZhciBjbnQgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjaGFyRGF0YSA9IHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRDaGFyRGF0YShkb2N1bWVudERhdGEuZmluYWxUZXh0W2ldLCBmb250RGF0YS5mU3R5bGUsIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5KTtcbiAgICAgIHNoYXBlRGF0YSA9IGNoYXJEYXRhICYmIGNoYXJEYXRhLmRhdGEgfHwge307XG4gICAgICBtYXRyaXhIZWxwZXIucmVzZXQoKTtcblxuICAgICAgaWYgKHNpbmdsZVNoYXBlICYmIGxldHRlcnNbaV0ubikge1xuICAgICAgICB4UG9zID0gLXRyYWNraW5nT2Zmc2V0O1xuICAgICAgICB5UG9zICs9IGRvY3VtZW50RGF0YS55T2Zmc2V0O1xuICAgICAgICB5UG9zICs9IGZpcnN0TGluZSA/IDEgOiAwO1xuICAgICAgICBmaXJzdExpbmUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgc2hhcGVzID0gc2hhcGVEYXRhLnNoYXBlcyA/IHNoYXBlRGF0YS5zaGFwZXNbMF0uaXQgOiBbXTtcbiAgICAgIGpMZW4gPSBzaGFwZXMubGVuZ3RoO1xuICAgICAgbWF0cml4SGVscGVyLnNjYWxlKGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDAsIGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDApO1xuXG4gICAgICBpZiAoc2luZ2xlU2hhcGUpIHtcbiAgICAgICAgdGhpcy5hcHBseVRleHRQcm9wZXJ0aWVzVG9NYXRyaXgoZG9jdW1lbnREYXRhLCBtYXRyaXhIZWxwZXIsIGxldHRlcnNbaV0ubGluZSwgeFBvcywgeVBvcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbW1hbmRzID0gY3JlYXRlU2l6ZWRBcnJheShqTGVuIC0gMSk7XG4gICAgICB2YXIgY29tbWFuZHNDb3VudGVyID0gMDtcblxuICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICBpZiAoc2hhcGVzW2pdLnR5ID09PSAnc2gnKSB7XG4gICAgICAgICAga0xlbiA9IHNoYXBlc1tqXS5rcy5rLmkubGVuZ3RoO1xuICAgICAgICAgIHBhdGhOb2RlcyA9IHNoYXBlc1tqXS5rcy5rO1xuICAgICAgICAgIHBhdGhBcnIgPSBbXTtcblxuICAgICAgICAgIGZvciAoayA9IDE7IGsgPCBrTGVuOyBrICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgIHBhdGhBcnIucHVzaChtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLnZbMF1bMF0sIHBhdGhOb2Rlcy52WzBdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy52WzBdWzBdLCBwYXRoTm9kZXMudlswXVsxXSwgMCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXRoQXJyLnB1c2gobWF0cml4SGVscGVyLmFwcGx5VG9YKHBhdGhOb2Rlcy5vW2sgLSAxXVswXSwgcGF0aE5vZGVzLm9bayAtIDFdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy5vW2sgLSAxXVswXSwgcGF0aE5vZGVzLm9bayAtIDFdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9YKHBhdGhOb2Rlcy5pW2tdWzBdLCBwYXRoTm9kZXMuaVtrXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWShwYXRoTm9kZXMuaVtrXVswXSwgcGF0aE5vZGVzLmlba11bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLnZba11bMF0sIHBhdGhOb2Rlcy52W2tdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy52W2tdWzBdLCBwYXRoTm9kZXMudltrXVsxXSwgMCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGhBcnIucHVzaChtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLm9bayAtIDFdWzBdLCBwYXRoTm9kZXMub1trIC0gMV1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLm9bayAtIDFdWzBdLCBwYXRoTm9kZXMub1trIC0gMV1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLmlbMF1bMF0sIHBhdGhOb2Rlcy5pWzBdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy5pWzBdWzBdLCBwYXRoTm9kZXMuaVswXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWChwYXRoTm9kZXMudlswXVswXSwgcGF0aE5vZGVzLnZbMF1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLnZbMF1bMF0sIHBhdGhOb2Rlcy52WzBdWzFdLCAwKSk7XG4gICAgICAgICAgY29tbWFuZHNbY29tbWFuZHNDb3VudGVyXSA9IHBhdGhBcnI7XG4gICAgICAgICAgY29tbWFuZHNDb3VudGVyICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNpbmdsZVNoYXBlKSB7XG4gICAgICAgIHhQb3MgKz0gbGV0dGVyc1tpXS5sO1xuICAgICAgICB4UG9zICs9IHRyYWNraW5nT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50ZXh0U3BhbnNbY250XSkge1xuICAgICAgICB0aGlzLnRleHRTcGFuc1tjbnRdLmVsZW0gPSBjb21tYW5kcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGV4dFNwYW5zW2NudF0gPSB7XG4gICAgICAgICAgZWxlbTogY29tbWFuZHNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY250ICs9IDE7XG4gICAgfVxuICB9O1xuXG4gIENWVGV4dEVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnZhbGlkYXRlVGV4dCgpO1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhc0NvbnRleHQ7XG4gICAgY3R4LmZvbnQgPSB0aGlzLnZhbHVlcy5mVmFsdWU7XG4gICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eExpbmVDYXAoJ2J1dHQnKTsgLy8gY3R4LmxpbmVDYXAgPSAnYnV0dCc7XG5cbiAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuY3R4TGluZUpvaW4oJ21pdGVyJyk7IC8vIGN0eC5saW5lSm9pbiA9ICdtaXRlcic7XG5cbiAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuY3R4TWl0ZXJMaW1pdCg0KTsgLy8gY3R4Lm1pdGVyTGltaXQgPSA0O1xuXG4gICAgaWYgKCF0aGlzLmRhdGEuc2luZ2xlU2hhcGUpIHtcbiAgICAgIHRoaXMudGV4dEFuaW1hdG9yLmdldE1lYXN1cmVzKHRoaXMudGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLCB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyk7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgaztcbiAgICB2YXIga0xlbjtcbiAgICB2YXIgcmVuZGVyZWRMZXR0ZXJzID0gdGhpcy50ZXh0QW5pbWF0b3IucmVuZGVyZWRMZXR0ZXJzO1xuICAgIHZhciBsZXR0ZXJzID0gdGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEubDtcbiAgICBsZW4gPSBsZXR0ZXJzLmxlbmd0aDtcbiAgICB2YXIgcmVuZGVyZWRMZXR0ZXI7XG4gICAgdmFyIGxhc3RGaWxsID0gbnVsbDtcbiAgICB2YXIgbGFzdFN0cm9rZSA9IG51bGw7XG4gICAgdmFyIGxhc3RTdHJva2VXID0gbnVsbDtcbiAgICB2YXIgY29tbWFuZHM7XG4gICAgdmFyIHBhdGhBcnI7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAoIWxldHRlcnNbaV0ubikge1xuICAgICAgICByZW5kZXJlZExldHRlciA9IHJlbmRlcmVkTGV0dGVyc1tpXTtcblxuICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIpIHtcbiAgICAgICAgICByZW5kZXJlci5zYXZlKCk7XG4gICAgICAgICAgcmVuZGVyZXIuY3R4VHJhbnNmb3JtKHJlbmRlcmVkTGV0dGVyLnApO1xuICAgICAgICAgIHJlbmRlcmVyLmN0eE9wYWNpdHkocmVuZGVyZWRMZXR0ZXIubyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5maWxsKSB7XG4gICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyICYmIHJlbmRlcmVkTGV0dGVyLmZjKSB7XG4gICAgICAgICAgICBpZiAobGFzdEZpbGwgIT09IHJlbmRlcmVkTGV0dGVyLmZjKSB7XG4gICAgICAgICAgICAgIHJlbmRlcmVyLmN0eEZpbGxTdHlsZShyZW5kZXJlZExldHRlci5mYyk7XG4gICAgICAgICAgICAgIGxhc3RGaWxsID0gcmVuZGVyZWRMZXR0ZXIuZmM7IC8vIGN0eC5maWxsU3R5bGUgPSByZW5kZXJlZExldHRlci5mYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RGaWxsICE9PSB0aGlzLnZhbHVlcy5maWxsKSB7XG4gICAgICAgICAgICBsYXN0RmlsbCA9IHRoaXMudmFsdWVzLmZpbGw7XG4gICAgICAgICAgICByZW5kZXJlci5jdHhGaWxsU3R5bGUodGhpcy52YWx1ZXMuZmlsbCk7IC8vIGN0eC5maWxsU3R5bGUgPSB0aGlzLnZhbHVlcy5maWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbW1hbmRzID0gdGhpcy50ZXh0U3BhbnNbaV0uZWxlbTtcbiAgICAgICAgICBqTGVuID0gY29tbWFuZHMubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgcGF0aEFyciA9IGNvbW1hbmRzW2pdO1xuICAgICAgICAgICAga0xlbiA9IHBhdGhBcnIubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQubW92ZVRvKHBhdGhBcnJbMF0sIHBhdGhBcnJbMV0pO1xuXG4gICAgICAgICAgICBmb3IgKGsgPSAyOyBrIDwga0xlbjsgayArPSA2KSB7XG4gICAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmJlemllckN1cnZlVG8ocGF0aEFycltrXSwgcGF0aEFycltrICsgMV0sIHBhdGhBcnJbayArIDJdLCBwYXRoQXJyW2sgKyAzXSwgcGF0aEFycltrICsgNF0sIHBhdGhBcnJbayArIDVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICByZW5kZXJlci5jdHhGaWxsKCk7IC8vIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmZpbGwoKTtcbiAgICAgICAgICAvLy8gY3R4LmZpbGxUZXh0KHRoaXMudGV4dFNwYW5zW2ldLnZhbCwwLDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyICYmIHJlbmRlcmVkTGV0dGVyLnN3KSB7XG4gICAgICAgICAgICBpZiAobGFzdFN0cm9rZVcgIT09IHJlbmRlcmVkTGV0dGVyLnN3KSB7XG4gICAgICAgICAgICAgIGxhc3RTdHJva2VXID0gcmVuZGVyZWRMZXR0ZXIuc3c7XG4gICAgICAgICAgICAgIHJlbmRlcmVyLmN0eExpbmVXaWR0aChyZW5kZXJlZExldHRlci5zdyk7IC8vIGN0eC5saW5lV2lkdGggPSByZW5kZXJlZExldHRlci5zdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RTdHJva2VXICE9PSB0aGlzLnZhbHVlcy5zV2lkdGgpIHtcbiAgICAgICAgICAgIGxhc3RTdHJva2VXID0gdGhpcy52YWx1ZXMuc1dpZHRoO1xuICAgICAgICAgICAgcmVuZGVyZXIuY3R4TGluZVdpZHRoKHRoaXMudmFsdWVzLnNXaWR0aCk7IC8vIGN0eC5saW5lV2lkdGggPSB0aGlzLnZhbHVlcy5zV2lkdGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyICYmIHJlbmRlcmVkTGV0dGVyLnNjKSB7XG4gICAgICAgICAgICBpZiAobGFzdFN0cm9rZSAhPT0gcmVuZGVyZWRMZXR0ZXIuc2MpIHtcbiAgICAgICAgICAgICAgbGFzdFN0cm9rZSA9IHJlbmRlcmVkTGV0dGVyLnNjO1xuICAgICAgICAgICAgICByZW5kZXJlci5jdHhTdHJva2VTdHlsZShyZW5kZXJlZExldHRlci5zYyk7IC8vIGN0eC5zdHJva2VTdHlsZSA9IHJlbmRlcmVkTGV0dGVyLnNjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobGFzdFN0cm9rZSAhPT0gdGhpcy52YWx1ZXMuc3Ryb2tlKSB7XG4gICAgICAgICAgICBsYXN0U3Ryb2tlID0gdGhpcy52YWx1ZXMuc3Ryb2tlO1xuICAgICAgICAgICAgcmVuZGVyZXIuY3R4U3Ryb2tlU3R5bGUodGhpcy52YWx1ZXMuc3Ryb2tlKTsgLy8gY3R4LnN0cm9rZVN0eWxlID0gdGhpcy52YWx1ZXMuc3Ryb2tlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbW1hbmRzID0gdGhpcy50ZXh0U3BhbnNbaV0uZWxlbTtcbiAgICAgICAgICBqTGVuID0gY29tbWFuZHMubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgcGF0aEFyciA9IGNvbW1hbmRzW2pdO1xuICAgICAgICAgICAga0xlbiA9IHBhdGhBcnIubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQubW92ZVRvKHBhdGhBcnJbMF0sIHBhdGhBcnJbMV0pO1xuXG4gICAgICAgICAgICBmb3IgKGsgPSAyOyBrIDwga0xlbjsgayArPSA2KSB7XG4gICAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmJlemllckN1cnZlVG8ocGF0aEFycltrXSwgcGF0aEFycltrICsgMV0sIHBhdGhBcnJbayArIDJdLCBwYXRoQXJyW2sgKyAzXSwgcGF0aEFycltrICsgNF0sIHBhdGhBcnJbayArIDVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICByZW5kZXJlci5jdHhTdHJva2UoKTsgLy8gdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgLy8vIGN0eC5zdHJva2VUZXh0KGxldHRlcnNbaV0udmFsLDAsMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIpIHtcbiAgICAgICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIENWSW1hZ2VFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmFzc2V0RGF0YSA9IGdsb2JhbERhdGEuZ2V0QXNzZXREYXRhKGRhdGEucmVmSWQpO1xuICAgIHRoaXMuaW1nID0gZ2xvYmFsRGF0YS5pbWFnZUxvYWRlci5nZXRBc3NldCh0aGlzLmFzc2V0RGF0YSk7XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIENWQmFzZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZUVsZW1lbnRdLCBDVkltYWdlRWxlbWVudCk7XG4gIENWSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudCA9IFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuaW5pdEVsZW1lbnQ7XG4gIENWSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBJSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWU7XG5cbiAgQ1ZJbWFnZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaW1nLndpZHRoICYmICh0aGlzLmFzc2V0RGF0YS53ICE9PSB0aGlzLmltZy53aWR0aCB8fCB0aGlzLmFzc2V0RGF0YS5oICE9PSB0aGlzLmltZy5oZWlnaHQpKSB7XG4gICAgICB2YXIgY2FudmFzID0gY3JlYXRlVGFnKCdjYW52YXMnKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuYXNzZXREYXRhLnc7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5hc3NldERhdGEuaDtcbiAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHZhciBpbWdXID0gdGhpcy5pbWcud2lkdGg7XG4gICAgICB2YXIgaW1nSCA9IHRoaXMuaW1nLmhlaWdodDtcbiAgICAgIHZhciBpbWdSZWwgPSBpbWdXIC8gaW1nSDtcbiAgICAgIHZhciBjYW52YXNSZWwgPSB0aGlzLmFzc2V0RGF0YS53IC8gdGhpcy5hc3NldERhdGEuaDtcbiAgICAgIHZhciB3aWR0aENyb3A7XG4gICAgICB2YXIgaGVpZ2h0Q3JvcDtcbiAgICAgIHZhciBwYXIgPSB0aGlzLmFzc2V0RGF0YS5wciB8fCB0aGlzLmdsb2JhbERhdGEucmVuZGVyQ29uZmlnLmltYWdlUHJlc2VydmVBc3BlY3RSYXRpbztcblxuICAgICAgaWYgKGltZ1JlbCA+IGNhbnZhc1JlbCAmJiBwYXIgPT09ICd4TWlkWU1pZCBzbGljZScgfHwgaW1nUmVsIDwgY2FudmFzUmVsICYmIHBhciAhPT0gJ3hNaWRZTWlkIHNsaWNlJykge1xuICAgICAgICBoZWlnaHRDcm9wID0gaW1nSDtcbiAgICAgICAgd2lkdGhDcm9wID0gaGVpZ2h0Q3JvcCAqIGNhbnZhc1JlbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoQ3JvcCA9IGltZ1c7XG4gICAgICAgIGhlaWdodENyb3AgPSB3aWR0aENyb3AgLyBjYW52YXNSZWw7XG4gICAgICB9XG5cbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5pbWcsIChpbWdXIC0gd2lkdGhDcm9wKSAvIDIsIChpbWdIIC0gaGVpZ2h0Q3JvcCkgLyAyLCB3aWR0aENyb3AsIGhlaWdodENyb3AsIDAsIDAsIHRoaXMuYXNzZXREYXRhLncsIHRoaXMuYXNzZXREYXRhLmgpO1xuICAgICAgdGhpcy5pbWcgPSBjYW52YXM7XG4gICAgfVxuICB9O1xuXG4gIENWSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LmRyYXdJbWFnZSh0aGlzLmltZywgMCwgMCk7XG4gIH07XG5cbiAgQ1ZJbWFnZUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pbWcgPSBudWxsO1xuICB9O1xuXG4gIGZ1bmN0aW9uIENWU29saWRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgQ1ZCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRWxlbWVudF0sIENWU29saWRFbGVtZW50KTtcbiAgQ1ZTb2xpZEVsZW1lbnQucHJvdG90eXBlLmluaXRFbGVtZW50ID0gU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudDtcbiAgQ1ZTb2xpZEVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IElJbWFnZUVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZTtcblxuICBDVlNvbGlkRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHZhciBjdHggPSB0aGlzLmNhbnZhc0NvbnRleHQ7XG4gICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eEZpbGxTdHlsZSh0aGlzLmRhdGEuc2MpOyAvLyBjdHguZmlsbFN0eWxlID0gdGhpcy5kYXRhLnNjO1xuXG4gICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eEZpbGxSZWN0KDAsIDAsIHRoaXMuZGF0YS5zdywgdGhpcy5kYXRhLnNoKTsgLy8gY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuZGF0YS5zdywgdGhpcy5kYXRhLnNoKTtcbiAgICAvL1xuICB9O1xuXG4gIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyQmFzZSgpIHt9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlUmVuZGVyZXJdLCBDYW52YXNSZW5kZXJlckJhc2UpO1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlU2hhcGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQ1ZTaGFwZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZVRleHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQ1ZUZXh0RWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlSW1hZ2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQ1ZJbWFnZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZVNvbGlkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IENWU29saWRFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVOdWxsID0gU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZU51bGw7XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jdHhUcmFuc2Zvcm0gPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBpZiAocHJvcHNbMF0gPT09IDEgJiYgcHJvcHNbMV0gPT09IDAgJiYgcHJvcHNbNF0gPT09IDAgJiYgcHJvcHNbNV0gPT09IDEgJiYgcHJvcHNbMTJdID09PSAwICYmIHByb3BzWzEzXSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2FudmFzQ29udGV4dC50cmFuc2Zvcm0ocHJvcHNbMF0sIHByb3BzWzFdLCBwcm9wc1s0XSwgcHJvcHNbNV0sIHByb3BzWzEyXSwgcHJvcHNbMTNdKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmN0eE9wYWNpdHkgPSBmdW5jdGlvbiAob3ApIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuZ2xvYmFsQWxwaGEgKj0gb3AgPCAwID8gMCA6IG9wO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4RmlsbFN0eWxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LmZpbGxTdHlsZSA9IHZhbHVlO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4U3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGUgPSB2YWx1ZTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmN0eExpbmVXaWR0aCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5saW5lV2lkdGggPSB2YWx1ZTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmN0eExpbmVDYXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQubGluZUNhcCA9IHZhbHVlO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4TGluZUpvaW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQubGluZUpvaW4gPSB2YWx1ZTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmN0eE1pdGVyTGltaXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQubWl0ZXJMaW1pdCA9IHZhbHVlO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4RmlsbCA9IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LmZpbGwocnVsZSk7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jdHhGaWxsUmVjdCA9IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4U3Ryb2tlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5zdHJva2UoKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZXh0RGF0YS5yZXNldCgpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuc2F2ZSgpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIChhY3Rpb25GbGFnKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uRmxhZykge1xuICAgICAgdGhpcy5nbG9iYWxEYXRhLmJsZW5kTW9kZSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZXh0RGF0YS5yZXN0b3JlKGFjdGlvbkZsYWcpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY29uZmlnQW5pbWF0aW9uID0gZnVuY3Rpb24gKGFuaW1EYXRhKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyID0gY3JlYXRlVGFnKCdjYW52YXMnKTtcbiAgICAgIHZhciBjb250YWluZXJTdHlsZSA9IHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuc3R5bGU7XG4gICAgICBjb250YWluZXJTdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgIGNvbnRhaW5lclN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgIHZhciBvcmlnaW4gPSAnMHB4IDBweCAwcHgnO1xuICAgICAgY29udGFpbmVyU3R5bGUudHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xuICAgICAgY29udGFpbmVyU3R5bGUubW96VHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xuICAgICAgY29udGFpbmVyU3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xuICAgICAgY29udGFpbmVyU3R5bGVbJy13ZWJraXQtdHJhbnNmb3JtJ10gPSBvcmlnaW47XG4gICAgICBjb250YWluZXJTdHlsZS5jb250ZW50VmlzaWJpbGl0eSA9IHRoaXMucmVuZGVyQ29uZmlnLmNvbnRlbnRWaXNpYmlsaXR5O1xuICAgICAgdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lcik7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQgPSB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5jbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmlkKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMucmVuZGVyQ29uZmlnLmlkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0ID0gdGhpcy5yZW5kZXJDb25maWcuY29udGV4dDtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRleHREYXRhLnNldENvbnRleHQodGhpcy5jYW52YXNDb250ZXh0KTtcbiAgICB0aGlzLmRhdGEgPSBhbmltRGF0YTtcbiAgICB0aGlzLmxheWVycyA9IGFuaW1EYXRhLmxheWVycztcbiAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcyA9IHtcbiAgICAgIHc6IGFuaW1EYXRhLncsXG4gICAgICBoOiBhbmltRGF0YS5oLFxuICAgICAgc3g6IDAsXG4gICAgICBzeTogMCxcbiAgICAgIHR4OiAwLFxuICAgICAgdHk6IDBcbiAgICB9O1xuICAgIHRoaXMuc2V0dXBHbG9iYWxEYXRhKGFuaW1EYXRhLCBkb2N1bWVudC5ib2R5KTtcbiAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dCA9IHRoaXMuY2FudmFzQ29udGV4dDtcbiAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIgPSB0aGlzO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5pc0Rhc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5wcm9ncmVzc2l2ZUxvYWQgPSB0aGlzLnJlbmRlckNvbmZpZy5wcm9ncmVzc2l2ZUxvYWQ7XG4gICAgdGhpcy5nbG9iYWxEYXRhLnRyYW5zZm9ybUNhbnZhcyA9IHRoaXMudHJhbnNmb3JtQ2FudmFzO1xuICAgIHRoaXMuZWxlbWVudHMgPSBjcmVhdGVTaXplZEFycmF5KGFuaW1EYXRhLmxheWVycy5sZW5ndGgpO1xuICAgIHRoaXMudXBkYXRlQ29udGFpbmVyU2l6ZSgpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUudXBkYXRlQ29udGFpbmVyU2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHZhciBlbGVtZW50V2lkdGg7XG4gICAgdmFyIGVsZW1lbnRIZWlnaHQ7XG5cbiAgICBpZiAod2lkdGgpIHtcbiAgICAgIGVsZW1lbnRXaWR0aCA9IHdpZHRoO1xuICAgICAgZWxlbWVudEhlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMud2lkdGggPSBlbGVtZW50V2lkdGg7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQuY2FudmFzLmhlaWdodCA9IGVsZW1lbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlciAmJiB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyKSB7XG4gICAgICAgIGVsZW1lbnRXaWR0aCA9IHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLm9mZnNldFdpZHRoO1xuICAgICAgICBlbGVtZW50SGVpZ2h0ID0gdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudFdpZHRoID0gdGhpcy5jYW52YXNDb250ZXh0LmNhbnZhcy53aWR0aDtcbiAgICAgICAgZWxlbWVudEhlaWdodCA9IHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQuY2FudmFzLndpZHRoID0gZWxlbWVudFdpZHRoICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBlbGVtZW50SGVpZ2h0ICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50UmVsO1xuICAgIHZhciBhbmltYXRpb25SZWw7XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcucHJlc2VydmVBc3BlY3RSYXRpby5pbmRleE9mKCdtZWV0JykgIT09IC0xIHx8IHRoaXMucmVuZGVyQ29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8uaW5kZXhPZignc2xpY2UnKSAhPT0gLTEpIHtcbiAgICAgIHZhciBwYXIgPSB0aGlzLnJlbmRlckNvbmZpZy5wcmVzZXJ2ZUFzcGVjdFJhdGlvLnNwbGl0KCcgJyk7XG4gICAgICB2YXIgZmlsbFR5cGUgPSBwYXJbMV0gfHwgJ21lZXQnO1xuICAgICAgdmFyIHBvcyA9IHBhclswXSB8fCAneE1pZFlNaWQnO1xuICAgICAgdmFyIHhQb3MgPSBwb3Muc3Vic3RyKDAsIDQpO1xuICAgICAgdmFyIHlQb3MgPSBwb3Muc3Vic3RyKDQpO1xuICAgICAgZWxlbWVudFJlbCA9IGVsZW1lbnRXaWR0aCAvIGVsZW1lbnRIZWlnaHQ7XG4gICAgICBhbmltYXRpb25SZWwgPSB0aGlzLnRyYW5zZm9ybUNhbnZhcy53IC8gdGhpcy50cmFuc2Zvcm1DYW52YXMuaDtcblxuICAgICAgaWYgKGFuaW1hdGlvblJlbCA+IGVsZW1lbnRSZWwgJiYgZmlsbFR5cGUgPT09ICdtZWV0JyB8fCBhbmltYXRpb25SZWwgPCBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnc2xpY2UnKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN4ID0gZWxlbWVudFdpZHRoIC8gKHRoaXMudHJhbnNmb3JtQ2FudmFzLncgLyB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSA9IGVsZW1lbnRXaWR0aCAvICh0aGlzLnRyYW5zZm9ybUNhbnZhcy53IC8gdGhpcy5yZW5kZXJDb25maWcuZHByKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN4ID0gZWxlbWVudEhlaWdodCAvICh0aGlzLnRyYW5zZm9ybUNhbnZhcy5oIC8gdGhpcy5yZW5kZXJDb25maWcuZHByKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3kgPSBlbGVtZW50SGVpZ2h0IC8gKHRoaXMudHJhbnNmb3JtQ2FudmFzLmggLyB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoeFBvcyA9PT0gJ3hNaWQnICYmIChhbmltYXRpb25SZWwgPCBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnbWVldCcgfHwgYW5pbWF0aW9uUmVsID4gZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHggPSAoZWxlbWVudFdpZHRoIC0gdGhpcy50cmFuc2Zvcm1DYW52YXMudyAqIChlbGVtZW50SGVpZ2h0IC8gdGhpcy50cmFuc2Zvcm1DYW52YXMuaCkpIC8gMiAqIHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcbiAgICAgIH0gZWxzZSBpZiAoeFBvcyA9PT0gJ3hNYXgnICYmIChhbmltYXRpb25SZWwgPCBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnbWVldCcgfHwgYW5pbWF0aW9uUmVsID4gZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHggPSAoZWxlbWVudFdpZHRoIC0gdGhpcy50cmFuc2Zvcm1DYW52YXMudyAqIChlbGVtZW50SGVpZ2h0IC8gdGhpcy50cmFuc2Zvcm1DYW52YXMuaCkpICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoeVBvcyA9PT0gJ1lNaWQnICYmIChhbmltYXRpb25SZWwgPiBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnbWVldCcgfHwgYW5pbWF0aW9uUmVsIDwgZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHkgPSAoZWxlbWVudEhlaWdodCAtIHRoaXMudHJhbnNmb3JtQ2FudmFzLmggKiAoZWxlbWVudFdpZHRoIC8gdGhpcy50cmFuc2Zvcm1DYW52YXMudykpIC8gMiAqIHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcbiAgICAgIH0gZWxzZSBpZiAoeVBvcyA9PT0gJ1lNYXgnICYmIChhbmltYXRpb25SZWwgPiBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnbWVldCcgfHwgYW5pbWF0aW9uUmVsIDwgZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHkgPSAoZWxlbWVudEhlaWdodCAtIHRoaXMudHJhbnNmb3JtQ2FudmFzLmggKiAoZWxlbWVudFdpZHRoIC8gdGhpcy50cmFuc2Zvcm1DYW52YXMudykpICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHkgPSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5yZW5kZXJDb25maWcucHJlc2VydmVBc3BlY3RSYXRpbyA9PT0gJ25vbmUnKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeCA9IGVsZW1lbnRXaWR0aCAvICh0aGlzLnRyYW5zZm9ybUNhbnZhcy53IC8gdGhpcy5yZW5kZXJDb25maWcuZHByKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN5ID0gZWxlbWVudEhlaWdodCAvICh0aGlzLnRyYW5zZm9ybUNhbnZhcy5oIC8gdGhpcy5yZW5kZXJDb25maWcuZHByKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR4ID0gMDtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3ggPSB0aGlzLnJlbmRlckNvbmZpZy5kcHI7XG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSA9IHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR4ID0gMDtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR5ID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5wcm9wcyA9IFt0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeCwgMCwgMCwgMCwgMCwgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3ksIDAsIDAsIDAsIDAsIDEsIDAsIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR4LCB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eSwgMCwgMV07XG4gICAgLyogdmFyIGksIGxlbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgaWYodGhpcy5lbGVtZW50c1tpXSAmJiB0aGlzLmVsZW1lbnRzW2ldLmRhdGEudHkgPT09IDApe1xyXG4gICAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbaV0ucmVzaXplKHRoaXMuZ2xvYmFsRGF0YS50cmFuc2Zvcm1DYW52YXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9ICovXG5cbiAgICB0aGlzLmN0eFRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybUNhbnZhcy5wcm9wcyk7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5yZWN0KDAsIDAsIHRoaXMudHJhbnNmb3JtQ2FudmFzLncsIHRoaXMudHJhbnNmb3JtQ2FudmFzLmgpO1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuY2xpcCgpO1xuICAgIHRoaXMucmVuZGVyRnJhbWUodGhpcy5yZW5kZXJlZEZyYW1lLCB0cnVlKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzICYmIHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5pbm5lclRleHQgPSAnJztcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMgPyB0aGlzLmxheWVycy5sZW5ndGggOiAwO1xuXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldICYmIHRoaXMuZWxlbWVudHNbaV0uZGVzdHJveSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKG51bSwgZm9yY2VSZW5kZXIpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlZEZyYW1lID09PSBudW0gJiYgdGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMgPT09IHRydWUgJiYgIWZvcmNlUmVuZGVyIHx8IHRoaXMuZGVzdHJveWVkIHx8IG51bSA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSBudW07XG4gICAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lTnVtID0gbnVtIC0gdGhpcy5hbmltYXRpb25JdGVtLl9pc0ZpcnN0RnJhbWU7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lSWQgKz0gMTtcbiAgICB0aGlzLmdsb2JhbERhdGEuX21kZiA9ICF0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcyB8fCBmb3JjZVJlbmRlcjtcbiAgICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5jdXJyZW50RnJhbWUgPSBudW07IC8vIGNvbnNvbGUubG9nKCctLS0tLS0tLScpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdORVc6ICcsbnVtKTtcblxuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG5cbiAgICBpZiAoIXRoaXMuY29tcGxldGVMYXllcnMpIHtcbiAgICAgIHRoaXMuY2hlY2tMYXllcnMobnVtKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnByZXBhcmVGcmFtZShudW0gLSB0aGlzLmxheWVyc1tpXS5zdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ2xvYmFsRGF0YS5fbWRmKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLnRyYW5zZm9ybUNhbnZhcy53LCB0aGlzLnRyYW5zZm9ybUNhbnZhcy5oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBpZiAodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5yZW5kZXJGcmFtZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcyAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5idWlsZEl0ZW0gPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcblxuICAgIGlmIChlbGVtZW50c1twb3NdIHx8IHRoaXMubGF5ZXJzW3Bvc10udHkgPT09IDk5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmNyZWF0ZUl0ZW0odGhpcy5sYXllcnNbcG9zXSwgdGhpcywgdGhpcy5nbG9iYWxEYXRhKTtcbiAgICBlbGVtZW50c1twb3NdID0gZWxlbWVudDtcbiAgICBlbGVtZW50LmluaXRFeHByZXNzaW9ucygpO1xuICAgIC8qIGlmKHRoaXMubGF5ZXJzW3Bvc10udHkgPT09IDApe1xyXG4gICAgICAgICAgZWxlbWVudC5yZXNpemUodGhpcy5nbG9iYWxEYXRhLnRyYW5zZm9ybUNhbnZhcyk7XHJcbiAgICAgIH0gKi9cbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmNoZWNrUGVuZGluZ0VsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHdoaWxlICh0aGlzLnBlbmRpbmdFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wZW5kaW5nRWxlbWVudHMucG9wKCk7XG4gICAgICBlbGVtZW50LmNoZWNrUGFyZW50aW5nKCk7XG4gICAgfVxuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gIH07XG5cbiAgZnVuY3Rpb24gQ2FudmFzQ29udGV4dCgpIHtcbiAgICB0aGlzLm9wYWNpdHkgPSAtMTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCAxNik7XG4gICAgdGhpcy5maWxsU3R5bGUgPSAnJztcbiAgICB0aGlzLnN0cm9rZVN0eWxlID0gJyc7XG4gICAgdGhpcy5saW5lV2lkdGggPSAnJztcbiAgICB0aGlzLmxpbmVDYXAgPSAnJztcbiAgICB0aGlzLmxpbmVKb2luID0gJyc7XG4gICAgdGhpcy5taXRlckxpbWl0ID0gJyc7XG4gICAgdGhpcy5pZCA9IE1hdGgucmFuZG9tKCk7XG4gIH1cblxuICBmdW5jdGlvbiBDVkNvbnRleHREYXRhKCkge1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLmNBcnJQb3MgPSAwO1xuICAgIHRoaXMuY1RyID0gbmV3IE1hdHJpeCgpO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSAxNTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdmFyIGNhbnZhc0NvbnRleHQgPSBuZXcgQ2FudmFzQ29udGV4dCgpO1xuICAgICAgdGhpcy5zdGFja1tpXSA9IGNhbnZhc0NvbnRleHQ7XG4gICAgfVxuXG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xuICAgIHRoaXMubmF0aXZlQ29udGV4dCA9IG51bGw7XG4gICAgdGhpcy50cmFuc2Zvcm1NYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5jdXJyZW50T3BhY2l0eSA9IDE7IC8vXG5cbiAgICB0aGlzLmN1cnJlbnRGaWxsU3R5bGUgPSAnJztcbiAgICB0aGlzLmFwcGxpZWRGaWxsU3R5bGUgPSAnJzsgLy9cblxuICAgIHRoaXMuY3VycmVudFN0cm9rZVN0eWxlID0gJyc7XG4gICAgdGhpcy5hcHBsaWVkU3Ryb2tlU3R5bGUgPSAnJzsgLy9cblxuICAgIHRoaXMuY3VycmVudExpbmVXaWR0aCA9ICcnO1xuICAgIHRoaXMuYXBwbGllZExpbmVXaWR0aCA9ICcnOyAvL1xuXG4gICAgdGhpcy5jdXJyZW50TGluZUNhcCA9ICcnO1xuICAgIHRoaXMuYXBwbGllZExpbmVDYXAgPSAnJzsgLy9cblxuICAgIHRoaXMuY3VycmVudExpbmVKb2luID0gJyc7XG4gICAgdGhpcy5hcHBsaWVkTGluZUpvaW4gPSAnJzsgLy9cblxuICAgIHRoaXMuYXBwbGllZE1pdGVyTGltaXQgPSAnJztcbiAgICB0aGlzLmN1cnJlbnRNaXRlckxpbWl0ID0gJyc7XG4gIH1cblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5kdXBsaWNhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5ld0xlbmd0aCA9IHRoaXMuX2xlbmd0aCAqIDI7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yIChpID0gdGhpcy5fbGVuZ3RoOyBpIDwgbmV3TGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuc3RhY2tbaV0gPSBuZXcgQ2FudmFzQ29udGV4dCgpO1xuICAgIH1cblxuICAgIHRoaXMuX2xlbmd0aCA9IG5ld0xlbmd0aDtcbiAgfTtcblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNBcnJQb3MgPSAwO1xuICAgIHRoaXMuY1RyLnJlc2V0KCk7XG4gICAgdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLm9wYWNpdHkgPSAxO1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiAoZm9yY2VSZXN0b3JlKSB7XG4gICAgdGhpcy5jQXJyUG9zIC09IDE7XG4gICAgdmFyIGN1cnJlbnRDb250ZXh0ID0gdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdO1xuICAgIHZhciB0cmFuc2Zvcm0gPSBjdXJyZW50Q29udGV4dC50cmFuc2Zvcm07XG4gICAgdmFyIGk7XG4gICAgdmFyIGFyciA9IHRoaXMuY1RyLnByb3BzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgIGFycltpXSA9IHRyYW5zZm9ybVtpXTtcbiAgICB9XG5cbiAgICBpZiAoZm9yY2VSZXN0b3JlKSB7XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgdmFyIHByZXZTdGFjayA9IHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zICsgMV07XG4gICAgICB0aGlzLmFwcGxpZWRGaWxsU3R5bGUgPSBwcmV2U3RhY2suZmlsbFN0eWxlO1xuICAgICAgdGhpcy5hcHBsaWVkU3Ryb2tlU3R5bGUgPSBwcmV2U3RhY2suc3Ryb2tlU3R5bGU7XG4gICAgICB0aGlzLmFwcGxpZWRMaW5lV2lkdGggPSBwcmV2U3RhY2subGluZVdpZHRoO1xuICAgICAgdGhpcy5hcHBsaWVkTGluZUNhcCA9IHByZXZTdGFjay5saW5lQ2FwO1xuICAgICAgdGhpcy5hcHBsaWVkTGluZUpvaW4gPSBwcmV2U3RhY2subGluZUpvaW47XG4gICAgICB0aGlzLmFwcGxpZWRNaXRlckxpbWl0ID0gcHJldlN0YWNrLm1pdGVyTGltaXQ7XG4gICAgfVxuXG4gICAgdGhpcy5uYXRpdmVDb250ZXh0LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm1bMF0sIHRyYW5zZm9ybVsxXSwgdHJhbnNmb3JtWzRdLCB0cmFuc2Zvcm1bNV0sIHRyYW5zZm9ybVsxMl0sIHRyYW5zZm9ybVsxM10pO1xuXG4gICAgaWYgKGZvcmNlUmVzdG9yZSB8fCBjdXJyZW50Q29udGV4dC5vcGFjaXR5ICE9PSAtMSAmJiB0aGlzLmN1cnJlbnRPcGFjaXR5ICE9PSBjdXJyZW50Q29udGV4dC5vcGFjaXR5KSB7XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQuZ2xvYmFsQWxwaGEgPSBjdXJyZW50Q29udGV4dC5vcGFjaXR5O1xuICAgICAgdGhpcy5jdXJyZW50T3BhY2l0eSA9IGN1cnJlbnRDb250ZXh0Lm9wYWNpdHk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50RmlsbFN0eWxlID0gY3VycmVudENvbnRleHQuZmlsbFN0eWxlO1xuICAgIHRoaXMuY3VycmVudFN0cm9rZVN0eWxlID0gY3VycmVudENvbnRleHQuc3Ryb2tlU3R5bGU7XG4gICAgdGhpcy5jdXJyZW50TGluZVdpZHRoID0gY3VycmVudENvbnRleHQubGluZVdpZHRoO1xuICAgIHRoaXMuY3VycmVudExpbmVDYXAgPSBjdXJyZW50Q29udGV4dC5saW5lQ2FwO1xuICAgIHRoaXMuY3VycmVudExpbmVKb2luID0gY3VycmVudENvbnRleHQubGluZUpvaW47XG4gICAgdGhpcy5jdXJyZW50TWl0ZXJMaW1pdCA9IGN1cnJlbnRDb250ZXh0Lm1pdGVyTGltaXQ7XG4gIH07XG5cbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIChzYXZlT25OYXRpdmVGbGFnKSB7XG4gICAgaWYgKHNhdmVPbk5hdGl2ZUZsYWcpIHtcbiAgICAgIHRoaXMubmF0aXZlQ29udGV4dC5zYXZlKCk7XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gdGhpcy5jVHIucHJvcHM7XG5cbiAgICBpZiAodGhpcy5fbGVuZ3RoIDw9IHRoaXMuY0FyclBvcykge1xuICAgICAgdGhpcy5kdXBsaWNhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudFN0YWNrID0gdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgIGN1cnJlbnRTdGFjay50cmFuc2Zvcm1baV0gPSBwcm9wc1tpXTtcbiAgICB9XG5cbiAgICB0aGlzLmNBcnJQb3MgKz0gMTtcbiAgICB2YXIgbmV3U3RhY2sgPSB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc107XG4gICAgbmV3U3RhY2sub3BhY2l0eSA9IGN1cnJlbnRTdGFjay5vcGFjaXR5O1xuICAgIG5ld1N0YWNrLmZpbGxTdHlsZSA9IGN1cnJlbnRTdGFjay5maWxsU3R5bGU7XG4gICAgbmV3U3RhY2suc3Ryb2tlU3R5bGUgPSBjdXJyZW50U3RhY2suc3Ryb2tlU3R5bGU7XG4gICAgbmV3U3RhY2subGluZVdpZHRoID0gY3VycmVudFN0YWNrLmxpbmVXaWR0aDtcbiAgICBuZXdTdGFjay5saW5lQ2FwID0gY3VycmVudFN0YWNrLmxpbmVDYXA7XG4gICAgbmV3U3RhY2subGluZUpvaW4gPSBjdXJyZW50U3RhY2subGluZUpvaW47XG4gICAgbmV3U3RhY2subWl0ZXJMaW1pdCA9IGN1cnJlbnRTdGFjay5taXRlckxpbWl0O1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLnNldE9wYWNpdHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ub3BhY2l0eSA9IHZhbHVlO1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLm5hdGl2ZUNvbnRleHQgPSB2YWx1ZTtcbiAgfTtcblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5maWxsU3R5bGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLmZpbGxTdHlsZSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuY3VycmVudEZpbGxTdHlsZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLmZpbGxTdHlsZSA9IHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5zdHJva2VTdHlsZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10uc3Ryb2tlU3R5bGUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTdHJva2VTdHlsZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLnN0cm9rZVN0eWxlID0gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLmxpbmVXaWR0aCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubGluZVdpZHRoICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5jdXJyZW50TGluZVdpZHRoID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubGluZVdpZHRoID0gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLmxpbmVDYXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLmxpbmVDYXAgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRMaW5lQ2FwID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubGluZUNhcCA9IHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5saW5lSm9pbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubGluZUpvaW4gIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRMaW5lSm9pbiA9IHZhbHVlO1xuICAgICAgdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLmxpbmVKb2luID0gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLm1pdGVyTGltaXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLm1pdGVyTGltaXQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRNaXRlckxpbWl0ID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubWl0ZXJMaW1pdCA9IHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB0aGlzLnRyYW5zZm9ybU1hdC5jbG9uZUZyb21Qcm9wcyhwcm9wcyk7IC8vIFRha2luZyB0aGUgbGFzdCB0cmFuc2Zvcm0gdmFsdWUgZnJvbSB0aGUgc3RvcmVkIHN0YWNrIG9mIHRyYW5zZm9ybXNcblxuICAgIHZhciBjdXJyZW50VHJhbnNmb3JtID0gdGhpcy5jVHI7IC8vIEFwcGx5aW5nIHRoZSBsYXN0IHRyYW5zZm9ybSB2YWx1ZSBhZnRlciB0aGUgbmV3IHRyYW5zZm9ybSB0byByZXNwZWN0IHRoZSBvcmRlciBvZiB0cmFuc2Zvcm1hdGlvbnNcblxuICAgIHRoaXMudHJhbnNmb3JtTWF0Lm11bHRpcGx5KGN1cnJlbnRUcmFuc2Zvcm0pOyAvLyBTdG9yaW5nIHRoZSBuZXcgdHJhbnNmb3JtZWQgdmFsdWUgaW4gdGhlIHN0b3JlZCB0cmFuc2Zvcm1cblxuICAgIGN1cnJlbnRUcmFuc2Zvcm0uY2xvbmVGcm9tUHJvcHModGhpcy50cmFuc2Zvcm1NYXQucHJvcHMpO1xuICAgIHZhciB0clByb3BzID0gY3VycmVudFRyYW5zZm9ybS5wcm9wczsgLy8gQXBwbHlpbmcgdGhlIG5ldyB0cmFuc2Zvcm0gdG8gdGhlIGNhbnZhc1xuXG4gICAgdGhpcy5uYXRpdmVDb250ZXh0LnNldFRyYW5zZm9ybSh0clByb3BzWzBdLCB0clByb3BzWzFdLCB0clByb3BzWzRdLCB0clByb3BzWzVdLCB0clByb3BzWzEyXSwgdHJQcm9wc1sxM10pO1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLm9wYWNpdHkgPSBmdW5jdGlvbiAob3ApIHtcbiAgICB2YXIgY3VycmVudE9wYWNpdHkgPSB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ub3BhY2l0eTtcbiAgICBjdXJyZW50T3BhY2l0eSAqPSBvcCA8IDAgPyAwIDogb3A7XG5cbiAgICBpZiAodGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLm9wYWNpdHkgIT09IGN1cnJlbnRPcGFjaXR5KSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50T3BhY2l0eSAhPT0gb3ApIHtcbiAgICAgICAgdGhpcy5uYXRpdmVDb250ZXh0Lmdsb2JhbEFscGhhID0gb3A7XG4gICAgICAgIHRoaXMuY3VycmVudE9wYWNpdHkgPSBvcDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLm9wYWNpdHkgPSBjdXJyZW50T3BhY2l0eTtcbiAgICB9XG4gIH07XG5cbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgaWYgKHRoaXMuYXBwbGllZEZpbGxTdHlsZSAhPT0gdGhpcy5jdXJyZW50RmlsbFN0eWxlKSB7XG4gICAgICB0aGlzLmFwcGxpZWRGaWxsU3R5bGUgPSB0aGlzLmN1cnJlbnRGaWxsU3R5bGU7XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5hcHBsaWVkRmlsbFN0eWxlO1xuICAgIH1cblxuICAgIHRoaXMubmF0aXZlQ29udGV4dC5maWxsKHJ1bGUpO1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLmZpbGxSZWN0ID0gZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcbiAgICBpZiAodGhpcy5hcHBsaWVkRmlsbFN0eWxlICE9PSB0aGlzLmN1cnJlbnRGaWxsU3R5bGUpIHtcbiAgICAgIHRoaXMuYXBwbGllZEZpbGxTdHlsZSA9IHRoaXMuY3VycmVudEZpbGxTdHlsZTtcbiAgICAgIHRoaXMubmF0aXZlQ29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmFwcGxpZWRGaWxsU3R5bGU7XG4gICAgfVxuXG4gICAgdGhpcy5uYXRpdmVDb250ZXh0LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLnN0cm9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5hcHBsaWVkU3Ryb2tlU3R5bGUgIT09IHRoaXMuY3VycmVudFN0cm9rZVN0eWxlKSB7XG4gICAgICB0aGlzLmFwcGxpZWRTdHJva2VTdHlsZSA9IHRoaXMuY3VycmVudFN0cm9rZVN0eWxlO1xuICAgICAgdGhpcy5uYXRpdmVDb250ZXh0LnN0cm9rZVN0eWxlID0gdGhpcy5hcHBsaWVkU3Ryb2tlU3R5bGU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYXBwbGllZExpbmVXaWR0aCAhPT0gdGhpcy5jdXJyZW50TGluZVdpZHRoKSB7XG4gICAgICB0aGlzLmFwcGxpZWRMaW5lV2lkdGggPSB0aGlzLmN1cnJlbnRMaW5lV2lkdGg7XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQubGluZVdpZHRoID0gdGhpcy5hcHBsaWVkTGluZVdpZHRoO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFwcGxpZWRMaW5lQ2FwICE9PSB0aGlzLmN1cnJlbnRMaW5lQ2FwKSB7XG4gICAgICB0aGlzLmFwcGxpZWRMaW5lQ2FwID0gdGhpcy5jdXJyZW50TGluZUNhcDtcbiAgICAgIHRoaXMubmF0aXZlQ29udGV4dC5saW5lQ2FwID0gdGhpcy5hcHBsaWVkTGluZUNhcDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hcHBsaWVkTGluZUpvaW4gIT09IHRoaXMuY3VycmVudExpbmVKb2luKSB7XG4gICAgICB0aGlzLmFwcGxpZWRMaW5lSm9pbiA9IHRoaXMuY3VycmVudExpbmVKb2luO1xuICAgICAgdGhpcy5uYXRpdmVDb250ZXh0LmxpbmVKb2luID0gdGhpcy5hcHBsaWVkTGluZUpvaW47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYXBwbGllZE1pdGVyTGltaXQgIT09IHRoaXMuY3VycmVudE1pdGVyTGltaXQpIHtcbiAgICAgIHRoaXMuYXBwbGllZE1pdGVyTGltaXQgPSB0aGlzLmN1cnJlbnRNaXRlckxpbWl0O1xuICAgICAgdGhpcy5uYXRpdmVDb250ZXh0Lm1pdGVyTGltaXQgPSB0aGlzLmFwcGxpZWRNaXRlckxpbWl0O1xuICAgIH1cblxuICAgIHRoaXMubmF0aXZlQ29udGV4dC5zdHJva2UoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBDVkNvbXBFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmNvbXBsZXRlTGF5ZXJzID0gZmFsc2U7XG4gICAgdGhpcy5sYXllcnMgPSBkYXRhLmxheWVycztcbiAgICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuZWxlbWVudHMgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMubGF5ZXJzLmxlbmd0aCk7XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICB0aGlzLnRtID0gZGF0YS50bSA/IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEudG0sIDAsIGdsb2JhbERhdGEuZnJhbWVSYXRlLCB0aGlzKSA6IHtcbiAgICAgIF9wbGFjZWhvbGRlcjogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0NhbnZhc1JlbmRlcmVyQmFzZSwgSUNvbXBFbGVtZW50LCBDVkJhc2VFbGVtZW50XSwgQ1ZDb21wRWxlbWVudCk7XG5cbiAgQ1ZDb21wRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhc0NvbnRleHQ7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgY3R4LmxpbmVUbyh0aGlzLmRhdGEudywgMCk7XG4gICAgY3R4LmxpbmVUbyh0aGlzLmRhdGEudywgdGhpcy5kYXRhLmgpO1xuICAgIGN0eC5saW5lVG8oMCwgdGhpcy5kYXRhLmgpO1xuICAgIGN0eC5saW5lVG8oMCwgMCk7XG4gICAgY3R4LmNsaXAoKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIGlmICh0aGlzLmNvbXBsZXRlTGF5ZXJzIHx8IHRoaXMuZWxlbWVudHNbaV0pIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5yZW5kZXJGcmFtZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBDVkNvbXBFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0pIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sYXllcnMgPSBudWxsO1xuICAgIHRoaXMuZWxlbWVudHMgPSBudWxsO1xuICB9O1xuXG4gIENWQ29tcEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQ1ZDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKGFuaW1hdGlvbkl0ZW0sIGNvbmZpZykge1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbSA9IGFuaW1hdGlvbkl0ZW07XG4gICAgdGhpcy5yZW5kZXJDb25maWcgPSB7XG4gICAgICBjbGVhckNhbnZhczogY29uZmlnICYmIGNvbmZpZy5jbGVhckNhbnZhcyAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmNsZWFyQ2FudmFzIDogdHJ1ZSxcbiAgICAgIGNvbnRleHQ6IGNvbmZpZyAmJiBjb25maWcuY29udGV4dCB8fCBudWxsLFxuICAgICAgcHJvZ3Jlc3NpdmVMb2FkOiBjb25maWcgJiYgY29uZmlnLnByb2dyZXNzaXZlTG9hZCB8fCBmYWxzZSxcbiAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IGNvbmZpZyAmJiBjb25maWcucHJlc2VydmVBc3BlY3RSYXRpbyB8fCAneE1pZFlNaWQgbWVldCcsXG4gICAgICBpbWFnZVByZXNlcnZlQXNwZWN0UmF0aW86IGNvbmZpZyAmJiBjb25maWcuaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvIHx8ICd4TWlkWU1pZCBzbGljZScsXG4gICAgICBjb250ZW50VmlzaWJpbGl0eTogY29uZmlnICYmIGNvbmZpZy5jb250ZW50VmlzaWJpbGl0eSB8fCAndmlzaWJsZScsXG4gICAgICBjbGFzc05hbWU6IGNvbmZpZyAmJiBjb25maWcuY2xhc3NOYW1lIHx8ICcnLFxuICAgICAgaWQ6IGNvbmZpZyAmJiBjb25maWcuaWQgfHwgJycsXG4gICAgICBydW5FeHByZXNzaW9uczogIWNvbmZpZyB8fCBjb25maWcucnVuRXhwcmVzc2lvbnMgPT09IHVuZGVmaW5lZCB8fCBjb25maWcucnVuRXhwcmVzc2lvbnNcbiAgICB9O1xuICAgIHRoaXMucmVuZGVyQ29uZmlnLmRwciA9IGNvbmZpZyAmJiBjb25maWcuZHByIHx8IDE7XG5cbiAgICBpZiAodGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyQ29uZmlnLmRwciA9IGNvbmZpZyAmJiBjb25maWcuZHByIHx8IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlZEZyYW1lID0gLTE7XG4gICAgdGhpcy5nbG9iYWxEYXRhID0ge1xuICAgICAgZnJhbWVOdW06IC0xLFxuICAgICAgX21kZjogZmFsc2UsXG4gICAgICByZW5kZXJDb25maWc6IHRoaXMucmVuZGVyQ29uZmlnLFxuICAgICAgY3VycmVudEdsb2JhbEFscGhhOiAtMVxuICAgIH07XG4gICAgdGhpcy5jb250ZXh0RGF0YSA9IG5ldyBDVkNvbnRleHREYXRhKCk7XG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICAgIHRoaXMucGVuZGluZ0VsZW1lbnRzID0gW107XG4gICAgdGhpcy50cmFuc2Zvcm1NYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5jb21wbGV0ZUxheWVycyA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyZXJUeXBlID0gJ2NhbnZhcyc7XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMpIHtcbiAgICAgIHRoaXMuY3R4VHJhbnNmb3JtID0gdGhpcy5jb250ZXh0RGF0YS50cmFuc2Zvcm0uYmluZCh0aGlzLmNvbnRleHREYXRhKTtcbiAgICAgIHRoaXMuY3R4T3BhY2l0eSA9IHRoaXMuY29udGV4dERhdGEub3BhY2l0eS5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhGaWxsU3R5bGUgPSB0aGlzLmNvbnRleHREYXRhLmZpbGxTdHlsZS5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhTdHJva2VTdHlsZSA9IHRoaXMuY29udGV4dERhdGEuc3Ryb2tlU3R5bGUuYmluZCh0aGlzLmNvbnRleHREYXRhKTtcbiAgICAgIHRoaXMuY3R4TGluZVdpZHRoID0gdGhpcy5jb250ZXh0RGF0YS5saW5lV2lkdGguYmluZCh0aGlzLmNvbnRleHREYXRhKTtcbiAgICAgIHRoaXMuY3R4TGluZUNhcCA9IHRoaXMuY29udGV4dERhdGEubGluZUNhcC5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhMaW5lSm9pbiA9IHRoaXMuY29udGV4dERhdGEubGluZUpvaW4uYmluZCh0aGlzLmNvbnRleHREYXRhKTtcbiAgICAgIHRoaXMuY3R4TWl0ZXJMaW1pdCA9IHRoaXMuY29udGV4dERhdGEubWl0ZXJMaW1pdC5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhGaWxsID0gdGhpcy5jb250ZXh0RGF0YS5maWxsLmJpbmQodGhpcy5jb250ZXh0RGF0YSk7XG4gICAgICB0aGlzLmN0eEZpbGxSZWN0ID0gdGhpcy5jb250ZXh0RGF0YS5maWxsUmVjdC5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhTdHJva2UgPSB0aGlzLmNvbnRleHREYXRhLnN0cm9rZS5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5zYXZlID0gdGhpcy5jb250ZXh0RGF0YS5zYXZlLmJpbmQodGhpcy5jb250ZXh0RGF0YSk7XG4gICAgfVxuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtDYW52YXNSZW5kZXJlckJhc2VdLCBDYW52YXNSZW5kZXJlcik7XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNvbXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQ1ZDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEhCYXNlRWxlbWVudCgpIHt9XG5cbiAgSEJhc2VFbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgICBjaGVja0JsZW5kTW9kZTogZnVuY3Rpb24gY2hlY2tCbGVuZE1vZGUoKSB7fSxcbiAgICBpbml0UmVuZGVyZXJFbGVtZW50OiBmdW5jdGlvbiBpbml0UmVuZGVyZXJFbGVtZW50KCkge1xuICAgICAgdGhpcy5iYXNlRWxlbWVudCA9IGNyZWF0ZVRhZyh0aGlzLmRhdGEudGcgfHwgJ2RpdicpO1xuXG4gICAgICBpZiAodGhpcy5kYXRhLmhhc01hc2spIHtcbiAgICAgICAgdGhpcy5zdmdFbGVtZW50ID0gY3JlYXRlTlMoJ3N2ZycpO1xuICAgICAgICB0aGlzLmxheWVyRWxlbWVudCA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICAgIHRoaXMubWFza2VkRWxlbWVudCA9IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5sYXllckVsZW1lbnQpO1xuICAgICAgICB0aGlzLmJhc2VFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc3ZnRWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxheWVyRWxlbWVudCA9IHRoaXMuYmFzZUVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlRGl2KHRoaXMuYmFzZUVsZW1lbnQpO1xuICAgIH0sXG4gICAgY3JlYXRlQ29udGFpbmVyRWxlbWVudHM6IGZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzKCkge1xuICAgICAgdGhpcy5yZW5kZXJhYmxlRWZmZWN0c01hbmFnZXIgPSBuZXcgQ1ZFZmZlY3RzKHRoaXMpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPSB0aGlzLmJhc2VFbGVtZW50O1xuICAgICAgdGhpcy5tYXNrZWRFbGVtZW50ID0gdGhpcy5sYXllckVsZW1lbnQ7XG5cbiAgICAgIGlmICh0aGlzLmRhdGEubG4pIHtcbiAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuZGF0YS5sbik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRhdGEuY2wpIHtcbiAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIHRoaXMuZGF0YS5jbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRhdGEuYm0gIT09IDApIHtcbiAgICAgICAgdGhpcy5zZXRCbGVuZE1vZGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlckVsZW1lbnQ6IGZ1bmN0aW9uIHJlbmRlckVsZW1lbnQoKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtZWRFbGVtZW50U3R5bGUgPSB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudCA/IHRoaXMudHJhbnNmb3JtZWRFbGVtZW50LnN0eWxlIDoge307XG5cbiAgICAgIGlmICh0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGYpIHtcbiAgICAgICAgdmFyIG1hdHJpeFZhbHVlID0gdGhpcy5maW5hbFRyYW5zZm9ybS5tYXQudG9DU1MoKTtcbiAgICAgICAgdHJhbnNmb3JtZWRFbGVtZW50U3R5bGUudHJhbnNmb3JtID0gbWF0cml4VmFsdWU7XG4gICAgICAgIHRyYW5zZm9ybWVkRWxlbWVudFN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IG1hdHJpeFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYpIHtcbiAgICAgICAgdHJhbnNmb3JtZWRFbGVtZW50U3R5bGUub3BhY2l0eSA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3Auby52O1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyRnJhbWU6IGZ1bmN0aW9uIHJlbmRlckZyYW1lKCkge1xuICAgICAgLy8gSWYgaXQgaXMgZXhwb3J0ZWQgYXMgaGlkZGVuIChkYXRhLmhkID09PSB0cnVlKSBubyBuZWVkIHRvIHJlbmRlclxuICAgICAgLy8gSWYgaXQgaXMgbm90IHZpc2libGUgbm8gbmVlZCB0byByZW5kZXJcbiAgICAgIGlmICh0aGlzLmRhdGEuaGQgfHwgdGhpcy5oaWRkZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlclRyYW5zZm9ybSgpO1xuICAgICAgdGhpcy5yZW5kZXJSZW5kZXJhYmxlKCk7XG4gICAgICB0aGlzLnJlbmRlckVsZW1lbnQoKTtcbiAgICAgIHRoaXMucmVuZGVySW5uZXJDb250ZW50KCk7XG5cbiAgICAgIGlmICh0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgdGhpcy5faXNGaXJzdEZyYW1lID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5tYXR0ZUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5tYXR0ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tYXNrTWFuYWdlcikge1xuICAgICAgICB0aGlzLm1hc2tNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tYXNrTWFuYWdlciA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVSZW5kZXJhYmxlQ29tcG9uZW50czogZnVuY3Rpb24gY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHMoKSB7XG4gICAgICB0aGlzLm1hc2tNYW5hZ2VyID0gbmV3IE1hc2tFbGVtZW50KHRoaXMuZGF0YSwgdGhpcywgdGhpcy5nbG9iYWxEYXRhKTtcbiAgICB9LFxuICAgIGFkZEVmZmVjdHM6IGZ1bmN0aW9uIGFkZEVmZmVjdHMoKSB7fSxcbiAgICBzZXRNYXR0ZTogZnVuY3Rpb24gc2V0TWF0dGUoKSB7fVxuICB9O1xuICBIQmFzZUVsZW1lbnQucHJvdG90eXBlLmdldEJhc2VFbGVtZW50ID0gU1ZHQmFzZUVsZW1lbnQucHJvdG90eXBlLmdldEJhc2VFbGVtZW50O1xuICBIQmFzZUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3lCYXNlRWxlbWVudCA9IEhCYXNlRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveTtcbiAgSEJhc2VFbGVtZW50LnByb3RvdHlwZS5idWlsZEVsZW1lbnRQYXJlbnRpbmcgPSBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkRWxlbWVudFBhcmVudGluZztcblxuICBmdW5jdGlvbiBIU29saWRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSEJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50XSwgSFNvbGlkRWxlbWVudCk7XG5cbiAgSFNvbGlkRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdDtcblxuICAgIGlmICh0aGlzLmRhdGEuaGFzTWFzaykge1xuICAgICAgcmVjdCA9IGNyZWF0ZU5TKCdyZWN0Jyk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmRhdGEuc3cpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuZGF0YS5zaCk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsIHRoaXMuZGF0YS5zYyk7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuZGF0YS5zdyk7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmRhdGEuc2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gY3JlYXRlVGFnKCdkaXYnKTtcbiAgICAgIHJlY3Quc3R5bGUud2lkdGggPSB0aGlzLmRhdGEuc3cgKyAncHgnO1xuICAgICAgcmVjdC5zdHlsZS5oZWlnaHQgPSB0aGlzLmRhdGEuc2ggKyAncHgnO1xuICAgICAgcmVjdC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmRhdGEuc2M7XG4gICAgfVxuXG4gICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQocmVjdCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gSFNoYXBlRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgLy8gTGlzdCBvZiBkcmF3YWJsZSBlbGVtZW50c1xuICAgIHRoaXMuc2hhcGVzID0gW107IC8vIEZ1bGwgc2hhcGUgZGF0YVxuXG4gICAgdGhpcy5zaGFwZXNEYXRhID0gZGF0YS5zaGFwZXM7IC8vIExpc3Qgb2Ygc3R5bGVzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHNoYXBlc1xuXG4gICAgdGhpcy5zdHlsZXNMaXN0ID0gW107IC8vIExpc3Qgb2YgbW9kaWZpZXJzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHNoYXBlc1xuXG4gICAgdGhpcy5zaGFwZU1vZGlmaWVycyA9IFtdOyAvLyBMaXN0IG9mIGl0ZW1zIGluIHNoYXBlIHRyZWVcblxuICAgIHRoaXMuaXRlbXNEYXRhID0gW107IC8vIExpc3Qgb2YgaXRlbXMgaW4gcHJldmlvdXMgc2hhcGUgdHJlZVxuXG4gICAgdGhpcy5wcm9jZXNzZWRFbGVtZW50cyA9IFtdOyAvLyBMaXN0IG9mIGFuaW1hdGVkIGNvbXBvbmVudHNcblxuICAgIHRoaXMuYW5pbWF0ZWRDb250ZW50cyA9IFtdO1xuICAgIHRoaXMuc2hhcGVzQ29udGFpbmVyID0gY3JlYXRlTlMoJ2cnKTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApOyAvLyBNb3ZpbmcgYW55IHByb3BlcnR5IHRoYXQgZG9lc24ndCBnZXQgdG9vIG11Y2ggYWNjZXNzIGFmdGVyIGluaXRpYWxpemF0aW9uIGJlY2F1c2Ugb2Ygdjggd2F5IG9mIGhhbmRsaW5nIG1vcmUgdGhhbiAxMCBwcm9wZXJ0aWVzLlxuICAgIC8vIExpc3Qgb2YgZWxlbWVudHMgdGhhdCBoYXZlIGJlZW4gY3JlYXRlZFxuXG4gICAgdGhpcy5wcmV2Vmlld0RhdGEgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRCQm94ID0ge1xuICAgICAgeDogOTk5OTk5LFxuICAgICAgeTogLTk5OTk5OSxcbiAgICAgIGg6IDAsXG4gICAgICB3OiAwXG4gICAgfTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhTb2xpZEVsZW1lbnQsIFNWR1NoYXBlRWxlbWVudCwgSEJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVFbGVtZW50XSwgSFNoYXBlRWxlbWVudCk7XG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLl9yZW5kZXJTaGFwZUZyYW1lID0gSFNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50O1xuXG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnQ7XG4gICAgdGhpcy5iYXNlRWxlbWVudC5zdHlsZS5mb250U2l6ZSA9IDA7XG5cbiAgICBpZiAodGhpcy5kYXRhLmhhc01hc2spIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc2hhcGVzQ29udGFpbmVyKTtcbiAgICAgIGNvbnQgPSB0aGlzLnN2Z0VsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnQgPSBjcmVhdGVOUygnc3ZnJyk7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuY29tcC5kYXRhID8gdGhpcy5jb21wLmRhdGEgOiB0aGlzLmdsb2JhbERhdGEuY29tcFNpemU7XG4gICAgICBjb250LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzaXplLncpO1xuICAgICAgY29udC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUuaCk7XG4gICAgICBjb250LmFwcGVuZENoaWxkKHRoaXMuc2hhcGVzQ29udGFpbmVyKTtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKGNvbnQpO1xuICAgIH1cblxuICAgIHRoaXMuc2VhcmNoU2hhcGVzKHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRoaXMucHJldlZpZXdEYXRhLCB0aGlzLnNoYXBlc0NvbnRhaW5lciwgMCwgW10sIHRydWUpO1xuICAgIHRoaXMuZmlsdGVyVW5pcXVlU2hhcGVzKCk7XG4gICAgdGhpcy5zaGFwZUNvbnQgPSBjb250O1xuICB9O1xuXG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmdldFRyYW5zZm9ybWVkUG9pbnQgPSBmdW5jdGlvbiAodHJhbnNmb3JtZXJzLCBwb2ludCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1lcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBwb2ludCA9IHRyYW5zZm9ybWVyc1tpXS5tUHJvcHMudi5hcHBseVRvUG9pbnRBcnJheShwb2ludFswXSwgcG9pbnRbMV0sIDApO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludDtcbiAgfTtcblxuICBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jYWxjdWxhdGVTaGFwZUJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKGl0ZW0sIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHNoYXBlID0gaXRlbS5zaC52O1xuICAgIHZhciB0cmFuc2Zvcm1lcnMgPSBpdGVtLnRyYW5zZm9ybWVycztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gc2hhcGUuX2xlbmd0aDtcbiAgICB2YXIgdlBvaW50O1xuICAgIHZhciBvUG9pbnQ7XG4gICAgdmFyIG5leHRJUG9pbnQ7XG4gICAgdmFyIG5leHRWUG9pbnQ7XG5cbiAgICBpZiAobGVuIDw9IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgaSArPSAxKSB7XG4gICAgICB2UG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS52W2ldKTtcbiAgICAgIG9Qb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLm9baV0pO1xuICAgICAgbmV4dElQb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLmlbaSArIDFdKTtcbiAgICAgIG5leHRWUG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS52W2kgKyAxXSk7XG4gICAgICB0aGlzLmNoZWNrQm91bmRzKHZQb2ludCwgb1BvaW50LCBuZXh0SVBvaW50LCBuZXh0VlBvaW50LCBib3VuZGluZ0JveCk7XG4gICAgfVxuXG4gICAgaWYgKHNoYXBlLmMpIHtcbiAgICAgIHZQb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLnZbaV0pO1xuICAgICAgb1BvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50KHRyYW5zZm9ybWVycywgc2hhcGUub1tpXSk7XG4gICAgICBuZXh0SVBvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50KHRyYW5zZm9ybWVycywgc2hhcGUuaVswXSk7XG4gICAgICBuZXh0VlBvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50KHRyYW5zZm9ybWVycywgc2hhcGUudlswXSk7XG4gICAgICB0aGlzLmNoZWNrQm91bmRzKHZQb2ludCwgb1BvaW50LCBuZXh0SVBvaW50LCBuZXh0VlBvaW50LCBib3VuZGluZ0JveCk7XG4gICAgfVxuICB9O1xuXG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNoZWNrQm91bmRzID0gZnVuY3Rpb24gKHZQb2ludCwgb1BvaW50LCBuZXh0SVBvaW50LCBuZXh0VlBvaW50LCBib3VuZGluZ0JveCkge1xuICAgIHRoaXMuZ2V0Qm91bmRzT2ZDdXJ2ZSh2UG9pbnQsIG9Qb2ludCwgbmV4dElQb2ludCwgbmV4dFZQb2ludCk7XG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuc2hhcGVCb3VuZGluZ0JveDtcbiAgICBib3VuZGluZ0JveC54ID0gYm1NaW4oYm91bmRzLmxlZnQsIGJvdW5kaW5nQm94LngpO1xuICAgIGJvdW5kaW5nQm94LnhNYXggPSBibU1heChib3VuZHMucmlnaHQsIGJvdW5kaW5nQm94LnhNYXgpO1xuICAgIGJvdW5kaW5nQm94LnkgPSBibU1pbihib3VuZHMudG9wLCBib3VuZGluZ0JveC55KTtcbiAgICBib3VuZGluZ0JveC55TWF4ID0gYm1NYXgoYm91bmRzLmJvdHRvbSwgYm91bmRpbmdCb3gueU1heCk7XG4gIH07XG5cbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuc2hhcGVCb3VuZGluZ0JveCA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IDBcbiAgfTtcbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUudGVtcEJvdW5kaW5nQm94ID0ge1xuICAgIHg6IDAsXG4gICAgeE1heDogMCxcbiAgICB5OiAwLFxuICAgIHlNYXg6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH07XG5cbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuZ2V0Qm91bmRzT2ZDdXJ2ZSA9IGZ1bmN0aW9uIChwMCwgcDEsIHAyLCBwMykge1xuICAgIHZhciBib3VuZHMgPSBbW3AwWzBdLCBwM1swXV0sIFtwMFsxXSwgcDNbMV1dXTtcblxuICAgIGZvciAodmFyIGEsIGIsIGMsIHQsIGIyYWMsIHQxLCB0MiwgaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGx1c3BsdXNcbiAgICAgIGIgPSA2ICogcDBbaV0gLSAxMiAqIHAxW2ldICsgNiAqIHAyW2ldO1xuICAgICAgYSA9IC0zICogcDBbaV0gKyA5ICogcDFbaV0gLSA5ICogcDJbaV0gKyAzICogcDNbaV07XG4gICAgICBjID0gMyAqIHAxW2ldIC0gMyAqIHAwW2ldO1xuICAgICAgYiB8PSAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWJpdHdpc2VcblxuICAgICAgYSB8PSAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWJpdHdpc2VcblxuICAgICAgYyB8PSAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWJpdHdpc2VcblxuICAgICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkgey8vXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IDApIHtcbiAgICAgICAgdCA9IC1jIC8gYjtcblxuICAgICAgICBpZiAodCA+IDAgJiYgdCA8IDEpIHtcbiAgICAgICAgICBib3VuZHNbaV0ucHVzaCh0aGlzLmNhbGN1bGF0ZUYodCwgcDAsIHAxLCBwMiwgcDMsIGkpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYjJhYyA9IGIgKiBiIC0gNCAqIGMgKiBhO1xuXG4gICAgICAgIGlmIChiMmFjID49IDApIHtcbiAgICAgICAgICB0MSA9ICgtYiArIGJtU3FydChiMmFjKSkgLyAoMiAqIGEpO1xuICAgICAgICAgIGlmICh0MSA+IDAgJiYgdDEgPCAxKSBib3VuZHNbaV0ucHVzaCh0aGlzLmNhbGN1bGF0ZUYodDEsIHAwLCBwMSwgcDIsIHAzLCBpKSk7XG4gICAgICAgICAgdDIgPSAoLWIgLSBibVNxcnQoYjJhYykpIC8gKDIgKiBhKTtcbiAgICAgICAgICBpZiAodDIgPiAwICYmIHQyIDwgMSkgYm91bmRzW2ldLnB1c2godGhpcy5jYWxjdWxhdGVGKHQyLCBwMCwgcDEsIHAyLCBwMywgaSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zaGFwZUJvdW5kaW5nQm94LmxlZnQgPSBibU1pbi5hcHBseShudWxsLCBib3VuZHNbMF0pO1xuICAgIHRoaXMuc2hhcGVCb3VuZGluZ0JveC50b3AgPSBibU1pbi5hcHBseShudWxsLCBib3VuZHNbMV0pO1xuICAgIHRoaXMuc2hhcGVCb3VuZGluZ0JveC5yaWdodCA9IGJtTWF4LmFwcGx5KG51bGwsIGJvdW5kc1swXSk7XG4gICAgdGhpcy5zaGFwZUJvdW5kaW5nQm94LmJvdHRvbSA9IGJtTWF4LmFwcGx5KG51bGwsIGJvdW5kc1sxXSk7XG4gIH07XG5cbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuY2FsY3VsYXRlRiA9IGZ1bmN0aW9uICh0LCBwMCwgcDEsIHAyLCBwMywgaSkge1xuICAgIHJldHVybiBibVBvdygxIC0gdCwgMykgKiBwMFtpXSArIDMgKiBibVBvdygxIC0gdCwgMikgKiB0ICogcDFbaV0gKyAzICogKDEgLSB0KSAqIGJtUG93KHQsIDIpICogcDJbaV0gKyBibVBvdyh0LCAzKSAqIHAzW2ldO1xuICB9O1xuXG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNhbGN1bGF0ZUJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKGl0ZW1zRGF0YSwgYm91bmRpbmdCb3gpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gaXRlbXNEYXRhLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKGl0ZW1zRGF0YVtpXSAmJiBpdGVtc0RhdGFbaV0uc2gpIHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVTaGFwZUJvdW5kaW5nQm94KGl0ZW1zRGF0YVtpXSwgYm91bmRpbmdCb3gpO1xuICAgICAgfSBlbHNlIGlmIChpdGVtc0RhdGFbaV0gJiYgaXRlbXNEYXRhW2ldLml0KSB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQm91bmRpbmdCb3goaXRlbXNEYXRhW2ldLml0LCBib3VuZGluZ0JveCk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1zRGF0YVtpXSAmJiBpdGVtc0RhdGFbaV0uc3R5bGUgJiYgaXRlbXNEYXRhW2ldLncpIHtcbiAgICAgICAgdGhpcy5leHBhbmRTdHJva2VCb3VuZGluZ0JveChpdGVtc0RhdGFbaV0udywgYm91bmRpbmdCb3gpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5leHBhbmRTdHJva2VCb3VuZGluZ0JveCA9IGZ1bmN0aW9uICh3aWR0aFByb3BlcnR5LCBib3VuZGluZ0JveCkge1xuICAgIHZhciB3aWR0aCA9IDA7XG5cbiAgICBpZiAod2lkdGhQcm9wZXJ0eS5rZXlmcmFtZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2lkdGhQcm9wZXJ0eS5rZXlmcmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGtmdyA9IHdpZHRoUHJvcGVydHkua2V5ZnJhbWVzW2ldLnM7XG5cbiAgICAgICAgaWYgKGtmdyA+IHdpZHRoKSB7XG4gICAgICAgICAgd2lkdGggPSBrZnc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2lkdGggKj0gd2lkdGhQcm9wZXJ0eS5tdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IHdpZHRoUHJvcGVydHkudiAqIHdpZHRoUHJvcGVydHkubXVsdDtcbiAgICB9XG5cbiAgICBib3VuZGluZ0JveC54IC09IHdpZHRoO1xuICAgIGJvdW5kaW5nQm94LnhNYXggKz0gd2lkdGg7XG4gICAgYm91bmRpbmdCb3gueSAtPSB3aWR0aDtcbiAgICBib3VuZGluZ0JveC55TWF4ICs9IHdpZHRoO1xuICB9O1xuXG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmN1cnJlbnRCb3hDb250YWlucyA9IGZ1bmN0aW9uIChib3gpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50QkJveC54IDw9IGJveC54ICYmIHRoaXMuY3VycmVudEJCb3gueSA8PSBib3gueSAmJiB0aGlzLmN1cnJlbnRCQm94LndpZHRoICsgdGhpcy5jdXJyZW50QkJveC54ID49IGJveC54ICsgYm94LndpZHRoICYmIHRoaXMuY3VycmVudEJCb3guaGVpZ2h0ICsgdGhpcy5jdXJyZW50QkJveC55ID49IGJveC55ICsgYm94LmhlaWdodDtcbiAgfTtcblxuICBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVuZGVyU2hhcGVGcmFtZSgpO1xuXG4gICAgaWYgKCF0aGlzLmhpZGRlbiAmJiAodGhpcy5faXNGaXJzdEZyYW1lIHx8IHRoaXMuX21kZikpIHtcbiAgICAgIHZhciB0ZW1wQm91bmRpbmdCb3ggPSB0aGlzLnRlbXBCb3VuZGluZ0JveDtcbiAgICAgIHZhciBtYXggPSA5OTk5OTk7XG4gICAgICB0ZW1wQm91bmRpbmdCb3gueCA9IG1heDtcbiAgICAgIHRlbXBCb3VuZGluZ0JveC54TWF4ID0gLW1heDtcbiAgICAgIHRlbXBCb3VuZGluZ0JveC55ID0gbWF4O1xuICAgICAgdGVtcEJvdW5kaW5nQm94LnlNYXggPSAtbWF4O1xuICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZGluZ0JveCh0aGlzLml0ZW1zRGF0YSwgdGVtcEJvdW5kaW5nQm94KTtcbiAgICAgIHRlbXBCb3VuZGluZ0JveC53aWR0aCA9IHRlbXBCb3VuZGluZ0JveC54TWF4IDwgdGVtcEJvdW5kaW5nQm94LnggPyAwIDogdGVtcEJvdW5kaW5nQm94LnhNYXggLSB0ZW1wQm91bmRpbmdCb3gueDtcbiAgICAgIHRlbXBCb3VuZGluZ0JveC5oZWlnaHQgPSB0ZW1wQm91bmRpbmdCb3gueU1heCA8IHRlbXBCb3VuZGluZ0JveC55ID8gMCA6IHRlbXBCb3VuZGluZ0JveC55TWF4IC0gdGVtcEJvdW5kaW5nQm94Lnk7IC8vIHZhciB0ZW1wQm91bmRpbmdCb3ggPSB0aGlzLnNoYXBlQ29udC5nZXRCQm94KCk7XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRCb3hDb250YWlucyh0ZW1wQm91bmRpbmdCb3gpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuY3VycmVudEJCb3gudyAhPT0gdGVtcEJvdW5kaW5nQm94LndpZHRoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3gudyA9IHRlbXBCb3VuZGluZ0JveC53aWR0aDtcbiAgICAgICAgdGhpcy5zaGFwZUNvbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRlbXBCb3VuZGluZ0JveC53aWR0aCk7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jdXJyZW50QkJveC5oICE9PSB0ZW1wQm91bmRpbmdCb3guaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3guaCA9IHRlbXBCb3VuZGluZ0JveC5oZWlnaHQ7XG4gICAgICAgIHRoaXMuc2hhcGVDb250LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGVtcEJvdW5kaW5nQm94LmhlaWdodCk7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlZCB8fCB0aGlzLmN1cnJlbnRCQm94LnggIT09IHRlbXBCb3VuZGluZ0JveC54IHx8IHRoaXMuY3VycmVudEJCb3gueSAhPT0gdGVtcEJvdW5kaW5nQm94LnkpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QkJveC53ID0gdGVtcEJvdW5kaW5nQm94LndpZHRoO1xuICAgICAgICB0aGlzLmN1cnJlbnRCQm94LmggPSB0ZW1wQm91bmRpbmdCb3guaGVpZ2h0O1xuICAgICAgICB0aGlzLmN1cnJlbnRCQm94LnggPSB0ZW1wQm91bmRpbmdCb3gueDtcbiAgICAgICAgdGhpcy5jdXJyZW50QkJveC55ID0gdGVtcEJvdW5kaW5nQm94Lnk7XG4gICAgICAgIHRoaXMuc2hhcGVDb250LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIHRoaXMuY3VycmVudEJCb3gueCArICcgJyArIHRoaXMuY3VycmVudEJCb3gueSArICcgJyArIHRoaXMuY3VycmVudEJCb3gudyArICcgJyArIHRoaXMuY3VycmVudEJCb3guaCk7XG4gICAgICAgIHZhciBzaGFwZVN0eWxlID0gdGhpcy5zaGFwZUNvbnQuc3R5bGU7XG4gICAgICAgIHZhciBzaGFwZVRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIHRoaXMuY3VycmVudEJCb3gueCArICdweCwnICsgdGhpcy5jdXJyZW50QkJveC55ICsgJ3B4KSc7XG4gICAgICAgIHNoYXBlU3R5bGUudHJhbnNmb3JtID0gc2hhcGVUcmFuc2Zvcm07XG4gICAgICAgIHNoYXBlU3R5bGUud2Via2l0VHJhbnNmb3JtID0gc2hhcGVUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEhUZXh0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy50ZXh0U3BhbnMgPSBbXTtcbiAgICB0aGlzLnRleHRQYXRocyA9IFtdO1xuICAgIHRoaXMuY3VycmVudEJCb3ggPSB7XG4gICAgICB4OiA5OTk5OTksXG4gICAgICB5OiAtOTk5OTk5LFxuICAgICAgaDogMCxcbiAgICAgIHc6IDBcbiAgICB9O1xuICAgIHRoaXMucmVuZGVyVHlwZSA9ICdzdmcnO1xuICAgIHRoaXMuaXNNYXNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSEJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50LCBJVGV4dEVsZW1lbnRdLCBIVGV4dEVsZW1lbnQpO1xuXG4gIEhUZXh0RWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzTWFza2VkID0gdGhpcy5jaGVja01hc2tzKCk7XG5cbiAgICBpZiAodGhpcy5pc01hc2tlZCkge1xuICAgICAgdGhpcy5yZW5kZXJUeXBlID0gJ3N2Zyc7XG4gICAgICB0aGlzLmNvbXBXID0gdGhpcy5jb21wLmRhdGEudztcbiAgICAgIHRoaXMuY29tcEggPSB0aGlzLmNvbXAuZGF0YS5oO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmNvbXBXKTtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuY29tcEgpO1xuICAgICAgdmFyIGcgPSBjcmVhdGVOUygnZycpO1xuICAgICAgdGhpcy5tYXNrZWRFbGVtZW50LmFwcGVuZENoaWxkKGcpO1xuICAgICAgdGhpcy5pbm5lckVsZW0gPSBnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlclR5cGUgPSAnaHRtbCc7XG4gICAgICB0aGlzLmlubmVyRWxlbSA9IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgIH1cblxuICAgIHRoaXMuY2hlY2tQYXJlbnRpbmcoKTtcbiAgfTtcblxuICBIVGV4dEVsZW1lbnQucHJvdG90eXBlLmJ1aWxkTmV3VGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZG9jdW1lbnREYXRhID0gdGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGE7XG4gICAgdGhpcy5yZW5kZXJlZExldHRlcnMgPSBjcmVhdGVTaXplZEFycmF5KGRvY3VtZW50RGF0YS5sID8gZG9jdW1lbnREYXRhLmwubGVuZ3RoIDogMCk7XG4gICAgdmFyIGlubmVyRWxlbVN0eWxlID0gdGhpcy5pbm5lckVsZW0uc3R5bGU7XG4gICAgdmFyIHRleHRDb2xvciA9IGRvY3VtZW50RGF0YS5mYyA/IHRoaXMuYnVpbGRDb2xvcihkb2N1bWVudERhdGEuZmMpIDogJ3JnYmEoMCwwLDAsMCknO1xuICAgIGlubmVyRWxlbVN0eWxlLmZpbGwgPSB0ZXh0Q29sb3I7XG4gICAgaW5uZXJFbGVtU3R5bGUuY29sb3IgPSB0ZXh0Q29sb3I7XG5cbiAgICBpZiAoZG9jdW1lbnREYXRhLnNjKSB7XG4gICAgICBpbm5lckVsZW1TdHlsZS5zdHJva2UgPSB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLnNjKTtcbiAgICAgIGlubmVyRWxlbVN0eWxlLnN0cm9rZVdpZHRoID0gZG9jdW1lbnREYXRhLnN3ICsgJ3B4JztcbiAgICB9XG5cbiAgICB2YXIgZm9udERhdGEgPSB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZik7XG5cbiAgICBpZiAoIXRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5jaGFycykge1xuICAgICAgaW5uZXJFbGVtU3R5bGUuZm9udFNpemUgPSBkb2N1bWVudERhdGEuZmluYWxTaXplICsgJ3B4JztcbiAgICAgIGlubmVyRWxlbVN0eWxlLmxpbmVIZWlnaHQgPSBkb2N1bWVudERhdGEuZmluYWxTaXplICsgJ3B4JztcblxuICAgICAgaWYgKGZvbnREYXRhLmZDbGFzcykge1xuICAgICAgICB0aGlzLmlubmVyRWxlbS5jbGFzc05hbWUgPSBmb250RGF0YS5mQ2xhc3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbm5lckVsZW1TdHlsZS5mb250RmFtaWx5ID0gZm9udERhdGEuZkZhbWlseTtcbiAgICAgICAgdmFyIGZXZWlnaHQgPSBkb2N1bWVudERhdGEuZldlaWdodDtcbiAgICAgICAgdmFyIGZTdHlsZSA9IGRvY3VtZW50RGF0YS5mU3R5bGU7XG4gICAgICAgIGlubmVyRWxlbVN0eWxlLmZvbnRTdHlsZSA9IGZTdHlsZTtcbiAgICAgICAgaW5uZXJFbGVtU3R5bGUuZm9udFdlaWdodCA9IGZXZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcbiAgICB2YXIgbGV0dGVycyA9IGRvY3VtZW50RGF0YS5sO1xuICAgIGxlbiA9IGxldHRlcnMubGVuZ3RoO1xuICAgIHZhciB0U3BhbjtcbiAgICB2YXIgdFBhcmVudDtcbiAgICB2YXIgdENvbnQ7XG4gICAgdmFyIG1hdHJpeEhlbHBlciA9IHRoaXMubUhlbHBlcjtcbiAgICB2YXIgc2hhcGVzO1xuICAgIHZhciBzaGFwZVN0ciA9ICcnO1xuICAgIHZhciBjbnQgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmNoYXJzKSB7XG4gICAgICAgIGlmICghdGhpcy50ZXh0UGF0aHNbY250XSkge1xuICAgICAgICAgIHRTcGFuID0gY3JlYXRlTlMoJ3BhdGgnKTtcbiAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgbGluZUNhcEVudW1bMV0pO1xuICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgbGluZUpvaW5FbnVtWzJdKTtcbiAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1taXRlcmxpbWl0JywgJzQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0U3BhbiA9IHRoaXMudGV4dFBhdGhzW2NudF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaXNNYXNrZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy50ZXh0U3BhbnNbY250XSkge1xuICAgICAgICAgICAgdFBhcmVudCA9IHRoaXMudGV4dFNwYW5zW2NudF07XG4gICAgICAgICAgICB0Q29udCA9IHRQYXJlbnQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRQYXJlbnQgPSBjcmVhdGVUYWcoJ2RpdicpO1xuICAgICAgICAgICAgdFBhcmVudC5zdHlsZS5saW5lSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIHRDb250ID0gY3JlYXRlTlMoJ3N2ZycpO1xuICAgICAgICAgICAgdENvbnQuYXBwZW5kQ2hpbGQodFNwYW4pO1xuICAgICAgICAgICAgc3R5bGVEaXYodFBhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzTWFza2VkKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHRTcGFuc1tjbnRdKSB7XG4gICAgICAgICAgdFBhcmVudCA9IHRoaXMudGV4dFNwYW5zW2NudF07XG4gICAgICAgICAgdFNwYW4gPSB0aGlzLnRleHRQYXRoc1tjbnRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRQYXJlbnQgPSBjcmVhdGVUYWcoJ3NwYW4nKTtcbiAgICAgICAgICBzdHlsZURpdih0UGFyZW50KTtcbiAgICAgICAgICB0U3BhbiA9IGNyZWF0ZVRhZygnc3BhbicpO1xuICAgICAgICAgIHN0eWxlRGl2KHRTcGFuKTtcbiAgICAgICAgICB0UGFyZW50LmFwcGVuZENoaWxkKHRTcGFuKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdFNwYW4gPSB0aGlzLnRleHRQYXRoc1tjbnRdID8gdGhpcy50ZXh0UGF0aHNbY250XSA6IGNyZWF0ZU5TKCd0ZXh0Jyk7XG4gICAgICB9IC8vIHRTcGFuLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcblxuXG4gICAgICBpZiAodGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmNoYXJzKSB7XG4gICAgICAgIHZhciBjaGFyRGF0YSA9IHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRDaGFyRGF0YShkb2N1bWVudERhdGEuZmluYWxUZXh0W2ldLCBmb250RGF0YS5mU3R5bGUsIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5KTtcbiAgICAgICAgdmFyIHNoYXBlRGF0YTtcblxuICAgICAgICBpZiAoY2hhckRhdGEpIHtcbiAgICAgICAgICBzaGFwZURhdGEgPSBjaGFyRGF0YS5kYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNoYXBlRGF0YSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBtYXRyaXhIZWxwZXIucmVzZXQoKTtcblxuICAgICAgICBpZiAoc2hhcGVEYXRhICYmIHNoYXBlRGF0YS5zaGFwZXMgJiYgc2hhcGVEYXRhLnNoYXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzaGFwZXMgPSBzaGFwZURhdGEuc2hhcGVzWzBdLml0O1xuICAgICAgICAgIG1hdHJpeEhlbHBlci5zY2FsZShkb2N1bWVudERhdGEuZmluYWxTaXplIC8gMTAwLCBkb2N1bWVudERhdGEuZmluYWxTaXplIC8gMTAwKTtcbiAgICAgICAgICBzaGFwZVN0ciA9IHRoaXMuY3JlYXRlUGF0aFNoYXBlKG1hdHJpeEhlbHBlciwgc2hhcGVzKTtcbiAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ2QnLCBzaGFwZVN0cik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaXNNYXNrZWQpIHtcbiAgICAgICAgICB0aGlzLmlubmVyRWxlbS5hcHBlbmRDaGlsZCh0UGFyZW50KTtcblxuICAgICAgICAgIGlmIChzaGFwZURhdGEgJiYgc2hhcGVEYXRhLnNoYXBlcykge1xuICAgICAgICAgICAgLy8gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCBpcyBuZWVkZWQgdG8gZ2V0IGV4YWN0IG1lYXN1cmUgb2Ygc2hhcGVcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodENvbnQpO1xuICAgICAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gdENvbnQuZ2V0QkJveCgpO1xuICAgICAgICAgICAgdENvbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGJvdW5kaW5nQm94LndpZHRoICsgMik7XG4gICAgICAgICAgICB0Q29udC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGJvdW5kaW5nQm94LmhlaWdodCArIDIpO1xuICAgICAgICAgICAgdENvbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgYm91bmRpbmdCb3gueCAtIDEgKyAnICcgKyAoYm91bmRpbmdCb3gueSAtIDEpICsgJyAnICsgKGJvdW5kaW5nQm94LndpZHRoICsgMikgKyAnICcgKyAoYm91bmRpbmdCb3guaGVpZ2h0ICsgMikpO1xuICAgICAgICAgICAgdmFyIHRDb250U3R5bGUgPSB0Q29udC5zdHlsZTtcbiAgICAgICAgICAgIHZhciB0Q29udFRyYW5zbGF0aW9uID0gJ3RyYW5zbGF0ZSgnICsgKGJvdW5kaW5nQm94LnggLSAxKSArICdweCwnICsgKGJvdW5kaW5nQm94LnkgLSAxKSArICdweCknO1xuICAgICAgICAgICAgdENvbnRTdHlsZS50cmFuc2Zvcm0gPSB0Q29udFRyYW5zbGF0aW9uO1xuICAgICAgICAgICAgdENvbnRTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0Q29udFRyYW5zbGF0aW9uO1xuICAgICAgICAgICAgbGV0dGVyc1tpXS55T2Zmc2V0ID0gYm91bmRpbmdCb3gueSAtIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRDb250LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAxKTtcbiAgICAgICAgICAgIHRDb250LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdFBhcmVudC5hcHBlbmRDaGlsZCh0Q29udCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pbm5lckVsZW0uYXBwZW5kQ2hpbGQodFNwYW4pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0U3Bhbi50ZXh0Q29udGVudCA9IGxldHRlcnNbaV0udmFsO1xuICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJywgJ3htbDpzcGFjZScsICdwcmVzZXJ2ZScpO1xuXG4gICAgICAgIGlmICghdGhpcy5pc01hc2tlZCkge1xuICAgICAgICAgIHRoaXMuaW5uZXJFbGVtLmFwcGVuZENoaWxkKHRQYXJlbnQpOyAvL1xuXG4gICAgICAgICAgdmFyIHRTdHlsZSA9IHRTcGFuLnN0eWxlO1xuICAgICAgICAgIHZhciB0U3BhblRyYW5zbGF0aW9uID0gJ3RyYW5zbGF0ZTNkKDAsJyArIC1kb2N1bWVudERhdGEuZmluYWxTaXplIC8gMS4yICsgJ3B4LDApJztcbiAgICAgICAgICB0U3R5bGUudHJhbnNmb3JtID0gdFNwYW5UcmFuc2xhdGlvbjtcbiAgICAgICAgICB0U3R5bGUud2Via2l0VHJhbnNmb3JtID0gdFNwYW5UcmFuc2xhdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmlubmVyRWxlbS5hcHBlbmRDaGlsZCh0U3Bhbik7XG4gICAgICAgIH1cbiAgICAgIH0gLy9cblxuXG4gICAgICBpZiAoIXRoaXMuaXNNYXNrZWQpIHtcbiAgICAgICAgdGhpcy50ZXh0U3BhbnNbY250XSA9IHRQYXJlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRleHRTcGFuc1tjbnRdID0gdFNwYW47XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGV4dFNwYW5zW2NudF0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLnRleHRQYXRoc1tjbnRdID0gdFNwYW47XG4gICAgICBjbnQgKz0gMTtcbiAgICB9XG5cbiAgICB3aGlsZSAoY250IDwgdGhpcy50ZXh0U3BhbnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnRleHRTcGFuc1tjbnRdLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBjbnQgKz0gMTtcbiAgICB9XG4gIH07XG5cbiAgSFRleHRFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy52YWxpZGF0ZVRleHQoKTtcbiAgICB2YXIgc3ZnU3R5bGU7XG5cbiAgICBpZiAodGhpcy5kYXRhLnNpbmdsZVNoYXBlKSB7XG4gICAgICBpZiAoIXRoaXMuX2lzRmlyc3RGcmFtZSAmJiAhdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc01hc2tlZCAmJiB0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGYpIHtcbiAgICAgICAgLy8gVG9kbyBCZW5jaG1hcmsgaWYgdXNpbmcgdGhpcyBpcyBiZXR0ZXIgdGhhbiBnZXRCQm94XG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCAtdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5wLnZbMF0gKyAnICcgKyAtdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5wLnZbMV0gKyAnICcgKyB0aGlzLmNvbXBXICsgJyAnICsgdGhpcy5jb21wSCk7XG4gICAgICAgIHN2Z1N0eWxlID0gdGhpcy5zdmdFbGVtZW50LnN0eWxlO1xuICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSAndHJhbnNsYXRlKCcgKyAtdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5wLnZbMF0gKyAncHgsJyArIC10aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLnAudlsxXSArICdweCknO1xuICAgICAgICBzdmdTdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2xhdGlvbjtcbiAgICAgICAgc3ZnU3R5bGUud2Via2l0VHJhbnNmb3JtID0gdHJhbnNsYXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0QW5pbWF0b3IuZ2V0TWVhc3VyZXModGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEsIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnKTtcblxuICAgIGlmICghdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgJiYgIXRoaXMudGV4dEFuaW1hdG9yLmxldHRlcnNDaGFuZ2VkRmxhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgcmVuZGVyZWRMZXR0ZXJzID0gdGhpcy50ZXh0QW5pbWF0b3IucmVuZGVyZWRMZXR0ZXJzO1xuICAgIHZhciBsZXR0ZXJzID0gdGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEubDtcbiAgICBsZW4gPSBsZXR0ZXJzLmxlbmd0aDtcbiAgICB2YXIgcmVuZGVyZWRMZXR0ZXI7XG4gICAgdmFyIHRleHRTcGFuO1xuICAgIHZhciB0ZXh0UGF0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKGxldHRlcnNbaV0ubikge1xuICAgICAgICBjb3VudCArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dFNwYW4gPSB0aGlzLnRleHRTcGFuc1tpXTtcbiAgICAgICAgdGV4dFBhdGggPSB0aGlzLnRleHRQYXRoc1tpXTtcbiAgICAgICAgcmVuZGVyZWRMZXR0ZXIgPSByZW5kZXJlZExldHRlcnNbY291bnRdO1xuICAgICAgICBjb3VudCArPSAxO1xuXG4gICAgICAgIGlmIChyZW5kZXJlZExldHRlci5fbWRmLm0pIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNNYXNrZWQpIHtcbiAgICAgICAgICAgIHRleHRTcGFuLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHJlbmRlcmVkTGV0dGVyLm07XG4gICAgICAgICAgICB0ZXh0U3Bhbi5zdHlsZS50cmFuc2Zvcm0gPSByZW5kZXJlZExldHRlci5tO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIHJlbmRlcmVkTGV0dGVyLm0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLy8gL3RleHRTcGFuLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScscmVuZGVyZWRMZXR0ZXIubyk7XG5cblxuICAgICAgICB0ZXh0U3Bhbi5zdHlsZS5vcGFjaXR5ID0gcmVuZGVyZWRMZXR0ZXIubztcblxuICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuc3cgJiYgcmVuZGVyZWRMZXR0ZXIuX21kZi5zdykge1xuICAgICAgICAgIHRleHRQYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgcmVuZGVyZWRMZXR0ZXIuc3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLnNjICYmIHJlbmRlcmVkTGV0dGVyLl9tZGYuc2MpIHtcbiAgICAgICAgICB0ZXh0UGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIHJlbmRlcmVkTGV0dGVyLnNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJlZExldHRlci5mYyAmJiByZW5kZXJlZExldHRlci5fbWRmLmZjKSB7XG4gICAgICAgICAgdGV4dFBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgcmVuZGVyZWRMZXR0ZXIuZmMpO1xuICAgICAgICAgIHRleHRQYXRoLnN0eWxlLmNvbG9yID0gcmVuZGVyZWRMZXR0ZXIuZmM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbm5lckVsZW0uZ2V0QkJveCAmJiAhdGhpcy5oaWRkZW4gJiYgKHRoaXMuX2lzRmlyc3RGcmFtZSB8fCB0aGlzLl9tZGYpKSB7XG4gICAgICB2YXIgYm91bmRpbmdCb3ggPSB0aGlzLmlubmVyRWxlbS5nZXRCQm94KCk7XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRCQm94LncgIT09IGJvdW5kaW5nQm94LndpZHRoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3gudyA9IGJvdW5kaW5nQm94LndpZHRoO1xuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGJvdW5kaW5nQm94LndpZHRoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY3VycmVudEJCb3guaCAhPT0gYm91bmRpbmdCb3guaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3guaCA9IGJvdW5kaW5nQm94LmhlaWdodDtcbiAgICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYm91bmRpbmdCb3guaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hcmdpbiA9IDE7XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRCQm94LncgIT09IGJvdW5kaW5nQm94LndpZHRoICsgbWFyZ2luICogMiB8fCB0aGlzLmN1cnJlbnRCQm94LmggIT09IGJvdW5kaW5nQm94LmhlaWdodCArIG1hcmdpbiAqIDIgfHwgdGhpcy5jdXJyZW50QkJveC54ICE9PSBib3VuZGluZ0JveC54IC0gbWFyZ2luIHx8IHRoaXMuY3VycmVudEJCb3gueSAhPT0gYm91bmRpbmdCb3gueSAtIG1hcmdpbikge1xuICAgICAgICB0aGlzLmN1cnJlbnRCQm94LncgPSBib3VuZGluZ0JveC53aWR0aCArIG1hcmdpbiAqIDI7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3guaCA9IGJvdW5kaW5nQm94LmhlaWdodCArIG1hcmdpbiAqIDI7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3gueCA9IGJvdW5kaW5nQm94LnggLSBtYXJnaW47XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3gueSA9IGJvdW5kaW5nQm94LnkgLSBtYXJnaW47XG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCB0aGlzLmN1cnJlbnRCQm94LnggKyAnICcgKyB0aGlzLmN1cnJlbnRCQm94LnkgKyAnICcgKyB0aGlzLmN1cnJlbnRCQm94LncgKyAnICcgKyB0aGlzLmN1cnJlbnRCQm94LmgpO1xuICAgICAgICBzdmdTdHlsZSA9IHRoaXMuc3ZnRWxlbWVudC5zdHlsZTtcbiAgICAgICAgdmFyIHN2Z1RyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIHRoaXMuY3VycmVudEJCb3gueCArICdweCwnICsgdGhpcy5jdXJyZW50QkJveC55ICsgJ3B4KSc7XG4gICAgICAgIHN2Z1N0eWxlLnRyYW5zZm9ybSA9IHN2Z1RyYW5zZm9ybTtcbiAgICAgICAgc3ZnU3R5bGUud2Via2l0VHJhbnNmb3JtID0gc3ZnVHJhbnNmb3JtO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBIQ2FtZXJhRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5pbml0RnJhbWUoKTtcbiAgICB0aGlzLmluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICB0aGlzLmluaXRIaWVyYXJjaHkoKTtcbiAgICB2YXIgZ2V0UHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wO1xuICAgIHRoaXMucGUgPSBnZXRQcm9wKHRoaXMsIGRhdGEucGUsIDAsIDAsIHRoaXMpO1xuXG4gICAgaWYgKGRhdGEua3MucC5zKSB7XG4gICAgICB0aGlzLnB4ID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnAueCwgMSwgMCwgdGhpcyk7XG4gICAgICB0aGlzLnB5ID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnAueSwgMSwgMCwgdGhpcyk7XG4gICAgICB0aGlzLnB6ID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnAueiwgMSwgMCwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucCA9IGdldFByb3AodGhpcywgZGF0YS5rcy5wLCAxLCAwLCB0aGlzKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5rcy5hKSB7XG4gICAgICB0aGlzLmEgPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MuYSwgMSwgMCwgdGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEua3Mub3Iuay5sZW5ndGggJiYgZGF0YS5rcy5vci5rWzBdLnRvKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBkYXRhLmtzLm9yLmsubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgZGF0YS5rcy5vci5rW2ldLnRvID0gbnVsbDtcbiAgICAgICAgZGF0YS5rcy5vci5rW2ldLnRpID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9yID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLm9yLCAxLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgIHRoaXMub3Iuc2ggPSB0cnVlO1xuICAgIHRoaXMucnggPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MucngsIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgdGhpcy5yeSA9IGdldFByb3AodGhpcywgZGF0YS5rcy5yeSwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcbiAgICB0aGlzLnJ6ID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnJ6LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgIHRoaXMubWF0ID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMuX3ByZXZNYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTsgLy8gVE9ETzogZmluZCBhIGJldHRlciB3YXkgdG8gbWFrZSB0aGUgSENhbWVyYSBlbGVtZW50IHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgTGF5ZXJJbnRlcmZhY2UgYW5kIFRyYW5zZm9ybUludGVyZmFjZS5cblxuICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0gPSB7XG4gICAgICBtUHJvcDogdGhpc1xuICAgIH07XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBGcmFtZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnRdLCBIQ2FtZXJhRWxlbWVudCk7XG5cbiAgSENhbWVyYUVsZW1lbnQucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmNvbXAudGhyZWVERWxlbWVudHMubGVuZ3RoO1xuICAgIHZhciBjb21wO1xuICAgIHZhciBwZXJzcGVjdGl2ZVN0eWxlO1xuICAgIHZhciBjb250YWluZXJTdHlsZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgLy8gW3BlcnNwZWN0aXZlRWxlbSxjb250YWluZXJdXG4gICAgICBjb21wID0gdGhpcy5jb21wLnRocmVlREVsZW1lbnRzW2ldO1xuXG4gICAgICBpZiAoY29tcC50eXBlID09PSAnM2QnKSB7XG4gICAgICAgIHBlcnNwZWN0aXZlU3R5bGUgPSBjb21wLnBlcnNwZWN0aXZlRWxlbS5zdHlsZTtcbiAgICAgICAgY29udGFpbmVyU3R5bGUgPSBjb21wLmNvbnRhaW5lci5zdHlsZTtcbiAgICAgICAgdmFyIHBlcnNwZWN0aXZlID0gdGhpcy5wZS52ICsgJ3B4JztcbiAgICAgICAgdmFyIG9yaWdpbiA9ICcwcHggMHB4IDBweCc7XG4gICAgICAgIHZhciBtYXRyaXggPSAnbWF0cml4M2QoMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMSknO1xuICAgICAgICBwZXJzcGVjdGl2ZVN0eWxlLnBlcnNwZWN0aXZlID0gcGVyc3BlY3RpdmU7XG4gICAgICAgIHBlcnNwZWN0aXZlU3R5bGUud2Via2l0UGVyc3BlY3RpdmUgPSBwZXJzcGVjdGl2ZTtcbiAgICAgICAgY29udGFpbmVyU3R5bGUudHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xuICAgICAgICBjb250YWluZXJTdHlsZS5tb3pUcmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIGNvbnRhaW5lclN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgcGVyc3BlY3RpdmVTdHlsZS50cmFuc2Zvcm0gPSBtYXRyaXg7XG4gICAgICAgIHBlcnNwZWN0aXZlU3R5bGUud2Via2l0VHJhbnNmb3JtID0gbWF0cml4O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBIQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBIQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIEhDYW1lcmFFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX21kZiA9IHRoaXMuX2lzRmlyc3RGcmFtZTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgaWYgKHRoaXMuaGllcmFyY2h5KSB7XG4gICAgICBsZW4gPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBfbWRmID0gdGhpcy5oaWVyYXJjaHlbaV0uZmluYWxUcmFuc2Zvcm0ubVByb3AuX21kZiB8fCBfbWRmO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChfbWRmIHx8IHRoaXMucGUuX21kZiB8fCB0aGlzLnAgJiYgdGhpcy5wLl9tZGYgfHwgdGhpcy5weCAmJiAodGhpcy5weC5fbWRmIHx8IHRoaXMucHkuX21kZiB8fCB0aGlzLnB6Ll9tZGYpIHx8IHRoaXMucnguX21kZiB8fCB0aGlzLnJ5Ll9tZGYgfHwgdGhpcy5yei5fbWRmIHx8IHRoaXMub3IuX21kZiB8fCB0aGlzLmEgJiYgdGhpcy5hLl9tZGYpIHtcbiAgICAgIHRoaXMubWF0LnJlc2V0KCk7XG5cbiAgICAgIGlmICh0aGlzLmhpZXJhcmNoeSkge1xuICAgICAgICBsZW4gPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGggLSAxO1xuXG4gICAgICAgIGZvciAoaSA9IGxlbjsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICB2YXIgbVRyYW5zZiA9IHRoaXMuaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wO1xuICAgICAgICAgIHRoaXMubWF0LnRyYW5zbGF0ZSgtbVRyYW5zZi5wLnZbMF0sIC1tVHJhbnNmLnAudlsxXSwgbVRyYW5zZi5wLnZbMl0pO1xuICAgICAgICAgIHRoaXMubWF0LnJvdGF0ZVgoLW1UcmFuc2Yub3IudlswXSkucm90YXRlWSgtbVRyYW5zZi5vci52WzFdKS5yb3RhdGVaKG1UcmFuc2Yub3IudlsyXSk7XG4gICAgICAgICAgdGhpcy5tYXQucm90YXRlWCgtbVRyYW5zZi5yeC52KS5yb3RhdGVZKC1tVHJhbnNmLnJ5LnYpLnJvdGF0ZVoobVRyYW5zZi5yei52KTtcbiAgICAgICAgICB0aGlzLm1hdC5zY2FsZSgxIC8gbVRyYW5zZi5zLnZbMF0sIDEgLyBtVHJhbnNmLnMudlsxXSwgMSAvIG1UcmFuc2Yucy52WzJdKTtcbiAgICAgICAgICB0aGlzLm1hdC50cmFuc2xhdGUobVRyYW5zZi5hLnZbMF0sIG1UcmFuc2YuYS52WzFdLCBtVHJhbnNmLmEudlsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucCkge1xuICAgICAgICB0aGlzLm1hdC50cmFuc2xhdGUoLXRoaXMucC52WzBdLCAtdGhpcy5wLnZbMV0sIHRoaXMucC52WzJdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWF0LnRyYW5zbGF0ZSgtdGhpcy5weC52LCAtdGhpcy5weS52LCB0aGlzLnB6LnYpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hKSB7XG4gICAgICAgIHZhciBkaWZmVmVjdG9yO1xuXG4gICAgICAgIGlmICh0aGlzLnApIHtcbiAgICAgICAgICBkaWZmVmVjdG9yID0gW3RoaXMucC52WzBdIC0gdGhpcy5hLnZbMF0sIHRoaXMucC52WzFdIC0gdGhpcy5hLnZbMV0sIHRoaXMucC52WzJdIC0gdGhpcy5hLnZbMl1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZWZWN0b3IgPSBbdGhpcy5weC52IC0gdGhpcy5hLnZbMF0sIHRoaXMucHkudiAtIHRoaXMuYS52WzFdLCB0aGlzLnB6LnYgLSB0aGlzLmEudlsyXV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFnID0gTWF0aC5zcXJ0KE1hdGgucG93KGRpZmZWZWN0b3JbMF0sIDIpICsgTWF0aC5wb3coZGlmZlZlY3RvclsxXSwgMikgKyBNYXRoLnBvdyhkaWZmVmVjdG9yWzJdLCAyKSk7IC8vIHZhciBsb29rRGlyID0gZ2V0Tm9ybWFsaXplZFBvaW50KGdldERpZmZWZWN0b3IodGhpcy5hLnYsdGhpcy5wLnYpKTtcblxuICAgICAgICB2YXIgbG9va0RpciA9IFtkaWZmVmVjdG9yWzBdIC8gbWFnLCBkaWZmVmVjdG9yWzFdIC8gbWFnLCBkaWZmVmVjdG9yWzJdIC8gbWFnXTtcbiAgICAgICAgdmFyIGxvb2tMZW5ndGhPblhaID0gTWF0aC5zcXJ0KGxvb2tEaXJbMl0gKiBsb29rRGlyWzJdICsgbG9va0RpclswXSAqIGxvb2tEaXJbMF0pO1xuICAgICAgICB2YXIgbVJvdGF0aW9uWCA9IE1hdGguYXRhbjIobG9va0RpclsxXSwgbG9va0xlbmd0aE9uWFopO1xuICAgICAgICB2YXIgbVJvdGF0aW9uWSA9IE1hdGguYXRhbjIobG9va0RpclswXSwgLWxvb2tEaXJbMl0pO1xuICAgICAgICB0aGlzLm1hdC5yb3RhdGVZKG1Sb3RhdGlvblkpLnJvdGF0ZVgoLW1Sb3RhdGlvblgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1hdC5yb3RhdGVYKC10aGlzLnJ4LnYpLnJvdGF0ZVkoLXRoaXMucnkudikucm90YXRlWih0aGlzLnJ6LnYpO1xuICAgICAgdGhpcy5tYXQucm90YXRlWCgtdGhpcy5vci52WzBdKS5yb3RhdGVZKC10aGlzLm9yLnZbMV0pLnJvdGF0ZVoodGhpcy5vci52WzJdKTtcbiAgICAgIHRoaXMubWF0LnRyYW5zbGF0ZSh0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudyAvIDIsIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oIC8gMiwgMCk7XG4gICAgICB0aGlzLm1hdC50cmFuc2xhdGUoMCwgMCwgdGhpcy5wZS52KTtcbiAgICAgIHZhciBoYXNNYXRyaXhDaGFuZ2VkID0gIXRoaXMuX3ByZXZNYXQuZXF1YWxzKHRoaXMubWF0KTtcblxuICAgICAgaWYgKChoYXNNYXRyaXhDaGFuZ2VkIHx8IHRoaXMucGUuX21kZikgJiYgdGhpcy5jb21wLnRocmVlREVsZW1lbnRzKSB7XG4gICAgICAgIGxlbiA9IHRoaXMuY29tcC50aHJlZURFbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBjb21wO1xuICAgICAgICB2YXIgcGVyc3BlY3RpdmVTdHlsZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lclN0eWxlO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGNvbXAgPSB0aGlzLmNvbXAudGhyZWVERWxlbWVudHNbaV07XG5cbiAgICAgICAgICBpZiAoY29tcC50eXBlID09PSAnM2QnKSB7XG4gICAgICAgICAgICBpZiAoaGFzTWF0cml4Q2hhbmdlZCkge1xuICAgICAgICAgICAgICB2YXIgbWF0VmFsdWUgPSB0aGlzLm1hdC50b0NTUygpO1xuICAgICAgICAgICAgICBjb250YWluZXJTdHlsZSA9IGNvbXAuY29udGFpbmVyLnN0eWxlO1xuICAgICAgICAgICAgICBjb250YWluZXJTdHlsZS50cmFuc2Zvcm0gPSBtYXRWYWx1ZTtcbiAgICAgICAgICAgICAgY29udGFpbmVyU3R5bGUud2Via2l0VHJhbnNmb3JtID0gbWF0VmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBlLl9tZGYpIHtcbiAgICAgICAgICAgICAgcGVyc3BlY3RpdmVTdHlsZSA9IGNvbXAucGVyc3BlY3RpdmVFbGVtLnN0eWxlO1xuICAgICAgICAgICAgICBwZXJzcGVjdGl2ZVN0eWxlLnBlcnNwZWN0aXZlID0gdGhpcy5wZS52ICsgJ3B4JztcbiAgICAgICAgICAgICAgcGVyc3BlY3RpdmVTdHlsZS53ZWJraXRQZXJzcGVjdGl2ZSA9IHRoaXMucGUudiArICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXQuY2xvbmUodGhpcy5fcHJldk1hdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gZmFsc2U7XG4gIH07XG5cbiAgSENhbWVyYUVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdHJ1ZSk7XG4gIH07XG5cbiAgSENhbWVyYUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBIQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUuZ2V0QmFzZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgZnVuY3Rpb24gSEltYWdlRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5hc3NldERhdGEgPSBnbG9iYWxEYXRhLmdldEFzc2V0RGF0YShkYXRhLnJlZklkKTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSEJhc2VFbGVtZW50LCBIU29saWRFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVFbGVtZW50XSwgSEltYWdlRWxlbWVudCk7XG5cbiAgSEltYWdlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXNzZXRQYXRoID0gdGhpcy5nbG9iYWxEYXRhLmdldEFzc2V0c1BhdGgodGhpcy5hc3NldERhdGEpO1xuICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuICAgIGlmICh0aGlzLmRhdGEuaGFzTWFzaykge1xuICAgICAgdGhpcy5pbWFnZUVsZW0gPSBjcmVhdGVOUygnaW1hZ2UnKTtcbiAgICAgIHRoaXMuaW1hZ2VFbGVtLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmFzc2V0RGF0YS53ICsgJ3B4Jyk7XG4gICAgICB0aGlzLmltYWdlRWxlbS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuYXNzZXREYXRhLmggKyAncHgnKTtcbiAgICAgIHRoaXMuaW1hZ2VFbGVtLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgJ2hyZWYnLCBhc3NldFBhdGgpO1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5pbWFnZUVsZW0pO1xuICAgICAgdGhpcy5iYXNlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5hc3NldERhdGEudyk7XG4gICAgICB0aGlzLmJhc2VFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5hc3NldERhdGEuaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKGltZyk7XG4gICAgfVxuXG4gICAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gICAgaW1nLnNyYyA9IGFzc2V0UGF0aDtcblxuICAgIGlmICh0aGlzLmRhdGEubG4pIHtcbiAgICAgIHRoaXMuYmFzZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuZGF0YS5sbik7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEh5YnJpZFJlbmRlcmVyQmFzZShhbmltYXRpb25JdGVtLCBjb25maWcpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0gPSBhbmltYXRpb25JdGVtO1xuICAgIHRoaXMubGF5ZXJzID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSAtMTtcbiAgICB0aGlzLnJlbmRlckNvbmZpZyA9IHtcbiAgICAgIGNsYXNzTmFtZTogY29uZmlnICYmIGNvbmZpZy5jbGFzc05hbWUgfHwgJycsXG4gICAgICBpbWFnZVByZXNlcnZlQXNwZWN0UmF0aW86IGNvbmZpZyAmJiBjb25maWcuaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvIHx8ICd4TWlkWU1pZCBzbGljZScsXG4gICAgICBoaWRlT25UcmFuc3BhcmVudDogIShjb25maWcgJiYgY29uZmlnLmhpZGVPblRyYW5zcGFyZW50ID09PSBmYWxzZSksXG4gICAgICBmaWx0ZXJTaXplOiB7XG4gICAgICAgIHdpZHRoOiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUud2lkdGggfHwgJzQwMCUnLFxuICAgICAgICBoZWlnaHQ6IGNvbmZpZyAmJiBjb25maWcuZmlsdGVyU2l6ZSAmJiBjb25maWcuZmlsdGVyU2l6ZS5oZWlnaHQgfHwgJzQwMCUnLFxuICAgICAgICB4OiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUueCB8fCAnLTEwMCUnLFxuICAgICAgICB5OiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUueSB8fCAnLTEwMCUnXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdsb2JhbERhdGEgPSB7XG4gICAgICBfbWRmOiBmYWxzZSxcbiAgICAgIGZyYW1lTnVtOiAtMSxcbiAgICAgIHJlbmRlckNvbmZpZzogdGhpcy5yZW5kZXJDb25maWdcbiAgICB9O1xuICAgIHRoaXMucGVuZGluZ0VsZW1lbnRzID0gW107XG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICAgIHRoaXMudGhyZWVERWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FtZXJhID0gbnVsbDtcbiAgICB0aGlzLnN1cHBvcnRzM2QgPSB0cnVlO1xuICAgIHRoaXMucmVuZGVyZXJUeXBlID0gJ2h0bWwnO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlUmVuZGVyZXJdLCBIeWJyaWRSZW5kZXJlckJhc2UpO1xuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmJ1aWxkSXRlbSA9IFNWR1JlbmRlcmVyLnByb3RvdHlwZS5idWlsZEl0ZW07XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jaGVja1BlbmRpbmdFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB3aGlsZSAodGhpcy5wZW5kaW5nRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGVuZGluZ0VsZW1lbnRzLnBvcCgpO1xuICAgICAgZWxlbWVudC5jaGVja1BhcmVudGluZygpO1xuICAgIH1cbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmFwcGVuZEVsZW1lbnRJblBvcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBwb3MpIHtcbiAgICB2YXIgbmV3RE9NRWxlbWVudCA9IGVsZW1lbnQuZ2V0QmFzZUVsZW1lbnQoKTtcblxuICAgIGlmICghbmV3RE9NRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsYXllciA9IHRoaXMubGF5ZXJzW3Bvc107XG5cbiAgICBpZiAoIWxheWVyLmRkZCB8fCAhdGhpcy5zdXBwb3J0czNkKSB7XG4gICAgICBpZiAodGhpcy50aHJlZURFbGVtZW50cykge1xuICAgICAgICB0aGlzLmFkZFRvM2RDb250YWluZXIobmV3RE9NRWxlbWVudCwgcG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIG5leHRET01FbGVtZW50O1xuICAgICAgICB2YXIgbmV4dExheWVyO1xuICAgICAgICB2YXIgdG1wRE9NRWxlbWVudDtcblxuICAgICAgICB3aGlsZSAoaSA8IHBvcykge1xuICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldICYmIHRoaXMuZWxlbWVudHNbaV0gIT09IHRydWUgJiYgdGhpcy5lbGVtZW50c1tpXS5nZXRCYXNlRWxlbWVudCkge1xuICAgICAgICAgICAgbmV4dExheWVyID0gdGhpcy5lbGVtZW50c1tpXTtcbiAgICAgICAgICAgIHRtcERPTUVsZW1lbnQgPSB0aGlzLmxheWVyc1tpXS5kZGQgPyB0aGlzLmdldFRocmVlRENvbnRhaW5lckJ5UG9zKGkpIDogbmV4dExheWVyLmdldEJhc2VFbGVtZW50KCk7XG4gICAgICAgICAgICBuZXh0RE9NRWxlbWVudCA9IHRtcERPTUVsZW1lbnQgfHwgbmV4dERPTUVsZW1lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRET01FbGVtZW50KSB7XG4gICAgICAgICAgaWYgKCFsYXllci5kZGQgfHwgIXRoaXMuc3VwcG9ydHMzZCkge1xuICAgICAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuaW5zZXJ0QmVmb3JlKG5ld0RPTUVsZW1lbnQsIG5leHRET01FbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWxheWVyLmRkZCB8fCAhdGhpcy5zdXBwb3J0czNkKSB7XG4gICAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQobmV3RE9NRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRUbzNkQ29udGFpbmVyKG5ld0RPTUVsZW1lbnQsIHBvcyk7XG4gICAgfVxuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlU2hhcGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICghdGhpcy5zdXBwb3J0czNkKSB7XG4gICAgICByZXR1cm4gbmV3IFNWR1NoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSFNoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKCF0aGlzLnN1cHBvcnRzM2QpIHtcbiAgICAgIHJldHVybiBuZXcgU1ZHVGV4dExvdHRpZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEhUZXh0RWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlQ2FtZXJhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBIQ2FtZXJhRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzLmNhbWVyYTtcbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZUltYWdlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydHMzZCkge1xuICAgICAgcmV0dXJuIG5ldyBJSW1hZ2VFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBISW1hZ2VFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVTb2xpZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKCF0aGlzLnN1cHBvcnRzM2QpIHtcbiAgICAgIHJldHVybiBuZXcgSVNvbGlkRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSFNvbGlkRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlTnVsbCA9IFNWR1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVOdWxsO1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuZ2V0VGhyZWVEQ29udGFpbmVyQnlQb3MgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0aGlzLnRocmVlREVsZW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAodGhpcy50aHJlZURFbGVtZW50c1tpXS5zdGFydFBvcyA8PSBwb3MgJiYgdGhpcy50aHJlZURFbGVtZW50c1tpXS5lbmRQb3MgPj0gcG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocmVlREVsZW1lbnRzW2ldLnBlcnNwZWN0aXZlRWxlbTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlVGhyZWVEQ29udGFpbmVyID0gZnVuY3Rpb24gKHBvcywgdHlwZSkge1xuICAgIHZhciBwZXJzcGVjdGl2ZUVsZW0gPSBjcmVhdGVUYWcoJ2RpdicpO1xuICAgIHZhciBzdHlsZTtcbiAgICB2YXIgY29udGFpbmVyU3R5bGU7XG4gICAgc3R5bGVEaXYocGVyc3BlY3RpdmVFbGVtKTtcbiAgICB2YXIgY29udGFpbmVyID0gY3JlYXRlVGFnKCdkaXYnKTtcbiAgICBzdHlsZURpdihjb250YWluZXIpO1xuXG4gICAgaWYgKHR5cGUgPT09ICczZCcpIHtcbiAgICAgIHN0eWxlID0gcGVyc3BlY3RpdmVFbGVtLnN0eWxlO1xuICAgICAgc3R5bGUud2lkdGggPSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudyArICdweCc7XG4gICAgICBzdHlsZS5oZWlnaHQgPSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaCArICdweCc7XG4gICAgICB2YXIgY2VudGVyID0gJzUwJSA1MCUnO1xuICAgICAgc3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gY2VudGVyO1xuICAgICAgc3R5bGUubW96VHJhbnNmb3JtT3JpZ2luID0gY2VudGVyO1xuICAgICAgc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gY2VudGVyO1xuICAgICAgY29udGFpbmVyU3R5bGUgPSBjb250YWluZXIuc3R5bGU7XG4gICAgICB2YXIgbWF0cml4ID0gJ21hdHJpeDNkKDEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDEpJztcbiAgICAgIGNvbnRhaW5lclN0eWxlLnRyYW5zZm9ybSA9IG1hdHJpeDtcbiAgICAgIGNvbnRhaW5lclN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IG1hdHJpeDtcbiAgICB9XG5cbiAgICBwZXJzcGVjdGl2ZUVsZW0uYXBwZW5kQ2hpbGQoY29udGFpbmVyKTsgLy8gdGhpcy5yZXNpemVyRWxlbS5hcHBlbmRDaGlsZChwZXJzcGVjdGl2ZUVsZW0pO1xuXG4gICAgdmFyIHRocmVlRENvbnRhaW5lckRhdGEgPSB7XG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgIHBlcnNwZWN0aXZlRWxlbTogcGVyc3BlY3RpdmVFbGVtLFxuICAgICAgc3RhcnRQb3M6IHBvcyxcbiAgICAgIGVuZFBvczogcG9zLFxuICAgICAgdHlwZTogdHlwZVxuICAgIH07XG4gICAgdGhpcy50aHJlZURFbGVtZW50cy5wdXNoKHRocmVlRENvbnRhaW5lckRhdGEpO1xuICAgIHJldHVybiB0aHJlZURDb250YWluZXJEYXRhO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuYnVpbGQzZENvbnRhaW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcbiAgICB2YXIgbGFzdFRocmVlRENvbnRhaW5lckRhdGE7XG4gICAgdmFyIGN1cnJlbnRDb250YWluZXIgPSAnJztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMubGF5ZXJzW2ldLmRkZCAmJiB0aGlzLmxheWVyc1tpXS50eSAhPT0gMykge1xuICAgICAgICBpZiAoY3VycmVudENvbnRhaW5lciAhPT0gJzNkJykge1xuICAgICAgICAgIGN1cnJlbnRDb250YWluZXIgPSAnM2QnO1xuICAgICAgICAgIGxhc3RUaHJlZURDb250YWluZXJEYXRhID0gdGhpcy5jcmVhdGVUaHJlZURDb250YWluZXIoaSwgJzNkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0VGhyZWVEQ29udGFpbmVyRGF0YS5lbmRQb3MgPSBNYXRoLm1heChsYXN0VGhyZWVEQ29udGFpbmVyRGF0YS5lbmRQb3MsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDb250YWluZXIgIT09ICcyZCcpIHtcbiAgICAgICAgICBjdXJyZW50Q29udGFpbmVyID0gJzJkJztcbiAgICAgICAgICBsYXN0VGhyZWVEQ29udGFpbmVyRGF0YSA9IHRoaXMuY3JlYXRlVGhyZWVEQ29udGFpbmVyKGksICcyZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFRocmVlRENvbnRhaW5lckRhdGEuZW5kUG9zID0gTWF0aC5tYXgobGFzdFRocmVlRENvbnRhaW5lckRhdGEuZW5kUG9zLCBpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZW4gPSB0aGlzLnRocmVlREVsZW1lbnRzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICB0aGlzLnJlc2l6ZXJFbGVtLmFwcGVuZENoaWxkKHRoaXMudGhyZWVERWxlbWVudHNbaV0ucGVyc3BlY3RpdmVFbGVtKTtcbiAgICB9XG4gIH07XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5hZGRUbzNkQ29udGFpbmVyID0gZnVuY3Rpb24gKGVsZW0sIHBvcykge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGhpcy50aHJlZURFbGVtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgaWYgKHBvcyA8PSB0aGlzLnRocmVlREVsZW1lbnRzW2ldLmVuZFBvcykge1xuICAgICAgICB2YXIgaiA9IHRoaXMudGhyZWVERWxlbWVudHNbaV0uc3RhcnRQb3M7XG4gICAgICAgIHZhciBuZXh0RWxlbWVudDtcblxuICAgICAgICB3aGlsZSAoaiA8IHBvcykge1xuICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2pdICYmIHRoaXMuZWxlbWVudHNbal0uZ2V0QmFzZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIG5leHRFbGVtZW50ID0gdGhpcy5lbGVtZW50c1tqXS5nZXRCYXNlRWxlbWVudCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0RWxlbWVudCkge1xuICAgICAgICAgIHRoaXMudGhyZWVERWxlbWVudHNbaV0uY29udGFpbmVyLmluc2VydEJlZm9yZShlbGVtLCBuZXh0RWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50aHJlZURFbGVtZW50c1tpXS5jb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmNvbmZpZ0FuaW1hdGlvbiA9IGZ1bmN0aW9uIChhbmltRGF0YSkge1xuICAgIHZhciByZXNpemVyRWxlbSA9IGNyZWF0ZVRhZygnZGl2Jyk7XG4gICAgdmFyIHdyYXBwZXIgPSB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlcjtcbiAgICB2YXIgc3R5bGUgPSByZXNpemVyRWxlbS5zdHlsZTtcbiAgICBzdHlsZS53aWR0aCA9IGFuaW1EYXRhLncgKyAncHgnO1xuICAgIHN0eWxlLmhlaWdodCA9IGFuaW1EYXRhLmggKyAncHgnO1xuICAgIHRoaXMucmVzaXplckVsZW0gPSByZXNpemVyRWxlbTtcbiAgICBzdHlsZURpdihyZXNpemVyRWxlbSk7XG4gICAgc3R5bGUudHJhbnNmb3JtU3R5bGUgPSAnZmxhdCc7XG4gICAgc3R5bGUubW96VHJhbnNmb3JtU3R5bGUgPSAnZmxhdCc7XG4gICAgc3R5bGUud2Via2l0VHJhbnNmb3JtU3R5bGUgPSAnZmxhdCc7XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKSB7XG4gICAgICByZXNpemVyRWxlbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHJlc2l6ZXJFbGVtKTtcbiAgICBzdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIHZhciBzdmcgPSBjcmVhdGVOUygnc3ZnJyk7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMScpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcxJyk7XG4gICAgc3R5bGVEaXYoc3ZnKTtcbiAgICB0aGlzLnJlc2l6ZXJFbGVtLmFwcGVuZENoaWxkKHN2Zyk7XG4gICAgdmFyIGRlZnMgPSBjcmVhdGVOUygnZGVmcycpO1xuICAgIHN2Zy5hcHBlbmRDaGlsZChkZWZzKTtcbiAgICB0aGlzLmRhdGEgPSBhbmltRGF0YTsgLy8gTWFzayBhbmltYXRpb25cblxuICAgIHRoaXMuc2V0dXBHbG9iYWxEYXRhKGFuaW1EYXRhLCBzdmcpO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzID0gZGVmcztcbiAgICB0aGlzLmxheWVycyA9IGFuaW1EYXRhLmxheWVycztcbiAgICB0aGlzLmxheWVyRWxlbWVudCA9IHRoaXMucmVzaXplckVsZW07XG4gICAgdGhpcy5idWlsZDNkQ29udGFpbmVycygpO1xuICAgIHRoaXMudXBkYXRlQ29udGFpbmVyU2l6ZSgpO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLmlubmVyVGV4dCA9ICcnO1xuICAgIH1cblxuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzID0gbnVsbDtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMgPyB0aGlzLmxheWVycy5sZW5ndGggOiAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5lbGVtZW50c1tpXSAmJiB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3kpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0gPSBudWxsO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUudXBkYXRlQ29udGFpbmVyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbWVudFdpZHRoID0gdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIub2Zmc2V0V2lkdGg7XG4gICAgdmFyIGVsZW1lbnRIZWlnaHQgPSB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIGVsZW1lbnRSZWwgPSBlbGVtZW50V2lkdGggLyBlbGVtZW50SGVpZ2h0O1xuICAgIHZhciBhbmltYXRpb25SZWwgPSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudyAvIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oO1xuICAgIHZhciBzeDtcbiAgICB2YXIgc3k7XG4gICAgdmFyIHR4O1xuICAgIHZhciB0eTtcblxuICAgIGlmIChhbmltYXRpb25SZWwgPiBlbGVtZW50UmVsKSB7XG4gICAgICBzeCA9IGVsZW1lbnRXaWR0aCAvIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53O1xuICAgICAgc3kgPSBlbGVtZW50V2lkdGggLyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudztcbiAgICAgIHR4ID0gMDtcbiAgICAgIHR5ID0gKGVsZW1lbnRIZWlnaHQgLSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaCAqIChlbGVtZW50V2lkdGggLyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudykpIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3ggPSBlbGVtZW50SGVpZ2h0IC8gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmg7XG4gICAgICBzeSA9IGVsZW1lbnRIZWlnaHQgLyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaDtcbiAgICAgIHR4ID0gKGVsZW1lbnRXaWR0aCAtIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53ICogKGVsZW1lbnRIZWlnaHQgLyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaCkpIC8gMjtcbiAgICAgIHR5ID0gMDtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSB0aGlzLnJlc2l6ZXJFbGVtLnN0eWxlO1xuICAgIHN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdtYXRyaXgzZCgnICsgc3ggKyAnLDAsMCwwLDAsJyArIHN5ICsgJywwLDAsMCwwLDEsMCwnICsgdHggKyAnLCcgKyB0eSArICcsMCwxKSc7XG4gICAgc3R5bGUudHJhbnNmb3JtID0gc3R5bGUud2Via2l0VHJhbnNmb3JtO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBTVkdSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRnJhbWU7XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVzaXplckVsZW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZXNpemVyRWxlbS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmluaXRJdGVtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmJ1aWxkQWxsSXRlbXMoKTtcblxuICAgIGlmICh0aGlzLmNhbWVyYSkge1xuICAgICAgdGhpcy5jYW1lcmEuc2V0dXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNXaWR0aCA9IHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53O1xuICAgICAgdmFyIGNIZWlnaHQgPSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaDtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMudGhyZWVERWxlbWVudHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy50aHJlZURFbGVtZW50c1tpXS5wZXJzcGVjdGl2ZUVsZW0uc3R5bGU7XG4gICAgICAgIHN0eWxlLndlYmtpdFBlcnNwZWN0aXZlID0gTWF0aC5zcXJ0KE1hdGgucG93KGNXaWR0aCwgMikgKyBNYXRoLnBvdyhjSGVpZ2h0LCAyKSkgKyAncHgnO1xuICAgICAgICBzdHlsZS5wZXJzcGVjdGl2ZSA9IHN0eWxlLndlYmtpdFBlcnNwZWN0aXZlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLnNlYXJjaEV4dHJhQ29tcG9zaXRpb25zID0gZnVuY3Rpb24gKGFzc2V0cykge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBhc3NldHMubGVuZ3RoO1xuICAgIHZhciBmbG9hdGluZ0NvbnRhaW5lciA9IGNyZWF0ZVRhZygnZGl2Jyk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmIChhc3NldHNbaV0ueHQpIHtcbiAgICAgICAgdmFyIGNvbXAgPSB0aGlzLmNyZWF0ZUNvbXAoYXNzZXRzW2ldLCBmbG9hdGluZ0NvbnRhaW5lciwgdGhpcy5nbG9iYWxEYXRhLmNvbXAsIG51bGwpO1xuICAgICAgICBjb21wLmluaXRFeHByZXNzaW9ucygpO1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5yZWdpc3RlckNvbXBvc2l0aW9uKGNvbXApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBIQ29tcEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMubGF5ZXJzID0gZGF0YS5sYXllcnM7XG4gICAgdGhpcy5zdXBwb3J0czNkID0gIWRhdGEuaGFzTWFzaztcbiAgICB0aGlzLmNvbXBsZXRlTGF5ZXJzID0gZmFsc2U7XG4gICAgdGhpcy5wZW5kaW5nRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLmVsZW1lbnRzID0gdGhpcy5sYXllcnMgPyBjcmVhdGVTaXplZEFycmF5KHRoaXMubGF5ZXJzLmxlbmd0aCkgOiBbXTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMudG0gPSBkYXRhLnRtID8gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS50bSwgMCwgZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIHRoaXMpIDoge1xuICAgICAgX3BsYWNlaG9sZGVyOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbSHlicmlkUmVuZGVyZXJCYXNlLCBJQ29tcEVsZW1lbnQsIEhCYXNlRWxlbWVudF0sIEhDb21wRWxlbWVudCk7XG4gIEhDb21wRWxlbWVudC5wcm90b3R5cGUuX2NyZWF0ZUJhc2VDb250YWluZXJFbGVtZW50cyA9IEhDb21wRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGFpbmVyRWxlbWVudHM7XG5cbiAgSENvbXBFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250YWluZXJFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jcmVhdGVCYXNlQ29udGFpbmVyRWxlbWVudHMoKTsgLy8gZGl2RWxlbWVudC5zdHlsZS5jbGlwID0gJ3JlY3QoMHB4LCAnK3RoaXMuZGF0YS53KydweCwgJyt0aGlzLmRhdGEuaCsncHgsIDBweCknO1xuXG5cbiAgICBpZiAodGhpcy5kYXRhLmhhc01hc2spIHtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5kYXRhLncpO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5kYXRhLmgpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPSB0aGlzLmJhc2VFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudCA9IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgIH1cbiAgfTtcblxuICBIQ29tcEVsZW1lbnQucHJvdG90eXBlLmFkZFRvM2RDb250YWluZXIgPSBmdW5jdGlvbiAoZWxlbSwgcG9zKSB7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBuZXh0RWxlbWVudDtcblxuICAgIHdoaWxlIChqIDwgcG9zKSB7XG4gICAgICBpZiAodGhpcy5lbGVtZW50c1tqXSAmJiB0aGlzLmVsZW1lbnRzW2pdLmdldEJhc2VFbGVtZW50KSB7XG4gICAgICAgIG5leHRFbGVtZW50ID0gdGhpcy5lbGVtZW50c1tqXS5nZXRCYXNlRWxlbWVudCgpO1xuICAgICAgfVxuXG4gICAgICBqICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKG5leHRFbGVtZW50KSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5pbnNlcnRCZWZvcmUoZWxlbSwgbmV4dEVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChlbGVtKTtcbiAgICB9XG4gIH07XG5cbiAgSENvbXBFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb21wID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydHMzZCkge1xuICAgICAgcmV0dXJuIG5ldyBTVkdDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSENvbXBFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gSHlicmlkUmVuZGVyZXIoYW5pbWF0aW9uSXRlbSwgY29uZmlnKSB7XG4gICAgdGhpcy5hbmltYXRpb25JdGVtID0gYW5pbWF0aW9uSXRlbTtcbiAgICB0aGlzLmxheWVycyA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJlZEZyYW1lID0gLTE7XG4gICAgdGhpcy5yZW5kZXJDb25maWcgPSB7XG4gICAgICBjbGFzc05hbWU6IGNvbmZpZyAmJiBjb25maWcuY2xhc3NOYW1lIHx8ICcnLFxuICAgICAgaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvOiBjb25maWcgJiYgY29uZmlnLmltYWdlUHJlc2VydmVBc3BlY3RSYXRpbyB8fCAneE1pZFlNaWQgc2xpY2UnLFxuICAgICAgaGlkZU9uVHJhbnNwYXJlbnQ6ICEoY29uZmlnICYmIGNvbmZpZy5oaWRlT25UcmFuc3BhcmVudCA9PT0gZmFsc2UpLFxuICAgICAgZmlsdGVyU2l6ZToge1xuICAgICAgICB3aWR0aDogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLndpZHRoIHx8ICc0MDAlJyxcbiAgICAgICAgaGVpZ2h0OiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUuaGVpZ2h0IHx8ICc0MDAlJyxcbiAgICAgICAgeDogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLnggfHwgJy0xMDAlJyxcbiAgICAgICAgeTogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLnkgfHwgJy0xMDAlJ1xuICAgICAgfSxcbiAgICAgIHJ1bkV4cHJlc3Npb25zOiAhY29uZmlnIHx8IGNvbmZpZy5ydW5FeHByZXNzaW9ucyA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5ydW5FeHByZXNzaW9uc1xuICAgIH07XG4gICAgdGhpcy5nbG9iYWxEYXRhID0ge1xuICAgICAgX21kZjogZmFsc2UsXG4gICAgICBmcmFtZU51bTogLTEsXG4gICAgICByZW5kZXJDb25maWc6IHRoaXMucmVuZGVyQ29uZmlnXG4gICAgfTtcbiAgICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLnRocmVlREVsZW1lbnRzID0gW107XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhbWVyYSA9IG51bGw7XG4gICAgdGhpcy5zdXBwb3J0czNkID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlcmVyVHlwZSA9ICdodG1sJztcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbSHlicmlkUmVuZGVyZXJCYXNlXSwgSHlicmlkUmVuZGVyZXIpO1xuXG4gIEh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDb21wID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydHMzZCkge1xuICAgICAgcmV0dXJuIG5ldyBTVkdDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSENvbXBFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgdmFyIENvbXBFeHByZXNzaW9uSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY29tcCkge1xuICAgICAgZnVuY3Rpb24gX3RoaXNMYXllckZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gY29tcC5sYXllcnMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKGNvbXAubGF5ZXJzW2ldLm5tID09PSBuYW1lIHx8IGNvbXAubGF5ZXJzW2ldLmluZCA9PT0gbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXAuZWxlbWVudHNbaV0ubGF5ZXJJbnRlcmZhY2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIHJldHVybiB7YWN0aXZlOmZhbHNlfTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzTGF5ZXJGdW5jdGlvbiwgJ19uYW1lJywge1xuICAgICAgICB2YWx1ZTogY29tcC5kYXRhLm5tXG4gICAgICB9KTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5sYXllciA9IF90aGlzTGF5ZXJGdW5jdGlvbjtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5waXhlbEFzcGVjdCA9IDE7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uaGVpZ2h0ID0gY29tcC5kYXRhLmggfHwgY29tcC5nbG9iYWxEYXRhLmNvbXBTaXplLmg7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24ud2lkdGggPSBjb21wLmRhdGEudyB8fCBjb21wLmdsb2JhbERhdGEuY29tcFNpemUudztcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5waXhlbEFzcGVjdCA9IDE7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uZnJhbWVEdXJhdGlvbiA9IDEgLyBjb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmRpc3BsYXlTdGFydFRpbWUgPSAwO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLm51bUxheWVycyA9IGNvbXAubGF5ZXJzLmxlbmd0aDtcbiAgICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb247XG4gICAgfTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIF90eXBlb2YkMihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiQyID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YkMiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mJDIob2JqKTsgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlICovXG5cbiAgLypcclxuICAgQ29weXJpZ2h0IDIwMTQgRGF2aWQgQmF1LlxyXG5cclxuICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiAgIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gICBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICAgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gICBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuICAgcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXHJcbiAgIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbiAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbiAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuICAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcclxuICAgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcclxuICAgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcclxuICAgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcblxyXG4gICAqL1xuICBmdW5jdGlvbiBzZWVkUmFuZG9tKHBvb2wsIG1hdGgpIHtcbiAgICAvL1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSByZWxhdGVkIHRvIElFRUUgNzU0IGxpbWl0cy5cbiAgICAvL1xuICAgIHZhciBnbG9iYWwgPSB0aGlzLFxuICAgICAgICB3aWR0aCA9IDI1NixcbiAgICAgICAgLy8gZWFjaCBSQzQgb3V0cHV0IGlzIDAgPD0geCA8IDI1NlxuICAgIGNodW5rcyA9IDYsXG4gICAgICAgIC8vIGF0IGxlYXN0IHNpeCBSQzQgb3V0cHV0cyBmb3IgZWFjaCBkb3VibGVcbiAgICBkaWdpdHMgPSA1MixcbiAgICAgICAgLy8gdGhlcmUgYXJlIDUyIHNpZ25pZmljYW50IGRpZ2l0cyBpbiBhIGRvdWJsZVxuICAgIHJuZ25hbWUgPSAncmFuZG9tJyxcbiAgICAgICAgLy8gcm5nbmFtZTogbmFtZSBmb3IgTWF0aC5yYW5kb20gYW5kIE1hdGguc2VlZHJhbmRvbVxuICAgIHN0YXJ0ZGVub20gPSBtYXRoLnBvdyh3aWR0aCwgY2h1bmtzKSxcbiAgICAgICAgc2lnbmlmaWNhbmNlID0gbWF0aC5wb3coMiwgZGlnaXRzKSxcbiAgICAgICAgb3ZlcmZsb3cgPSBzaWduaWZpY2FuY2UgKiAyLFxuICAgICAgICBtYXNrID0gd2lkdGggLSAxLFxuICAgICAgICBub2RlY3J5cHRvOyAvLyBub2RlLmpzIGNyeXB0byBtb2R1bGUsIGluaXRpYWxpemVkIGF0IHRoZSBib3R0b20uXG4gICAgLy9cbiAgICAvLyBzZWVkcmFuZG9tKClcbiAgICAvLyBUaGlzIGlzIHRoZSBzZWVkcmFuZG9tIGZ1bmN0aW9uIGRlc2NyaWJlZCBhYm92ZS5cbiAgICAvL1xuXG4gICAgZnVuY3Rpb24gc2VlZHJhbmRvbShzZWVkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGtleSA9IFtdO1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPT09IHRydWUgPyB7XG4gICAgICAgIGVudHJvcHk6IHRydWVcbiAgICAgIH0gOiBvcHRpb25zIHx8IHt9OyAvLyBGbGF0dGVuIHRoZSBzZWVkIHN0cmluZyBvciBidWlsZCBvbmUgZnJvbSBsb2NhbCBlbnRyb3B5IGlmIG5lZWRlZC5cblxuICAgICAgdmFyIHNob3J0c2VlZCA9IG1peGtleShmbGF0dGVuKG9wdGlvbnMuZW50cm9weSA/IFtzZWVkLCB0b3N0cmluZyhwb29sKV0gOiBzZWVkID09PSBudWxsID8gYXV0b3NlZWQoKSA6IHNlZWQsIDMpLCBrZXkpOyAvLyBVc2UgdGhlIHNlZWQgdG8gaW5pdGlhbGl6ZSBhbiBBUkM0IGdlbmVyYXRvci5cblxuICAgICAgdmFyIGFyYzQgPSBuZXcgQVJDNChrZXkpOyAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSByYW5kb20gZG91YmxlIGluIFswLCAxKSB0aGF0IGNvbnRhaW5zXG4gICAgICAvLyByYW5kb21uZXNzIGluIGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2Egb2YgdGhlIElFRUUgNzU0IHZhbHVlLlxuXG4gICAgICB2YXIgcHJuZyA9IGZ1bmN0aW9uIHBybmcoKSB7XG4gICAgICAgIHZhciBuID0gYXJjNC5nKGNodW5rcyksXG4gICAgICAgICAgICAvLyBTdGFydCB3aXRoIGEgbnVtZXJhdG9yIG4gPCAyIF4gNDhcbiAgICAgICAgZCA9IHN0YXJ0ZGVub20sXG4gICAgICAgICAgICAvLyAgIGFuZCBkZW5vbWluYXRvciBkID0gMiBeIDQ4LlxuICAgICAgICB4ID0gMDsgLy8gICBhbmQgbm8gJ2V4dHJhIGxhc3QgYnl0ZScuXG5cbiAgICAgICAgd2hpbGUgKG4gPCBzaWduaWZpY2FuY2UpIHtcbiAgICAgICAgICAvLyBGaWxsIHVwIGFsbCBzaWduaWZpY2FudCBkaWdpdHMgYnlcbiAgICAgICAgICBuID0gKG4gKyB4KSAqIHdpZHRoOyAvLyAgIHNoaWZ0aW5nIG51bWVyYXRvciBhbmRcblxuICAgICAgICAgIGQgKj0gd2lkdGg7IC8vICAgZGVub21pbmF0b3IgYW5kIGdlbmVyYXRpbmcgYVxuXG4gICAgICAgICAgeCA9IGFyYzQuZygxKTsgLy8gICBuZXcgbGVhc3Qtc2lnbmlmaWNhbnQtYnl0ZS5cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChuID49IG92ZXJmbG93KSB7XG4gICAgICAgICAgLy8gVG8gYXZvaWQgcm91bmRpbmcgdXAsIGJlZm9yZSBhZGRpbmdcbiAgICAgICAgICBuIC89IDI7IC8vICAgbGFzdCBieXRlLCBzaGlmdCBldmVyeXRoaW5nXG5cbiAgICAgICAgICBkIC89IDI7IC8vICAgcmlnaHQgdXNpbmcgaW50ZWdlciBtYXRoIHVudGlsXG5cbiAgICAgICAgICB4ID4+Pj0gMTsgLy8gICB3ZSBoYXZlIGV4YWN0bHkgdGhlIGRlc2lyZWQgYml0cy5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobiArIHgpIC8gZDsgLy8gRm9ybSB0aGUgbnVtYmVyIHdpdGhpbiBbMCwgMSkuXG4gICAgICB9O1xuXG4gICAgICBwcm5nLmludDMyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJjNC5nKDQpIHwgMDtcbiAgICAgIH07XG5cbiAgICAgIHBybmcucXVpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmM0LmcoNCkgLyAweDEwMDAwMDAwMDtcbiAgICAgIH07XG5cbiAgICAgIHBybmdbXCJkb3VibGVcIl0gPSBwcm5nOyAvLyBNaXggdGhlIHJhbmRvbW5lc3MgaW50byBhY2N1bXVsYXRlZCBlbnRyb3B5LlxuXG4gICAgICBtaXhrZXkodG9zdHJpbmcoYXJjNC5TKSwgcG9vbCk7IC8vIENhbGxpbmcgY29udmVudGlvbjogd2hhdCB0byByZXR1cm4gYXMgYSBmdW5jdGlvbiBvZiBwcm5nLCBzZWVkLCBpc19tYXRoLlxuXG4gICAgICByZXR1cm4gKG9wdGlvbnMucGFzcyB8fCBjYWxsYmFjayB8fCBmdW5jdGlvbiAocHJuZywgc2VlZCwgaXNfbWF0aF9jYWxsLCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAvLyBMb2FkIHRoZSBhcmM0IHN0YXRlIGZyb20gdGhlIGdpdmVuIHN0YXRlIGlmIGl0IGhhcyBhbiBTIGFycmF5LlxuICAgICAgICAgIGlmIChzdGF0ZS5TKSB7XG4gICAgICAgICAgICBjb3B5KHN0YXRlLCBhcmM0KTtcbiAgICAgICAgICB9IC8vIE9ubHkgcHJvdmlkZSB0aGUgLnN0YXRlIG1ldGhvZCBpZiByZXF1ZXN0ZWQgdmlhIG9wdGlvbnMuc3RhdGUuXG5cblxuICAgICAgICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29weShhcmM0LCB7fSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSAvLyBJZiBjYWxsZWQgYXMgYSBtZXRob2Qgb2YgTWF0aCAoTWF0aC5zZWVkcmFuZG9tKCkpLCBtdXRhdGVcbiAgICAgICAgLy8gTWF0aC5yYW5kb20gYmVjYXVzZSB0aGF0IGlzIGhvdyBzZWVkcmFuZG9tLmpzIGhhcyB3b3JrZWQgc2luY2UgdjEuMC5cblxuXG4gICAgICAgIGlmIChpc19tYXRoX2NhbGwpIHtcbiAgICAgICAgICBtYXRoW3JuZ25hbWVdID0gcHJuZztcbiAgICAgICAgICByZXR1cm4gc2VlZDtcbiAgICAgICAgfSAvLyBPdGhlcndpc2UsIGl0IGlzIGEgbmV3ZXIgY2FsbGluZyBjb252ZW50aW9uLCBzbyByZXR1cm4gdGhlXG4gICAgICAgIC8vIHBybmcgZGlyZWN0bHkuXG4gICAgICAgIGVsc2UgcmV0dXJuIHBybmc7XG4gICAgICB9KShwcm5nLCBzaG9ydHNlZWQsICdnbG9iYWwnIGluIG9wdGlvbnMgPyBvcHRpb25zLmdsb2JhbCA6IHRoaXMgPT0gbWF0aCwgb3B0aW9ucy5zdGF0ZSk7XG4gICAgfVxuXG4gICAgbWF0aFsnc2VlZCcgKyBybmduYW1lXSA9IHNlZWRyYW5kb207IC8vXG4gICAgLy8gQVJDNFxuICAgIC8vXG4gICAgLy8gQW4gQVJDNCBpbXBsZW1lbnRhdGlvbi4gIFRoZSBjb25zdHJ1Y3RvciB0YWtlcyBhIGtleSBpbiB0aGUgZm9ybSBvZlxuICAgIC8vIGFuIGFycmF5IG9mIGF0IG1vc3QgKHdpZHRoKSBpbnRlZ2VycyB0aGF0IHNob3VsZCBiZSAwIDw9IHggPCAod2lkdGgpLlxuICAgIC8vXG4gICAgLy8gVGhlIGcoY291bnQpIG1ldGhvZCByZXR1cm5zIGEgcHNldWRvcmFuZG9tIGludGVnZXIgdGhhdCBjb25jYXRlbmF0ZXNcbiAgICAvLyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgZnJvbSBBUkM0LiAgSXRzIHJldHVybiB2YWx1ZSBpcyBhIG51bWJlciB4XG4gICAgLy8gdGhhdCBpcyBpbiB0aGUgcmFuZ2UgMCA8PSB4IDwgKHdpZHRoIF4gY291bnQpLlxuICAgIC8vXG5cbiAgICBmdW5jdGlvbiBBUkM0KGtleSkge1xuICAgICAgdmFyIHQsXG4gICAgICAgICAga2V5bGVuID0ga2V5Lmxlbmd0aCxcbiAgICAgICAgICBtZSA9IHRoaXMsXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgaiA9IG1lLmkgPSBtZS5qID0gMCxcbiAgICAgICAgICBzID0gbWUuUyA9IFtdOyAvLyBUaGUgZW1wdHkga2V5IFtdIGlzIHRyZWF0ZWQgYXMgWzBdLlxuXG4gICAgICBpZiAoIWtleWxlbikge1xuICAgICAgICBrZXkgPSBba2V5bGVuKytdO1xuICAgICAgfSAvLyBTZXQgdXAgUyB1c2luZyB0aGUgc3RhbmRhcmQga2V5IHNjaGVkdWxpbmcgYWxnb3JpdGhtLlxuXG5cbiAgICAgIHdoaWxlIChpIDwgd2lkdGgpIHtcbiAgICAgICAgc1tpXSA9IGkrKztcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgc1tpXSA9IHNbaiA9IG1hc2sgJiBqICsga2V5W2kgJSBrZXlsZW5dICsgKHQgPSBzW2ldKV07XG4gICAgICAgIHNbal0gPSB0O1xuICAgICAgfSAvLyBUaGUgXCJnXCIgbWV0aG9kIHJldHVybnMgdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGFzIG9uZSBudW1iZXIuXG5cblxuICAgICAgbWUuZyA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICAvLyBVc2luZyBpbnN0YW5jZSBtZW1iZXJzIGluc3RlYWQgb2YgY2xvc3VyZSBzdGF0ZSBuZWFybHkgZG91YmxlcyBzcGVlZC5cbiAgICAgICAgdmFyIHQsXG4gICAgICAgICAgICByID0gMCxcbiAgICAgICAgICAgIGkgPSBtZS5pLFxuICAgICAgICAgICAgaiA9IG1lLmosXG4gICAgICAgICAgICBzID0gbWUuUztcblxuICAgICAgICB3aGlsZSAoY291bnQtLSkge1xuICAgICAgICAgIHQgPSBzW2kgPSBtYXNrICYgaSArIDFdO1xuICAgICAgICAgIHIgPSByICogd2lkdGggKyBzW21hc2sgJiAoc1tpXSA9IHNbaiA9IG1hc2sgJiBqICsgdF0pICsgKHNbal0gPSB0KV07XG4gICAgICAgIH1cblxuICAgICAgICBtZS5pID0gaTtcbiAgICAgICAgbWUuaiA9IGo7XG4gICAgICAgIHJldHVybiByOyAvLyBGb3Igcm9idXN0IHVucHJlZGljdGFiaWxpdHksIHRoZSBmdW5jdGlvbiBjYWxsIGJlbG93IGF1dG9tYXRpY2FsbHlcbiAgICAgICAgLy8gZGlzY2FyZHMgYW4gaW5pdGlhbCBiYXRjaCBvZiB2YWx1ZXMuICBUaGlzIGlzIGNhbGxlZCBSQzQtZHJvcFsyNTZdLlxuICAgICAgICAvLyBTZWUgaHR0cDovL2dvb2dsZS5jb20vc2VhcmNoP3E9cnNhK2ZsdWhyZXIrcmVzcG9uc2UmYnRuSVxuICAgICAgfTtcbiAgICB9IC8vXG4gICAgLy8gY29weSgpXG4gICAgLy8gQ29waWVzIGludGVybmFsIHN0YXRlIG9mIEFSQzQgdG8gb3IgZnJvbSBhIHBsYWluIG9iamVjdC5cbiAgICAvL1xuXG5cbiAgICBmdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgICAgIHQuaSA9IGYuaTtcbiAgICAgIHQuaiA9IGYuajtcbiAgICAgIHQuUyA9IGYuUy5zbGljZSgpO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfSAvL1xuICAgIC8vIGZsYXR0ZW4oKVxuICAgIC8vIENvbnZlcnRzIGFuIG9iamVjdCB0cmVlIHRvIG5lc3RlZCBhcnJheXMgb2Ygc3RyaW5ncy5cbiAgICAvL1xuXG5cbiAgICBmdW5jdGlvbiBmbGF0dGVuKG9iaiwgZGVwdGgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICB0eXAgPSBfdHlwZW9mJDIob2JqKSxcbiAgICAgICAgICBwcm9wO1xuXG4gICAgICBpZiAoZGVwdGggJiYgdHlwID09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZmxhdHRlbihvYmpbcHJvcF0sIGRlcHRoIC0gMSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPyByZXN1bHQgOiB0eXAgPT0gJ3N0cmluZycgPyBvYmogOiBvYmogKyAnXFwwJztcbiAgICB9IC8vXG4gICAgLy8gbWl4a2V5KClcbiAgICAvLyBNaXhlcyBhIHN0cmluZyBzZWVkIGludG8gYSBrZXkgdGhhdCBpcyBhbiBhcnJheSBvZiBpbnRlZ2VycywgYW5kXG4gICAgLy8gcmV0dXJucyBhIHNob3J0ZW5lZCBzdHJpbmcgc2VlZCB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIHJlc3VsdCBrZXkuXG4gICAgLy9cblxuXG4gICAgZnVuY3Rpb24gbWl4a2V5KHNlZWQsIGtleSkge1xuICAgICAgdmFyIHN0cmluZ3NlZWQgPSBzZWVkICsgJycsXG4gICAgICAgICAgc21lYXIsXG4gICAgICAgICAgaiA9IDA7XG5cbiAgICAgIHdoaWxlIChqIDwgc3RyaW5nc2VlZC5sZW5ndGgpIHtcbiAgICAgICAga2V5W21hc2sgJiBqXSA9IG1hc2sgJiAoc21lYXIgXj0ga2V5W21hc2sgJiBqXSAqIDE5KSArIHN0cmluZ3NlZWQuY2hhckNvZGVBdChqKyspO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9zdHJpbmcoa2V5KTtcbiAgICB9IC8vXG4gICAgLy8gYXV0b3NlZWQoKVxuICAgIC8vIFJldHVybnMgYW4gb2JqZWN0IGZvciBhdXRvc2VlZGluZywgdXNpbmcgd2luZG93LmNyeXB0byBhbmQgTm9kZSBjcnlwdG9cbiAgICAvLyBtb2R1bGUgaWYgYXZhaWxhYmxlLlxuICAgIC8vXG5cblxuICAgIGZ1bmN0aW9uIGF1dG9zZWVkKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG5vZGVjcnlwdG8pIHtcbiAgICAgICAgICByZXR1cm4gdG9zdHJpbmcobm9kZWNyeXB0by5yYW5kb21CeXRlcyh3aWR0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dCA9IG5ldyBVaW50OEFycmF5KHdpZHRoKTtcbiAgICAgICAgKGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvKS5nZXRSYW5kb21WYWx1ZXMob3V0KTtcbiAgICAgICAgcmV0dXJuIHRvc3RyaW5nKG91dCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHZhciBicm93c2VyID0gZ2xvYmFsLm5hdmlnYXRvcixcbiAgICAgICAgICAgIHBsdWdpbnMgPSBicm93c2VyICYmIGJyb3dzZXIucGx1Z2lucztcbiAgICAgICAgcmV0dXJuIFsrbmV3IERhdGUoKSwgZ2xvYmFsLCBwbHVnaW5zLCBnbG9iYWwuc2NyZWVuLCB0b3N0cmluZyhwb29sKV07XG4gICAgICB9XG4gICAgfSAvL1xuICAgIC8vIHRvc3RyaW5nKClcbiAgICAvLyBDb252ZXJ0cyBhbiBhcnJheSBvZiBjaGFyY29kZXMgdG8gYSBzdHJpbmdcbiAgICAvL1xuXG5cbiAgICBmdW5jdGlvbiB0b3N0cmluZyhhKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSgwLCBhKTtcbiAgICB9IC8vXG4gICAgLy8gV2hlbiBzZWVkcmFuZG9tLmpzIGlzIGxvYWRlZCwgd2UgaW1tZWRpYXRlbHkgbWl4IGEgZmV3IGJpdHNcbiAgICAvLyBmcm9tIHRoZSBidWlsdC1pbiBSTkcgaW50byB0aGUgZW50cm9weSBwb29sLiAgQmVjYXVzZSB3ZSBkb1xuICAgIC8vIG5vdCB3YW50IHRvIGludGVyZmVyZSB3aXRoIGRldGVybWluaXN0aWMgUFJORyBzdGF0ZSBsYXRlcixcbiAgICAvLyBzZWVkcmFuZG9tIHdpbGwgbm90IGNhbGwgbWF0aC5yYW5kb20gb24gaXRzIG93biBhZ2FpbiBhZnRlclxuICAgIC8vIGluaXRpYWxpemF0aW9uLlxuICAgIC8vXG5cblxuICAgIG1peGtleShtYXRoLnJhbmRvbSgpLCBwb29sKTsgLy9cbiAgICAvLyBOb2RlanMgYW5kIEFNRCBzdXBwb3J0OiBleHBvcnQgdGhlIGltcGxlbWVudGF0aW9uIGFzIGEgbW9kdWxlIHVzaW5nXG4gICAgLy8gZWl0aGVyIGNvbnZlbnRpb24uXG4gICAgLy9cbiAgICAvLyBFbmQgYW5vbnltb3VzIHNjb3BlLCBhbmQgcGFzcyBpbml0aWFsIHZhbHVlcy5cbiAgfVxuXG4gIDtcblxuICBmdW5jdGlvbiBpbml0aWFsaXplJDIoQk1NYXRoKSB7XG4gICAgc2VlZFJhbmRvbShbXSwgQk1NYXRoKTtcbiAgfVxuXG4gIHZhciBwcm9wVHlwZXMgPSB7XG4gICAgU0hBUEU6ICdzaGFwZSdcbiAgfTtcblxuICBmdW5jdGlvbiBfdHlwZW9mJDEob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YkMSA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mJDEgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZiQxKG9iaik7IH1cblxuICB2YXIgRXhwcmVzc2lvbk1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG9iID0ge307XG4gICAgdmFyIE1hdGggPSBCTU1hdGg7XG4gICAgdmFyIHdpbmRvdyA9IG51bGw7XG4gICAgdmFyIGRvY3VtZW50ID0gbnVsbDtcbiAgICB2YXIgWE1MSHR0cFJlcXVlc3QgPSBudWxsO1xuICAgIHZhciBmZXRjaCA9IG51bGw7XG4gICAgdmFyIGZyYW1lcyA9IG51bGw7XG4gICAgdmFyIF9sb3R0aWVHbG9iYWwgPSB7fTtcbiAgICBpbml0aWFsaXplJDIoQk1NYXRoKTtcblxuICAgIGZ1bmN0aW9uIHJlc2V0RnJhbWUoKSB7XG4gICAgICBfbG90dGllR2xvYmFsID0ge307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJGJtX2lzSW5zdGFuY2VPZkFycmF5KGFycikge1xuICAgICAgcmV0dXJuIGFyci5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgfHwgYXJyLmNvbnN0cnVjdG9yID09PSBGbG9hdDMyQXJyYXk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1lcmFibGUodE9mViwgdikge1xuICAgICAgcmV0dXJuIHRPZlYgPT09ICdudW1iZXInIHx8IHYgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdE9mViA9PT0gJ2Jvb2xlYW4nIHx8IHRPZlYgPT09ICdzdHJpbmcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICRibV9uZWcoYSkge1xuICAgICAgdmFyIHRPZkEgPSBfdHlwZW9mJDEoYSk7XG5cbiAgICAgIGlmICh0T2ZBID09PSAnbnVtYmVyJyB8fCBhIGluc3RhbmNlb2YgTnVtYmVyIHx8IHRPZkEgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gLWE7XG4gICAgICB9XG5cbiAgICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW5BID0gYS5sZW5ndGg7XG4gICAgICAgIHZhciByZXRBcnIgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuQTsgaSArPSAxKSB7XG4gICAgICAgICAgcmV0QXJyW2ldID0gLWFbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgfVxuXG4gICAgICBpZiAoYS5wcm9wVHlwZSkge1xuICAgICAgICByZXR1cm4gYS52O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLWE7XG4gICAgfVxuXG4gICAgdmFyIGVhc2VJbkJleiA9IEJlemllckZhY3RvcnkuZ2V0QmV6aWVyRWFzaW5nKDAuMzMzLCAwLCAwLjgzMywgMC44MzMsICdlYXNlSW4nKS5nZXQ7XG4gICAgdmFyIGVhc2VPdXRCZXogPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZygwLjE2NywgMC4xNjcsIDAuNjY3LCAxLCAnZWFzZU91dCcpLmdldDtcbiAgICB2YXIgZWFzZUluT3V0QmV6ID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcoMC4zMywgMCwgMC42NjcsIDEsICdlYXNlSW5PdXQnKS5nZXQ7XG5cbiAgICBmdW5jdGlvbiBzdW0oYSwgYikge1xuICAgICAgdmFyIHRPZkEgPSBfdHlwZW9mJDEoYSk7XG5cbiAgICAgIHZhciB0T2ZCID0gX3R5cGVvZiQxKGIpO1xuXG4gICAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikgfHwgdE9mQSA9PT0gJ3N0cmluZycgfHwgdE9mQiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGEgKyBiO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XG4gICAgICAgIGEgPSBhLnNsaWNlKDApO1xuICAgICAgICBhWzBdICs9IGI7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgJGJtX2lzSW5zdGFuY2VPZkFycmF5KGIpKSB7XG4gICAgICAgIGIgPSBiLnNsaWNlKDApO1xuICAgICAgICBiWzBdID0gYSArIGJbMF07XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW5BID0gYS5sZW5ndGg7XG4gICAgICAgIHZhciBsZW5CID0gYi5sZW5ndGg7XG4gICAgICAgIHZhciByZXRBcnIgPSBbXTtcblxuICAgICAgICB3aGlsZSAoaSA8IGxlbkEgfHwgaSA8IGxlbkIpIHtcbiAgICAgICAgICBpZiAoKHR5cGVvZiBhW2ldID09PSAnbnVtYmVyJyB8fCBhW2ldIGluc3RhbmNlb2YgTnVtYmVyKSAmJiAodHlwZW9mIGJbaV0gPT09ICdudW1iZXInIHx8IGJbaV0gaW5zdGFuY2VvZiBOdW1iZXIpKSB7XG4gICAgICAgICAgICByZXRBcnJbaV0gPSBhW2ldICsgYltpXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0QXJyW2ldID0gYltpXSA9PT0gdW5kZWZpbmVkID8gYVtpXSA6IGFbaV0gfHwgYltpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgYWRkID0gc3VtO1xuXG4gICAgZnVuY3Rpb24gc3ViKGEsIGIpIHtcbiAgICAgIHZhciB0T2ZBID0gX3R5cGVvZiQxKGEpO1xuXG4gICAgICB2YXIgdE9mQiA9IF90eXBlb2YkMShiKTtcblxuICAgICAgaWYgKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XG4gICAgICAgIGlmICh0T2ZBID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGEgPSBwYXJzZUludChhLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodE9mQiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBiID0gcGFyc2VJbnQoYiwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XG4gICAgICAgIGEgPSBhLnNsaWNlKDApO1xuICAgICAgICBhWzBdIC09IGI7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgJGJtX2lzSW5zdGFuY2VPZkFycmF5KGIpKSB7XG4gICAgICAgIGIgPSBiLnNsaWNlKDApO1xuICAgICAgICBiWzBdID0gYSAtIGJbMF07XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW5BID0gYS5sZW5ndGg7XG4gICAgICAgIHZhciBsZW5CID0gYi5sZW5ndGg7XG4gICAgICAgIHZhciByZXRBcnIgPSBbXTtcblxuICAgICAgICB3aGlsZSAoaSA8IGxlbkEgfHwgaSA8IGxlbkIpIHtcbiAgICAgICAgICBpZiAoKHR5cGVvZiBhW2ldID09PSAnbnVtYmVyJyB8fCBhW2ldIGluc3RhbmNlb2YgTnVtYmVyKSAmJiAodHlwZW9mIGJbaV0gPT09ICdudW1iZXInIHx8IGJbaV0gaW5zdGFuY2VvZiBOdW1iZXIpKSB7XG4gICAgICAgICAgICByZXRBcnJbaV0gPSBhW2ldIC0gYltpXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0QXJyW2ldID0gYltpXSA9PT0gdW5kZWZpbmVkID8gYVtpXSA6IGFbaV0gfHwgYltpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtdWwoYSwgYikge1xuICAgICAgdmFyIHRPZkEgPSBfdHlwZW9mJDEoYSk7XG5cbiAgICAgIHZhciB0T2ZCID0gX3R5cGVvZiQxKGIpO1xuXG4gICAgICB2YXIgYXJyO1xuXG4gICAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcbiAgICAgICAgcmV0dXJuIGEgKiBiO1xuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW47XG5cbiAgICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcbiAgICAgICAgbGVuID0gYS5sZW5ndGg7XG4gICAgICAgIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGFycltpXSA9IGFbaV0gKiBiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xuICAgICAgICBsZW4gPSBiLmxlbmd0aDtcbiAgICAgICAgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgYXJyW2ldID0gYSAqIGJbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXYoYSwgYikge1xuICAgICAgdmFyIHRPZkEgPSBfdHlwZW9mJDEoYSk7XG5cbiAgICAgIHZhciB0T2ZCID0gX3R5cGVvZiQxKGIpO1xuXG4gICAgICB2YXIgYXJyO1xuXG4gICAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcbiAgICAgICAgcmV0dXJuIGEgLyBiO1xuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW47XG5cbiAgICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcbiAgICAgICAgbGVuID0gYS5sZW5ndGg7XG4gICAgICAgIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGFycltpXSA9IGFbaV0gLyBiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xuICAgICAgICBsZW4gPSBiLmxlbmd0aDtcbiAgICAgICAgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgYXJyW2ldID0gYSAvIGJbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb2QoYSwgYikge1xuICAgICAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJykge1xuICAgICAgICBhID0gcGFyc2VJbnQoYSwgMTApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGIgPSBwYXJzZUludChiLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhICUgYjtcbiAgICB9XG5cbiAgICB2YXIgJGJtX3N1bSA9IHN1bTtcbiAgICB2YXIgJGJtX3N1YiA9IHN1YjtcbiAgICB2YXIgJGJtX211bCA9IG11bDtcbiAgICB2YXIgJGJtX2RpdiA9IGRpdjtcbiAgICB2YXIgJGJtX21vZCA9IG1vZDtcblxuICAgIGZ1bmN0aW9uIGNsYW1wKG51bSwgbWluLCBtYXgpIHtcbiAgICAgIGlmIChtaW4gPiBtYXgpIHtcbiAgICAgICAgdmFyIG1tID0gbWF4O1xuICAgICAgICBtYXggPSBtaW47XG4gICAgICAgIG1pbiA9IG1tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobnVtLCBtaW4pLCBtYXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJhZGlhbnNUb0RlZ3JlZXModmFsKSB7XG4gICAgICByZXR1cm4gdmFsIC8gZGVnVG9SYWRzO1xuICAgIH1cblxuICAgIHZhciByYWRpYW5zX3RvX2RlZ3JlZXMgPSByYWRpYW5zVG9EZWdyZWVzO1xuXG4gICAgZnVuY3Rpb24gZGVncmVlc1RvUmFkaWFucyh2YWwpIHtcbiAgICAgIHJldHVybiB2YWwgKiBkZWdUb1JhZHM7XG4gICAgfVxuXG4gICAgdmFyIGRlZ3JlZXNfdG9fcmFkaWFucyA9IHJhZGlhbnNUb0RlZ3JlZXM7XG4gICAgdmFyIGhlbHBlckxlbmd0aEFycmF5ID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuXG4gICAgZnVuY3Rpb24gbGVuZ3RoKGFycjEsIGFycjIpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJyMSA9PT0gJ251bWJlcicgfHwgYXJyMSBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICBhcnIyID0gYXJyMiB8fCAwO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYXJyMSAtIGFycjIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFycjIpIHtcbiAgICAgICAgYXJyMiA9IGhlbHBlckxlbmd0aEFycmF5O1xuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnIxLmxlbmd0aCwgYXJyMi5sZW5ndGgpO1xuICAgICAgdmFyIGFkZGVkTGVuZ3RoID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGFkZGVkTGVuZ3RoICs9IE1hdGgucG93KGFycjJbaV0gLSBhcnIxW2ldLCAyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1hdGguc3FydChhZGRlZExlbmd0aCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKHZlYykge1xuICAgICAgcmV0dXJuIGRpdih2ZWMsIGxlbmd0aCh2ZWMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZ2JUb0hzbCh2YWwpIHtcbiAgICAgIHZhciByID0gdmFsWzBdO1xuICAgICAgdmFyIGcgPSB2YWxbMV07XG4gICAgICB2YXIgYiA9IHZhbFsyXTtcbiAgICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICAgIHZhciBoO1xuICAgICAgdmFyIHM7XG4gICAgICB2YXIgbCA9IChtYXggKyBtaW4pIC8gMjtcblxuICAgICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgIGggPSAwOyAvLyBhY2hyb21hdGljXG5cbiAgICAgICAgcyA9IDA7IC8vIGFjaHJvbWF0aWNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG5cbiAgICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgZzpcbiAgICAgICAgICAgIGggPSAoYiAtIHIpIC8gZCArIDI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgYjpcbiAgICAgICAgICAgIGggPSAociAtIGcpIC8gZCArIDQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGggLz0gNjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtoLCBzLCBsLCB2YWxbM11dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICAgICAgaWYgKHQgPCAwKSB0ICs9IDE7XG4gICAgICBpZiAodCA+IDEpIHQgLT0gMTtcbiAgICAgIGlmICh0IDwgMSAvIDYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgICAgaWYgKHQgPCAxIC8gMikgcmV0dXJuIHE7XG4gICAgICBpZiAodCA8IDIgLyAzKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoc2xUb1JnYih2YWwpIHtcbiAgICAgIHZhciBoID0gdmFsWzBdO1xuICAgICAgdmFyIHMgPSB2YWxbMV07XG4gICAgICB2YXIgbCA9IHZhbFsyXTtcbiAgICAgIHZhciByO1xuICAgICAgdmFyIGc7XG4gICAgICB2YXIgYjtcblxuICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgciA9IGw7IC8vIGFjaHJvbWF0aWNcblxuICAgICAgICBiID0gbDsgLy8gYWNocm9tYXRpY1xuXG4gICAgICAgIGcgPSBsOyAvLyBhY2hyb21hdGljXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHZhciBwID0gMiAqIGwgLSBxO1xuICAgICAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICAgICAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtyLCBnLCBiLCB2YWxbM11dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVhcih0LCB0TWluLCB0TWF4LCB2YWx1ZTEsIHZhbHVlMikge1xuICAgICAgaWYgKHZhbHVlMSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlMSA9IHRNaW47XG4gICAgICAgIHZhbHVlMiA9IHRNYXg7XG4gICAgICAgIHRNaW4gPSAwO1xuICAgICAgICB0TWF4ID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRNYXggPCB0TWluKSB7XG4gICAgICAgIHZhciBfdE1pbiA9IHRNYXg7XG4gICAgICAgIHRNYXggPSB0TWluO1xuICAgICAgICB0TWluID0gX3RNaW47XG4gICAgICB9XG5cbiAgICAgIGlmICh0IDw9IHRNaW4pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQgPj0gdE1heCkge1xuICAgICAgICByZXR1cm4gdmFsdWUyO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGVyYyA9IHRNYXggPT09IHRNaW4gPyAwIDogKHQgLSB0TWluKSAvICh0TWF4IC0gdE1pbik7XG5cbiAgICAgIGlmICghdmFsdWUxLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdmFsdWUxICsgKHZhbHVlMiAtIHZhbHVlMSkgKiBwZXJjO1xuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB2YWx1ZTEubGVuZ3RoO1xuICAgICAgdmFyIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYXJyW2ldID0gdmFsdWUxW2ldICsgKHZhbHVlMltpXSAtIHZhbHVlMVtpXSkgKiBwZXJjO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCkge1xuICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG1pbiA9IDA7XG4gICAgICAgICAgbWF4ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXggPSBtaW47XG4gICAgICAgICAgbWluID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXgubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuID0gbWF4Lmxlbmd0aDtcblxuICAgICAgICBpZiAoIW1pbikge1xuICAgICAgICAgIG1pbiA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuICAgICAgICB2YXIgcm5kID0gQk1NYXRoLnJhbmRvbSgpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGFycltpXSA9IG1pbltpXSArIHJuZCAqIChtYXhbaV0gLSBtaW5baV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBybmRtID0gQk1NYXRoLnJhbmRvbSgpO1xuICAgICAgcmV0dXJuIG1pbiArIHJuZG0gKiAobWF4IC0gbWluKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXRoKHBvaW50cywgaW5UYW5nZW50cywgb3V0VGFuZ2VudHMsIGNsb3NlZCkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgIHZhciBwYXRoID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgIHBhdGguc2V0UGF0aERhdGEoISFjbG9zZWQsIGxlbik7XG4gICAgICB2YXIgYXJyUGxhY2Vob2xkZXIgPSBbMCwgMF07XG4gICAgICB2YXIgaW5WZXJ0ZXhQb2ludDtcbiAgICAgIHZhciBvdXRWZXJ0ZXhQb2ludDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGluVmVydGV4UG9pbnQgPSBpblRhbmdlbnRzICYmIGluVGFuZ2VudHNbaV0gPyBpblRhbmdlbnRzW2ldIDogYXJyUGxhY2Vob2xkZXI7XG4gICAgICAgIG91dFZlcnRleFBvaW50ID0gb3V0VGFuZ2VudHMgJiYgb3V0VGFuZ2VudHNbaV0gPyBvdXRUYW5nZW50c1tpXSA6IGFyclBsYWNlaG9sZGVyO1xuICAgICAgICBwYXRoLnNldFRyaXBsZUF0KHBvaW50c1tpXVswXSwgcG9pbnRzW2ldWzFdLCBvdXRWZXJ0ZXhQb2ludFswXSArIHBvaW50c1tpXVswXSwgb3V0VmVydGV4UG9pbnRbMV0gKyBwb2ludHNbaV1bMV0sIGluVmVydGV4UG9pbnRbMF0gKyBwb2ludHNbaV1bMF0sIGluVmVydGV4UG9pbnRbMV0gKyBwb2ludHNbaV1bMV0sIGksIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0aWF0ZUV4cHJlc3Npb24oZWxlbSwgZGF0YSwgcHJvcGVydHkpIHtcbiAgICAgIC8vIEJhaWwgb3V0IGlmIHdlIGRvbid0IHdhbnQgZXhwcmVzc2lvbnNcbiAgICAgIGZ1bmN0aW9uIG5vT3AoX3ZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghZWxlbS5nbG9iYWxEYXRhLnJlbmRlckNvbmZpZy5ydW5FeHByZXNzaW9ucykge1xuICAgICAgICByZXR1cm4gbm9PcDtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbCA9IGRhdGEueDtcbiAgICAgIHZhciBuZWVkc1ZlbG9jaXR5ID0gL3ZlbG9jaXR5KD8hW1xcd1xcZF0pLy50ZXN0KHZhbCk7XG5cbiAgICAgIHZhciBfbmVlZHNSYW5kb20gPSB2YWwuaW5kZXhPZigncmFuZG9tJykgIT09IC0xO1xuXG4gICAgICB2YXIgZWxlbVR5cGUgPSBlbGVtLmRhdGEudHk7XG4gICAgICB2YXIgdHJhbnNmb3JtO1xuICAgICAgdmFyICRibV90cmFuc2Zvcm07XG4gICAgICB2YXIgY29udGVudDtcbiAgICAgIHZhciBlZmZlY3Q7XG4gICAgICB2YXIgdGhpc1Byb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICB0aGlzUHJvcGVydHkudmFsdWVBdFRpbWUgPSB0aGlzUHJvcGVydHkuZ2V0VmFsdWVBdFRpbWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpc1Byb3BlcnR5LCAndmFsdWUnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzUHJvcGVydHkudjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlbGVtLmNvbXAuZnJhbWVEdXJhdGlvbiA9IDEgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICBlbGVtLmNvbXAuZGlzcGxheVN0YXJ0VGltZSA9IDA7XG4gICAgICB2YXIgaW5Qb2ludCA9IGVsZW0uZGF0YS5pcCAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgIHZhciBvdXRQb2ludCA9IGVsZW0uZGF0YS5vcCAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgIHZhciB3aWR0aCA9IGVsZW0uZGF0YS5zdyA/IGVsZW0uZGF0YS5zdyA6IDA7XG4gICAgICB2YXIgaGVpZ2h0ID0gZWxlbS5kYXRhLnNoID8gZWxlbS5kYXRhLnNoIDogMDtcbiAgICAgIHZhciBuYW1lID0gZWxlbS5kYXRhLm5tO1xuICAgICAgdmFyIGxvb3BJbjtcbiAgICAgIHZhciBsb29wX2luO1xuICAgICAgdmFyIGxvb3BPdXQ7XG4gICAgICB2YXIgbG9vcF9vdXQ7XG4gICAgICB2YXIgc21vb3RoO1xuICAgICAgdmFyIHRvV29ybGQ7XG4gICAgICB2YXIgZnJvbVdvcmxkO1xuICAgICAgdmFyIGZyb21Db21wO1xuICAgICAgdmFyIHRvQ29tcDtcbiAgICAgIHZhciBmcm9tQ29tcFRvU3VyZmFjZTtcbiAgICAgIHZhciBwb3NpdGlvbjtcbiAgICAgIHZhciByb3RhdGlvbjtcbiAgICAgIHZhciBhbmNob3JQb2ludDtcbiAgICAgIHZhciBzY2FsZTtcbiAgICAgIHZhciB0aGlzTGF5ZXI7XG4gICAgICB2YXIgdGhpc0NvbXA7XG4gICAgICB2YXIgbWFzaztcbiAgICAgIHZhciB2YWx1ZUF0VGltZTtcbiAgICAgIHZhciB2ZWxvY2l0eUF0VGltZTtcbiAgICAgIHZhciBzY29wZWRfYm1fcnQ7IC8vIHZhbCA9IHZhbC5yZXBsYWNlKC8oXFxcXD9cInwnKSgoaHR0cCkocyk/KDpcXC8pKT9cXC8uKj8oXFxcXD9cInwnKS9nLCBcIlxcXCJcXFwiXCIpOyAvLyBkZXRlciBwb3RlbnRpYWwgbmV0d29yayBjYWxsc1xuXG4gICAgICB2YXIgZXhwcmVzc2lvbl9mdW5jdGlvbiA9IGV2YWwoJ1tmdW5jdGlvbiBfZXhwcmVzc2lvbl9mdW5jdGlvbigpeycgKyB2YWwgKyAnO3Njb3BlZF9ibV9ydD0kYm1fcnR9XScpWzBdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcblxuICAgICAgdmFyIG51bUtleXMgPSBwcm9wZXJ0eS5rZiA/IGRhdGEuay5sZW5ndGggOiAwO1xuICAgICAgdmFyIGFjdGl2ZSA9ICF0aGlzLmRhdGEgfHwgdGhpcy5kYXRhLmhkICE9PSB0cnVlO1xuXG4gICAgICB2YXIgd2lnZ2xlID0gZnVuY3Rpb24gd2lnZ2xlKGZyZXEsIGFtcCkge1xuICAgICAgICB2YXIgaVdpZ2dsZTtcbiAgICAgICAgdmFyIGo7XG4gICAgICAgIHZhciBsZW5XaWdnbGUgPSB0aGlzLnB2Lmxlbmd0aCA/IHRoaXMucHYubGVuZ3RoIDogMTtcbiAgICAgICAgdmFyIGFkZGVkQW1wcyA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW5XaWdnbGUpO1xuICAgICAgICBmcmVxID0gNTtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBNYXRoLmZsb29yKHRpbWUgKiBmcmVxKTtcbiAgICAgICAgaVdpZ2dsZSA9IDA7XG4gICAgICAgIGogPSAwO1xuXG4gICAgICAgIHdoaWxlIChpV2lnZ2xlIDwgaXRlcmF0aW9ucykge1xuICAgICAgICAgIC8vIHZhciBybmQgPSBCTU1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbldpZ2dsZTsgaiArPSAxKSB7XG4gICAgICAgICAgICBhZGRlZEFtcHNbal0gKz0gLWFtcCArIGFtcCAqIDIgKiBCTU1hdGgucmFuZG9tKCk7IC8vIGFkZGVkQW1wc1tqXSArPSAtYW1wICsgYW1wKjIqcm5kO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlXaWdnbGUgKz0gMTtcbiAgICAgICAgfSAvLyB2YXIgcm5kMiA9IEJNTWF0aC5yYW5kb20oKTtcblxuXG4gICAgICAgIHZhciBwZXJpb2RzID0gdGltZSAqIGZyZXE7XG4gICAgICAgIHZhciBwZXJjID0gcGVyaW9kcyAtIE1hdGguZmxvb3IocGVyaW9kcyk7XG4gICAgICAgIHZhciBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuV2lnZ2xlKTtcblxuICAgICAgICBpZiAobGVuV2lnZ2xlID4gMSkge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsZW5XaWdnbGU7IGogKz0gMSkge1xuICAgICAgICAgICAgYXJyW2pdID0gdGhpcy5wdltqXSArIGFkZGVkQW1wc1tqXSArICgtYW1wICsgYW1wICogMiAqIEJNTWF0aC5yYW5kb20oKSkgKiBwZXJjOyAvLyBhcnJbal0gPSB0aGlzLnB2W2pdICsgYWRkZWRBbXBzW2pdICsgKC1hbXAgKyBhbXAqMipybmQpKnBlcmM7XG4gICAgICAgICAgICAvLyBhcnJbaV0gPSB0aGlzLnB2W2ldICsgYWRkZWRBbXAgKyBhbXAxKnBlcmMgKyBhbXAyKigxLXBlcmMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5wdiArIGFkZGVkQW1wc1swXSArICgtYW1wICsgYW1wICogMiAqIEJNTWF0aC5yYW5kb20oKSkgKiBwZXJjO1xuICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICBpZiAodGhpc1Byb3BlcnR5Lmxvb3BJbikge1xuICAgICAgICBsb29wSW4gPSB0aGlzUHJvcGVydHkubG9vcEluLmJpbmQodGhpc1Byb3BlcnR5KTtcbiAgICAgICAgbG9vcF9pbiA9IGxvb3BJbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNQcm9wZXJ0eS5sb29wT3V0KSB7XG4gICAgICAgIGxvb3BPdXQgPSB0aGlzUHJvcGVydHkubG9vcE91dC5iaW5kKHRoaXNQcm9wZXJ0eSk7XG4gICAgICAgIGxvb3Bfb3V0ID0gbG9vcE91dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNQcm9wZXJ0eS5zbW9vdGgpIHtcbiAgICAgICAgc21vb3RoID0gdGhpc1Byb3BlcnR5LnNtb290aC5iaW5kKHRoaXNQcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxvb3BJbkR1cmF0aW9uKHR5cGUsIGR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBsb29wSW4odHlwZSwgZHVyYXRpb24sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsb29wT3V0RHVyYXRpb24odHlwZSwgZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGxvb3BPdXQodHlwZSwgZHVyYXRpb24sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5nZXRWYWx1ZUF0VGltZSkge1xuICAgICAgICB2YWx1ZUF0VGltZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUuYmluZCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZ2V0VmVsb2NpdHlBdFRpbWUpIHtcbiAgICAgICAgdmVsb2NpdHlBdFRpbWUgPSB0aGlzLmdldFZlbG9jaXR5QXRUaW1lLmJpbmQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wID0gZWxlbS5jb21wLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5iaW5kKGVsZW0uY29tcC5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UpO1xuXG4gICAgICBmdW5jdGlvbiBsb29rQXQoZWxlbTEsIGVsZW0yKSB7XG4gICAgICAgIHZhciBmVmVjID0gW2VsZW0yWzBdIC0gZWxlbTFbMF0sIGVsZW0yWzFdIC0gZWxlbTFbMV0sIGVsZW0yWzJdIC0gZWxlbTFbMl1dO1xuICAgICAgICB2YXIgcGl0Y2ggPSBNYXRoLmF0YW4yKGZWZWNbMF0sIE1hdGguc3FydChmVmVjWzFdICogZlZlY1sxXSArIGZWZWNbMl0gKiBmVmVjWzJdKSkgLyBkZWdUb1JhZHM7XG4gICAgICAgIHZhciB5YXcgPSAtTWF0aC5hdGFuMihmVmVjWzFdLCBmVmVjWzJdKSAvIGRlZ1RvUmFkcztcbiAgICAgICAgcmV0dXJuIFt5YXcsIHBpdGNoLCAwXTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZWFzZU91dCh0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKSB7XG4gICAgICAgIHJldHVybiBhcHBseUVhc2UoZWFzZU91dEJleiwgdCwgdE1pbiwgdE1heCwgdmFsMSwgdmFsMik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVhc2VJbih0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKSB7XG4gICAgICAgIHJldHVybiBhcHBseUVhc2UoZWFzZUluQmV6LCB0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZWFzZSh0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKSB7XG4gICAgICAgIHJldHVybiBhcHBseUVhc2UoZWFzZUluT3V0QmV6LCB0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYXBwbHlFYXNlKGZuLCB0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKSB7XG4gICAgICAgIGlmICh2YWwxID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YWwxID0gdE1pbjtcbiAgICAgICAgICB2YWwyID0gdE1heDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ID0gKHQgLSB0TWluKSAvICh0TWF4IC0gdE1pbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodCA+IDEpIHtcbiAgICAgICAgICB0ID0gMTtcbiAgICAgICAgfSBlbHNlIGlmICh0IDwgMCkge1xuICAgICAgICAgIHQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG11bHQgPSBmbih0KTtcblxuICAgICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KHZhbDEpKSB7XG4gICAgICAgICAgdmFyIGlLZXk7XG4gICAgICAgICAgdmFyIGxlbktleSA9IHZhbDEubGVuZ3RoO1xuICAgICAgICAgIHZhciBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuS2V5KTtcblxuICAgICAgICAgIGZvciAoaUtleSA9IDA7IGlLZXkgPCBsZW5LZXk7IGlLZXkgKz0gMSkge1xuICAgICAgICAgICAgYXJyW2lLZXldID0gKHZhbDJbaUtleV0gLSB2YWwxW2lLZXldKSAqIG11bHQgKyB2YWwxW2lLZXldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHZhbDIgLSB2YWwxKSAqIG11bHQgKyB2YWwxO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBuZWFyZXN0S2V5KHRpbWUpIHtcbiAgICAgICAgdmFyIGlLZXk7XG4gICAgICAgIHZhciBsZW5LZXkgPSBkYXRhLmsubGVuZ3RoO1xuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIHZhciBrZXlUaW1lO1xuXG4gICAgICAgIGlmICghZGF0YS5rLmxlbmd0aCB8fCB0eXBlb2YgZGF0YS5rWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICBrZXlUaW1lID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgIHRpbWUgKj0gZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuXG4gICAgICAgICAgaWYgKHRpbWUgPCBkYXRhLmtbMF0udCkge1xuICAgICAgICAgICAgaW5kZXggPSAxO1xuICAgICAgICAgICAga2V5VGltZSA9IGRhdGEua1swXS50O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGlLZXkgPSAwOyBpS2V5IDwgbGVuS2V5IC0gMTsgaUtleSArPSAxKSB7XG4gICAgICAgICAgICAgIGlmICh0aW1lID09PSBkYXRhLmtbaUtleV0udCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaUtleSArIDE7XG4gICAgICAgICAgICAgICAga2V5VGltZSA9IGRhdGEua1tpS2V5XS50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRpbWUgPiBkYXRhLmtbaUtleV0udCAmJiB0aW1lIDwgZGF0YS5rW2lLZXkgKyAxXS50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgLSBkYXRhLmtbaUtleV0udCA+IGRhdGEua1tpS2V5ICsgMV0udCAtIHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgIGluZGV4ID0gaUtleSArIDI7XG4gICAgICAgICAgICAgICAgICBrZXlUaW1lID0gZGF0YS5rW2lLZXkgKyAxXS50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpbmRleCA9IGlLZXkgKyAxO1xuICAgICAgICAgICAgICAgICAga2V5VGltZSA9IGRhdGEua1tpS2V5XS50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgaW5kZXggPSBpS2V5ICsgMTtcbiAgICAgICAgICAgICAga2V5VGltZSA9IGRhdGEua1tpS2V5XS50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvYktleSA9IHt9O1xuICAgICAgICBvYktleS5pbmRleCA9IGluZGV4O1xuICAgICAgICBvYktleS50aW1lID0ga2V5VGltZSAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgICAgcmV0dXJuIG9iS2V5O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBrZXkoaW5kKSB7XG4gICAgICAgIHZhciBvYktleTtcbiAgICAgICAgdmFyIGlLZXk7XG4gICAgICAgIHZhciBsZW5LZXk7XG5cbiAgICAgICAgaWYgKCFkYXRhLmsubGVuZ3RoIHx8IHR5cGVvZiBkYXRhLmtbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvcGVydHkgaGFzIG5vIGtleWZyYW1lIGF0IGluZGV4ICcgKyBpbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kIC09IDE7XG4gICAgICAgIG9iS2V5ID0ge1xuICAgICAgICAgIHRpbWU6IGRhdGEua1tpbmRdLnQgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsXG4gICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBhcnIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YS5rW2luZF0sICdzJykgPyBkYXRhLmtbaW5kXS5zIDogZGF0YS5rW2luZCAtIDFdLmU7XG4gICAgICAgIGxlbktleSA9IGFyci5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpS2V5ID0gMDsgaUtleSA8IGxlbktleTsgaUtleSArPSAxKSB7XG4gICAgICAgICAgb2JLZXlbaUtleV0gPSBhcnJbaUtleV07XG4gICAgICAgICAgb2JLZXkudmFsdWVbaUtleV0gPSBhcnJbaUtleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JLZXk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZyYW1lc1RvVGltZShmciwgZnBzKSB7XG4gICAgICAgIGlmICghZnBzKSB7XG4gICAgICAgICAgZnBzID0gZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZyIC8gZnBzO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0aW1lVG9GcmFtZXModCwgZnBzKSB7XG4gICAgICAgIGlmICghdCAmJiB0ICE9PSAwKSB7XG4gICAgICAgICAgdCA9IHRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZwcykge1xuICAgICAgICAgIGZwcyA9IGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ICogZnBzO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZWVkUmFuZG9tKHNlZWQpIHtcbiAgICAgICAgQk1NYXRoLnNlZWRyYW5kb20ocmFuZFNlZWQgKyBzZWVkKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc291cmNlUmVjdEF0VGltZSgpIHtcbiAgICAgICAgcmV0dXJuIGVsZW0uc291cmNlUmVjdEF0VGltZSgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdWJzdHJpbmcoaW5pdCwgZW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKGluaXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcoaW5pdCwgZW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc3Vic3RyKGluaXQsIGVuZCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cihpbml0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyKGluaXQsIGVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBvc3Rlcml6ZVRpbWUoZnJhbWVzUGVyU2Vjb25kKSB7XG4gICAgICAgIHRpbWUgPSBmcmFtZXNQZXJTZWNvbmQgPT09IDAgPyAwIDogTWF0aC5mbG9vcih0aW1lICogZnJhbWVzUGVyU2Vjb25kKSAvIGZyYW1lc1BlclNlY29uZDtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWU7XG4gICAgICB2YXIgdmVsb2NpdHk7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB2YXIgdGV4dDtcbiAgICAgIHZhciB0ZXh0SW5kZXg7XG4gICAgICB2YXIgdGV4dFRvdGFsO1xuICAgICAgdmFyIHNlbGVjdG9yVmFsdWU7XG4gICAgICB2YXIgaW5kZXggPSBlbGVtLmRhdGEuaW5kO1xuICAgICAgdmFyIGhhc1BhcmVudCA9ICEhKGVsZW0uaGllcmFyY2h5ICYmIGVsZW0uaGllcmFyY2h5Lmxlbmd0aCk7XG4gICAgICB2YXIgcGFyZW50O1xuICAgICAgdmFyIHJhbmRTZWVkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMCk7XG4gICAgICB2YXIgZ2xvYmFsRGF0YSA9IGVsZW0uZ2xvYmFsRGF0YTtcblxuICAgICAgZnVuY3Rpb24gZXhlY3V0ZUV4cHJlc3Npb24oX3ZhbHVlKSB7XG4gICAgICAgIC8vIGdsb2JhbERhdGEucHVzaEV4cHJlc3Npb24oKTtcbiAgICAgICAgdmFsdWUgPSBfdmFsdWU7XG5cbiAgICAgICAgaWYgKHRoaXMuZnJhbWVFeHByZXNzaW9uSWQgPT09IGVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkICYmIHRoaXMucHJvcFR5cGUgIT09ICd0ZXh0U2VsZWN0b3InKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcFR5cGUgPT09ICd0ZXh0U2VsZWN0b3InKSB7XG4gICAgICAgICAgdGV4dEluZGV4ID0gdGhpcy50ZXh0SW5kZXg7XG4gICAgICAgICAgdGV4dFRvdGFsID0gdGhpcy50ZXh0VG90YWw7XG4gICAgICAgICAgc2VsZWN0b3JWYWx1ZSA9IHRoaXMuc2VsZWN0b3JWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpc0xheWVyKSB7XG4gICAgICAgICAgdGV4dCA9IGVsZW0ubGF5ZXJJbnRlcmZhY2UudGV4dDtcbiAgICAgICAgICB0aGlzTGF5ZXIgPSBlbGVtLmxheWVySW50ZXJmYWNlO1xuICAgICAgICAgIHRoaXNDb21wID0gZWxlbS5jb21wLmNvbXBJbnRlcmZhY2U7XG4gICAgICAgICAgdG9Xb3JsZCA9IHRoaXNMYXllci50b1dvcmxkLmJpbmQodGhpc0xheWVyKTtcbiAgICAgICAgICBmcm9tV29ybGQgPSB0aGlzTGF5ZXIuZnJvbVdvcmxkLmJpbmQodGhpc0xheWVyKTtcbiAgICAgICAgICBmcm9tQ29tcCA9IHRoaXNMYXllci5mcm9tQ29tcC5iaW5kKHRoaXNMYXllcik7XG4gICAgICAgICAgdG9Db21wID0gdGhpc0xheWVyLnRvQ29tcC5iaW5kKHRoaXNMYXllcik7XG4gICAgICAgICAgbWFzayA9IHRoaXNMYXllci5tYXNrID8gdGhpc0xheWVyLm1hc2suYmluZCh0aGlzTGF5ZXIpIDogbnVsbDtcbiAgICAgICAgICBmcm9tQ29tcFRvU3VyZmFjZSA9IGZyb21Db21wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgICB0cmFuc2Zvcm0gPSBlbGVtLmxheWVySW50ZXJmYWNlKCdBREJFIFRyYW5zZm9ybSBHcm91cCcpO1xuICAgICAgICAgICRibV90cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cbiAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBhbmNob3JQb2ludCA9IHRyYW5zZm9ybS5hbmNob3JQb2ludDtcbiAgICAgICAgICAgIC8qIHBvc2l0aW9uID0gdHJhbnNmb3JtLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgcm90YXRpb24gPSB0cmFuc2Zvcm0ucm90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IHRyYW5zZm9ybS5zY2FsZTsgKi9cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbVR5cGUgPT09IDQgJiYgIWNvbnRlbnQpIHtcbiAgICAgICAgICBjb250ZW50ID0gdGhpc0xheWVyKCdBREJFIFJvb3QgVmVjdG9ycyBHcm91cCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlZmZlY3QpIHtcbiAgICAgICAgICBlZmZlY3QgPSB0aGlzTGF5ZXIoNCk7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNQYXJlbnQgPSAhIShlbGVtLmhpZXJhcmNoeSAmJiBlbGVtLmhpZXJhcmNoeS5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChoYXNQYXJlbnQgJiYgIXBhcmVudCkge1xuICAgICAgICAgIHBhcmVudCA9IGVsZW0uaGllcmFyY2h5WzBdLmxheWVySW50ZXJmYWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGltZSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuXG4gICAgICAgIGlmIChfbmVlZHNSYW5kb20pIHtcbiAgICAgICAgICBzZWVkUmFuZG9tKHJhbmRTZWVkICsgdGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmVlZHNWZWxvY2l0eSkge1xuICAgICAgICAgIHZlbG9jaXR5ID0gdmVsb2NpdHlBdFRpbWUodGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBleHByZXNzaW9uX2Z1bmN0aW9uKCk7XG4gICAgICAgIHRoaXMuZnJhbWVFeHByZXNzaW9uSWQgPSBlbGVtLmdsb2JhbERhdGEuZnJhbWVJZDsgLy8gVE9ETzogQ2hlY2sgaWYgaXQncyBwb3NzaWJsZSB0byByZXR1cm4gb24gU2hhcGVJbnRlcmZhY2UgdGhlIC52IHZhbHVlXG4gICAgICAgIC8vIENoYW5nZWQgdGhpcyB0byBhIHRlcm5hcnkgb3BlcmF0aW9uIGJlY2F1c2UgUm9sbHVwIGZhaWxlZCBjb21waWxpbmcgaXQgY29ycmVjdGx5XG5cbiAgICAgICAgc2NvcGVkX2JtX3J0ID0gc2NvcGVkX2JtX3J0LnByb3BUeXBlID09PSBwcm9wVHlwZXMuU0hBUEUgPyBzY29wZWRfYm1fcnQudiA6IHNjb3BlZF9ibV9ydDtcbiAgICAgICAgcmV0dXJuIHNjb3BlZF9ibV9ydDtcbiAgICAgIH0gLy8gQnVuZGxlcnMgd2lsbCBzZWUgdGhlc2UgYXMgZGVhZCBjb2RlIGFuZCB1bmxlc3Mgd2UgcmVmZXJlbmNlIHRoZW1cblxuXG4gICAgICBleGVjdXRlRXhwcmVzc2lvbi5fX3ByZXZlbnREZWFkQ29kZVJlbW92YWwgPSBbJGJtX3RyYW5zZm9ybSwgYW5jaG9yUG9pbnQsIHRpbWUsIHZlbG9jaXR5LCBpblBvaW50LCBvdXRQb2ludCwgd2lkdGgsIGhlaWdodCwgbmFtZSwgbG9vcF9pbiwgbG9vcF9vdXQsIHNtb290aCwgdG9Db21wLCBmcm9tQ29tcFRvU3VyZmFjZSwgdG9Xb3JsZCwgZnJvbVdvcmxkLCBtYXNrLCBwb3NpdGlvbiwgcm90YXRpb24sIHNjYWxlLCB0aGlzQ29tcCwgbnVtS2V5cywgYWN0aXZlLCB3aWdnbGUsIGxvb3BJbkR1cmF0aW9uLCBsb29wT3V0RHVyYXRpb24sIGNvbXAsIGxvb2tBdCwgZWFzZU91dCwgZWFzZUluLCBlYXNlLCBuZWFyZXN0S2V5LCBrZXksIHRleHQsIHRleHRJbmRleCwgdGV4dFRvdGFsLCBzZWxlY3RvclZhbHVlLCBmcmFtZXNUb1RpbWUsIHRpbWVUb0ZyYW1lcywgc291cmNlUmVjdEF0VGltZSwgc3Vic3RyaW5nLCBzdWJzdHIsIHBvc3Rlcml6ZVRpbWUsIGluZGV4LCBnbG9iYWxEYXRhXTtcbiAgICAgIHJldHVybiBleGVjdXRlRXhwcmVzc2lvbjtcbiAgICB9XG5cbiAgICBvYi5pbml0aWF0ZUV4cHJlc3Npb24gPSBpbml0aWF0ZUV4cHJlc3Npb247XG4gICAgb2IuX19wcmV2ZW50RGVhZENvZGVSZW1vdmFsID0gW3dpbmRvdywgZG9jdW1lbnQsIFhNTEh0dHBSZXF1ZXN0LCBmZXRjaCwgZnJhbWVzLCAkYm1fbmVnLCBhZGQsICRibV9zdW0sICRibV9zdWIsICRibV9tdWwsICRibV9kaXYsICRibV9tb2QsIGNsYW1wLCByYWRpYW5zX3RvX2RlZ3JlZXMsIGRlZ3JlZXNUb1JhZGlhbnMsIGRlZ3JlZXNfdG9fcmFkaWFucywgbm9ybWFsaXplLCByZ2JUb0hzbCwgaHNsVG9SZ2IsIGxpbmVhciwgcmFuZG9tLCBjcmVhdGVQYXRoLCBfbG90dGllR2xvYmFsXTtcbiAgICBvYi5yZXNldEZyYW1lID0gcmVzZXRGcmFtZTtcbiAgICByZXR1cm4gb2I7XG4gIH0oKTtcblxuICB2YXIgRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iID0ge307XG4gICAgb2IuaW5pdEV4cHJlc3Npb25zID0gaW5pdEV4cHJlc3Npb25zO1xuICAgIG9iLnJlc2V0RnJhbWUgPSBFeHByZXNzaW9uTWFuYWdlci5yZXNldEZyYW1lO1xuXG4gICAgZnVuY3Rpb24gaW5pdEV4cHJlc3Npb25zKGFuaW1hdGlvbikge1xuICAgICAgdmFyIHN0YWNrQ291bnQgPSAwO1xuICAgICAgdmFyIHJlZ2lzdGVycyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiBwdXNoRXhwcmVzc2lvbigpIHtcbiAgICAgICAgc3RhY2tDb3VudCArPSAxO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwb3BFeHByZXNzaW9uKCkge1xuICAgICAgICBzdGFja0NvdW50IC09IDE7XG5cbiAgICAgICAgaWYgKHN0YWNrQ291bnQgPT09IDApIHtcbiAgICAgICAgICByZWxlYXNlSW5zdGFuY2VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVnaXN0ZXJFeHByZXNzaW9uUHJvcGVydHkoZXhwcmVzc2lvbikge1xuICAgICAgICBpZiAocmVnaXN0ZXJzLmluZGV4T2YoZXhwcmVzc2lvbikgPT09IC0xKSB7XG4gICAgICAgICAgcmVnaXN0ZXJzLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVsZWFzZUluc3RhbmNlcygpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSByZWdpc3RlcnMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHJlZ2lzdGVyc1tpXS5yZWxlYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlcnMubGVuZ3RoID0gMDtcbiAgICAgIH1cblxuICAgICAgYW5pbWF0aW9uLnJlbmRlcmVyLmNvbXBJbnRlcmZhY2UgPSBDb21wRXhwcmVzc2lvbkludGVyZmFjZShhbmltYXRpb24ucmVuZGVyZXIpO1xuICAgICAgYW5pbWF0aW9uLnJlbmRlcmVyLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5yZWdpc3RlckNvbXBvc2l0aW9uKGFuaW1hdGlvbi5yZW5kZXJlcik7XG4gICAgICBhbmltYXRpb24ucmVuZGVyZXIuZ2xvYmFsRGF0YS5wdXNoRXhwcmVzc2lvbiA9IHB1c2hFeHByZXNzaW9uO1xuICAgICAgYW5pbWF0aW9uLnJlbmRlcmVyLmdsb2JhbERhdGEucG9wRXhwcmVzc2lvbiA9IHBvcEV4cHJlc3Npb247XG4gICAgICBhbmltYXRpb24ucmVuZGVyZXIuZ2xvYmFsRGF0YS5yZWdpc3RlckV4cHJlc3Npb25Qcm9wZXJ0eSA9IHJlZ2lzdGVyRXhwcmVzc2lvblByb3BlcnR5O1xuICAgIH1cblxuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIHZhciBNYXNrTWFuYWdlckludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXNrSW50ZXJmYWNlKG1hc2ssIGRhdGEpIHtcbiAgICAgIHRoaXMuX21hc2sgPSBtYXNrO1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hc2tJbnRlcmZhY2UucHJvdG90eXBlLCAnbWFza1BhdGgnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hc2sucHJvcC5rKSB7XG4gICAgICAgICAgdGhpcy5fbWFzay5wcm9wLmdldFZhbHVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fbWFzay5wcm9wO1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXNrSW50ZXJmYWNlLnByb3RvdHlwZSwgJ21hc2tPcGFjaXR5Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXNrLm9wLmspIHtcbiAgICAgICAgICB0aGlzLl9tYXNrLm9wLmdldFZhbHVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fbWFzay5vcC52ICogMTAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIE1hc2tNYW5hZ2VyID0gZnVuY3Rpb24gTWFza01hbmFnZXIobWFza01hbmFnZXIpIHtcbiAgICAgIHZhciBfbWFza3NJbnRlcmZhY2VzID0gY3JlYXRlU2l6ZWRBcnJheShtYXNrTWFuYWdlci52aWV3RGF0YS5sZW5ndGgpO1xuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBtYXNrTWFuYWdlci52aWV3RGF0YS5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBfbWFza3NJbnRlcmZhY2VzW2ldID0gbmV3IE1hc2tJbnRlcmZhY2UobWFza01hbmFnZXIudmlld0RhdGFbaV0sIG1hc2tNYW5hZ2VyLm1hc2tzUHJvcGVydGllc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXNrRnVuY3Rpb24gPSBmdW5jdGlvbiBtYXNrRnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpID0gMDtcblxuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgIGlmIChtYXNrTWFuYWdlci5tYXNrc1Byb3BlcnRpZXNbaV0ubm0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfbWFza3NJbnRlcmZhY2VzW2ldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG1hc2tGdW5jdGlvbjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hc2tNYW5hZ2VyO1xuICB9KCk7XG5cbiAgdmFyIEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGVmYXVsdFVuaWRpbWVuc2lvbmFsVmFsdWUgPSB7XG4gICAgICBwdjogMCxcbiAgICAgIHY6IDAsXG4gICAgICBtdWx0OiAxXG4gICAgfTtcbiAgICB2YXIgZGVmYXVsdE11bHRpZGltZW5zaW9uYWxWYWx1ZSA9IHtcbiAgICAgIHB2OiBbMCwgMCwgMF0sXG4gICAgICB2OiBbMCwgMCwgMF0sXG4gICAgICBtdWx0OiAxXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlUHJvcGVydHkoZXhwcmVzc2lvblZhbHVlLCBwcm9wZXJ0eSwgdHlwZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cHJlc3Npb25WYWx1ZSwgJ3ZlbG9jaXR5Jywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcGVydHkuZ2V0VmVsb2NpdHlBdFRpbWUocHJvcGVydHkuY29tcC5jdXJyZW50RnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGV4cHJlc3Npb25WYWx1ZS5udW1LZXlzID0gcHJvcGVydHkua2V5ZnJhbWVzID8gcHJvcGVydHkua2V5ZnJhbWVzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGV4cHJlc3Npb25WYWx1ZS5rZXkgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIGlmICghZXhwcmVzc2lvblZhbHVlLm51bUtleXMpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9ICcnO1xuXG4gICAgICAgIGlmICgncycgaW4gcHJvcGVydHkua2V5ZnJhbWVzW3BvcyAtIDFdKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wZXJ0eS5rZXlmcmFtZXNbcG9zIC0gMV0ucztcbiAgICAgICAgfSBlbHNlIGlmICgnZScgaW4gcHJvcGVydHkua2V5ZnJhbWVzW3BvcyAtIDJdKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wZXJ0eS5rZXlmcmFtZXNbcG9zIC0gMl0uZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BlcnR5LmtleWZyYW1lc1twb3MgLSAyXS5zO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlUHJvcCA9IHR5cGUgPT09ICd1bmlkaW1lbnNpb25hbCcgPyBuZXcgTnVtYmVyKHZhbHVlKSA6IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblxuICAgICAgICB2YWx1ZVByb3AudGltZSA9IHByb3BlcnR5LmtleWZyYW1lc1twb3MgLSAxXS50IC8gcHJvcGVydHkuZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgICB2YWx1ZVByb3AudmFsdWUgPSB0eXBlID09PSAndW5pZGltZW5zaW9uYWwnID8gdmFsdWVbMF0gOiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlUHJvcDtcbiAgICAgIH07XG5cbiAgICAgIGV4cHJlc3Npb25WYWx1ZS52YWx1ZUF0VGltZSA9IHByb3BlcnR5LmdldFZhbHVlQXRUaW1lO1xuICAgICAgZXhwcmVzc2lvblZhbHVlLnNwZWVkQXRUaW1lID0gcHJvcGVydHkuZ2V0U3BlZWRBdFRpbWU7XG4gICAgICBleHByZXNzaW9uVmFsdWUudmVsb2NpdHlBdFRpbWUgPSBwcm9wZXJ0eS5nZXRWZWxvY2l0eUF0VGltZTtcbiAgICAgIGV4cHJlc3Npb25WYWx1ZS5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHkucHJvcGVydHlHcm91cDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBVbmlkaW1lbnNpb25hbFByb3BlcnR5SW50ZXJmYWNlKHByb3BlcnR5KSB7XG4gICAgICBpZiAoIXByb3BlcnR5IHx8ICEoJ3B2JyBpbiBwcm9wZXJ0eSkpIHtcbiAgICAgICAgcHJvcGVydHkgPSBkZWZhdWx0VW5pZGltZW5zaW9uYWxWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG11bHQgPSAxIC8gcHJvcGVydHkubXVsdDtcbiAgICAgIHZhciB2YWwgPSBwcm9wZXJ0eS5wdiAqIG11bHQ7XG4gICAgICB2YXIgZXhwcmVzc2lvblZhbHVlID0gbmV3IE51bWJlcih2YWwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXG4gICAgICBleHByZXNzaW9uVmFsdWUudmFsdWUgPSB2YWw7XG4gICAgICBjb21wbGV0ZVByb3BlcnR5KGV4cHJlc3Npb25WYWx1ZSwgcHJvcGVydHksICd1bmlkaW1lbnNpb25hbCcpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5LmspIHtcbiAgICAgICAgICBwcm9wZXJ0eS5nZXRWYWx1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsID0gcHJvcGVydHkudiAqIG11bHQ7XG5cbiAgICAgICAgaWYgKGV4cHJlc3Npb25WYWx1ZS52YWx1ZSAhPT0gdmFsKSB7XG4gICAgICAgICAgZXhwcmVzc2lvblZhbHVlID0gbmV3IE51bWJlcih2YWwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXG4gICAgICAgICAgZXhwcmVzc2lvblZhbHVlLnZhbHVlID0gdmFsO1xuICAgICAgICAgIGNvbXBsZXRlUHJvcGVydHkoZXhwcmVzc2lvblZhbHVlLCBwcm9wZXJ0eSwgJ3VuaWRpbWVuc2lvbmFsJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvblZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBNdWx0aWRpbWVuc2lvbmFsUHJvcGVydHlJbnRlcmZhY2UocHJvcGVydHkpIHtcbiAgICAgIGlmICghcHJvcGVydHkgfHwgISgncHYnIGluIHByb3BlcnR5KSkge1xuICAgICAgICBwcm9wZXJ0eSA9IGRlZmF1bHRNdWx0aWRpbWVuc2lvbmFsVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBtdWx0ID0gMSAvIHByb3BlcnR5Lm11bHQ7XG4gICAgICB2YXIgbGVuID0gcHJvcGVydHkuZGF0YSAmJiBwcm9wZXJ0eS5kYXRhLmwgfHwgcHJvcGVydHkucHYubGVuZ3RoO1xuICAgICAgdmFyIGV4cHJlc3Npb25WYWx1ZSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuICAgICAgdmFyIGFyclZhbHVlID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG4gICAgICBleHByZXNzaW9uVmFsdWUudmFsdWUgPSBhcnJWYWx1ZTtcbiAgICAgIGNvbXBsZXRlUHJvcGVydHkoZXhwcmVzc2lvblZhbHVlLCBwcm9wZXJ0eSwgJ211bHRpZGltZW5zaW9uYWwnKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eS5rKSB7XG4gICAgICAgICAgcHJvcGVydHkuZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBhcnJWYWx1ZVtpXSA9IHByb3BlcnR5LnZbaV0gKiBtdWx0O1xuICAgICAgICAgIGV4cHJlc3Npb25WYWx1ZVtpXSA9IGFyclZhbHVlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25WYWx1ZTtcbiAgICAgIH07XG4gICAgfSAvLyBUT0RPOiB0cnkgdG8gYXZvaWQgdXNpbmcgdGhpcyBnZXR0ZXJcblxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdEdldHRlcigpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VW5pZGltZW5zaW9uYWxWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICBpZiAoIXByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0R2V0dGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcGVydHkucHJvcFR5cGUgPT09ICd1bmlkaW1lbnNpb25hbCcpIHtcbiAgICAgICAgcmV0dXJuIFVuaWRpbWVuc2lvbmFsUHJvcGVydHlJbnRlcmZhY2UocHJvcGVydHkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTXVsdGlkaW1lbnNpb25hbFByb3BlcnR5SW50ZXJmYWNlKHByb3BlcnR5KTtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIFRyYW5zZm9ybUV4cHJlc3Npb25JbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICAgIGZ1bmN0aW9uIF90aGlzRnVuY3Rpb24obmFtZSkge1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICBjYXNlICdzY2FsZSc6XG4gICAgICAgICAgY2FzZSAnU2NhbGUnOlxuICAgICAgICAgIGNhc2UgJ0FEQkUgU2NhbGUnOlxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLnNjYWxlO1xuXG4gICAgICAgICAgY2FzZSAncm90YXRpb24nOlxuICAgICAgICAgIGNhc2UgJ1JvdGF0aW9uJzpcbiAgICAgICAgICBjYXNlICdBREJFIFJvdGF0aW9uJzpcbiAgICAgICAgICBjYXNlICdBREJFIFJvdGF0ZSBaJzpcbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24ucm90YXRpb247XG5cbiAgICAgICAgICBjYXNlICdBREJFIFJvdGF0ZSBYJzpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLnhSb3RhdGlvbjtcblxuICAgICAgICAgIGNhc2UgJ0FEQkUgUm90YXRlIFknOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24ueVJvdGF0aW9uO1xuXG4gICAgICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICAgIGNhc2UgJ1Bvc2l0aW9uJzpcbiAgICAgICAgICBjYXNlICdBREJFIFBvc2l0aW9uJzpcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi5wb3NpdGlvbjtcblxuICAgICAgICAgIGNhc2UgJ0FEQkUgUG9zaXRpb25fMCc6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi54UG9zaXRpb247XG5cbiAgICAgICAgICBjYXNlICdBREJFIFBvc2l0aW9uXzEnOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24ueVBvc2l0aW9uO1xuXG4gICAgICAgICAgY2FzZSAnQURCRSBQb3NpdGlvbl8yJzpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLnpQb3NpdGlvbjtcblxuICAgICAgICAgIGNhc2UgJ2FuY2hvclBvaW50JzpcbiAgICAgICAgICBjYXNlICdBbmNob3JQb2ludCc6XG4gICAgICAgICAgY2FzZSAnQW5jaG9yIFBvaW50JzpcbiAgICAgICAgICBjYXNlICdBREJFIEFuY2hvclBvaW50JzpcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi5hbmNob3JQb2ludDtcblxuICAgICAgICAgIGNhc2UgJ29wYWNpdHknOlxuICAgICAgICAgIGNhc2UgJ09wYWNpdHknOlxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi5vcGFjaXR5O1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAncm90YXRpb24nLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5yIHx8IHRyYW5zZm9ybS5yeilcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICd6Um90YXRpb24nLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5yeiB8fCB0cmFuc2Zvcm0ucilcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICd4Um90YXRpb24nLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5yeClcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICd5Um90YXRpb24nLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5yeSlcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICdzY2FsZScsIHtcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnMpXG4gICAgICB9KTtcblxuICAgICAgdmFyIF9weDtcblxuICAgICAgdmFyIF9weTtcblxuICAgICAgdmFyIF9wejtcblxuICAgICAgdmFyIF90cmFuc2Zvcm1GYWN0b3J5O1xuXG4gICAgICBpZiAodHJhbnNmb3JtLnApIHtcbiAgICAgICAgX3RyYW5zZm9ybUZhY3RvcnkgPSBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3B4ID0gRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5weCk7XG4gICAgICAgIF9weSA9IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHkpO1xuXG4gICAgICAgIGlmICh0cmFuc2Zvcm0ucHopIHtcbiAgICAgICAgICBfcHogPSBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnB6KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3Bvc2l0aW9uJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICBpZiAodHJhbnNmb3JtLnApIHtcbiAgICAgICAgICAgIHJldHVybiBfdHJhbnNmb3JtRmFjdG9yeSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbX3B4KCksIF9weSgpLCBfcHogPyBfcHooKSA6IDBdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAneFBvc2l0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHgpXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAneVBvc2l0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHkpXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAnelBvc2l0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHopXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAnYW5jaG9yUG9pbnQnLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5hKVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ29wYWNpdHknLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5vKVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3NrZXcnLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5zaylcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICdza2V3QXhpcycsIHtcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnNhKVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ29yaWVudGF0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ub3IpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgTGF5ZXJFeHByZXNzaW9uSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGdldE1hdHJpeCh0aW1lKSB7XG4gICAgICB2YXIgdG9Xb3JsZE1hdCA9IG5ldyBNYXRyaXgoKTtcblxuICAgICAgaWYgKHRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgcHJvcE1hdHJpeCA9IHRoaXMuX2VsZW0uZmluYWxUcmFuc2Zvcm0ubVByb3AuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG5cbiAgICAgICAgcHJvcE1hdHJpeC5jbG9uZSh0b1dvcmxkTWF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1NYXQgPSB0aGlzLl9lbGVtLmZpbmFsVHJhbnNmb3JtLm1Qcm9wO1xuICAgICAgICB0cmFuc2Zvcm1NYXQuYXBwbHlUb01hdHJpeCh0b1dvcmxkTWF0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvV29ybGRNYXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Xb3JsZFZlYyhhcnIsIHRpbWUpIHtcbiAgICAgIHZhciB0b1dvcmxkTWF0ID0gdGhpcy5nZXRNYXRyaXgodGltZSk7XG4gICAgICB0b1dvcmxkTWF0LnByb3BzWzEyXSA9IDA7XG4gICAgICB0b1dvcmxkTWF0LnByb3BzWzEzXSA9IDA7XG4gICAgICB0b1dvcmxkTWF0LnByb3BzWzE0XSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseVBvaW50KHRvV29ybGRNYXQsIGFycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Xb3JsZChhcnIsIHRpbWUpIHtcbiAgICAgIHZhciB0b1dvcmxkTWF0ID0gdGhpcy5nZXRNYXRyaXgodGltZSk7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseVBvaW50KHRvV29ybGRNYXQsIGFycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbVdvcmxkVmVjKGFyciwgdGltZSkge1xuICAgICAgdmFyIHRvV29ybGRNYXQgPSB0aGlzLmdldE1hdHJpeCh0aW1lKTtcbiAgICAgIHRvV29ybGRNYXQucHJvcHNbMTJdID0gMDtcbiAgICAgIHRvV29ybGRNYXQucHJvcHNbMTNdID0gMDtcbiAgICAgIHRvV29ybGRNYXQucHJvcHNbMTRdID0gMDtcbiAgICAgIHJldHVybiB0aGlzLmludmVydFBvaW50KHRvV29ybGRNYXQsIGFycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbVdvcmxkKGFyciwgdGltZSkge1xuICAgICAgdmFyIHRvV29ybGRNYXQgPSB0aGlzLmdldE1hdHJpeCh0aW1lKTtcbiAgICAgIHJldHVybiB0aGlzLmludmVydFBvaW50KHRvV29ybGRNYXQsIGFycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlQb2ludChtYXRyaXgsIGFycikge1xuICAgICAgaWYgKHRoaXMuX2VsZW0uaGllcmFyY2h5ICYmIHRoaXMuX2VsZW0uaGllcmFyY2h5Lmxlbmd0aCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuX2VsZW0uaGllcmFyY2h5Lmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICB0aGlzLl9lbGVtLmhpZXJhcmNoeVtpXS5maW5hbFRyYW5zZm9ybS5tUHJvcC5hcHBseVRvTWF0cml4KG1hdHJpeCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdHJpeC5hcHBseVRvUG9pbnRBcnJheShhcnJbMF0sIGFyclsxXSwgYXJyWzJdIHx8IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmVydFBvaW50KG1hdHJpeCwgYXJyKSB7XG4gICAgICBpZiAodGhpcy5fZWxlbS5oaWVyYXJjaHkgJiYgdGhpcy5fZWxlbS5oaWVyYXJjaHkubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5fZWxlbS5oaWVyYXJjaHkubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHRoaXMuX2VsZW0uaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLmFwcGx5VG9NYXRyaXgobWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0cml4LmludmVyc2VQb2ludChhcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb21Db21wKGFycikge1xuICAgICAgdmFyIHRvV29ybGRNYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgICB0b1dvcmxkTWF0LnJlc2V0KCk7XG5cbiAgICAgIHRoaXMuX2VsZW0uZmluYWxUcmFuc2Zvcm0ubVByb3AuYXBwbHlUb01hdHJpeCh0b1dvcmxkTWF0KTtcblxuICAgICAgaWYgKHRoaXMuX2VsZW0uaGllcmFyY2h5ICYmIHRoaXMuX2VsZW0uaGllcmFyY2h5Lmxlbmd0aCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuX2VsZW0uaGllcmFyY2h5Lmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICB0aGlzLl9lbGVtLmhpZXJhcmNoeVtpXS5maW5hbFRyYW5zZm9ybS5tUHJvcC5hcHBseVRvTWF0cml4KHRvV29ybGRNYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvV29ybGRNYXQuaW52ZXJzZVBvaW50KGFycik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b1dvcmxkTWF0LmludmVyc2VQb2ludChhcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNhbXBsZUltYWdlKCkge1xuICAgICAgcmV0dXJuIFsxLCAxLCAxLCAxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1JbnRlcmZhY2U7XG5cbiAgICAgIGZ1bmN0aW9uIF9yZWdpc3Rlck1hc2tJbnRlcmZhY2UobWFza01hbmFnZXIpIHtcbiAgICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLm1hc2sgPSBuZXcgTWFza01hbmFnZXJJbnRlcmZhY2UobWFza01hbmFnZXIsIGVsZW0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfcmVnaXN0ZXJFZmZlY3RzSW50ZXJmYWNlKGVmZmVjdHMpIHtcbiAgICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmVmZmVjdCA9IGVmZmVjdHM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aGlzTGF5ZXJGdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgIGNhc2UgJ0FEQkUgUm9vdCBWZWN0b3JzIEdyb3VwJzpcbiAgICAgICAgICBjYXNlICdDb250ZW50cyc6XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbi5zaGFwZUludGVyZmFjZTtcblxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgY2FzZSAnVHJhbnNmb3JtJzpcbiAgICAgICAgICBjYXNlICd0cmFuc2Zvcm0nOlxuICAgICAgICAgIGNhc2UgJ0FEQkUgVHJhbnNmb3JtIEdyb3VwJzpcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1JbnRlcmZhY2U7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSAnQURCRSBFZmZlY3QgUGFyYWRlJzpcbiAgICAgICAgICBjYXNlICdlZmZlY3RzJzpcbiAgICAgICAgICBjYXNlICdFZmZlY3RzJzpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb24uZWZmZWN0O1xuXG4gICAgICAgICAgY2FzZSAnQURCRSBUZXh0IFByb3BlcnRpZXMnOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbi50ZXh0SW50ZXJmYWNlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5nZXRNYXRyaXggPSBnZXRNYXRyaXg7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uaW52ZXJ0UG9pbnQgPSBpbnZlcnRQb2ludDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5hcHBseVBvaW50ID0gYXBwbHlQb2ludDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi50b1dvcmxkID0gdG9Xb3JsZDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi50b1dvcmxkVmVjID0gdG9Xb3JsZFZlYztcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5mcm9tV29ybGQgPSBmcm9tV29ybGQ7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uZnJvbVdvcmxkVmVjID0gZnJvbVdvcmxkVmVjO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnRvQ29tcCA9IHRvV29ybGQ7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uZnJvbUNvbXAgPSBmcm9tQ29tcDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5zYW1wbGVJbWFnZSA9IHNhbXBsZUltYWdlO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnNvdXJjZVJlY3RBdFRpbWUgPSBlbGVtLnNvdXJjZVJlY3RBdFRpbWUuYmluZChlbGVtKTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5fZWxlbSA9IGVsZW07XG4gICAgICB0cmFuc2Zvcm1JbnRlcmZhY2UgPSBUcmFuc2Zvcm1FeHByZXNzaW9uSW50ZXJmYWNlKGVsZW0uZmluYWxUcmFuc2Zvcm0ubVByb3ApO1xuICAgICAgdmFyIGFuY2hvclBvaW50RGVzY3JpcHRvciA9IGdldERlc2NyaXB0b3IodHJhbnNmb3JtSW50ZXJmYWNlLCAnYW5jaG9yUG9pbnQnKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzTGF5ZXJGdW5jdGlvbiwge1xuICAgICAgICBoYXNQYXJlbnQ6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmhpZXJhcmNoeS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmhpZXJhcmNoeVswXS5sYXllckludGVyZmFjZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJvdGF0aW9uOiBnZXREZXNjcmlwdG9yKHRyYW5zZm9ybUludGVyZmFjZSwgJ3JvdGF0aW9uJyksXG4gICAgICAgIHNjYWxlOiBnZXREZXNjcmlwdG9yKHRyYW5zZm9ybUludGVyZmFjZSwgJ3NjYWxlJyksXG4gICAgICAgIHBvc2l0aW9uOiBnZXREZXNjcmlwdG9yKHRyYW5zZm9ybUludGVyZmFjZSwgJ3Bvc2l0aW9uJyksXG4gICAgICAgIG9wYWNpdHk6IGdldERlc2NyaXB0b3IodHJhbnNmb3JtSW50ZXJmYWNlLCAnb3BhY2l0eScpLFxuICAgICAgICBhbmNob3JQb2ludDogYW5jaG9yUG9pbnREZXNjcmlwdG9yLFxuICAgICAgICBhbmNob3JfcG9pbnQ6IGFuY2hvclBvaW50RGVzY3JpcHRvcixcbiAgICAgICAgdHJhbnNmb3JtOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtSW50ZXJmYWNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWN0aXZlOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5pc0luUmFuZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5zdGFydFRpbWUgPSBlbGVtLmRhdGEuc3Q7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uaW5kZXggPSBlbGVtLmRhdGEuaW5kO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnNvdXJjZSA9IGVsZW0uZGF0YS5yZWZJZDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5oZWlnaHQgPSBlbGVtLmRhdGEudHkgPT09IDAgPyBlbGVtLmRhdGEuaCA6IDEwMDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi53aWR0aCA9IGVsZW0uZGF0YS50eSA9PT0gMCA/IGVsZW0uZGF0YS53IDogMTAwO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmluUG9pbnQgPSBlbGVtLmRhdGEuaXAgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24ub3V0UG9pbnQgPSBlbGVtLmRhdGEub3AgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uX25hbWUgPSBlbGVtLmRhdGEubm07XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24ucmVnaXN0ZXJNYXNrSW50ZXJmYWNlID0gX3JlZ2lzdGVyTWFza0ludGVyZmFjZTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5yZWdpc3RlckVmZmVjdHNJbnRlcmZhY2UgPSBfcmVnaXN0ZXJFZmZlY3RzSW50ZXJmYWNlO1xuICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbjtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIHByb3BlcnR5R3JvdXBGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW50ZXJmYWNlRnVuY3Rpb24sIHBhcmVudFByb3BlcnR5R3JvdXApIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhbCA9IHZhbCA9PT0gdW5kZWZpbmVkID8gMSA6IHZhbDtcblxuICAgICAgICBpZiAodmFsIDw9IDApIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50UHJvcGVydHlHcm91cCh2YWwgLSAxKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBQcm9wZXJ0eUludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSwgcHJvcGVydHlHcm91cCkge1xuICAgICAgdmFyIGludGVyZmFjZUZ1bmN0aW9uID0ge1xuICAgICAgICBfbmFtZTogcHJvcGVydHlOYW1lXG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBfcHJvcGVydHlHcm91cCh2YWwpIHtcbiAgICAgICAgdmFsID0gdmFsID09PSB1bmRlZmluZWQgPyAxIDogdmFsO1xuXG4gICAgICAgIGlmICh2YWwgPD0gMCkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUdyb3VwKHZhbCAtIDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3Byb3BlcnR5R3JvdXA7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBFZmZlY3RzRXhwcmVzc2lvbkludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2IgPSB7XG4gICAgICBjcmVhdGVFZmZlY3RzSW50ZXJmYWNlOiBjcmVhdGVFZmZlY3RzSW50ZXJmYWNlXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVmZmVjdHNJbnRlcmZhY2UoZWxlbSwgcHJvcGVydHlHcm91cCkge1xuICAgICAgaWYgKGVsZW0uZWZmZWN0c01hbmFnZXIpIHtcbiAgICAgICAgdmFyIGVmZmVjdEVsZW1lbnRzID0gW107XG4gICAgICAgIHZhciBlZmZlY3RzRGF0YSA9IGVsZW0uZGF0YS5lZjtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSBlbGVtLmVmZmVjdHNNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBlZmZlY3RFbGVtZW50cy5wdXNoKGNyZWF0ZUdyb3VwSW50ZXJmYWNlKGVmZmVjdHNEYXRhW2ldLCBlbGVtLmVmZmVjdHNNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzW2ldLCBwcm9wZXJ0eUdyb3VwLCBlbGVtKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWZmZWN0cyA9IGVsZW0uZGF0YS5lZiB8fCBbXTtcblxuICAgICAgICB2YXIgZ3JvdXBJbnRlcmZhY2UgPSBmdW5jdGlvbiBncm91cEludGVyZmFjZShuYW1lKSB7XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgbGVuID0gZWZmZWN0cy5sZW5ndGg7XG5cbiAgICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IGVmZmVjdHNbaV0ubm0gfHwgbmFtZSA9PT0gZWZmZWN0c1tpXS5tbiB8fCBuYW1lID09PSBlZmZlY3RzW2ldLml4KSB7XG4gICAgICAgICAgICAgIHJldHVybiBlZmZlY3RFbGVtZW50c1tpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShncm91cEludGVyZmFjZSwgJ251bVByb3BlcnRpZXMnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZWZmZWN0cy5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdyb3VwSW50ZXJmYWNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVHcm91cEludGVyZmFjZShkYXRhLCBlbGVtZW50cywgcHJvcGVydHlHcm91cCwgZWxlbSkge1xuICAgICAgZnVuY3Rpb24gZ3JvdXBJbnRlcmZhY2UobmFtZSkge1xuICAgICAgICB2YXIgZWZmZWN0cyA9IGRhdGEuZWY7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IGVmZmVjdHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09IGVmZmVjdHNbaV0ubm0gfHwgbmFtZSA9PT0gZWZmZWN0c1tpXS5tbiB8fCBuYW1lID09PSBlZmZlY3RzW2ldLml4KSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0c1tpXS50eSA9PT0gNSkge1xuICAgICAgICAgICAgICByZXR1cm4gZWZmZWN0RWxlbWVudHNbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlZmZlY3RFbGVtZW50c1tpXSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShncm91cEludGVyZmFjZSwgcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIHZhciBlZmZlY3RFbGVtZW50cyA9IFtdO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gZGF0YS5lZi5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoZGF0YS5lZltpXS50eSA9PT0gNSkge1xuICAgICAgICAgIGVmZmVjdEVsZW1lbnRzLnB1c2goY3JlYXRlR3JvdXBJbnRlcmZhY2UoZGF0YS5lZltpXSwgZWxlbWVudHMuZWZmZWN0RWxlbWVudHNbaV0sIGVsZW1lbnRzLmVmZmVjdEVsZW1lbnRzW2ldLnByb3BlcnR5R3JvdXAsIGVsZW0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZmZlY3RFbGVtZW50cy5wdXNoKGNyZWF0ZVZhbHVlSW50ZXJmYWNlKGVsZW1lbnRzLmVmZmVjdEVsZW1lbnRzW2ldLCBkYXRhLmVmW2ldLnR5LCBlbGVtLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLm1uID09PSAnQURCRSBDb2xvciBDb250cm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ3JvdXBJbnRlcmZhY2UsICdjb2xvcicsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBlZmZlY3RFbGVtZW50c1swXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGdyb3VwSW50ZXJmYWNlLCB7XG4gICAgICAgIG51bVByb3BlcnRpZXM6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLm5wO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogZGF0YS5ubVxuICAgICAgICB9LFxuICAgICAgICBwcm9wZXJ0eUdyb3VwOiB7XG4gICAgICAgICAgdmFsdWU6IF9wcm9wZXJ0eUdyb3VwXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZ3JvdXBJbnRlcmZhY2UuZW5hYmxlZCA9IGRhdGEuZW4gIT09IDA7XG4gICAgICBncm91cEludGVyZmFjZS5hY3RpdmUgPSBncm91cEludGVyZmFjZS5lbmFibGVkO1xuICAgICAgcmV0dXJuIGdyb3VwSW50ZXJmYWNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVZhbHVlSW50ZXJmYWNlKGVsZW1lbnQsIHR5cGUsIGVsZW0sIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIHZhciBleHByZXNzaW9uUHJvcGVydHkgPSBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UoZWxlbWVudC5wKTtcblxuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAxMCkge1xuICAgICAgICAgIHJldHVybiBlbGVtLmNvbXAuY29tcEludGVyZmFjZShlbGVtZW50LnAudik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvblByb3BlcnR5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50LnAuc2V0R3JvdXBQcm9wZXJ0eSkge1xuICAgICAgICBlbGVtZW50LnAuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnJywgcHJvcGVydHlHcm91cCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iO1xuICB9KCk7XG5cbiAgdmFyIFNoYXBlUGF0aEludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcGF0aEludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIHZhciBwcm9wID0gdmlldy5zaDtcblxuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT09ICdTaGFwZScgfHwgdmFsID09PSAnc2hhcGUnIHx8IHZhbCA9PT0gJ1BhdGgnIHx8IHZhbCA9PT0gJ3BhdGgnIHx8IHZhbCA9PT0gJ0FEQkUgVmVjdG9yIFNoYXBlJyB8fCB2YWwgPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIHByb3Auc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnUGF0aCcsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAocHJvcC5rKSB7XG4gICAgICAgICAgICAgIHByb3AuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgaWYgKHByb3Auaykge1xuICAgICAgICAgICAgICBwcm9wLmdldFZhbHVlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfSxcbiAgICAgICAgaXg6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUuaXhcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcGVydHlJbmRleDoge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5peFxuICAgICAgICB9LFxuICAgICAgICBtbjoge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5tblxuICAgICAgICB9LFxuICAgICAgICBwcm9wZXJ0eUdyb3VwOiB7XG4gICAgICAgICAgdmFsdWU6IHByb3BlcnR5R3JvdXBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBTaGFwZUV4cHJlc3Npb25JbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gaXRlcmF0ZUVsZW1lbnRzKHNoYXBlcywgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc2hhcGVzID8gc2hhcGVzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoc2hhcGVzW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgICAgYXJyLnB1c2goZ3JvdXBJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ2ZsJykge1xuICAgICAgICAgIGFyci5wdXNoKGZpbGxJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3N0Jykge1xuICAgICAgICAgIGFyci5wdXNoKHN0cm9rZUludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAndG0nKSB7XG4gICAgICAgICAgYXJyLnB1c2godHJpbUludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAndHInKSB7Ly8gYXJyLnB1c2godHJhbnNmb3JtSW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sdmlld1tpXSxwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAnZWwnKSB7XG4gICAgICAgICAgYXJyLnB1c2goZWxsaXBzZUludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAnc3InKSB7XG4gICAgICAgICAgYXJyLnB1c2goc3RhckludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAnc2gnKSB7XG4gICAgICAgICAgYXJyLnB1c2goU2hhcGVQYXRoSW50ZXJmYWNlKHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3JjJykge1xuICAgICAgICAgIGFyci5wdXNoKHJlY3RJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3JkJykge1xuICAgICAgICAgIGFyci5wdXNoKHJvdW5kZWRJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3JwJykge1xuICAgICAgICAgIGFyci5wdXNoKHJlcGVhdGVySW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sIHZpZXdbaV0sIHByb3BlcnR5R3JvdXApKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICdnZicpIHtcbiAgICAgICAgICBhcnIucHVzaChncmFkaWVudEZpbGxJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyci5wdXNoKGRlZmF1bHRJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udGVudHNJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICB2YXIgaW50ZXJmYWNlcztcblxuICAgICAgdmFyIGludGVyZmFjZUZ1bmN0aW9uID0gZnVuY3Rpb24gX2ludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IGludGVyZmFjZXMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKGludGVyZmFjZXNbaV0uX25hbWUgPT09IHZhbHVlIHx8IGludGVyZmFjZXNbaV0ubW4gPT09IHZhbHVlIHx8IGludGVyZmFjZXNbaV0ucHJvcGVydHlJbmRleCA9PT0gdmFsdWUgfHwgaW50ZXJmYWNlc1tpXS5peCA9PT0gdmFsdWUgfHwgaW50ZXJmYWNlc1tpXS5pbmQgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlc1tpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VzW3ZhbHVlIC0gMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG4gICAgICBpbnRlcmZhY2VzID0gaXRlcmF0ZUVsZW1lbnRzKHNoYXBlLml0LCB2aWV3Lml0LCBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwKTtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm51bVByb3BlcnRpZXMgPSBpbnRlcmZhY2VzLmxlbmd0aDtcbiAgICAgIHZhciB0cmFuc2Zvcm1JbnRlcmZhY2UgPSB0cmFuc2Zvcm1JbnRlcmZhY2VGYWN0b3J5KHNoYXBlLml0W3NoYXBlLml0Lmxlbmd0aCAtIDFdLCB2aWV3Lml0W3ZpZXcuaXQubGVuZ3RoIC0gMV0sIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXApO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24udHJhbnNmb3JtID0gdHJhbnNmb3JtSW50ZXJmYWNlO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLmNpeDtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLl9uYW1lID0gc2hhcGUubm07XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ3JvdXBJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICB2YXIgaW50ZXJmYWNlRnVuY3Rpb24gPSBmdW5jdGlvbiBfaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ0FEQkUgVmVjdG9ycyBHcm91cCc6XG4gICAgICAgICAgY2FzZSAnQ29udGVudHMnOlxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5jb250ZW50O1xuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnkgZm9yIG5vdy4gS2VlcGluZyB0aGVtIGhlcmUgaW4gY2FzZSBhIG5ldyBjYXNlIGFwcGVhcnNcbiAgICAgICAgICAvLyBjYXNlICdBREJFIFZlY3RvciBUcmFuc2Zvcm0gR3JvdXAnOlxuICAgICAgICAgIC8vIGNhc2UgMzpcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24udHJhbnNmb3JtO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xuICAgICAgdmFyIGNvbnRlbnQgPSBjb250ZW50c0ludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXApO1xuICAgICAgdmFyIHRyYW5zZm9ybUludGVyZmFjZSA9IHRyYW5zZm9ybUludGVyZmFjZUZhY3Rvcnkoc2hhcGUuaXRbc2hhcGUuaXQubGVuZ3RoIC0gMV0sIHZpZXcuaXRbdmlldy5pdC5sZW5ndGggLSAxXSwgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5jb250ZW50ID0gY29udGVudDtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnRyYW5zZm9ybSA9IHRyYW5zZm9ybUludGVyZmFjZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnRlcmZhY2VGdW5jdGlvbiwgJ19uYW1lJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gc2hhcGUubm07XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBpbnRlcmZhY2VGdW5jdGlvbi5jb250ZW50ID0gaW50ZXJmYWNlRnVuY3Rpb247XG5cbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm51bVByb3BlcnRpZXMgPSBzaGFwZS5ucDtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5peDtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm5tID0gc2hhcGUubm07XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbGxJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gJ0NvbG9yJyB8fCB2YWwgPT09ICdjb2xvcicpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uY29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsID09PSAnT3BhY2l0eScgfHwgdmFsID09PSAnb3BhY2l0eScpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcuYylcbiAgICAgICAgfSxcbiAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcubylcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfSxcbiAgICAgICAgbW46IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubW5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2aWV3LmMuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnQ29sb3InLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3Lm8uc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnT3BhY2l0eScsIHByb3BlcnR5R3JvdXApKTtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBncmFkaWVudEZpbGxJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gJ1N0YXJ0IFBvaW50JyB8fCB2YWwgPT09ICdzdGFydCBwb2ludCcpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc3RhcnRQb2ludDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPT09ICdFbmQgUG9pbnQnIHx8IHZhbCA9PT0gJ2VuZCBwb2ludCcpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uZW5kUG9pbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsID09PSAnT3BhY2l0eScgfHwgdmFsID09PSAnb3BhY2l0eScpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBzdGFydFBvaW50OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5zKVxuICAgICAgICB9LFxuICAgICAgICBlbmRQb2ludDoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcuZSlcbiAgICAgICAgfSxcbiAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcubylcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuICdhJztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9uYW1lOiB7XG4gICAgICAgICAgdmFsdWU6IHNoYXBlLm5tXG4gICAgICAgIH0sXG4gICAgICAgIG1uOiB7XG4gICAgICAgICAgdmFsdWU6IHNoYXBlLm1uXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmlldy5zLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1N0YXJ0IFBvaW50JywgcHJvcGVydHlHcm91cCkpO1xuICAgICAgdmlldy5lLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ0VuZCBQb2ludCcsIHByb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcuby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPcGFjaXR5JywgcHJvcGVydHlHcm91cCkpO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRJbnRlcmZhY2VGYWN0b3J5KCkge1xuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3Ryb2tlSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgdmFyIF9wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xuXG4gICAgICB2YXIgX2Rhc2hQcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoZGFzaE9iLCBfcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZFByb3BlcnR5VG9EYXNoT2IoaSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGFzaE9iLCBzaGFwZS5kW2ldLm5tLCB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5kLmRhdGFQcm9wc1tpXS5wKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc2hhcGUuZCA/IHNoYXBlLmQubGVuZ3RoIDogMDtcbiAgICAgIHZhciBkYXNoT2IgPSB7fTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGFkZFByb3BlcnR5VG9EYXNoT2IoaSk7XG4gICAgICAgIHZpZXcuZC5kYXRhUHJvcHNbaV0ucC5zZXRHcm91cFByb3BlcnR5KF9kYXNoUHJvcGVydHlHcm91cCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBpZiAodmFsID09PSAnQ29sb3InIHx8IHZhbCA9PT0gJ2NvbG9yJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5jb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPT09ICdPcGFjaXR5JyB8fCB2YWwgPT09ICdvcGFjaXR5Jykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vcGFjaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbCA9PT0gJ1N0cm9rZSBXaWR0aCcgfHwgdmFsID09PSAnc3Ryb2tlIHdpZHRoJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5zdHJva2VXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcuYylcbiAgICAgICAgfSxcbiAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcubylcbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LncpXG4gICAgICAgIH0sXG4gICAgICAgIGRhc2g6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXNoT2I7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfbmFtZToge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5ubVxuICAgICAgICB9LFxuICAgICAgICBtbjoge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5tblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZpZXcuYy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdDb2xvcicsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3Lm8uc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnT3BhY2l0eScsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3Lncuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnU3Ryb2tlIFdpZHRoJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmltSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT09IHNoYXBlLmUuaXggfHwgdmFsID09PSAnRW5kJyB8fCB2YWwgPT09ICdlbmQnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmVuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPT09IHNoYXBlLnMuaXgpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsID09PSBzaGFwZS5vLml4KSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLm9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5peDtcbiAgICAgIHZpZXcucy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTdGFydCcsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3LmUuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnRW5kJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcuby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPZmZzZXQnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBzdGFydDoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcucylcbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5lKVxuICAgICAgICB9LFxuICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3Lm8pXG4gICAgICAgIH0sXG4gICAgICAgIF9uYW1lOiB7XG4gICAgICAgICAgdmFsdWU6IHNoYXBlLm5tXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ubW4gPSBzaGFwZS5tbjtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1JbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoc2hhcGUuYS5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdBbmNob3IgUG9pbnQnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmFuY2hvclBvaW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLm8uaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnT3BhY2l0eScpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5wLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1Bvc2l0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5yLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1JvdGF0aW9uJyB8fCB2YWx1ZSA9PT0gJ0FEQkUgVmVjdG9yIFJvdGF0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5yb3RhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5zLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1NjYWxlJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5zY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5zayAmJiBzaGFwZS5zay5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdTa2V3Jykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5za2V3O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLnNhICYmIHNoYXBlLnNhLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1NrZXcgQXhpcycpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc2tld0F4aXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIF9wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xuXG4gICAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMuby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPcGFjaXR5JywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5wLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1Bvc2l0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5hLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ0FuY2hvciBQb2ludCcsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMucy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTY2FsZScsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMuci5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdSb3RhdGlvbicsIF9wcm9wZXJ0eUdyb3VwKSk7XG5cbiAgICAgIGlmICh2aWV3LnRyYW5zZm9ybS5tUHJvcHMuc2spIHtcbiAgICAgICAgdmlldy50cmFuc2Zvcm0ubVByb3BzLnNrLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1NrZXcnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMuc2Euc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnU2tldyBBbmdsZScsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB9XG5cbiAgICAgIHZpZXcudHJhbnNmb3JtLm9wLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ09wYWNpdHknLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcbiAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5vKVxuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5wKVxuICAgICAgICB9LFxuICAgICAgICBhbmNob3JQb2ludDoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5hKVxuICAgICAgICB9LFxuICAgICAgICBzY2FsZToge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5zKVxuICAgICAgICB9LFxuICAgICAgICByb3RhdGlvbjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5yKVxuICAgICAgICB9LFxuICAgICAgICBza2V3OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLnNrKVxuICAgICAgICB9LFxuICAgICAgICBza2V3QXhpczoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5zYSlcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi50eSA9ICd0cic7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXA7XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWxsaXBzZUludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChzaGFwZS5wLml4ID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5zLml4ID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5zaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGludGVyZmFjZUZ1bmN0aW9uLCBwcm9wZXJ0eUdyb3VwKTtcblxuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xuICAgICAgdmFyIHByb3AgPSB2aWV3LnNoLnR5ID09PSAndG0nID8gdmlldy5zaC5wcm9wIDogdmlldy5zaDtcbiAgICAgIHByb3Aucy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTaXplJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHByb3AucC5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdQb3NpdGlvbicsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5zKVxuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucClcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoc2hhcGUucC5peCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUuci5peCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucm90YXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUucHQuaXggPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnBvaW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5vci5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdBREJFIFZlY3RvciBTdGFyIE91dGVyIFJhZGl1cycpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3V0ZXJSYWRpdXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUub3MuaXggPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLm91dGVyUm91bmRuZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLmlyICYmIChzaGFwZS5pci5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdBREJFIFZlY3RvciBTdGFyIElubmVyIFJhZGl1cycpKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmlubmVyUmFkaXVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLmlzICYmIHNoYXBlLmlzLml4ID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5pbm5lclJvdW5kbmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIHZhciBwcm9wID0gdmlldy5zaC50eSA9PT0gJ3RtJyA/IHZpZXcuc2gucHJvcCA6IHZpZXcuc2g7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuaXg7XG4gICAgICBwcm9wLm9yLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ091dGVyIFJhZGl1cycsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBwcm9wLm9zLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ091dGVyIFJvdW5kbmVzcycsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBwcm9wLnB0LnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1BvaW50cycsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBwcm9wLnAuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnUG9zaXRpb24nLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgcHJvcC5yLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1JvdGF0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcblxuICAgICAgaWYgKHNoYXBlLmlyKSB7XG4gICAgICAgIHByb3AuaXIuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnSW5uZXIgUmFkaXVzJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgICAgcHJvcC5pcy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdJbm5lciBSb3VuZG5lc3MnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucClcbiAgICAgICAgfSxcbiAgICAgICAgcm90YXRpb246IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLnIpXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50czoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucHQpXG4gICAgICAgIH0sXG4gICAgICAgIG91dGVyUmFkaXVzOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5vcilcbiAgICAgICAgfSxcbiAgICAgICAgb3V0ZXJSb3VuZG5lc3M6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLm9zKVxuICAgICAgICB9LFxuICAgICAgICBpbm5lclJhZGl1czoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AuaXIpXG4gICAgICAgIH0sXG4gICAgICAgIGlubmVyUm91bmRuZXNzOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5pcylcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlY3RJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoc2hhcGUucC5peCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUuci5peCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucm91bmRuZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLnMuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnU2l6ZScgfHwgdmFsdWUgPT09ICdBREJFIFZlY3RvciBSZWN0IFNpemUnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnNpemU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIF9wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xuXG4gICAgICB2YXIgcHJvcCA9IHZpZXcuc2gudHkgPT09ICd0bScgPyB2aWV3LnNoLnByb3AgOiB2aWV3LnNoO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xuICAgICAgcHJvcC5wLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1Bvc2l0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHByb3Aucy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTaXplJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHByb3Auci5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdSb3RhdGlvbicsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucClcbiAgICAgICAgfSxcbiAgICAgICAgcm91bmRuZXNzOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5yKVxuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5zKVxuICAgICAgICB9LFxuICAgICAgICBfbmFtZToge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5ubVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm91bmRlZEludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChzaGFwZS5yLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1JvdW5kIENvcm5lcnMgMScpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucmFkaXVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGludGVyZmFjZUZ1bmN0aW9uLCBwcm9wZXJ0eUdyb3VwKTtcblxuICAgICAgdmFyIHByb3AgPSB2aWV3O1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xuICAgICAgcHJvcC5yZC5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdSYWRpdXMnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcbiAgICAgICAgcmFkaXVzOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5yZClcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGVhdGVySW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHNoYXBlLmMuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnQ29waWVzJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5jb3BpZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUuby5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdPZmZzZXQnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLm9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIHZhciBwcm9wID0gdmlldztcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5peDtcbiAgICAgIHByb3AuYy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdDb3BpZXMnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgcHJvcC5vLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ09mZnNldCcsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBjb3BpZXM6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLmMpXG4gICAgICAgIH0sXG4gICAgICAgIG9mZnNldDoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AubylcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoc2hhcGVzLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICB2YXIgaW50ZXJmYWNlcztcblxuICAgICAgZnVuY3Rpb24gX2ludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gMSA6IHZhbHVlO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydHlHcm91cDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlc1t2YWx1ZSAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gaW50ZXJmYWNlcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICBpZiAoaW50ZXJmYWNlc1tpXS5fbmFtZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VzW2ldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwYXJlbnRHcm91cFdyYXBwZXIoKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUdyb3VwO1xuICAgICAgfVxuXG4gICAgICBfaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KF9pbnRlcmZhY2VGdW5jdGlvbiwgcGFyZW50R3JvdXBXcmFwcGVyKTtcbiAgICAgIGludGVyZmFjZXMgPSBpdGVyYXRlRWxlbWVudHMoc2hhcGVzLCB2aWV3LCBfaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCk7XG4gICAgICBfaW50ZXJmYWNlRnVuY3Rpb24ubnVtUHJvcGVydGllcyA9IGludGVyZmFjZXMubGVuZ3RoO1xuICAgICAgX2ludGVyZmFjZUZ1bmN0aW9uLl9uYW1lID0gJ0NvbnRlbnRzJztcbiAgICAgIHJldHVybiBfaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBUZXh0RXhwcmVzc2lvbkludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIHZhciBfc291cmNlVGV4dDtcblxuICAgICAgZnVuY3Rpb24gX3RoaXNMYXllckZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgY2FzZSAnQURCRSBUZXh0IERvY3VtZW50JzpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb24uc291cmNlVGV4dDtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNMYXllckZ1bmN0aW9uLCAnc291cmNlVGV4dCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgZWxlbS50ZXh0UHJvcGVydHkuZ2V0VmFsdWUoKTtcbiAgICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSBlbGVtLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YS50O1xuXG4gICAgICAgICAgaWYgKCFfc291cmNlVGV4dCB8fCBzdHJpbmdWYWx1ZSAhPT0gX3NvdXJjZVRleHQudmFsdWUpIHtcbiAgICAgICAgICAgIF9zb3VyY2VUZXh0ID0gbmV3IFN0cmluZyhzdHJpbmdWYWx1ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG4gICAgICAgICAgICAvLyBJZiBzdHJpbmdWYWx1ZSBpcyBhbiBlbXB0eSBzdHJpbmcsIGV2YWwgcmV0dXJucyB1bmRlZmluZWQsIHNvIGl0IGhhcyB0byBiZSByZXR1cm5lZCBhcyBhIFN0cmluZyBwcmltaXRpdmVcblxuICAgICAgICAgICAgX3NvdXJjZVRleHQudmFsdWUgPSBzdHJpbmdWYWx1ZSB8fCBuZXcgU3RyaW5nKHN0cmluZ1ZhbHVlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9zb3VyY2VUZXh0LCAnc3R5bGUnLCB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6IGVsZW0udGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLmZjXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF9zb3VyY2VUZXh0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb247XG4gICAgfTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuICB2YXIgRm9vdGFnZUludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3V0bGluZUludGVyZmFjZUZhY3RvcnkgPSBmdW5jdGlvbiBvdXRsaW5lSW50ZXJmYWNlRmFjdG9yeShlbGVtKSB7XG4gICAgICB2YXIgY3VycmVudFByb3BlcnR5TmFtZSA9ICcnO1xuICAgICAgdmFyIGN1cnJlbnRQcm9wZXJ0eSA9IGVsZW0uZ2V0Rm9vdGFnZURhdGEoKTtcblxuICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgY3VycmVudFByb3BlcnR5TmFtZSA9ICcnO1xuICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBlbGVtLmdldEZvb3RhZ2VEYXRhKCk7XG4gICAgICAgIHJldHVybiBzZWFyY2hQcm9wZXJ0eTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2VhcmNoUHJvcGVydHkodmFsdWUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRQcm9wZXJ0eVt2YWx1ZV0pIHtcbiAgICAgICAgICBjdXJyZW50UHJvcGVydHlOYW1lID0gdmFsdWU7XG4gICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gY3VycmVudFByb3BlcnR5W3ZhbHVlXTtcblxuICAgICAgICAgIGlmIChfdHlwZW9mKGN1cnJlbnRQcm9wZXJ0eSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VhcmNoUHJvcGVydHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRQcm9wZXJ0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9wZXJ0eU5hbWVJbmRleCA9IHZhbHVlLmluZGV4T2YoY3VycmVudFByb3BlcnR5TmFtZSk7XG5cbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cihwcm9wZXJ0eU5hbWVJbmRleCArIGN1cnJlbnRQcm9wZXJ0eU5hbWUubGVuZ3RoKSwgMTApO1xuICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IGN1cnJlbnRQcm9wZXJ0eVtpbmRleF07XG5cbiAgICAgICAgICBpZiAoX3R5cGVvZihjdXJyZW50UHJvcGVydHkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHNlYXJjaFByb3BlcnR5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjdXJyZW50UHJvcGVydHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbml0O1xuICAgIH07XG5cbiAgICB2YXIgZGF0YUludGVyZmFjZUZhY3RvcnkgPSBmdW5jdGlvbiBkYXRhSW50ZXJmYWNlRmFjdG9yeShlbGVtKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09ICdPdXRsaW5lJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vdXRsaW5lSW50ZXJmYWNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24uX25hbWUgPSAnT3V0bGluZSc7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5vdXRsaW5lSW50ZXJmYWNlID0gb3V0bGluZUludGVyZmFjZUZhY3RvcnkoZWxlbSk7XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgZnVuY3Rpb24gX2ludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ0RhdGEnKSB7XG4gICAgICAgICAgcmV0dXJuIF9pbnRlcmZhY2VGdW5jdGlvbi5kYXRhSW50ZXJmYWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIF9pbnRlcmZhY2VGdW5jdGlvbi5fbmFtZSA9ICdEYXRhJztcbiAgICAgIF9pbnRlcmZhY2VGdW5jdGlvbi5kYXRhSW50ZXJmYWNlID0gZGF0YUludGVyZmFjZUZhY3RvcnkoZWxlbSk7XG4gICAgICByZXR1cm4gX2ludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgaW50ZXJmYWNlcyA9IHtcbiAgICBsYXllcjogTGF5ZXJFeHByZXNzaW9uSW50ZXJmYWNlLFxuICAgIGVmZmVjdHM6IEVmZmVjdHNFeHByZXNzaW9uSW50ZXJmYWNlLFxuICAgIGNvbXA6IENvbXBFeHByZXNzaW9uSW50ZXJmYWNlLFxuICAgIHNoYXBlOiBTaGFwZUV4cHJlc3Npb25JbnRlcmZhY2UsXG4gICAgdGV4dDogVGV4dEV4cHJlc3Npb25JbnRlcmZhY2UsXG4gICAgZm9vdGFnZTogRm9vdGFnZUludGVyZmFjZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldEludGVyZmFjZSh0eXBlKSB7XG4gICAgcmV0dXJuIGludGVyZmFjZXNbdHlwZV0gfHwgbnVsbDtcbiAgfVxuXG4gIHZhciBleHByZXNzaW9uSGVscGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBzZWFyY2hFeHByZXNzaW9ucyhlbGVtLCBkYXRhLCBwcm9wKSB7XG4gICAgICBpZiAoZGF0YS54KSB7XG4gICAgICAgIHByb3AuayA9IHRydWU7XG4gICAgICAgIHByb3AueCA9IHRydWU7XG4gICAgICAgIHByb3AuaW5pdGlhdGVFeHByZXNzaW9uID0gRXhwcmVzc2lvbk1hbmFnZXIuaW5pdGlhdGVFeHByZXNzaW9uO1xuICAgICAgICBwcm9wLmVmZmVjdHNTZXF1ZW5jZS5wdXNoKHByb3AuaW5pdGlhdGVFeHByZXNzaW9uKGVsZW0sIGRhdGEsIHByb3ApLmJpbmQocHJvcCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZhbHVlQXRUaW1lKGZyYW1lTnVtKSB7XG4gICAgICBmcmFtZU51bSAqPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICBmcmFtZU51bSAtPSB0aGlzLm9mZnNldFRpbWU7XG5cbiAgICAgIGlmIChmcmFtZU51bSAhPT0gdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0RnJhbWUpIHtcbiAgICAgICAgdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0SW5kZXggPSB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RGcmFtZSA8IGZyYW1lTnVtID8gdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0SW5kZXggOiAwO1xuICAgICAgICB0aGlzLl9jYWNoaW5nQXRUaW1lLnZhbHVlID0gdGhpcy5pbnRlcnBvbGF0ZVZhbHVlKGZyYW1lTnVtLCB0aGlzLl9jYWNoaW5nQXRUaW1lKTtcbiAgICAgICAgdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0RnJhbWUgPSBmcmFtZU51bTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hpbmdBdFRpbWUudmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3BlZWRBdFRpbWUoZnJhbWVOdW0pIHtcbiAgICAgIHZhciBkZWx0YSA9IC0wLjAxO1xuICAgICAgdmFyIHYxID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmcmFtZU51bSk7XG4gICAgICB2YXIgdjIgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGZyYW1lTnVtICsgZGVsdGEpO1xuICAgICAgdmFyIHNwZWVkID0gMDtcblxuICAgICAgaWYgKHYxLmxlbmd0aCkge1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdjEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBzcGVlZCArPSBNYXRoLnBvdyh2MltpXSAtIHYxW2ldLCAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNwZWVkID0gTWF0aC5zcXJ0KHNwZWVkKSAqIDEwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwZWVkID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNwZWVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZlbG9jaXR5QXRUaW1lKGZyYW1lTnVtKSB7XG4gICAgICBpZiAodGhpcy52ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZWw7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWx0YSA9IC0wLjAwMTsgLy8gZnJhbWVOdW0gKz0gdGhpcy5lbGVtLmRhdGEuc3Q7XG5cbiAgICAgIHZhciB2MSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoZnJhbWVOdW0pO1xuICAgICAgdmFyIHYyID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmcmFtZU51bSArIGRlbHRhKTtcbiAgICAgIHZhciB2ZWxvY2l0eTtcblxuICAgICAgaWYgKHYxLmxlbmd0aCkge1xuICAgICAgICB2ZWxvY2l0eSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCB2MS5sZW5ndGgpO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdjEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAvLyByZW1vdmluZyBmcmFtZVJhdGVcbiAgICAgICAgICAvLyBpZiBuZWVkZWQsIGRvbid0IGFkZCBpdCBoZXJlXG4gICAgICAgICAgLy8gdmVsb2NpdHlbaV0gPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZVJhdGUqKCh2MltpXSAtIHYxW2ldKS9kZWx0YSk7XG4gICAgICAgICAgdmVsb2NpdHlbaV0gPSAodjJbaV0gLSB2MVtpXSkgLyBkZWx0YTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVsb2NpdHkgPSAodjIgLSB2MSkgLyBkZWx0YTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZlbG9jaXR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFN0YXRpY1ZhbHVlQXRUaW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0R3JvdXBQcm9wZXJ0eShwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICB0aGlzLnByb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzZWFyY2hFeHByZXNzaW9uczogc2VhcmNoRXhwcmVzc2lvbnMsXG4gICAgICBnZXRTcGVlZEF0VGltZTogZ2V0U3BlZWRBdFRpbWUsXG4gICAgICBnZXRWZWxvY2l0eUF0VGltZTogZ2V0VmVsb2NpdHlBdFRpbWUsXG4gICAgICBnZXRWYWx1ZUF0VGltZTogZ2V0VmFsdWVBdFRpbWUsXG4gICAgICBnZXRTdGF0aWNWYWx1ZUF0VGltZTogZ2V0U3RhdGljVmFsdWVBdFRpbWUsXG4gICAgICBzZXRHcm91cFByb3BlcnR5OiBzZXRHcm91cFByb3BlcnR5XG4gICAgfTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIGFkZFByb3BlcnR5RGVjb3JhdG9yKCkge1xuICAgIGZ1bmN0aW9uIGxvb3BPdXQodHlwZSwgZHVyYXRpb24sIGR1cmF0aW9uRmxhZykge1xuICAgICAgaWYgKCF0aGlzLmsgfHwgIXRoaXMua2V5ZnJhbWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB2O1xuICAgICAgfVxuXG4gICAgICB0eXBlID0gdHlwZSA/IHR5cGUudG9Mb3dlckNhc2UoKSA6ICcnO1xuICAgICAgdmFyIGN1cnJlbnRGcmFtZSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lO1xuICAgICAgdmFyIGtleWZyYW1lcyA9IHRoaXMua2V5ZnJhbWVzO1xuICAgICAgdmFyIGxhc3RLZXlGcmFtZSA9IGtleWZyYW1lc1trZXlmcmFtZXMubGVuZ3RoIC0gMV0udDtcblxuICAgICAgaWYgKGN1cnJlbnRGcmFtZSA8PSBsYXN0S2V5RnJhbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHY7XG4gICAgICB9XG5cbiAgICAgIHZhciBjeWNsZUR1cmF0aW9uO1xuICAgICAgdmFyIGZpcnN0S2V5RnJhbWU7XG5cbiAgICAgIGlmICghZHVyYXRpb25GbGFnKSB7XG4gICAgICAgIGlmICghZHVyYXRpb24gfHwgZHVyYXRpb24gPiBrZXlmcmFtZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGR1cmF0aW9uID0ga2V5ZnJhbWVzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBmaXJzdEtleUZyYW1lID0ga2V5ZnJhbWVzW2tleWZyYW1lcy5sZW5ndGggLSAxIC0gZHVyYXRpb25dLnQ7XG4gICAgICAgIGN5Y2xlRHVyYXRpb24gPSBsYXN0S2V5RnJhbWUgLSBmaXJzdEtleUZyYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICAgIGN5Y2xlRHVyYXRpb24gPSBNYXRoLm1heCgwLCBsYXN0S2V5RnJhbWUgLSB0aGlzLmVsZW0uZGF0YS5pcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3ljbGVEdXJhdGlvbiA9IE1hdGguYWJzKGxhc3RLZXlGcmFtZSAtIHRoaXMuZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlICogZHVyYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgZmlyc3RLZXlGcmFtZSA9IGxhc3RLZXlGcmFtZSAtIGN5Y2xlRHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbjtcbiAgICAgIHZhciByZXQ7XG5cbiAgICAgIGlmICh0eXBlID09PSAncGluZ3BvbmcnKSB7XG4gICAgICAgIHZhciBpdGVyYXRpb25zID0gTWF0aC5mbG9vcigoY3VycmVudEZyYW1lIC0gZmlyc3RLZXlGcmFtZSkgLyBjeWNsZUR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXRlcmF0aW9ucyAlIDIgIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZUF0VGltZSgoY3ljbGVEdXJhdGlvbiAtIChjdXJyZW50RnJhbWUgLSBmaXJzdEtleUZyYW1lKSAlIGN5Y2xlRHVyYXRpb24gKyBmaXJzdEtleUZyYW1lKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2Zmc2V0Jykge1xuICAgICAgICB2YXIgaW5pdFYgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGZpcnN0S2V5RnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xuICAgICAgICB2YXIgZW5kViA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUobGFzdEtleUZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldFZhbHVlQXRUaW1lKCgoY3VycmVudEZyYW1lIC0gZmlyc3RLZXlGcmFtZSkgJSBjeWNsZUR1cmF0aW9uICsgZmlyc3RLZXlGcmFtZSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgICAgdmFyIHJlcGVhdHMgPSBNYXRoLmZsb29yKChjdXJyZW50RnJhbWUgLSBmaXJzdEtleUZyYW1lKSAvIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgIGlmICh0aGlzLnB2Lmxlbmd0aCkge1xuICAgICAgICAgIHJldCA9IG5ldyBBcnJheShpbml0Vi5sZW5ndGgpO1xuICAgICAgICAgIGxlbiA9IHJldC5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHJldFtpXSA9IChlbmRWW2ldIC0gaW5pdFZbaV0pICogcmVwZWF0cyArIGN1cnJlbnRbaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoZW5kViAtIGluaXRWKSAqIHJlcGVhdHMgKyBjdXJyZW50O1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnY29udGludWUnKSB7XG4gICAgICAgIHZhciBsYXN0VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGxhc3RLZXlGcmFtZSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7XG4gICAgICAgIHZhciBuZXh0TGFzdFZhbHVlID0gdGhpcy5nZXRWYWx1ZUF0VGltZSgobGFzdEtleUZyYW1lIC0gMC4wMDEpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcblxuICAgICAgICBpZiAodGhpcy5wdi5sZW5ndGgpIHtcbiAgICAgICAgICByZXQgPSBuZXcgQXJyYXkobGFzdFZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgbGVuID0gcmV0Lmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcmV0W2ldID0gbGFzdFZhbHVlW2ldICsgKGxhc3RWYWx1ZVtpXSAtIG5leHRMYXN0VmFsdWVbaV0pICogKChjdXJyZW50RnJhbWUgLSBsYXN0S2V5RnJhbWUpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlKSAvIDAuMDAwNTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGFzdFZhbHVlICsgKGxhc3RWYWx1ZSAtIG5leHRMYXN0VmFsdWUpICogKChjdXJyZW50RnJhbWUgLSBsYXN0S2V5RnJhbWUpIC8gMC4wMDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZUF0VGltZSgoKGN1cnJlbnRGcmFtZSAtIGZpcnN0S2V5RnJhbWUpICUgY3ljbGVEdXJhdGlvbiArIGZpcnN0S2V5RnJhbWUpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb3BJbih0eXBlLCBkdXJhdGlvbiwgZHVyYXRpb25GbGFnKSB7XG4gICAgICBpZiAoIXRoaXMuaykge1xuICAgICAgICByZXR1cm4gdGhpcy5wdjtcbiAgICAgIH1cblxuICAgICAgdHlwZSA9IHR5cGUgPyB0eXBlLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgICAgIHZhciBjdXJyZW50RnJhbWUgPSB0aGlzLmNvbXAucmVuZGVyZWRGcmFtZTtcbiAgICAgIHZhciBrZXlmcmFtZXMgPSB0aGlzLmtleWZyYW1lcztcbiAgICAgIHZhciBmaXJzdEtleUZyYW1lID0ga2V5ZnJhbWVzWzBdLnQ7XG5cbiAgICAgIGlmIChjdXJyZW50RnJhbWUgPj0gZmlyc3RLZXlGcmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdjtcbiAgICAgIH1cblxuICAgICAgdmFyIGN5Y2xlRHVyYXRpb247XG4gICAgICB2YXIgbGFzdEtleUZyYW1lO1xuXG4gICAgICBpZiAoIWR1cmF0aW9uRmxhZykge1xuICAgICAgICBpZiAoIWR1cmF0aW9uIHx8IGR1cmF0aW9uID4ga2V5ZnJhbWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBkdXJhdGlvbiA9IGtleWZyYW1lcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdEtleUZyYW1lID0ga2V5ZnJhbWVzW2R1cmF0aW9uXS50O1xuICAgICAgICBjeWNsZUR1cmF0aW9uID0gbGFzdEtleUZyYW1lIC0gZmlyc3RLZXlGcmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghZHVyYXRpb24pIHtcbiAgICAgICAgICBjeWNsZUR1cmF0aW9uID0gTWF0aC5tYXgoMCwgdGhpcy5lbGVtLmRhdGEub3AgLSBmaXJzdEtleUZyYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeWNsZUR1cmF0aW9uID0gTWF0aC5hYnModGhpcy5lbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUgKiBkdXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0S2V5RnJhbWUgPSBmaXJzdEtleUZyYW1lICsgY3ljbGVEdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuO1xuICAgICAgdmFyIHJldDtcblxuICAgICAgaWYgKHR5cGUgPT09ICdwaW5ncG9uZycpIHtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBNYXRoLmZsb29yKChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKSAvIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpdGVyYXRpb25zICUgMiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlQXRUaW1lKCgoZmlyc3RLZXlGcmFtZSAtIGN1cnJlbnRGcmFtZSkgJSBjeWNsZUR1cmF0aW9uICsgZmlyc3RLZXlGcmFtZSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29mZnNldCcpIHtcbiAgICAgICAgdmFyIGluaXRWID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmaXJzdEtleUZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgdmFyIGVuZFYgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGxhc3RLZXlGcmFtZSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRWYWx1ZUF0VGltZSgoY3ljbGVEdXJhdGlvbiAtIChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKSAlIGN5Y2xlRHVyYXRpb24gKyBmaXJzdEtleUZyYW1lKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7XG4gICAgICAgIHZhciByZXBlYXRzID0gTWF0aC5mbG9vcigoZmlyc3RLZXlGcmFtZSAtIGN1cnJlbnRGcmFtZSkgLyBjeWNsZUR1cmF0aW9uKSArIDE7XG5cbiAgICAgICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0ID0gbmV3IEFycmF5KGluaXRWLmxlbmd0aCk7XG4gICAgICAgICAgbGVuID0gcmV0Lmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcmV0W2ldID0gY3VycmVudFtpXSAtIChlbmRWW2ldIC0gaW5pdFZbaV0pICogcmVwZWF0cztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQgLSAoZW5kViAtIGluaXRWKSAqIHJlcGVhdHM7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjb250aW51ZScpIHtcbiAgICAgICAgdmFyIGZpcnN0VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGZpcnN0S2V5RnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xuICAgICAgICB2YXIgbmV4dEZpcnN0VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKChmaXJzdEtleUZyYW1lICsgMC4wMDEpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcblxuICAgICAgICBpZiAodGhpcy5wdi5sZW5ndGgpIHtcbiAgICAgICAgICByZXQgPSBuZXcgQXJyYXkoZmlyc3RWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgIGxlbiA9IHJldC5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHJldFtpXSA9IGZpcnN0VmFsdWVbaV0gKyAoZmlyc3RWYWx1ZVtpXSAtIG5leHRGaXJzdFZhbHVlW2ldKSAqIChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKSAvIDAuMDAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlyc3RWYWx1ZSArIChmaXJzdFZhbHVlIC0gbmV4dEZpcnN0VmFsdWUpICogKGZpcnN0S2V5RnJhbWUgLSBjdXJyZW50RnJhbWUpIC8gMC4wMDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlQXRUaW1lKChjeWNsZUR1cmF0aW9uIC0gKChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKSAlIGN5Y2xlRHVyYXRpb24gKyBmaXJzdEtleUZyYW1lKSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc21vb3RoKHdpZHRoLCBzYW1wbGVzKSB7XG4gICAgICBpZiAoIXRoaXMuaykge1xuICAgICAgICByZXR1cm4gdGhpcy5wdjtcbiAgICAgIH1cblxuICAgICAgd2lkdGggPSAod2lkdGggfHwgMC40KSAqIDAuNTtcbiAgICAgIHNhbXBsZXMgPSBNYXRoLmZsb29yKHNhbXBsZXMgfHwgNSk7XG5cbiAgICAgIGlmIChzYW1wbGVzIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHY7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50VGltZSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgdmFyIGluaXRGcmFtZSA9IGN1cnJlbnRUaW1lIC0gd2lkdGg7XG4gICAgICB2YXIgZW5kRnJhbWUgPSBjdXJyZW50VGltZSArIHdpZHRoO1xuICAgICAgdmFyIHNhbXBsZUZyZXF1ZW5jeSA9IHNhbXBsZXMgPiAxID8gKGVuZEZyYW1lIC0gaW5pdEZyYW1lKSAvIChzYW1wbGVzIC0gMSkgOiAxO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGogPSAwO1xuICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICBpZiAodGhpcy5wdi5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgdGhpcy5wdi5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2FtcGxlVmFsdWU7XG5cbiAgICAgIHdoaWxlIChpIDwgc2FtcGxlcykge1xuICAgICAgICBzYW1wbGVWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoaW5pdEZyYW1lICsgaSAqIHNhbXBsZUZyZXF1ZW5jeSk7XG5cbiAgICAgICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMucHYubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIHZhbHVlW2pdICs9IHNhbXBsZVZhbHVlW2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSArPSBzYW1wbGVWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLnB2Lmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgdmFsdWVbal0gLz0gc2FtcGxlcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgLz0gc2FtcGxlcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRyYW5zZm9ybVZhbHVlQXRUaW1lKHRpbWUpIHtcbiAgICAgIGlmICghdGhpcy5fdHJhbnNmb3JtQ2FjaGluZ0F0VGltZSkge1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1DYWNoaW5nQXRUaW1lID0ge1xuICAgICAgICAgIHY6IG5ldyBNYXRyaXgoKVxuICAgICAgICB9O1xuICAgICAgfSAvLy8gL1xuXG5cbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLl90cmFuc2Zvcm1DYWNoaW5nQXRUaW1lLnY7XG4gICAgICBtYXRyaXguY2xvbmVGcm9tUHJvcHModGhpcy5wcmUucHJvcHMpO1xuXG4gICAgICBpZiAodGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgMSkge1xuICAgICAgICB2YXIgYW5jaG9yID0gdGhpcy5hLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICBtYXRyaXgudHJhbnNsYXRlKC1hbmNob3JbMF0gKiB0aGlzLmEubXVsdCwgLWFuY2hvclsxXSAqIHRoaXMuYS5tdWx0LCBhbmNob3JbMl0gKiB0aGlzLmEubXVsdCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCAyKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMucy5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgbWF0cml4LnNjYWxlKHNjYWxlWzBdICogdGhpcy5zLm11bHQsIHNjYWxlWzFdICogdGhpcy5zLm11bHQsIHNjYWxlWzJdICogdGhpcy5zLm11bHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zayAmJiB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCAzKSB7XG4gICAgICAgIHZhciBza2V3ID0gdGhpcy5zay5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgdmFyIHNrZXdBeGlzID0gdGhpcy5zYS5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgbWF0cml4LnNrZXdGcm9tQXhpcygtc2tldyAqIHRoaXMuc2subXVsdCwgc2tld0F4aXMgKiB0aGlzLnNhLm11bHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5yICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDQpIHtcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gdGhpcy5yLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICBtYXRyaXgucm90YXRlKC1yb3RhdGlvbiAqIHRoaXMuci5tdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuciAmJiB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCA0KSB7XG4gICAgICAgIHZhciByb3RhdGlvblogPSB0aGlzLnJ6LmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICB2YXIgcm90YXRpb25ZID0gdGhpcy5yeS5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgdmFyIHJvdGF0aW9uWCA9IHRoaXMucnguZ2V0VmFsdWVBdFRpbWUodGltZSk7XG4gICAgICAgIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3IuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG4gICAgICAgIG1hdHJpeC5yb3RhdGVaKC1yb3RhdGlvblogKiB0aGlzLnJ6Lm11bHQpLnJvdGF0ZVkocm90YXRpb25ZICogdGhpcy5yeS5tdWx0KS5yb3RhdGVYKHJvdGF0aW9uWCAqIHRoaXMucngubXVsdCkucm90YXRlWigtb3JpZW50YXRpb25bMl0gKiB0aGlzLm9yLm11bHQpLnJvdGF0ZVkob3JpZW50YXRpb25bMV0gKiB0aGlzLm9yLm11bHQpLnJvdGF0ZVgob3JpZW50YXRpb25bMF0gKiB0aGlzLm9yLm11bHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kYXRhLnAgJiYgdGhpcy5kYXRhLnAucykge1xuICAgICAgICB2YXIgcG9zaXRpb25YID0gdGhpcy5weC5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uWSA9IHRoaXMucHkuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5wLnopIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb25aID0gdGhpcy5wei5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKHBvc2l0aW9uWCAqIHRoaXMucHgubXVsdCwgcG9zaXRpb25ZICogdGhpcy5weS5tdWx0LCAtcG9zaXRpb25aICogdGhpcy5wei5tdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKHBvc2l0aW9uWCAqIHRoaXMucHgubXVsdCwgcG9zaXRpb25ZICogdGhpcy5weS5tdWx0LCAwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICBtYXRyaXgudHJhbnNsYXRlKHBvc2l0aW9uWzBdICogdGhpcy5wLm11bHQsIHBvc2l0aW9uWzFdICogdGhpcy5wLm11bHQsIC1wb3NpdGlvblsyXSAqIHRoaXMucC5tdWx0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdHJpeDsgLy8vIC9cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1TdGF0aWNWYWx1ZUF0VGltZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnYuY2xvbmUobmV3IE1hdHJpeCgpKTtcbiAgICB9XG5cbiAgICB2YXIgZ2V0VHJhbnNmb3JtUHJvcGVydHkgPSBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkuZ2V0VHJhbnNmb3JtUHJvcGVydHk7XG5cbiAgICBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkuZ2V0VHJhbnNmb3JtUHJvcGVydHkgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSwgY29udGFpbmVyKSB7XG4gICAgICB2YXIgcHJvcCA9IGdldFRyYW5zZm9ybVByb3BlcnR5KGVsZW0sIGRhdGEsIGNvbnRhaW5lcik7XG5cbiAgICAgIGlmIChwcm9wLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICBwcm9wLmdldFZhbHVlQXRUaW1lID0gZ2V0VHJhbnNmb3JtVmFsdWVBdFRpbWUuYmluZChwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AuZ2V0VmFsdWVBdFRpbWUgPSBnZXRUcmFuc2Zvcm1TdGF0aWNWYWx1ZUF0VGltZS5iaW5kKHByb3ApO1xuICAgICAgfVxuXG4gICAgICBwcm9wLnNldEdyb3VwUHJvcGVydHkgPSBleHByZXNzaW9uSGVscGVycy5zZXRHcm91cFByb3BlcnR5O1xuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfTtcblxuICAgIHZhciBwcm9wZXJ0eUdldFByb3AgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcDtcblxuICAgIFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEsIHR5cGUsIG11bHQsIGNvbnRhaW5lcikge1xuICAgICAgdmFyIHByb3AgPSBwcm9wZXJ0eUdldFByb3AoZWxlbSwgZGF0YSwgdHlwZSwgbXVsdCwgY29udGFpbmVyKTsgLy8gcHJvcC5nZXRWZWxvY2l0eUF0VGltZSA9IGdldFZlbG9jaXR5QXRUaW1lO1xuICAgICAgLy8gcHJvcC5sb29wT3V0ID0gbG9vcE91dDtcbiAgICAgIC8vIHByb3AubG9vcEluID0gbG9vcEluO1xuXG4gICAgICBpZiAocHJvcC5rZikge1xuICAgICAgICBwcm9wLmdldFZhbHVlQXRUaW1lID0gZXhwcmVzc2lvbkhlbHBlcnMuZ2V0VmFsdWVBdFRpbWUuYmluZChwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AuZ2V0VmFsdWVBdFRpbWUgPSBleHByZXNzaW9uSGVscGVycy5nZXRTdGF0aWNWYWx1ZUF0VGltZS5iaW5kKHByb3ApO1xuICAgICAgfVxuXG4gICAgICBwcm9wLnNldEdyb3VwUHJvcGVydHkgPSBleHByZXNzaW9uSGVscGVycy5zZXRHcm91cFByb3BlcnR5O1xuICAgICAgcHJvcC5sb29wT3V0ID0gbG9vcE91dDtcbiAgICAgIHByb3AubG9vcEluID0gbG9vcEluO1xuICAgICAgcHJvcC5zbW9vdGggPSBzbW9vdGg7XG4gICAgICBwcm9wLmdldFZlbG9jaXR5QXRUaW1lID0gZXhwcmVzc2lvbkhlbHBlcnMuZ2V0VmVsb2NpdHlBdFRpbWUuYmluZChwcm9wKTtcbiAgICAgIHByb3AuZ2V0U3BlZWRBdFRpbWUgPSBleHByZXNzaW9uSGVscGVycy5nZXRTcGVlZEF0VGltZS5iaW5kKHByb3ApO1xuICAgICAgcHJvcC5udW1LZXlzID0gZGF0YS5hID09PSAxID8gZGF0YS5rLmxlbmd0aCA6IDA7XG4gICAgICBwcm9wLnByb3BlcnR5SW5kZXggPSBkYXRhLml4O1xuICAgICAgdmFyIHZhbHVlID0gMDtcblxuICAgICAgaWYgKHR5cGUgIT09IDApIHtcbiAgICAgICAgdmFsdWUgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgZGF0YS5hID09PSAxID8gZGF0YS5rWzBdLnMubGVuZ3RoIDogZGF0YS5rLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIHByb3AuX2NhY2hpbmdBdFRpbWUgPSB7XG4gICAgICAgIGxhc3RGcmFtZTogaW5pdGlhbERlZmF1bHRGcmFtZSxcbiAgICAgICAgbGFzdEluZGV4OiAwLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgICBleHByZXNzaW9uSGVscGVycy5zZWFyY2hFeHByZXNzaW9ucyhlbGVtLCBkYXRhLCBwcm9wKTtcblxuICAgICAgaWYgKHByb3Auaykge1xuICAgICAgICBjb250YWluZXIuYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0U2hhcGVWYWx1ZUF0VGltZShmcmFtZU51bSkge1xuICAgICAgLy8gRm9yIG5vdyB0aGlzIGNhY2hpbmcgb2JqZWN0IGlzIGNyZWF0ZWQgb25seSB3aGVuIG5lZWRlZCBpbnN0ZWFkIG9mIGNyZWF0aW5nIGl0IHdoZW4gdGhlIHNoYXBlIGlzIGluaXRpYWxpemVkLlxuICAgICAgaWYgKCF0aGlzLl9jYWNoaW5nQXRUaW1lKSB7XG4gICAgICAgIHRoaXMuX2NhY2hpbmdBdFRpbWUgPSB7XG4gICAgICAgICAgc2hhcGVWYWx1ZTogc2hhcGVQb29sLmNsb25lKHRoaXMucHYpLFxuICAgICAgICAgIGxhc3RJbmRleDogMCxcbiAgICAgICAgICBsYXN0VGltZTogaW5pdGlhbERlZmF1bHRGcmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmcmFtZU51bSAqPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICBmcmFtZU51bSAtPSB0aGlzLm9mZnNldFRpbWU7XG5cbiAgICAgIGlmIChmcmFtZU51bSAhPT0gdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0VGltZSkge1xuICAgICAgICB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RJbmRleCA9IHRoaXMuX2NhY2hpbmdBdFRpbWUubGFzdFRpbWUgPCBmcmFtZU51bSA/IHRoaXMuX2NhY2hpbmcubGFzdEluZGV4IDogMDtcbiAgICAgICAgdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0VGltZSA9IGZyYW1lTnVtO1xuICAgICAgICB0aGlzLmludGVycG9sYXRlU2hhcGUoZnJhbWVOdW0sIHRoaXMuX2NhY2hpbmdBdFRpbWUuc2hhcGVWYWx1ZSwgdGhpcy5fY2FjaGluZ0F0VGltZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9jYWNoaW5nQXRUaW1lLnNoYXBlVmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIFNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uID0gU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0Q29uc3RydWN0b3JGdW5jdGlvbigpO1xuICAgIHZhciBLZXlmcmFtZWRTaGFwZVByb3BlcnR5Q29uc3RydWN0b3JGdW5jdGlvbiA9IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldEtleWZyYW1lZENvbnN0cnVjdG9yRnVuY3Rpb24oKTtcblxuICAgIGZ1bmN0aW9uIFNoYXBlRXhwcmVzc2lvbnMoKSB7fVxuXG4gICAgU2hhcGVFeHByZXNzaW9ucy5wcm90b3R5cGUgPSB7XG4gICAgICB2ZXJ0aWNlczogZnVuY3Rpb24gdmVydGljZXMocHJvcCwgdGltZSkge1xuICAgICAgICBpZiAodGhpcy5rKSB7XG4gICAgICAgICAgdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNoYXBlUGF0aCA9IHRoaXMudjtcblxuICAgICAgICBpZiAodGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2hhcGVQYXRoID0gdGhpcy5nZXRWYWx1ZUF0VGltZSh0aW1lLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuID0gc2hhcGVQYXRoLl9sZW5ndGg7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHNoYXBlUGF0aFtwcm9wXTtcbiAgICAgICAgdmFyIHBvaW50cyA9IHNoYXBlUGF0aC52O1xuICAgICAgICB2YXIgYXJyID0gY3JlYXRlU2l6ZWRBcnJheShsZW4pO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChwcm9wID09PSAnaScgfHwgcHJvcCA9PT0gJ28nKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBbdmVydGljZXNbaV1bMF0gLSBwb2ludHNbaV1bMF0sIHZlcnRpY2VzW2ldWzFdIC0gcG9pbnRzW2ldWzFdXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyW2ldID0gW3ZlcnRpY2VzW2ldWzBdLCB2ZXJ0aWNlc1tpXVsxXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH0sXG4gICAgICBwb2ludHM6IGZ1bmN0aW9uIHBvaW50cyh0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRpY2VzKCd2JywgdGltZSk7XG4gICAgICB9LFxuICAgICAgaW5UYW5nZW50czogZnVuY3Rpb24gaW5UYW5nZW50cyh0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRpY2VzKCdpJywgdGltZSk7XG4gICAgICB9LFxuICAgICAgb3V0VGFuZ2VudHM6IGZ1bmN0aW9uIG91dFRhbmdlbnRzKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGljZXMoJ28nLCB0aW1lKTtcbiAgICAgIH0sXG4gICAgICBpc0Nsb3NlZDogZnVuY3Rpb24gaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnYuYztcbiAgICAgIH0sXG4gICAgICBwb2ludE9uUGF0aDogZnVuY3Rpb24gcG9pbnRPblBhdGgocGVyYywgdGltZSkge1xuICAgICAgICB2YXIgc2hhcGVQYXRoID0gdGhpcy52O1xuXG4gICAgICAgIGlmICh0aW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzaGFwZVBhdGggPSB0aGlzLmdldFZhbHVlQXRUaW1lKHRpbWUsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9zZWdtZW50c0xlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX3NlZ21lbnRzTGVuZ3RoID0gYmV6LmdldFNlZ21lbnRzTGVuZ3RoKHNoYXBlUGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VnbWVudHNMZW5ndGggPSB0aGlzLl9zZWdtZW50c0xlbmd0aDtcbiAgICAgICAgdmFyIGxlbmd0aHMgPSBzZWdtZW50c0xlbmd0aC5sZW5ndGhzO1xuICAgICAgICB2YXIgbGVuZ3RoUG9zID0gc2VnbWVudHNMZW5ndGgudG90YWxMZW5ndGggKiBwZXJjO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBsZW5ndGhzLmxlbmd0aDtcbiAgICAgICAgdmFyIGFjY3VtdWxhdGVkTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHB0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKGFjY3VtdWxhdGVkTGVuZ3RoICsgbGVuZ3Roc1tpXS5hZGRlZExlbmd0aCA+IGxlbmd0aFBvcykge1xuICAgICAgICAgICAgdmFyIGluaXRJbmRleCA9IGk7XG4gICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBzaGFwZVBhdGguYyAmJiBpID09PSBsZW4gLSAxID8gMCA6IGkgKyAxO1xuICAgICAgICAgICAgdmFyIHNlZ21lbnRQZXJjID0gKGxlbmd0aFBvcyAtIGFjY3VtdWxhdGVkTGVuZ3RoKSAvIGxlbmd0aHNbaV0uYWRkZWRMZW5ndGg7XG4gICAgICAgICAgICBwdCA9IGJlei5nZXRQb2ludEluU2VnbWVudChzaGFwZVBhdGgudltpbml0SW5kZXhdLCBzaGFwZVBhdGgudltlbmRJbmRleF0sIHNoYXBlUGF0aC5vW2luaXRJbmRleF0sIHNoYXBlUGF0aC5pW2VuZEluZGV4XSwgc2VnbWVudFBlcmMsIGxlbmd0aHNbaV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkTGVuZ3RoICs9IGxlbmd0aHNbaV0uYWRkZWRMZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwdCkge1xuICAgICAgICAgIHB0ID0gc2hhcGVQYXRoLmMgPyBbc2hhcGVQYXRoLnZbMF1bMF0sIHNoYXBlUGF0aC52WzBdWzFdXSA6IFtzaGFwZVBhdGgudltzaGFwZVBhdGguX2xlbmd0aCAtIDFdWzBdLCBzaGFwZVBhdGgudltzaGFwZVBhdGguX2xlbmd0aCAtIDFdWzFdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwdDtcbiAgICAgIH0sXG4gICAgICB2ZWN0b3JPblBhdGg6IGZ1bmN0aW9uIHZlY3Rvck9uUGF0aChwZXJjLCB0aW1lLCB2ZWN0b3JUeXBlKSB7XG4gICAgICAgIC8vIHBlcmMgZG9lc24ndCB1c2UgdHJpcGxlIGVxdWFsaXR5IGJlY2F1c2UgaXQgY2FuIGJlIGEgTnVtYmVyIG9iamVjdCBhcyB3ZWxsIGFzIGEgcHJpbWl0aXZlLlxuICAgICAgICBpZiAocGVyYyA9PSAxKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgICBwZXJjID0gdGhpcy52LmM7XG4gICAgICAgIH0gZWxzZSBpZiAocGVyYyA9PSAwKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgICBwZXJjID0gMC45OTk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHQxID0gdGhpcy5wb2ludE9uUGF0aChwZXJjLCB0aW1lKTtcbiAgICAgICAgdmFyIHB0MiA9IHRoaXMucG9pbnRPblBhdGgocGVyYyArIDAuMDAxLCB0aW1lKTtcbiAgICAgICAgdmFyIHhMZW5ndGggPSBwdDJbMF0gLSBwdDFbMF07XG4gICAgICAgIHZhciB5TGVuZ3RoID0gcHQyWzFdIC0gcHQxWzFdO1xuICAgICAgICB2YXIgbWFnbml0dWRlID0gTWF0aC5zcXJ0KE1hdGgucG93KHhMZW5ndGgsIDIpICsgTWF0aC5wb3coeUxlbmd0aCwgMikpO1xuXG4gICAgICAgIGlmIChtYWduaXR1ZGUgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVuaXRWZWN0b3IgPSB2ZWN0b3JUeXBlID09PSAndGFuZ2VudCcgPyBbeExlbmd0aCAvIG1hZ25pdHVkZSwgeUxlbmd0aCAvIG1hZ25pdHVkZV0gOiBbLXlMZW5ndGggLyBtYWduaXR1ZGUsIHhMZW5ndGggLyBtYWduaXR1ZGVdO1xuICAgICAgICByZXR1cm4gdW5pdFZlY3RvcjtcbiAgICAgIH0sXG4gICAgICB0YW5nZW50T25QYXRoOiBmdW5jdGlvbiB0YW5nZW50T25QYXRoKHBlcmMsIHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVjdG9yT25QYXRoKHBlcmMsIHRpbWUsICd0YW5nZW50Jyk7XG4gICAgICB9LFxuICAgICAgbm9ybWFsT25QYXRoOiBmdW5jdGlvbiBub3JtYWxPblBhdGgocGVyYywgdGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZWN0b3JPblBhdGgocGVyYywgdGltZSwgJ25vcm1hbCcpO1xuICAgICAgfSxcbiAgICAgIHNldEdyb3VwUHJvcGVydHk6IGV4cHJlc3Npb25IZWxwZXJzLnNldEdyb3VwUHJvcGVydHksXG4gICAgICBnZXRWYWx1ZUF0VGltZTogZXhwcmVzc2lvbkhlbHBlcnMuZ2V0U3RhdGljVmFsdWVBdFRpbWVcbiAgICB9O1xuICAgIGV4dGVuZFByb3RvdHlwZShbU2hhcGVFeHByZXNzaW9uc10sIFNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uKTtcbiAgICBleHRlbmRQcm90b3R5cGUoW1NoYXBlRXhwcmVzc2lvbnNdLCBLZXlmcmFtZWRTaGFwZVByb3BlcnR5Q29uc3RydWN0b3JGdW5jdGlvbik7XG4gICAgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eUNvbnN0cnVjdG9yRnVuY3Rpb24ucHJvdG90eXBlLmdldFZhbHVlQXRUaW1lID0gZ2V0U2hhcGVWYWx1ZUF0VGltZTtcbiAgICBLZXlmcmFtZWRTaGFwZVByb3BlcnR5Q29uc3RydWN0b3JGdW5jdGlvbi5wcm90b3R5cGUuaW5pdGlhdGVFeHByZXNzaW9uID0gRXhwcmVzc2lvbk1hbmFnZXIuaW5pdGlhdGVFeHByZXNzaW9uO1xuICAgIHZhciBwcm9wZXJ0eUdldFNoYXBlUHJvcCA9IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcDtcblxuICAgIFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcCA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhLCB0eXBlLCBhcnIsIHRyaW1zKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BlcnR5R2V0U2hhcGVQcm9wKGVsZW0sIGRhdGEsIHR5cGUsIGFyciwgdHJpbXMpO1xuICAgICAgcHJvcC5wcm9wZXJ0eUluZGV4ID0gZGF0YS5peDtcbiAgICAgIHByb3AubG9jayA9IGZhbHNlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gMykge1xuICAgICAgICBleHByZXNzaW9uSGVscGVycy5zZWFyY2hFeHByZXNzaW9ucyhlbGVtLCBkYXRhLnB0LCBwcm9wKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNCkge1xuICAgICAgICBleHByZXNzaW9uSGVscGVycy5zZWFyY2hFeHByZXNzaW9ucyhlbGVtLCBkYXRhLmtzLCBwcm9wKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3Auaykge1xuICAgICAgICBlbGVtLmFkZER5bmFtaWNQcm9wZXJ0eShwcm9wKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUkMSgpIHtcbiAgICBhZGRQcm9wZXJ0eURlY29yYXRvcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRGVjb3JhdG9yKCkge1xuICAgIGZ1bmN0aW9uIHNlYXJjaEV4cHJlc3Npb25zKCkge1xuICAgICAgaWYgKHRoaXMuZGF0YS5kLngpIHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVFeHByZXNzaW9uID0gRXhwcmVzc2lvbk1hbmFnZXIuaW5pdGlhdGVFeHByZXNzaW9uLmJpbmQodGhpcykodGhpcy5lbGVtLCB0aGlzLmRhdGEuZCwgdGhpcyk7XG4gICAgICAgIHRoaXMuYWRkRWZmZWN0KHRoaXMuZ2V0RXhwcmVzc2lvblZhbHVlLmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5nZXRFeHByZXNzaW9uVmFsdWUgPSBmdW5jdGlvbiAoY3VycmVudFZhbHVlLCB0ZXh0KSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLmNhbGN1bGF0ZUV4cHJlc3Npb24odGV4dCk7XG5cbiAgICAgIGlmIChjdXJyZW50VmFsdWUudCAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgdmFyIG5ld0RhdGEgPSB7fTtcbiAgICAgICAgdGhpcy5jb3B5RGF0YShuZXdEYXRhLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICBuZXdEYXRhLnQgPSBuZXdWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICBuZXdEYXRhLl9fY29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfTtcblxuICAgIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuc2VhcmNoUHJvcGVydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaXNLZXlmcmFtZWQgPSB0aGlzLnNlYXJjaEtleWZyYW1lcygpO1xuICAgICAgdmFyIGhhc0V4cHJlc3Npb25zID0gdGhpcy5zZWFyY2hFeHByZXNzaW9ucygpO1xuICAgICAgdGhpcy5rZiA9IGlzS2V5ZnJhbWVkIHx8IGhhc0V4cHJlc3Npb25zO1xuICAgICAgcmV0dXJuIHRoaXMua2Y7XG4gICAgfTtcblxuICAgIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuc2VhcmNoRXhwcmVzc2lvbnMgPSBzZWFyY2hFeHByZXNzaW9ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgYWRkRGVjb3JhdG9yKCk7XG4gIH1cblxuICBmdW5jdGlvbiBTVkdDb21wb3NhYmxlRWZmZWN0KCkge31cblxuICBTVkdDb21wb3NhYmxlRWZmZWN0LnByb3RvdHlwZSA9IHtcbiAgICBjcmVhdGVNZXJnZU5vZGU6IGZ1bmN0aW9uIGNyZWF0ZU1lcmdlTm9kZShyZXN1bHRJZCwgaW5zKSB7XG4gICAgICB2YXIgZmVNZXJnZSA9IGNyZWF0ZU5TKCdmZU1lcmdlJyk7XG4gICAgICBmZU1lcmdlLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgcmVzdWx0SWQpO1xuICAgICAgdmFyIGZlTWVyZ2VOb2RlO1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgZmVNZXJnZU5vZGUgPSBjcmVhdGVOUygnZmVNZXJnZU5vZGUnKTtcbiAgICAgICAgZmVNZXJnZU5vZGUuc2V0QXR0cmlidXRlKCdpbicsIGluc1tpXSk7XG4gICAgICAgIGZlTWVyZ2UuYXBwZW5kQ2hpbGQoZmVNZXJnZU5vZGUpO1xuICAgICAgICBmZU1lcmdlLmFwcGVuZENoaWxkKGZlTWVyZ2VOb2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZlTWVyZ2U7XG4gICAgfVxuICB9O1xuXG4gIHZhciBsaW5lYXJGaWx0ZXJWYWx1ZSA9ICcwLjMzMzMgMC4zMzMzIDAuMzMzMyAwIDAgMC4zMzMzIDAuMzMzMyAwLjMzMzMgMCAwIDAuMzMzMyAwLjMzMzMgMC4zMzMzIDAgMCAwIDAgMCc7XG5cbiAgZnVuY3Rpb24gU1ZHVGludEZpbHRlcihmaWx0ZXIsIGZpbHRlck1hbmFnZXIsIGVsZW0sIGlkLCBzb3VyY2UpIHtcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyO1xuICAgIHZhciBmZUNvbG9yTWF0cml4ID0gY3JlYXRlTlMoJ2ZlQ29sb3JNYXRyaXgnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndHlwZScsICdtYXRyaXgnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2xpbmVhclJHQicpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCBsaW5lYXJGaWx0ZXJWYWx1ZSArICcgMSAwJyk7XG4gICAgdGhpcy5saW5lYXJGaWx0ZXIgPSBmZUNvbG9yTWF0cml4O1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCArICdfdGludF8xJyk7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29sb3JNYXRyaXgpO1xuICAgIGZlQ29sb3JNYXRyaXggPSBjcmVhdGVOUygnZmVDb2xvck1hdHJpeCcpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd0eXBlJywgJ21hdHJpeCcpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnc1JHQicpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCAnMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMSAwJyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3Jlc3VsdCcsIGlkICsgJ190aW50XzInKTtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb2xvck1hdHJpeCk7XG4gICAgdGhpcy5tYXRyaXhGaWx0ZXIgPSBmZUNvbG9yTWF0cml4O1xuICAgIHZhciBmZU1lcmdlID0gdGhpcy5jcmVhdGVNZXJnZU5vZGUoaWQsIFtzb3VyY2UsIGlkICsgJ190aW50XzEnLCBpZCArICdfdGludF8yJ10pO1xuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZU1lcmdlKTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbU1ZHQ29tcG9zYWJsZUVmZmVjdF0sIFNWR1RpbnRGaWx0ZXIpO1xuXG4gIFNWR1RpbnRGaWx0ZXIucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5fbWRmKSB7XG4gICAgICB2YXIgY29sb3JCbGFjayA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnY7XG4gICAgICB2YXIgY29sb3JXaGl0ZSA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxXS5wLnY7XG4gICAgICB2YXIgb3BhY2l0eSA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1syXS5wLnYgLyAxMDA7XG4gICAgICB0aGlzLmxpbmVhckZpbHRlci5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsIGxpbmVhckZpbHRlclZhbHVlICsgJyAnICsgb3BhY2l0eSArICcgMCcpO1xuICAgICAgdGhpcy5tYXRyaXhGaWx0ZXIuc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCBjb2xvcldoaXRlWzBdIC0gY29sb3JCbGFja1swXSArICcgMCAwIDAgJyArIGNvbG9yQmxhY2tbMF0gKyAnICcgKyAoY29sb3JXaGl0ZVsxXSAtIGNvbG9yQmxhY2tbMV0pICsgJyAwIDAgMCAnICsgY29sb3JCbGFja1sxXSArICcgJyArIChjb2xvcldoaXRlWzJdIC0gY29sb3JCbGFja1syXSkgKyAnIDAgMCAwICcgKyBjb2xvckJsYWNrWzJdICsgJyAwIDAgMCAxIDAnKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gU1ZHRmlsbEZpbHRlcihmaWx0ZXIsIGZpbHRlck1hbmFnZXIsIGVsZW0sIGlkKSB7XG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcbiAgICB2YXIgZmVDb2xvck1hdHJpeCA9IGNyZWF0ZU5TKCdmZUNvbG9yTWF0cml4Jyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnbWF0cml4Jyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdzUkdCJyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsICcxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgncmVzdWx0JywgaWQpO1xuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUNvbG9yTWF0cml4KTtcbiAgICB0aGlzLm1hdHJpeEZpbHRlciA9IGZlQ29sb3JNYXRyaXg7XG4gIH1cblxuICBTVkdGaWxsRmlsdGVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xuICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuX21kZikge1xuICAgICAgdmFyIGNvbG9yID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudjtcbiAgICAgIHZhciBvcGFjaXR5ID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzZdLnAudjtcbiAgICAgIHRoaXMubWF0cml4RmlsdGVyLnNldEF0dHJpYnV0ZSgndmFsdWVzJywgJzAgMCAwIDAgJyArIGNvbG9yWzBdICsgJyAwIDAgMCAwICcgKyBjb2xvclsxXSArICcgMCAwIDAgMCAnICsgY29sb3JbMl0gKyAnIDAgMCAwICcgKyBvcGFjaXR5ICsgJyAwJyk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR1N0cm9rZUVmZmVjdChmaWwsIGZpbHRlck1hbmFnZXIsIGVsZW0pIHtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMucGF0aHMgPSBbXTtcbiAgfVxuXG4gIFNWR1N0cm9rZUVmZmVjdC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbUNoaWxkcmVuID0gdGhpcy5lbGVtLmxheWVyRWxlbWVudC5jaGlsZHJlbiB8fCB0aGlzLmVsZW0ubGF5ZXJFbGVtZW50LmNoaWxkTm9kZXM7XG4gICAgdmFyIHBhdGg7XG4gICAgdmFyIGdyb3VwUGF0aDtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgaWYgKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxXS5wLnYgPT09IDEpIHtcbiAgICAgIGxlbiA9IHRoaXMuZWxlbS5tYXNrTWFuYWdlci5tYXNrc1Byb3BlcnRpZXMubGVuZ3RoO1xuICAgICAgaSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMF0ucC52IC0gMTtcbiAgICAgIGxlbiA9IGkgKyAxO1xuICAgIH1cblxuICAgIGdyb3VwUGF0aCA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgZ3JvdXBQYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XG4gICAgZ3JvdXBQYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCAncm91bmQnKTtcbiAgICBncm91cFBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIDEpO1xuXG4gICAgZm9yIChpOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHBhdGggPSBjcmVhdGVOUygncGF0aCcpO1xuICAgICAgZ3JvdXBQYXRoLmFwcGVuZENoaWxkKHBhdGgpO1xuICAgICAgdGhpcy5wYXRocy5wdXNoKHtcbiAgICAgICAgcDogcGF0aCxcbiAgICAgICAgbTogaVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAzKSB7XG4gICAgICB2YXIgbWFzayA9IGNyZWF0ZU5TKCdtYXNrJyk7XG4gICAgICB2YXIgaWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICAgIG1hc2suc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgIG1hc2suc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCAnYWxwaGEnKTtcbiAgICAgIG1hc2suYXBwZW5kQ2hpbGQoZ3JvdXBQYXRoKTtcbiAgICAgIHRoaXMuZWxlbS5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQobWFzayk7XG4gICAgICB2YXIgZyA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICBnLnNldEF0dHJpYnV0ZSgnbWFzaycsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgaWQgKyAnKScpO1xuXG4gICAgICB3aGlsZSAoZWxlbUNoaWxkcmVuWzBdKSB7XG4gICAgICAgIGcuYXBwZW5kQ2hpbGQoZWxlbUNoaWxkcmVuWzBdKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbGVtLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChnKTtcbiAgICAgIHRoaXMubWFza2VyID0gbWFzaztcbiAgICAgIGdyb3VwUGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICcjZmZmJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMTBdLnAudiA9PT0gMSB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMTBdLnAudiA9PT0gMikge1xuICAgICAgaWYgKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAyKSB7XG4gICAgICAgIGVsZW1DaGlsZHJlbiA9IHRoaXMuZWxlbS5sYXllckVsZW1lbnQuY2hpbGRyZW4gfHwgdGhpcy5lbGVtLmxheWVyRWxlbWVudC5jaGlsZE5vZGVzO1xuXG4gICAgICAgIHdoaWxlIChlbGVtQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5lbGVtLmxheWVyRWxlbWVudC5yZW1vdmVDaGlsZChlbGVtQ2hpbGRyZW5bMF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxlbS5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQoZ3JvdXBQYXRoKTtcbiAgICAgIHRoaXMuZWxlbS5sYXllckVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdtYXNrJyk7XG4gICAgICBncm91cFBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnI2ZmZicpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMucGF0aE1hc2tlciA9IGdyb3VwUGF0aDtcbiAgfTtcblxuICBTVkdTdHJva2VFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5wYXRocy5sZW5ndGg7XG4gICAgdmFyIG1hc2s7XG4gICAgdmFyIHBhdGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLnBhdGhzW2ldLm0gIT09IC0xKSB7XG4gICAgICAgIG1hc2sgPSB0aGlzLmVsZW0ubWFza01hbmFnZXIudmlld0RhdGFbdGhpcy5wYXRoc1tpXS5tXTtcbiAgICAgICAgcGF0aCA9IHRoaXMucGF0aHNbaV0ucDtcblxuICAgICAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYgfHwgbWFzay5wcm9wLl9tZGYpIHtcbiAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZCcsIG1hc2subGFzdFBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s5XS5wLl9tZGYgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAuX21kZiB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbN10ucC5fbWRmIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s4XS5wLl9tZGYgfHwgbWFzay5wcm9wLl9tZGYpIHtcbiAgICAgICAgICB2YXIgZGFzaGFycmF5VmFsdWU7XG5cbiAgICAgICAgICBpZiAodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzddLnAudiAhPT0gMCB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOF0ucC52ICE9PSAxMDApIHtcbiAgICAgICAgICAgIHZhciBzID0gTWF0aC5taW4odGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzddLnAudiwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzhdLnAudikgKiAwLjAxO1xuICAgICAgICAgICAgdmFyIGUgPSBNYXRoLm1heCh0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbN10ucC52LCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOF0ucC52KSAqIDAuMDE7XG4gICAgICAgICAgICB2YXIgbCA9IHBhdGguZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgICAgIGRhc2hhcnJheVZhbHVlID0gJzAgMCAwICcgKyBsICogcyArICcgJztcbiAgICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gbCAqIChlIC0gcyk7XG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IDEgKyB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNF0ucC52ICogMiAqIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s5XS5wLnYgKiAwLjAxO1xuICAgICAgICAgICAgdmFyIHVuaXRzID0gTWF0aC5mbG9vcihsaW5lTGVuZ3RoIC8gc2VnbWVudCk7XG4gICAgICAgICAgICB2YXIgajtcblxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHVuaXRzOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgZGFzaGFycmF5VmFsdWUgKz0gJzEgJyArIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLnYgKiAyICogdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzldLnAudiAqIDAuMDEgKyAnICc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhc2hhcnJheVZhbHVlICs9ICcwICcgKyBsICogMTAgKyAnIDAgMCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhc2hhcnJheVZhbHVlID0gJzEgJyArIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLnYgKiAyICogdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzldLnAudiAqIDAuMDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBkYXNoYXJyYXlWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAuX21kZikge1xuICAgICAgdGhpcy5wYXRoTWFza2VyLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAudiAqIDIpO1xuICAgIH1cblxuICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNl0ucC5fbWRmKSB7XG4gICAgICB0aGlzLnBhdGhNYXNrZXIuc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzZdLnAudik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAxIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAyKSB7XG4gICAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzNdLnAuX21kZikge1xuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbM10ucC52O1xuICAgICAgICB0aGlzLnBhdGhNYXNrZXIuc2V0QXR0cmlidXRlKCdzdHJva2UnLCAncmdiKCcgKyBibUZsb29yKGNvbG9yWzBdICogMjU1KSArICcsJyArIGJtRmxvb3IoY29sb3JbMV0gKiAyNTUpICsgJywnICsgYm1GbG9vcihjb2xvclsyXSAqIDI1NSkgKyAnKScpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBTVkdUcml0b25lRmlsdGVyKGZpbHRlciwgZmlsdGVyTWFuYWdlciwgZWxlbSwgaWQpIHtcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyO1xuICAgIHZhciBmZUNvbG9yTWF0cml4ID0gY3JlYXRlTlMoJ2ZlQ29sb3JNYXRyaXgnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndHlwZScsICdtYXRyaXgnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2xpbmVhclJHQicpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCAnMC4zMzMzIDAuMzMzMyAwLjMzMzMgMCAwIDAuMzMzMyAwLjMzMzMgMC4zMzMzIDAgMCAwLjMzMzMgMC4zMzMzIDAuMzMzMyAwIDAgMCAwIDAgMSAwJyk7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29sb3JNYXRyaXgpO1xuICAgIHZhciBmZUNvbXBvbmVudFRyYW5zZmVyID0gY3JlYXRlTlMoJ2ZlQ29tcG9uZW50VHJhbnNmZXInKTtcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ3NSR0InKTtcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgaWQpO1xuICAgIHRoaXMubWF0cml4RmlsdGVyID0gZmVDb21wb25lbnRUcmFuc2ZlcjtcbiAgICB2YXIgZmVGdW5jUiA9IGNyZWF0ZU5TKCdmZUZ1bmNSJyk7XG4gICAgZmVGdW5jUi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGFibGUnKTtcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLmFwcGVuZENoaWxkKGZlRnVuY1IpO1xuICAgIHRoaXMuZmVGdW5jUiA9IGZlRnVuY1I7XG4gICAgdmFyIGZlRnVuY0cgPSBjcmVhdGVOUygnZmVGdW5jRycpO1xuICAgIGZlRnVuY0cuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RhYmxlJyk7XG4gICAgZmVDb21wb25lbnRUcmFuc2Zlci5hcHBlbmRDaGlsZChmZUZ1bmNHKTtcbiAgICB0aGlzLmZlRnVuY0cgPSBmZUZ1bmNHO1xuICAgIHZhciBmZUZ1bmNCID0gY3JlYXRlTlMoJ2ZlRnVuY0InKTtcbiAgICBmZUZ1bmNCLnNldEF0dHJpYnV0ZSgndHlwZScsICd0YWJsZScpO1xuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuYXBwZW5kQ2hpbGQoZmVGdW5jQik7XG4gICAgdGhpcy5mZUZ1bmNCID0gZmVGdW5jQjtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gIH1cblxuICBTVkdUcml0b25lRmlsdGVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xuICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuX21kZikge1xuICAgICAgdmFyIGNvbG9yMSA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnY7XG4gICAgICB2YXIgY29sb3IyID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzFdLnAudjtcbiAgICAgIHZhciBjb2xvcjMgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMl0ucC52O1xuICAgICAgdmFyIHRhYmxlUiA9IGNvbG9yM1swXSArICcgJyArIGNvbG9yMlswXSArICcgJyArIGNvbG9yMVswXTtcbiAgICAgIHZhciB0YWJsZUcgPSBjb2xvcjNbMV0gKyAnICcgKyBjb2xvcjJbMV0gKyAnICcgKyBjb2xvcjFbMV07XG4gICAgICB2YXIgdGFibGVCID0gY29sb3IzWzJdICsgJyAnICsgY29sb3IyWzJdICsgJyAnICsgY29sb3IxWzJdO1xuICAgICAgdGhpcy5mZUZ1bmNSLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB0YWJsZVIpO1xuICAgICAgdGhpcy5mZUZ1bmNHLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB0YWJsZUcpO1xuICAgICAgdGhpcy5mZUZ1bmNCLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB0YWJsZUIpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBTVkdQcm9MZXZlbHNGaWx0ZXIoZmlsdGVyLCBmaWx0ZXJNYW5hZ2VyLCBlbGVtLCBpZCkge1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XG4gICAgdmFyIGVmZmVjdEVsZW1lbnRzID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzO1xuICAgIHZhciBmZUNvbXBvbmVudFRyYW5zZmVyID0gY3JlYXRlTlMoJ2ZlQ29tcG9uZW50VHJhbnNmZXInKTsgLy8gUmVkXG5cbiAgICBpZiAoZWZmZWN0RWxlbWVudHNbMTBdLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxMF0ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzExXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTFdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1sxMl0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzEyXS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbMTNdLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxM10ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzE0XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTRdLnAudiAhPT0gMSkge1xuICAgICAgdGhpcy5mZUZ1bmNSID0gdGhpcy5jcmVhdGVGZUZ1bmMoJ2ZlRnVuY1InLCBmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgICB9IC8vIEdyZWVuXG5cblxuICAgIGlmIChlZmZlY3RFbGVtZW50c1sxN10ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzE3XS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMThdLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxOF0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzE5XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTldLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1syMF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzIwXS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMjFdLnAuayB8fCBlZmZlY3RFbGVtZW50c1syMV0ucC52ICE9PSAxKSB7XG4gICAgICB0aGlzLmZlRnVuY0cgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jRycsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIH0gLy8gQmx1ZVxuXG5cbiAgICBpZiAoZWZmZWN0RWxlbWVudHNbMjRdLnAuayB8fCBlZmZlY3RFbGVtZW50c1syNF0ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzI1XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMjVdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1syNl0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzI2XS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbMjddLnAuayB8fCBlZmZlY3RFbGVtZW50c1syN10ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzI4XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMjhdLnAudiAhPT0gMSkge1xuICAgICAgdGhpcy5mZUZ1bmNCID0gdGhpcy5jcmVhdGVGZUZ1bmMoJ2ZlRnVuY0InLCBmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgICB9IC8vIEFscGhhXG5cblxuICAgIGlmIChlZmZlY3RFbGVtZW50c1szMV0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzMxXS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMzJdLnAuayB8fCBlZmZlY3RFbGVtZW50c1szMl0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzMzXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMzNdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1szNF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzM0XS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMzVdLnAuayB8fCBlZmZlY3RFbGVtZW50c1szNV0ucC52ICE9PSAxKSB7XG4gICAgICB0aGlzLmZlRnVuY0EgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jQScsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIH0gLy8gUkdCXG5cblxuICAgIGlmICh0aGlzLmZlRnVuY1IgfHwgdGhpcy5mZUZ1bmNHIHx8IHRoaXMuZmVGdW5jQiB8fCB0aGlzLmZlRnVuY0EpIHtcbiAgICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnc1JHQicpO1xuICAgICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIH1cblxuICAgIGlmIChlZmZlY3RFbGVtZW50c1szXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbM10ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzRdLnAuayB8fCBlZmZlY3RFbGVtZW50c1s0XS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbNV0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzVdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1s2XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbNl0ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzddLnAuayB8fCBlZmZlY3RFbGVtZW50c1s3XS5wLnYgIT09IDEpIHtcbiAgICAgIGZlQ29tcG9uZW50VHJhbnNmZXIgPSBjcmVhdGVOUygnZmVDb21wb25lbnRUcmFuc2ZlcicpO1xuICAgICAgZmVDb21wb25lbnRUcmFuc2Zlci5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdzUkdCJyk7XG4gICAgICBmZUNvbXBvbmVudFRyYW5zZmVyLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgaWQpO1xuICAgICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgICAgdGhpcy5mZUZ1bmNSQ29tcG9zZWQgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jUicsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgICAgdGhpcy5mZUZ1bmNHQ29tcG9zZWQgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jRycsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgICAgdGhpcy5mZUZ1bmNCQ29tcG9zZWQgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jQicsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIH1cbiAgfVxuXG4gIFNWR1Byb0xldmVsc0ZpbHRlci5wcm90b3R5cGUuY3JlYXRlRmVGdW5jID0gZnVuY3Rpb24gKHR5cGUsIGZlQ29tcG9uZW50VHJhbnNmZXIpIHtcbiAgICB2YXIgZmVGdW5jID0gY3JlYXRlTlModHlwZSk7XG4gICAgZmVGdW5jLnNldEF0dHJpYnV0ZSgndHlwZScsICd0YWJsZScpO1xuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuYXBwZW5kQ2hpbGQoZmVGdW5jKTtcbiAgICByZXR1cm4gZmVGdW5jO1xuICB9O1xuXG4gIFNWR1Byb0xldmVsc0ZpbHRlci5wcm90b3R5cGUuZ2V0VGFibGVWYWx1ZSA9IGZ1bmN0aW9uIChpbnB1dEJsYWNrLCBpbnB1dFdoaXRlLCBnYW1tYSwgb3V0cHV0QmxhY2ssIG91dHB1dFdoaXRlKSB7XG4gICAgdmFyIGNudCA9IDA7XG4gICAgdmFyIHNlZ21lbnRzID0gMjU2O1xuICAgIHZhciBwZXJjO1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihpbnB1dEJsYWNrLCBpbnB1dFdoaXRlKTtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgoaW5wdXRCbGFjaywgaW5wdXRXaGl0ZSk7XG4gICAgdmFyIHRhYmxlID0gQXJyYXkuY2FsbChudWxsLCB7XG4gICAgICBsZW5ndGg6IHNlZ21lbnRzXG4gICAgfSk7XG4gICAgdmFyIGNvbG9yVmFsdWU7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgdmFyIG91dHB1dERlbHRhID0gb3V0cHV0V2hpdGUgLSBvdXRwdXRCbGFjaztcbiAgICB2YXIgaW5wdXREZWx0YSA9IGlucHV0V2hpdGUgLSBpbnB1dEJsYWNrO1xuXG4gICAgd2hpbGUgKGNudCA8PSAyNTYpIHtcbiAgICAgIHBlcmMgPSBjbnQgLyAyNTY7XG5cbiAgICAgIGlmIChwZXJjIDw9IG1pbikge1xuICAgICAgICBjb2xvclZhbHVlID0gaW5wdXREZWx0YSA8IDAgPyBvdXRwdXRXaGl0ZSA6IG91dHB1dEJsYWNrO1xuICAgICAgfSBlbHNlIGlmIChwZXJjID49IG1heCkge1xuICAgICAgICBjb2xvclZhbHVlID0gaW5wdXREZWx0YSA8IDAgPyBvdXRwdXRCbGFjayA6IG91dHB1dFdoaXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sb3JWYWx1ZSA9IG91dHB1dEJsYWNrICsgb3V0cHV0RGVsdGEgKiBNYXRoLnBvdygocGVyYyAtIGlucHV0QmxhY2spIC8gaW5wdXREZWx0YSwgMSAvIGdhbW1hKTtcbiAgICAgIH1cblxuICAgICAgdGFibGVbcG9zXSA9IGNvbG9yVmFsdWU7XG4gICAgICBwb3MgKz0gMTtcbiAgICAgIGNudCArPSAyNTYgLyAoc2VnbWVudHMgLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGUuam9pbignICcpO1xuICB9O1xuXG4gIFNWR1Byb0xldmVsc0ZpbHRlci5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoZm9yY2VSZW5kZXIpIHtcbiAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYpIHtcbiAgICAgIHZhciB2YWw7XG4gICAgICB2YXIgZWZmZWN0RWxlbWVudHMgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHM7XG5cbiAgICAgIGlmICh0aGlzLmZlRnVuY1JDb21wb3NlZCAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbM10ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzRdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1s1XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbNl0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzddLnAuX21kZikpIHtcbiAgICAgICAgdmFsID0gdGhpcy5nZXRUYWJsZVZhbHVlKGVmZmVjdEVsZW1lbnRzWzNdLnAudiwgZWZmZWN0RWxlbWVudHNbNF0ucC52LCBlZmZlY3RFbGVtZW50c1s1XS5wLnYsIGVmZmVjdEVsZW1lbnRzWzZdLnAudiwgZWZmZWN0RWxlbWVudHNbN10ucC52KTtcbiAgICAgICAgdGhpcy5mZUZ1bmNSQ29tcG9zZWQuc2V0QXR0cmlidXRlKCd0YWJsZVZhbHVlcycsIHZhbCk7XG4gICAgICAgIHRoaXMuZmVGdW5jR0NvbXBvc2VkLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB2YWwpO1xuICAgICAgICB0aGlzLmZlRnVuY0JDb21wb3NlZC5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZmVGdW5jUiAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbMTBdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1sxMV0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzEyXS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMTNdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1sxNF0ucC5fbWRmKSkge1xuICAgICAgICB2YWwgPSB0aGlzLmdldFRhYmxlVmFsdWUoZWZmZWN0RWxlbWVudHNbMTBdLnAudiwgZWZmZWN0RWxlbWVudHNbMTFdLnAudiwgZWZmZWN0RWxlbWVudHNbMTJdLnAudiwgZWZmZWN0RWxlbWVudHNbMTNdLnAudiwgZWZmZWN0RWxlbWVudHNbMTRdLnAudik7XG4gICAgICAgIHRoaXMuZmVGdW5jUi5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZmVGdW5jRyAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbMTddLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1sxOF0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzE5XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMjBdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1syMV0ucC5fbWRmKSkge1xuICAgICAgICB2YWwgPSB0aGlzLmdldFRhYmxlVmFsdWUoZWZmZWN0RWxlbWVudHNbMTddLnAudiwgZWZmZWN0RWxlbWVudHNbMThdLnAudiwgZWZmZWN0RWxlbWVudHNbMTldLnAudiwgZWZmZWN0RWxlbWVudHNbMjBdLnAudiwgZWZmZWN0RWxlbWVudHNbMjFdLnAudik7XG4gICAgICAgIHRoaXMuZmVGdW5jRy5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZmVGdW5jQiAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbMjRdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1syNV0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzI2XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMjddLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1syOF0ucC5fbWRmKSkge1xuICAgICAgICB2YWwgPSB0aGlzLmdldFRhYmxlVmFsdWUoZWZmZWN0RWxlbWVudHNbMjRdLnAudiwgZWZmZWN0RWxlbWVudHNbMjVdLnAudiwgZWZmZWN0RWxlbWVudHNbMjZdLnAudiwgZWZmZWN0RWxlbWVudHNbMjddLnAudiwgZWZmZWN0RWxlbWVudHNbMjhdLnAudik7XG4gICAgICAgIHRoaXMuZmVGdW5jQi5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZmVGdW5jQSAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbMzFdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1szMl0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzMzXS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMzRdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1szNV0ucC5fbWRmKSkge1xuICAgICAgICB2YWwgPSB0aGlzLmdldFRhYmxlVmFsdWUoZWZmZWN0RWxlbWVudHNbMzFdLnAudiwgZWZmZWN0RWxlbWVudHNbMzJdLnAudiwgZWZmZWN0RWxlbWVudHNbMzNdLnAudiwgZWZmZWN0RWxlbWVudHNbMzRdLnAudiwgZWZmZWN0RWxlbWVudHNbMzVdLnAudik7XG4gICAgICAgIHRoaXMuZmVGdW5jQS5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gU1ZHRHJvcFNoYWRvd0VmZmVjdChmaWx0ZXIsIGZpbHRlck1hbmFnZXIsIGVsZW0sIGlkLCBzb3VyY2UpIHtcbiAgICB2YXIgZ2xvYmFsRmlsdGVyU2l6ZSA9IGZpbHRlck1hbmFnZXIuY29udGFpbmVyLmdsb2JhbERhdGEucmVuZGVyQ29uZmlnLmZpbHRlclNpemU7XG4gICAgdmFyIGZpbHRlclNpemUgPSBmaWx0ZXJNYW5hZ2VyLmRhdGEuZnMgfHwgZ2xvYmFsRmlsdGVyU2l6ZTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKCd4JywgZmlsdGVyU2l6ZS54IHx8IGdsb2JhbEZpbHRlclNpemUueCk7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZSgneScsIGZpbHRlclNpemUueSB8fCBnbG9iYWxGaWx0ZXJTaXplLnkpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgZmlsdGVyU2l6ZS53aWR0aCB8fCBnbG9iYWxGaWx0ZXJTaXplLndpZHRoKTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBmaWx0ZXJTaXplLmhlaWdodCB8fCBnbG9iYWxGaWx0ZXJTaXplLmhlaWdodCk7XG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcbiAgICB2YXIgZmVHYXVzc2lhbkJsdXIgPSBjcmVhdGVOUygnZmVHYXVzc2lhbkJsdXInKTtcbiAgICBmZUdhdXNzaWFuQmx1ci5zZXRBdHRyaWJ1dGUoJ2luJywgJ1NvdXJjZUFscGhhJyk7XG4gICAgZmVHYXVzc2lhbkJsdXIuc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCArICdfZHJvcF9zaGFkb3dfMScpO1xuICAgIGZlR2F1c3NpYW5CbHVyLnNldEF0dHJpYnV0ZSgnc3RkRGV2aWF0aW9uJywgJzAnKTtcbiAgICB0aGlzLmZlR2F1c3NpYW5CbHVyID0gZmVHYXVzc2lhbkJsdXI7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlR2F1c3NpYW5CbHVyKTtcbiAgICB2YXIgZmVPZmZzZXQgPSBjcmVhdGVOUygnZmVPZmZzZXQnKTtcbiAgICBmZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ2R4JywgJzI1Jyk7XG4gICAgZmVPZmZzZXQuc2V0QXR0cmlidXRlKCdkeScsICcwJyk7XG4gICAgZmVPZmZzZXQuc2V0QXR0cmlidXRlKCdpbicsIGlkICsgJ19kcm9wX3NoYWRvd18xJyk7XG4gICAgZmVPZmZzZXQuc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCArICdfZHJvcF9zaGFkb3dfMicpO1xuICAgIHRoaXMuZmVPZmZzZXQgPSBmZU9mZnNldDtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVPZmZzZXQpO1xuICAgIHZhciBmZUZsb29kID0gY3JlYXRlTlMoJ2ZlRmxvb2QnKTtcbiAgICBmZUZsb29kLnNldEF0dHJpYnV0ZSgnZmxvb2QtY29sb3InLCAnIzAwZmYwMCcpO1xuICAgIGZlRmxvb2Quc2V0QXR0cmlidXRlKCdmbG9vZC1vcGFjaXR5JywgJzEnKTtcbiAgICBmZUZsb29kLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgaWQgKyAnX2Ryb3Bfc2hhZG93XzMnKTtcbiAgICB0aGlzLmZlRmxvb2QgPSBmZUZsb29kO1xuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUZsb29kKTtcbiAgICB2YXIgZmVDb21wb3NpdGUgPSBjcmVhdGVOUygnZmVDb21wb3NpdGUnKTtcbiAgICBmZUNvbXBvc2l0ZS5zZXRBdHRyaWJ1dGUoJ2luJywgaWQgKyAnX2Ryb3Bfc2hhZG93XzMnKTtcbiAgICBmZUNvbXBvc2l0ZS5zZXRBdHRyaWJ1dGUoJ2luMicsIGlkICsgJ19kcm9wX3NoYWRvd18yJyk7XG4gICAgZmVDb21wb3NpdGUuc2V0QXR0cmlidXRlKCdvcGVyYXRvcicsICdpbicpO1xuICAgIGZlQ29tcG9zaXRlLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgaWQgKyAnX2Ryb3Bfc2hhZG93XzQnKTtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb21wb3NpdGUpO1xuICAgIHZhciBmZU1lcmdlID0gdGhpcy5jcmVhdGVNZXJnZU5vZGUoaWQsIFtpZCArICdfZHJvcF9zaGFkb3dfNCcsIHNvdXJjZV0pO1xuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZU1lcmdlKTsgLy9cbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbU1ZHQ29tcG9zYWJsZUVmZmVjdF0sIFNWR0Ryb3BTaGFkb3dFZmZlY3QpO1xuXG4gIFNWR0Ryb3BTaGFkb3dFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5fbWRmKSB7XG4gICAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAuX21kZikge1xuICAgICAgICB0aGlzLmZlR2F1c3NpYW5CbHVyLnNldEF0dHJpYnV0ZSgnc3RkRGV2aWF0aW9uJywgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAudiAvIDQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzBdLnAuX21kZikge1xuICAgICAgICB2YXIgY29sID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzBdLnAudjtcbiAgICAgICAgdGhpcy5mZUZsb29kLnNldEF0dHJpYnV0ZSgnZmxvb2QtY29sb3InLCByZ2JUb0hleChNYXRoLnJvdW5kKGNvbFswXSAqIDI1NSksIE1hdGgucm91bmQoY29sWzFdICogMjU1KSwgTWF0aC5yb3VuZChjb2xbMl0gKiAyNTUpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC5fbWRmKSB7XG4gICAgICAgIHRoaXMuZmVGbG9vZC5zZXRBdHRyaWJ1dGUoJ2Zsb29kLW9wYWNpdHknLCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC52IC8gMjU1KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1syXS5wLl9tZGYgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzNdLnAuX21kZikge1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbM10ucC52O1xuICAgICAgICB2YXIgYW5nbGUgPSAodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudiAtIDkwKSAqIGRlZ1RvUmFkcztcbiAgICAgICAgdmFyIHggPSBkaXN0YW5jZSAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgdmFyIHkgPSBkaXN0YW5jZSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdGhpcy5mZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ2R4JywgeCk7XG4gICAgICAgIHRoaXMuZmVPZmZzZXQuc2V0QXR0cmlidXRlKCdkeScsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgX3N2Z01hdHRlU3ltYm9scyA9IFtdO1xuXG4gIGZ1bmN0aW9uIFNWR01hdHRlM0VmZmVjdChmaWx0ZXJFbGVtLCBmaWx0ZXJNYW5hZ2VyLCBlbGVtKSB7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XG4gICAgdGhpcy5maWx0ZXJFbGVtID0gZmlsdGVyRWxlbTtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIGVsZW0ubWF0dGVFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcbiAgICBlbGVtLm1hdHRlRWxlbWVudC5hcHBlbmRDaGlsZChlbGVtLmxheWVyRWxlbWVudCk7XG4gICAgZWxlbS5tYXR0ZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbS50cmFuc2Zvcm1lZEVsZW1lbnQpO1xuICAgIGVsZW0uYmFzZUVsZW1lbnQgPSBlbGVtLm1hdHRlRWxlbWVudDtcbiAgfVxuXG4gIFNWR01hdHRlM0VmZmVjdC5wcm90b3R5cGUuZmluZFN5bWJvbCA9IGZ1bmN0aW9uIChtYXNrKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBfc3ZnTWF0dGVTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAoX3N2Z01hdHRlU3ltYm9sc1tpXSA9PT0gbWFzaykge1xuICAgICAgICByZXR1cm4gX3N2Z01hdHRlU3ltYm9sc1tpXTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIFNWR01hdHRlM0VmZmVjdC5wcm90b3R5cGUucmVwbGFjZUluUGFyZW50ID0gZnVuY3Rpb24gKG1hc2ssIHN5bWJvbElkKSB7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBtYXNrLmxheWVyRWxlbWVudC5wYXJlbnROb2RlO1xuXG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gcGFyZW50Tm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAoY2hpbGRyZW5baV0gPT09IG1hc2subGF5ZXJFbGVtZW50KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgdmFyIG5leHRDaGlsZDtcblxuICAgIGlmIChpIDw9IGxlbiAtIDIpIHtcbiAgICAgIG5leHRDaGlsZCA9IGNoaWxkcmVuW2kgKyAxXTtcbiAgICB9XG5cbiAgICB2YXIgdXNlRWxlbSA9IGNyZWF0ZU5TKCd1c2UnKTtcbiAgICB1c2VFbGVtLnNldEF0dHJpYnV0ZSgnaHJlZicsICcjJyArIHN5bWJvbElkKTtcblxuICAgIGlmIChuZXh0Q2hpbGQpIHtcbiAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHVzZUVsZW0sIG5leHRDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodXNlRWxlbSk7XG4gICAgfVxuICB9O1xuXG4gIFNWR01hdHRlM0VmZmVjdC5wcm90b3R5cGUuc2V0RWxlbWVudEFzTWFzayA9IGZ1bmN0aW9uIChlbGVtLCBtYXNrKSB7XG4gICAgaWYgKCF0aGlzLmZpbmRTeW1ib2wobWFzaykpIHtcbiAgICAgIHZhciBzeW1ib2xJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgdmFyIG1hc2tlciA9IGNyZWF0ZU5TKCdtYXNrJyk7XG4gICAgICBtYXNrZXIuc2V0QXR0cmlidXRlKCdpZCcsIG1hc2subGF5ZXJJZCk7XG4gICAgICBtYXNrZXIuc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCAnYWxwaGEnKTtcblxuICAgICAgX3N2Z01hdHRlU3ltYm9scy5wdXNoKG1hc2spO1xuXG4gICAgICB2YXIgZGVmcyA9IGVsZW0uZ2xvYmFsRGF0YS5kZWZzO1xuICAgICAgZGVmcy5hcHBlbmRDaGlsZChtYXNrZXIpO1xuICAgICAgdmFyIHN5bWJvbCA9IGNyZWF0ZU5TKCdzeW1ib2wnKTtcbiAgICAgIHN5bWJvbC5zZXRBdHRyaWJ1dGUoJ2lkJywgc3ltYm9sSWQpO1xuICAgICAgdGhpcy5yZXBsYWNlSW5QYXJlbnQobWFzaywgc3ltYm9sSWQpO1xuICAgICAgc3ltYm9sLmFwcGVuZENoaWxkKG1hc2subGF5ZXJFbGVtZW50KTtcbiAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoc3ltYm9sKTtcbiAgICAgIHZhciB1c2VFbGVtID0gY3JlYXRlTlMoJ3VzZScpO1xuICAgICAgdXNlRWxlbS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycgKyBzeW1ib2xJZCk7XG4gICAgICBtYXNrZXIuYXBwZW5kQ2hpbGQodXNlRWxlbSk7XG4gICAgICBtYXNrLmRhdGEuaGQgPSBmYWxzZTtcbiAgICAgIG1hc2suc2hvdygpO1xuICAgIH1cblxuICAgIGVsZW0uc2V0TWF0dGUobWFzay5sYXllcklkKTtcbiAgfTtcblxuICBTVkdNYXR0ZTNFZmZlY3QucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluZCA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnY7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtLmNvbXAuZWxlbWVudHM7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBlbGVtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgaWYgKGVsZW1lbnRzW2ldICYmIGVsZW1lbnRzW2ldLmRhdGEuaW5kID09PSBpbmQpIHtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50QXNNYXNrKHRoaXMuZWxlbSwgZWxlbWVudHNbaV0pO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gIH07XG5cbiAgU1ZHTWF0dGUzRWZmZWN0LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBTVkdHYXVzc2lhbkJsdXJFZmZlY3QoZmlsdGVyLCBmaWx0ZXJNYW5hZ2VyLCBlbGVtLCBpZCkge1xuICAgIC8vIE91dHNldCB0aGUgZmlsdGVyIHJlZ2lvbiBieSAxMDAlIG9uIGFsbCBzaWRlcyB0byBhY2NvbW1vZGF0ZSBibHVyIGV4cGFuc2lvbi5cbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKCd4JywgJy0xMDAlJyk7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZSgneScsICctMTAwJScpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzMwMCUnKTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnMzAwJScpO1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XG4gICAgdmFyIGZlR2F1c3NpYW5CbHVyID0gY3JlYXRlTlMoJ2ZlR2F1c3NpYW5CbHVyJyk7XG4gICAgZmVHYXVzc2lhbkJsdXIuc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCk7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlR2F1c3NpYW5CbHVyKTtcbiAgICB0aGlzLmZlR2F1c3NpYW5CbHVyID0gZmVHYXVzc2lhbkJsdXI7XG4gIH1cblxuICBTVkdHYXVzc2lhbkJsdXJFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5fbWRmKSB7XG4gICAgICAvLyBFbXBpcmljYWwgdmFsdWUsIG1hdGNoaW5nIEFFJ3MgYmx1ciBhcHBlYXJhbmNlLlxuICAgICAgdmFyIGtCbHVycmluZXNzVG9TaWdtYSA9IDAuMztcbiAgICAgIHZhciBzaWdtYSA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnYgKiBrQmx1cnJpbmVzc1RvU2lnbWE7IC8vIERpbWVuc2lvbnMgbWFwcGluZzpcbiAgICAgIC8vXG4gICAgICAvLyAgIDEgLT4gaG9yaXpvbnRhbCAmIHZlcnRpY2FsXG4gICAgICAvLyAgIDIgLT4gaG9yaXpvbnRhbCBvbmx5XG4gICAgICAvLyAgIDMgLT4gdmVydGljYWwgb25seVxuICAgICAgLy9cblxuICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC52O1xuICAgICAgdmFyIHNpZ21hWCA9IGRpbWVuc2lvbnMgPT0gMyA/IDAgOiBzaWdtYTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcblxuICAgICAgdmFyIHNpZ21hWSA9IGRpbWVuc2lvbnMgPT0gMiA/IDAgOiBzaWdtYTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcblxuICAgICAgdGhpcy5mZUdhdXNzaWFuQmx1ci5zZXRBdHRyaWJ1dGUoJ3N0ZERldmlhdGlvbicsIHNpZ21hWCArICcgJyArIHNpZ21hWSk7IC8vIFJlcGVhdCBlZGdlcyBtYXBwaW5nOlxuICAgICAgLy9cbiAgICAgIC8vICAgMCAtPiBvZmYgLT4gZHVwbGljYXRlXG4gICAgICAvLyAgIDEgLT4gb24gIC0+IHdyYXBcblxuICAgICAgdmFyIGVkZ2VNb2RlID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudiA9PSAxID8gJ3dyYXAnIDogJ2R1cGxpY2F0ZSc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG5cbiAgICAgIHRoaXMuZmVHYXVzc2lhbkJsdXIuc2V0QXR0cmlidXRlKCdlZGdlTW9kZScsIGVkZ2VNb2RlKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gVHJhbnNmb3JtRWZmZWN0KCkge31cblxuICBUcmFuc2Zvcm1FZmZlY3QucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZWZmZWN0c01hbmFnZXIpIHtcbiAgICB0aGlzLmVmZmVjdHNNYW5hZ2VyID0gZWZmZWN0c01hbmFnZXI7XG4gICAgdGhpcy50eXBlID0gZWZmZWN0VHlwZXMuVFJBTlNGT1JNX0VGRkVDVDtcbiAgICB0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLm9wYWNpdHkgPSAtMTtcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB0aGlzLl9vcE1kZiA9IGZhbHNlO1xuICB9O1xuXG4gIFRyYW5zZm9ybUVmZmVjdC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoZm9yY2VGcmFtZSkge1xuICAgIHRoaXMuX29wTWRmID0gZmFsc2U7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG5cbiAgICBpZiAoZm9yY2VGcmFtZSB8fCB0aGlzLmVmZmVjdHNNYW5hZ2VyLl9tZGYpIHtcbiAgICAgIHZhciBlZmZlY3RFbGVtZW50cyA9IHRoaXMuZWZmZWN0c01hbmFnZXIuZWZmZWN0RWxlbWVudHM7XG4gICAgICB2YXIgYW5jaG9yID0gZWZmZWN0RWxlbWVudHNbMF0ucC52O1xuICAgICAgdmFyIHBvc2l0aW9uID0gZWZmZWN0RWxlbWVudHNbMV0ucC52O1xuICAgICAgdmFyIGlzVW5pZm9ybVNjYWxlID0gZWZmZWN0RWxlbWVudHNbMl0ucC52ID09PSAxO1xuICAgICAgdmFyIHNjYWxlSGVpZ2h0ID0gZWZmZWN0RWxlbWVudHNbM10ucC52O1xuICAgICAgdmFyIHNjYWxlV2lkdGggPSBpc1VuaWZvcm1TY2FsZSA/IHNjYWxlSGVpZ2h0IDogZWZmZWN0RWxlbWVudHNbNF0ucC52O1xuICAgICAgdmFyIHNrZXcgPSBlZmZlY3RFbGVtZW50c1s1XS5wLnY7XG4gICAgICB2YXIgc2tld0F4aXMgPSBlZmZlY3RFbGVtZW50c1s2XS5wLnY7XG4gICAgICB2YXIgcm90YXRpb24gPSBlZmZlY3RFbGVtZW50c1s3XS5wLnY7XG4gICAgICB0aGlzLm1hdHJpeC5yZXNldCgpO1xuICAgICAgdGhpcy5tYXRyaXgudHJhbnNsYXRlKC1hbmNob3JbMF0sIC1hbmNob3JbMV0sIGFuY2hvclsyXSk7XG4gICAgICB0aGlzLm1hdHJpeC5zY2FsZShzY2FsZVdpZHRoICogMC4wMSwgc2NhbGVIZWlnaHQgKiAwLjAxLCAxKTtcbiAgICAgIHRoaXMubWF0cml4LnJvdGF0ZSgtcm90YXRpb24gKiBkZWdUb1JhZHMpO1xuICAgICAgdGhpcy5tYXRyaXguc2tld0Zyb21BeGlzKC1za2V3ICogZGVnVG9SYWRzLCAoc2tld0F4aXMgKyA5MCkgKiBkZWdUb1JhZHMpO1xuICAgICAgdGhpcy5tYXRyaXgudHJhbnNsYXRlKHBvc2l0aW9uWzBdLCBwb3NpdGlvblsxXSwgMCk7XG4gICAgICB0aGlzLl9tZGYgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5vcGFjaXR5ICE9PSBlZmZlY3RFbGVtZW50c1s4XS5wLnYpIHtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gZWZmZWN0RWxlbWVudHNbOF0ucC52O1xuICAgICAgICB0aGlzLl9vcE1kZiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR1RyYW5zZm9ybUVmZmVjdChfLCBmaWx0ZXJNYW5hZ2VyKSB7XG4gICAgdGhpcy5pbml0KGZpbHRlck1hbmFnZXIpO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtUcmFuc2Zvcm1FZmZlY3RdLCBTVkdUcmFuc2Zvcm1FZmZlY3QpO1xuXG4gIGZ1bmN0aW9uIENWVHJhbnNmb3JtRWZmZWN0KGVmZmVjdHNNYW5hZ2VyKSB7XG4gICAgdGhpcy5pbml0KGVmZmVjdHNNYW5hZ2VyKTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbVHJhbnNmb3JtRWZmZWN0XSwgQ1ZUcmFuc2Zvcm1FZmZlY3QpO1xuXG4gIHJlZ2lzdGVyUmVuZGVyZXIoJ2NhbnZhcycsIENhbnZhc1JlbmRlcmVyKTtcbiAgcmVnaXN0ZXJSZW5kZXJlcignaHRtbCcsIEh5YnJpZFJlbmRlcmVyKTtcbiAgcmVnaXN0ZXJSZW5kZXJlcignc3ZnJywgU1ZHUmVuZGVyZXIpOyAvLyBSZWdpc3RlcmluZyBzaGFwZSBtb2RpZmllcnNcblxuICBTaGFwZU1vZGlmaWVycy5yZWdpc3Rlck1vZGlmaWVyKCd0bScsIFRyaW1Nb2RpZmllcik7XG4gIFNoYXBlTW9kaWZpZXJzLnJlZ2lzdGVyTW9kaWZpZXIoJ3BiJywgUHVja2VyQW5kQmxvYXRNb2RpZmllcik7XG4gIFNoYXBlTW9kaWZpZXJzLnJlZ2lzdGVyTW9kaWZpZXIoJ3JwJywgUmVwZWF0ZXJNb2RpZmllcik7XG4gIFNoYXBlTW9kaWZpZXJzLnJlZ2lzdGVyTW9kaWZpZXIoJ3JkJywgUm91bmRDb3JuZXJzTW9kaWZpZXIpO1xuICBTaGFwZU1vZGlmaWVycy5yZWdpc3Rlck1vZGlmaWVyKCd6eicsIFppZ1phZ01vZGlmaWVyKTtcbiAgU2hhcGVNb2RpZmllcnMucmVnaXN0ZXJNb2RpZmllcignb3AnLCBPZmZzZXRQYXRoTW9kaWZpZXIpOyAvLyBSZWdpc3RlcmluZyBleHByZXNzaW9uIHBsdWdpblxuXG4gIHNldEV4cHJlc3Npb25zUGx1Z2luKEV4cHJlc3Npb25zKTtcbiAgc2V0RXhwcmVzc2lvbkludGVyZmFjZXMoZ2V0SW50ZXJmYWNlKTtcbiAgaW5pdGlhbGl6ZSQxKCk7XG4gIGluaXRpYWxpemUoKTsgLy8gUmVnaXN0ZXJpbmcgc3ZnIGVmZmVjdHNcblxuICByZWdpc3RlckVmZmVjdCQxKDIwLCBTVkdUaW50RmlsdGVyLCB0cnVlKTtcbiAgcmVnaXN0ZXJFZmZlY3QkMSgyMSwgU1ZHRmlsbEZpbHRlciwgdHJ1ZSk7XG4gIHJlZ2lzdGVyRWZmZWN0JDEoMjIsIFNWR1N0cm9rZUVmZmVjdCwgZmFsc2UpO1xuICByZWdpc3RlckVmZmVjdCQxKDIzLCBTVkdUcml0b25lRmlsdGVyLCB0cnVlKTtcbiAgcmVnaXN0ZXJFZmZlY3QkMSgyNCwgU1ZHUHJvTGV2ZWxzRmlsdGVyLCB0cnVlKTtcbiAgcmVnaXN0ZXJFZmZlY3QkMSgyNSwgU1ZHRHJvcFNoYWRvd0VmZmVjdCwgdHJ1ZSk7XG4gIHJlZ2lzdGVyRWZmZWN0JDEoMjgsIFNWR01hdHRlM0VmZmVjdCwgZmFsc2UpO1xuICByZWdpc3RlckVmZmVjdCQxKDI5LCBTVkdHYXVzc2lhbkJsdXJFZmZlY3QsIHRydWUpO1xuICByZWdpc3RlckVmZmVjdCQxKDM1LCBTVkdUcmFuc2Zvcm1FZmZlY3QsIGZhbHNlKTtcbiAgcmVnaXN0ZXJFZmZlY3QoMzUsIENWVHJhbnNmb3JtRWZmZWN0KTtcblxuICByZXR1cm4gbG90dGllO1xuXG59KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lottie-web/build/player/lottie.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CCasper%5Cportfoliocaspervandamme%5Csrc%5Capp%5Ccontactme%5Cpage.tsx&server=false!":
/*!******************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CCasper%5Cportfoliocaspervandamme%5Csrc%5Capp%5Ccontactme%5Cpage.tsx&server=false! ***!
  \******************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/contactme/page.tsx */ \"(app-pages-browser)/./src/app/contactme/page.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz1DJTNBJTVDQ2FzcGVyJTVDcG9ydGZvbGlvY2FzcGVydmFuZGFtbWUlNUNzcmMlNUNhcHAlNUNjb250YWN0bWUlNUNwYWdlLnRzeCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/MWM3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXENhc3BlclxcXFxwb3J0Zm9saW9jYXNwZXJ2YW5kYW1tZVxcXFxzcmNcXFxcYXBwXFxcXGNvbnRhY3RtZVxcXFxwYWdlLnRzeFwiKSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CCasper%5Cportfoliocaspervandamme%5Csrc%5Capp%5Ccontactme%5Cpage.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/components/email.tsx":
/*!**************************************!*\
  !*** ./src/app/components/email.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\nfunction Email() {\n    _s();\n    const [tooltipText, setTooltipText] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"Click here to send me an email\");\n    const [copied, setCopied] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [tooltipVisible, setTooltipVisible] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    function copyToClipboard(text) {\n        const el = document.createElement(\"textarea\");\n        el.value = text;\n        document.body.appendChild(el);\n        el.select();\n        document.execCommand(\"Click here to send me an email\");\n        document.body.removeChild(el);\n        setCopied(true);\n        setTooltipText(\"Click here to send me an email\");\n        setTooltipVisible(true);\n    }\n    function resetTooltipText() {\n        if (copied) {\n            setTooltipText(\"Click here to send me an email\");\n            setCopied(false);\n            setTooltipVisible(false);\n        }\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n        className: \"xl:ml-20 lg:ml-20 ml-6 mt-6 w-80 3xl:w-7/12 bg-slate-800 py-2 px-4 rounded relative grid justify-items-start transition-all duration-2500\",\n        onClick: ()=>copyToClipboard(\"casper.van.damme@outlook.com\"),\n        onMouseEnter: ()=>setTooltipVisible(true),\n        onMouseLeave: ()=>setTooltipVisible(false),\n        href: \"mailto:caspervandamme03@gmail.com\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                className: \"text-slate-600 3xl:text-xl 3xl:mb-1  transition-all duration-2500\",\n                children: \"My e-mail address\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\components\\\\email.tsx\",\n                lineNumber: 35,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                className: \"text-sky-500 font-bold text-lg 3xl:text-2xl 3xl:mb-1  transition-all duration-2500\",\n                children: \"caspervandamme03@gmail.com\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\components\\\\email.tsx\",\n                lineNumber: 36,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                className: \"opacity-0 bg-black text-white text-center text-xs rounded-lg py-2 px-3 absolute bottom-7 left-1/2 transform -translate-x-1/2 pointer-events-none z-50 transition-opacity duration-150  \".concat(tooltipVisible ? \"opacity-100\" : \"\", \" transition-all duration-2500\"),\n                children: [\n                    tooltipText,\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                        className: \"absolute text-black h-2 w-full left-0 top-full\",\n                        x: \"0px\",\n                        y: \"0px\",\n                        viewBox: \"0 0 255 255\",\n                        xmlSpace: \"preserve\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"polygon\", {\n                            className: \"fill-current\",\n                            points: \"0,0 127.5,127.5 255,0\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\components\\\\email.tsx\",\n                            lineNumber: 48,\n                            columnNumber: 17\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\components\\\\email.tsx\",\n                        lineNumber: 41,\n                        columnNumber: 13\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\components\\\\email.tsx\",\n                lineNumber: 37,\n                columnNumber: 9\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\components\\\\email.tsx\",\n        lineNumber: 28,\n        columnNumber: 5\n    }, this);\n}\n_s(Email, \"oJHoc1olzuqWPk3qk2OAHx8sRn0=\");\n_c = Email;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Email);\nvar _c;\n$RefreshReg$(_c, \"Email\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29tcG9uZW50cy9lbWFpbC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXdDO0FBRXhDLFNBQVNFOztJQUNMLE1BQU0sQ0FBQ0MsYUFBYUMsZUFBZSxHQUFHSCwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUNJLFFBQVFDLFVBQVUsR0FBR0wsK0NBQVFBLENBQUM7SUFDckMsTUFBTSxDQUFDTSxnQkFBZ0JDLGtCQUFrQixHQUFHUCwrQ0FBUUEsQ0FBQztJQUVyRCxTQUFTUSxnQkFBZ0JDLElBQVE7UUFDN0IsTUFBTUMsS0FBS0MsU0FBU0MsYUFBYSxDQUFDO1FBQ2xDRixHQUFHRyxLQUFLLEdBQUdKO1FBQ1hFLFNBQVNHLElBQUksQ0FBQ0MsV0FBVyxDQUFDTDtRQUMxQkEsR0FBR00sTUFBTTtRQUNUTCxTQUFTTSxXQUFXLENBQUM7UUFDckJOLFNBQVNHLElBQUksQ0FBQ0ksV0FBVyxDQUFDUjtRQUMxQkwsVUFBVTtRQUNWRixlQUFlO1FBQ2ZJLGtCQUFrQjtJQUN0QjtJQUVBLFNBQVNZO1FBQ0wsSUFBSWYsUUFBUTtZQUNaRCxlQUFlO1lBQ2ZFLFVBQVU7WUFDVkUsa0JBQWtCO1FBQ2xCO0lBQ0o7SUFDRixxQkFDRSw4REFBQ2E7UUFDR0MsV0FBWTtRQUNaQyxTQUFTLElBQU1kLGdCQUFnQjtRQUMvQmUsY0FBYyxJQUFNaEIsa0JBQWtCO1FBQ3RDaUIsY0FBYyxJQUFNakIsa0JBQWtCO1FBQ3RDa0IsTUFBSzs7MEJBRUwsOERBQUNDO2dCQUFHTCxXQUFZOzBCQUFvRTs7Ozs7OzBCQUNwRiw4REFBQ007Z0JBQUdOLFdBQVk7MEJBQXFGOzs7Ozs7MEJBQ3JHLDhEQUFDTztnQkFDR1AsV0FBVywwTEFBOE4sT0FBcENmLGlCQUFpQixnQkFBZ0IsSUFBRzs7b0JBRXhPSjtrQ0FDRCw4REFBQzJCO3dCQUNHUixXQUFVO3dCQUNWUyxHQUFFO3dCQUNGQyxHQUFFO3dCQUNGQyxTQUFRO3dCQUNSQyxVQUFTO2tDQUVULDRFQUFDQzs0QkFBUWIsV0FBVTs0QkFBZWMsUUFBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLekQ7R0FsRFNsQztLQUFBQTtBQW9EVCwrREFBZUEsS0FBS0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL2NvbXBvbmVudHMvZW1haWwudHN4P2RmYmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuZnVuY3Rpb24gRW1haWwoKSB7XHJcbiAgICBjb25zdCBbdG9vbHRpcFRleHQsIHNldFRvb2x0aXBUZXh0XSA9IHVzZVN0YXRlKCdDbGljayBoZXJlIHRvIHNlbmQgbWUgYW4gZW1haWwnKTtcclxuICAgIGNvbnN0IFtjb3BpZWQsIHNldENvcGllZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbdG9vbHRpcFZpc2libGUsIHNldFRvb2x0aXBWaXNpYmxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICBmdW5jdGlvbiBjb3B5VG9DbGlwYm9hcmQodGV4dDphbnkpIHtcclxuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XHJcbiAgICAgICAgZWwudmFsdWUgPSB0ZXh0O1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xyXG4gICAgICAgIGVsLnNlbGVjdCgpO1xyXG4gICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdDbGljayBoZXJlIHRvIHNlbmQgbWUgYW4gZW1haWwnKTtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcclxuICAgICAgICBzZXRDb3BpZWQodHJ1ZSk7XHJcbiAgICAgICAgc2V0VG9vbHRpcFRleHQoJ0NsaWNrIGhlcmUgdG8gc2VuZCBtZSBhbiBlbWFpbCcpO1xyXG4gICAgICAgIHNldFRvb2x0aXBWaXNpYmxlKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlc2V0VG9vbHRpcFRleHQoKSB7XHJcbiAgICAgICAgaWYgKGNvcGllZCkge1xyXG4gICAgICAgIHNldFRvb2x0aXBUZXh0KCdDbGljayBoZXJlIHRvIHNlbmQgbWUgYW4gZW1haWwnKTtcclxuICAgICAgICBzZXRDb3BpZWQoZmFsc2UpO1xyXG4gICAgICAgIHNldFRvb2x0aXBWaXNpYmxlKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgcmV0dXJuIChcclxuICAgIDxhXHJcbiAgICAgICAgY2xhc3NOYW1lPXtgeGw6bWwtMjAgbGc6bWwtMjAgbWwtNiBtdC02IHctODAgM3hsOnctNy8xMiBiZy1zbGF0ZS04MDAgcHktMiBweC00IHJvdW5kZWQgcmVsYXRpdmUgZ3JpZCBqdXN0aWZ5LWl0ZW1zLXN0YXJ0IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTI1MDBgfVxyXG4gICAgICAgIG9uQ2xpY2s9eygpID0+IGNvcHlUb0NsaXBib2FyZCgnY2FzcGVyLnZhbi5kYW1tZUBvdXRsb29rLmNvbScpfVxyXG4gICAgICAgIG9uTW91c2VFbnRlcj17KCkgPT4gc2V0VG9vbHRpcFZpc2libGUodHJ1ZSl9XHJcbiAgICAgICAgb25Nb3VzZUxlYXZlPXsoKSA9PiBzZXRUb29sdGlwVmlzaWJsZShmYWxzZSl9XHJcbiAgICAgICAgaHJlZj1cIm1haWx0bzpjYXNwZXJ2YW5kYW1tZTAzQGdtYWlsLmNvbVwiXHJcbiAgICA+XHJcbiAgICAgICAgPGg0IGNsYXNzTmFtZT17YHRleHQtc2xhdGUtNjAwIDN4bDp0ZXh0LXhsIDN4bDptYi0xICB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yNTAwYH0+TXkgZS1tYWlsIGFkZHJlc3M8L2g0PlxyXG4gICAgICAgIDxoMyBjbGFzc05hbWU9e2B0ZXh0LXNreS01MDAgZm9udC1ib2xkIHRleHQtbGcgM3hsOnRleHQtMnhsIDN4bDptYi0xICB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yNTAwYH0+Y2FzcGVydmFuZGFtbWUwM0BnbWFpbC5jb208L2gzPlxyXG4gICAgICAgIDxzcGFuXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17YG9wYWNpdHktMCBiZy1ibGFjayB0ZXh0LXdoaXRlIHRleHQtY2VudGVyIHRleHQteHMgcm91bmRlZC1sZyBweS0yIHB4LTMgYWJzb2x1dGUgYm90dG9tLTcgbGVmdC0xLzIgdHJhbnNmb3JtIC10cmFuc2xhdGUteC0xLzIgcG9pbnRlci1ldmVudHMtbm9uZSB6LTUwIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi0xNTAgICR7dG9vbHRpcFZpc2libGUgPyAnb3BhY2l0eS0xMDAnIDogJyd9IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTI1MDBgfVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAge3Rvb2x0aXBUZXh0fVxyXG4gICAgICAgICAgICA8c3ZnXHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSB0ZXh0LWJsYWNrIGgtMiB3LWZ1bGwgbGVmdC0wIHRvcC1mdWxsXCJcclxuICAgICAgICAgICAgICAgIHg9XCIwcHhcIlxyXG4gICAgICAgICAgICAgICAgeT1cIjBweFwiXHJcbiAgICAgICAgICAgICAgICB2aWV3Qm94PVwiMCAwIDI1NSAyNTVcIlxyXG4gICAgICAgICAgICAgICAgeG1sU3BhY2U9XCJwcmVzZXJ2ZVwiXHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxwb2x5Z29uIGNsYXNzTmFtZT1cImZpbGwtY3VycmVudFwiIHBvaW50cz1cIjAsMCAxMjcuNSwxMjcuNSAyNTUsMFwiIC8+XHJcbiAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgIDwvc3Bhbj5cclxuICAgIDwvYT5cclxuICApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBFbWFpbDsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsIkVtYWlsIiwidG9vbHRpcFRleHQiLCJzZXRUb29sdGlwVGV4dCIsImNvcGllZCIsInNldENvcGllZCIsInRvb2x0aXBWaXNpYmxlIiwic2V0VG9vbHRpcFZpc2libGUiLCJjb3B5VG9DbGlwYm9hcmQiLCJ0ZXh0IiwiZWwiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ2YWx1ZSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInNlbGVjdCIsImV4ZWNDb21tYW5kIiwicmVtb3ZlQ2hpbGQiLCJyZXNldFRvb2x0aXBUZXh0IiwiYSIsImNsYXNzTmFtZSIsIm9uQ2xpY2siLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJocmVmIiwiaDQiLCJoMyIsInNwYW4iLCJzdmciLCJ4IiwieSIsInZpZXdCb3giLCJ4bWxTcGFjZSIsInBvbHlnb24iLCJwb2ludHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/components/email.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/components/logo.tsx":
/*!*************************************!*\
  !*** ./src/app/components/logo.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var lottie_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lottie-react */ \"(app-pages-browser)/./node_modules/lottie-react/build/index.umd.js\");\n/* harmony import */ var lottie_react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lottie_react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _public_avatars_avatar_loop_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../public/avatars/avatar_loop.json */ \"(app-pages-browser)/./public/avatars/avatar_loop.json\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (()=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((lottie_react__WEBPACK_IMPORTED_MODULE_1___default()), {\n            animationData: _public_avatars_avatar_loop_json__WEBPACK_IMPORTED_MODULE_3__,\n            loop: true\n        }, void 0, false, {\n            fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\components\\\\logo.tsx\",\n            lineNumber: 10,\n            columnNumber: 11\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\components\\\\logo.tsx\",\n        lineNumber: 9,\n        columnNumber: 5\n    }, undefined);\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29tcG9uZW50cy9sb2dvLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNpQztBQUNSO0FBQ29DO0FBRzdELCtEQUFlO0lBQ1gscUJBQ0EsOERBQUNHO2tCQUNLLDRFQUFDSCxxREFBTUE7WUFBQ0ksZUFBZUYsNkRBQU1BO1lBQUVHLE1BQU07Ozs7Ozs7Ozs7O0FBRy9DLEdBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9jb21wb25lbnRzL2xvZ28udHN4PzI4NDMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXHJcbmltcG9ydCBMb3R0aWUgZnJvbSBcImxvdHRpZS1yZWFjdFwiXHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcclxuaW1wb3J0IGF2YXRhciBmcm9tICcuLi8uLi8uLi9wdWJsaWMvYXZhdGFycy9hdmF0YXJfbG9vcC5qc29uJ1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0ICgpPT4ge1xyXG4gICAgcmV0dXJuKFxyXG4gICAgPGRpdj5cclxuICAgICAgICAgIDxMb3R0aWUgYW5pbWF0aW9uRGF0YT17YXZhdGFyfSBsb29wPXt0cnVlfS8+XHJcbiAgICA8L2Rpdj5cclxuICAgIClcclxufSJdLCJuYW1lcyI6WyJMb3R0aWUiLCJSZWFjdCIsImF2YXRhciIsImRpdiIsImFuaW1hdGlvbkRhdGEiLCJsb29wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/components/logo.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/contactme/page.tsx":
/*!************************************!*\
  !*** ./src/app/contactme/page.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Page; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _components_logo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/logo */ \"(app-pages-browser)/./src/app/components/logo.tsx\");\n/* harmony import */ var _components_email__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/email */ \"(app-pages-browser)/./src/app/components/email.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\nfunction Page() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"w-screen h-90% grid lg:grid-rows-2 lg:grid-flow-col lg:gap-40 lg:pt-28 mb-24 lg:mb-0\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"block md:hidden lg:hidden w-80\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_logo__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n                        fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\contactme\\\\page.tsx\",\n                        lineNumber: 10,\n                        columnNumber: 21\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\contactme\\\\page.tsx\",\n                    lineNumber: 9,\n                    columnNumber: 17\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"hidden md:block lg:hidden w-80\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_logo__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n                        fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\contactme\\\\page.tsx\",\n                        lineNumber: 13,\n                        columnNumber: 21\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\contactme\\\\page.tsx\",\n                    lineNumber: 12,\n                    columnNumber: 17\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"row-span-2 xl:mt-10 lg:w-7/12 sm:p-10 xl:p-0\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                    className: \"xl:text-5xl text-3xl 3xl:text-6xl font-semibold text-sky-500 3xl:pt-10 pl-6 lg:pl-20 xl:pt-0 lg:pt-8  transition-all duration-2500\",\n                                    children: \"Let's work together!\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\contactme\\\\page.tsx\",\n                                    lineNumber: 17,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    href: \"https://www.linkedin.com/in/casper-van-damme-18a98520b/\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                        className: \"block lg:hidden pr-6 pt-1 h-9\",\n                                        src: \"/icons/linkedin.png\",\n                                        alt: \"linkedin\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\contactme\\\\page.tsx\",\n                                        lineNumber: 19,\n                                        columnNumber: 29\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\contactme\\\\page.tsx\",\n                                    lineNumber: 18,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\contactme\\\\page.tsx\",\n                            lineNumber: 16,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                            className: \"xl:text-xl font-medium text-slate-700 pt-0 3xl:text-2xl xl:pt-3 pl-6 lg:pl-20  transition-all duration-2500\",\n                            children: \"Front-end development\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\contactme\\\\page.tsx\",\n                            lineNumber: 22,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                            className: \"text-slate-200 pt-3 pl-6 lg:pl-20 pr-5 3xl:text-xl  transition-all duration-2500\",\n                            children: \"I love working on the front-end of websites and apps. besides development I also like working on the design!\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\contactme\\\\page.tsx\",\n                            lineNumber: 23,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                            className: \"text-slate-200 pt-2 pl-6 lg:pl-20 pr-5 3xl:text-xl  transition-all duration-2500\",\n                            children: \"Do you wish to get in touch with me? Feel free to send me an email!\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\contactme\\\\page.tsx\",\n                            lineNumber: 24,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_email__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                            fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\contactme\\\\page.tsx\",\n                            lineNumber: 25,\n                            columnNumber: 21\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\contactme\\\\page.tsx\",\n                    lineNumber: 15,\n                    columnNumber: 17\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"hidden lg:block lg:row-span-2 lg:w-96 3xl:hidden\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_logo__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n                        fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\contactme\\\\page.tsx\",\n                        lineNumber: 28,\n                        columnNumber: 21\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\contactme\\\\page.tsx\",\n                    lineNumber: 27,\n                    columnNumber: 17\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"hidden 3xl:block lg:row-span-2 lg:w-96\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_logo__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n                        fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\contactme\\\\page.tsx\",\n                        lineNumber: 31,\n                        columnNumber: 21\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\contactme\\\\page.tsx\",\n                    lineNumber: 30,\n                    columnNumber: 17\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\contactme\\\\page.tsx\",\n            lineNumber: 8,\n            columnNumber: 13\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Casper\\\\portfoliocaspervandamme\\\\src\\\\app\\\\contactme\\\\page.tsx\",\n        lineNumber: 7,\n        columnNumber: 9\n    }, this);\n}\n_c = Page;\nvar _c;\n$RefreshReg$(_c, \"Page\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29udGFjdG1lL3BhZ2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQ3NDO0FBQ0U7QUFFekIsU0FBU0U7SUFDcEIscUJBQ0ksOERBQUNDO1FBQUtDLFdBQVU7a0JBQ1osNEVBQUNDO1lBQUlELFdBQVU7OzhCQUNYLDhEQUFDQztvQkFBSUQsV0FBVTs4QkFDWCw0RUFBQ0osd0RBQUlBOzs7Ozs7Ozs7OzhCQUVULDhEQUFDSztvQkFBSUQsV0FBVTs4QkFDWCw0RUFBQ0osd0RBQUlBOzs7Ozs7Ozs7OzhCQUVULDhEQUFDSztvQkFBSUQsV0FBVTs7c0NBQ1gsOERBQUNDOzRCQUFJRCxXQUFVOzs4Q0FDWCw4REFBQ0U7b0NBQUdGLFdBQVk7OENBQXFJOzs7Ozs7OENBQ3JKLDhEQUFDRztvQ0FBRUMsTUFBSzs4Q0FDSiw0RUFBQ0M7d0NBQUlMLFdBQVU7d0NBQWdDTSxLQUFNO3dDQUFzQkMsS0FBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7c0NBR3ZGLDhEQUFDQzs0QkFBR1IsV0FBWTtzQ0FBOEc7Ozs7OztzQ0FDOUgsOERBQUNTOzRCQUFHVCxXQUFZO3NDQUFtRjs7Ozs7O3NDQUNuRyw4REFBQ1M7NEJBQUdULFdBQVk7c0NBQW1GOzs7Ozs7c0NBQ25HLDhEQUFDSCx5REFBS0E7Ozs7Ozs7Ozs7OzhCQUVWLDhEQUFDSTtvQkFBSUQsV0FBVTs4QkFDWCw0RUFBQ0osd0RBQUlBOzs7Ozs7Ozs7OzhCQUVULDhEQUFDSztvQkFBSUQsV0FBVTs4QkFDWCw0RUFBQ0osd0RBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLekI7S0EvQndCRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL2NvbnRhY3RtZS9wYWdlLnRzeD9kNjdmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG5pbXBvcnQgTG9nbyBmcm9tIFwiLi4vY29tcG9uZW50cy9sb2dvXCI7XHJcbmltcG9ydCBFbWFpbCBmcm9tIFwiLi4vY29tcG9uZW50cy9lbWFpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUGFnZSAoKSB7XHJcbiAgICByZXR1cm4oXHJcbiAgICAgICAgPG1haW4gY2xhc3NOYW1lPVwiXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1zY3JlZW4gaC05MCUgZ3JpZCBsZzpncmlkLXJvd3MtMiBsZzpncmlkLWZsb3ctY29sIGxnOmdhcC00MCBsZzpwdC0yOCBtYi0yNCBsZzptYi0wXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJsb2NrIG1kOmhpZGRlbiBsZzpoaWRkZW4gdy04MFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxMb2dvLz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoaWRkZW4gbWQ6YmxvY2sgbGc6aGlkZGVuIHctODBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8TG9nby8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93LXNwYW4tMiB4bDptdC0xMCBsZzp3LTcvMTIgc206cC0xMCB4bDpwLTBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXhcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGgxIGNsYXNzTmFtZT17YHhsOnRleHQtNXhsIHRleHQtM3hsIDN4bDp0ZXh0LTZ4bCBmb250LXNlbWlib2xkIHRleHQtc2t5LTUwMCAzeGw6cHQtMTAgcGwtNiBsZzpwbC0yMCB4bDpwdC0wIGxnOnB0LTggIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTI1MDBgfT5MZXQncyB3b3JrIHRvZ2V0aGVyITwvaDE+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJodHRwczovL3d3dy5saW5rZWRpbi5jb20vaW4vY2FzcGVyLXZhbi1kYW1tZS0xOGE5ODUyMGIvXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzTmFtZT1cImJsb2NrIGxnOmhpZGRlbiBwci02IHB0LTEgaC05XCIgc3JjPXtgL2ljb25zL2xpbmtlZGluLnBuZ2B9IGFsdD1cImxpbmtlZGluXCIvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGgyIGNsYXNzTmFtZT17YHhsOnRleHQteGwgZm9udC1tZWRpdW0gdGV4dC1zbGF0ZS03MDAgcHQtMCAzeGw6dGV4dC0yeGwgeGw6cHQtMyBwbC02IGxnOnBsLTIwICB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yNTAwYH0+RnJvbnQtZW5kIGRldmVsb3BtZW50PC9oMj5cclxuICAgICAgICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPXtgdGV4dC1zbGF0ZS0yMDAgcHQtMyBwbC02IGxnOnBsLTIwIHByLTUgM3hsOnRleHQteGwgIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTI1MDBgfT5JIGxvdmUgd29ya2luZyBvbiB0aGUgZnJvbnQtZW5kIG9mIHdlYnNpdGVzIGFuZCBhcHBzLiBiZXNpZGVzIGRldmVsb3BtZW50IEkgYWxzbyBsaWtlIHdvcmtpbmcgb24gdGhlIGRlc2lnbiE8L2gzPlxyXG4gICAgICAgICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9e2B0ZXh0LXNsYXRlLTIwMCBwdC0yIHBsLTYgbGc6cGwtMjAgcHItNSAzeGw6dGV4dC14bCAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjUwMGB9PkRvIHlvdSB3aXNoIHRvIGdldCBpbiB0b3VjaCB3aXRoIG1lPyBGZWVsIGZyZWUgdG8gc2VuZCBtZSBhbiBlbWFpbCE8L2gzPlxyXG4gICAgICAgICAgICAgICAgICAgIDxFbWFpbC8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGlkZGVuIGxnOmJsb2NrIGxnOnJvdy1zcGFuLTIgbGc6dy05NiAzeGw6aGlkZGVuXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPExvZ28vPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhpZGRlbiAzeGw6YmxvY2sgbGc6cm93LXNwYW4tMiBsZzp3LTk2XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPExvZ28vPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvbWFpbj5cclxuICAgIClcclxufSJdLCJuYW1lcyI6WyJMb2dvIiwiRW1haWwiLCJQYWdlIiwibWFpbiIsImNsYXNzTmFtZSIsImRpdiIsImgxIiwiYSIsImhyZWYiLCJpbWciLCJzcmMiLCJhbHQiLCJoMiIsImgzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/contactme/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      case REACT_SERVER_CONTEXT_TYPE:\n        {\n          var context2 = type;\n          return (context2.displayName || context2._globalName) + '.Provider';\n        }\n\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe[prop-missing]\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      } // TODO(luna): This will currently only throw if the function component\n      // tries to access React/ReactDOM/props. We should probably make this throw\n      // in simple components too\n\n\n      var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n      // component, which we don't yet support. Attach a noop catch handler to\n      // silence the error.\n      // TODO: Implement component stacks for async client components?\n\n      if (maybePromise && typeof maybePromise.catch === 'function') {\n        maybePromise.catch(function () {});\n      }\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement$1(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement$1(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (hasOwnProperty.call(props, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(props).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV = jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkhBQTJIO0FBQzNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0VBQW9FOztBQUVwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7O0FBRWxHO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjs7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OztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4Q0FBOEMsZ0RBQWdELE1BQU0sYUFBYTs7QUFFakg7QUFDQSwrQ0FBK0Msa0NBQWtDLE9BQU87O0FBRXhGLHVHQUF1RyxjQUFjLFVBQVUsZ0dBQWdHLGtCQUFrQixVQUFVLFVBQVU7O0FBRXJRO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzPzVkMmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2VydmVyX2NvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgICBjYXNlIFJFQUNUX0NBQ0hFX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiAnQ2FjaGUnO1xuICAgICAgfVxuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNvbnRleHQyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gKGNvbnRleHQyLmRpc3BsYXlOYW1lIHx8IGNvbnRleHQyLl9nbG9iYWxOYW1lKSArICcuUHJvdmlkZXInO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgLy8gdHJpZXMgdG8gYWNjZXNzIFJlYWN0L1JlYWN0RE9NL3Byb3BzLiBXZSBzaG91bGQgcHJvYmFibHkgbWFrZSB0aGlzIHRocm93XG4gICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgIC8vIGNvbXBvbmVudCwgd2hpY2ggd2UgZG9uJ3QgeWV0IHN1cHBvcnQuIEF0dGFjaCBhIG5vb3AgY2F0Y2ggaGFuZGxlciB0b1xuICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgIGlmIChtYXliZVByb21pc2UgJiYgdHlwZW9mIG1heWJlUHJvbWlzZS5jYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/ZDRmZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/avatars/avatar_loop.json":
/*!*****************************************!*\
  !*** ./public/avatars/avatar_loop.json ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = JSON.parse('{"v":"4.8.0","meta":{"g":"LottieFiles AE 3.4.3","a":"","k":"","d":"","tc":""},"fr":60,"ip":0,"op":1001,"w":1500,"h":1500,"nm":"avatar_loop","ddd":0,"assets":[{"id":"image_0","w":3000,"h":2000,"u":"","p":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAC7gAAAfQCAYAAABSEhI6AAAACXBIWXMAAAABAAAAAQBPJcTWAAAAJHpUWHRDcmVhdG9yAAAImXNMyU9KVXBMK0ktUnBNS0tNLikGAEF6Bs5qehXFAAAgAElEQVR4nOzcTWtdVRiG4WftY5rGFmMioiYYpJRQjJ00UVAaQXTsL7YTIyJy2oHSUL8l1aiIiQda0ySe/Tqogw4dFHc+rmu4YMH9Ax7eBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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DNwBAAAAAAAAAAAAAMgEA3cAAAAAAAAAAAAAADLBwB0AAAAAAAAAAAAAgEwwcAcAAAAAAAAAAAAAIBMM3AEAAAAAAAAAAAAAyAQDdwAAAAAAAAAAAAAAMsHAHQAAAAAAAAAAAACATDBwBwAAAAAAAAAAAAAgEwzcAQAAAAAAAAAAAADIBAN3AAAAAAAAAAAAAAAywcAdAAAAAAAAAAAAAIBMMHAHAAAAAAAAAAAAACATDNwBAAAAAAAAAAAAAMgEA3cAAAAAAAAAAAAAADLBwB0AAAAAAAAAAAAAgEwwcAcAAAAAAAAAAAAAIBMM3AEAAAAAAAAAAAAAyAQDdwAAAAAAAAAAAAAAMsHAHQAAAAAAAAAAAACATDBwBwAAAAAAAAAAAAAgEwzcAQAAAAAAAAAAAADIBAN3AAAAAAAAAAAAAAAywcAdAAAAAAAAAAAAAIBMMHAHAAAAAAAAAAAAACATDNwBAAAAAAAAAAAAAMgEA3cAAAAAAAAAAAAAADLBwB0AAAAAAAAAAAAAgEwwcAcAAAAAAAAAAAAAIBMM3AEAAAAAAAAAAAAAyAQDdwAAAAAAAAAAAAAAMsHAHQAAAAAAAAAAAACATDBwBwAAAAAAAAAAAAAgEwzcAQAAAAAAAAAAAADIBAN3AAAAAAAAAAAAAAAywcAdAAAAAAAAAAAAAIBMMHAHAAAAAAAAAAAAACATDNwBAAAAAAAAAAAAAMgEA3cAAAAAAAAAAAAAADLBwB0AAAAAAAAAAAAAgEwwcAcAAAAAAAAAAAAAIBMM3AEAAAAAAAAAAAAAyAQDdwAAAAAAAAAAAAAAMsHAHQAAAAAAAAAAAACATDBwBwAAAAAAAAAAAAAgEwzcAQAAAAAAAAAAAADIBAN3AAAAAAAAAAAAAAAywcAdAAAAAAAAAAAAAIBMMHAHAAAAAAAAAAAAACATDNwBAAAAAAAAAAAAAMgEA3cAAAAAAAAAAAAAADLBwB0AAAAAAAAAAAAAgEwwcAcAAAAAAAAAAAAAIBMM3AEAAAAAAAAAAAAAyAQDdwAAAAAAAAAAAAAAMsHAHQAAAAAAAAAAAACATDBwBwAAAAAAAAAAAAAgEwzcAQAAAAAAAAAAAADIBAN3AAAAAAAAAAAAAAAywcAdAAAAAAAAAAAAAIBMMHAHAAAAAAAAAAAAACATDNwBAAAAAAAAAAAAAMgEA3cAAAAAAAAAAAAAADLBwB0AAAAAAAAAAAAAgEwwcAcAAAAAAAAAAAAAIBMM3AEAAAAAAAAAAAAAyAQDdwAAAAAAAAAAAAAAMsHAHQAAAAAAAAAAAACATDBwBwAAAAAAAAAAAAAgEwzcAQAAAAAAAAAAAADIBAN3AAAAAAAAAAAAAAAywcAdAAAAAAAAAAAAAIBMMHAHAAAAAAAAAAAAACATDNwBAAAAAAAAAAAAAMgEA3cAAAAAAAAAAAAAADLBwB0AAAAAAAAAAAAAgEwwcAcAAAAAAAAAAAAAIBMM3AEAAAAAAAAAAAAAyAQDdwAAAAAAAAAAAAAAMsHAHQAAAAAAAAAAAACATDBwBwAAAAAAAAAAAAAgEwzcAQAAAAAAAAAAAADIBAN3AAAAAAAAAAAAAAAywcAdAAAAAAAAAAAAAIBMMHAHAAAAAAAAAAAAACATDNwBAAAAAAAAAAAAAMgEA3cAAAAAAAAAAAAAADLBwB0AAAAAAAAAAAAAgEwwcAcAAAAAAAAAAAAAIBMM3AEAAAAAAAAAAAAAyAQDdwAAAAAAAAAAAAAAMsHAHQAAAAAAAAAAAACATDBwBwAAAAAAAAAAAAAgEwzcAQAAAAAAAAAAAADIBAN3AAAAAAAAAAAAAAAywcAdAAAAAAAAAAAAAIBMMHAHAAAAAAAAAAAAACATDNwBAAAAAAAAAAAAAMgEA3cAAAAAAAAAAAAAADLBwB0AAAAAAAAAAAAAgEwwcAcAAAAAAAAAAAAAIBMM3AEAAAAAAAAAAAAAyAQDdwAAAAAAAAAAAAAAMsHAHQAAAAAAAAAAAACATDBwBwAAAAAAAAAAAAAgEwzcAQAAAAAAAAAAAADIBAN3AAAAAAAAAAAAAAAywcAdAAAAAAAAAAAAAIBMMHAHAAAAAAAAAAAAACATDNwBAAAAAAAAAAAAAMgEA3cAAAAAAAAAAAAAADLBwB0AAAAAAAAAAAAAgEwwcAcAAAAAAAAAAAAAIBMM3AEAAAAAAAAAAAAAyAQDdwAAAAAAAAAAAAAAMsHAHQAAAAAAAAAAAACATDBwBwAAAAAAAAAAAAAgEwzcAQAAAAAAAAAAAADIBAN3AAAAAAAAAAAAAAAywcAdAAAAAAAAAMhbxQVFqRMAAAB4HwN3AACADCkp6JQ6AQAAAADySqcwcAcAAMgSA3cAAIAM6VLYOXUCAAAAAOSVzg6dAAAAyBQDdwAAAAAAAAAAAAAAMsHAHQAAIENKC0tSJwAAAABAXil1V0UAAIBMMXAHAADIkC4F3kwDAAAAAAAAAPKXgTsAAAAAAAAAkLdKC9xVEQAAIEsM3AEAADKkpKBT6gQAAAAAyCudC12TAwAAyBIDdwAAgAwpLeySOgEAAAAAAAAAIBkDdwAAAAAAAAAgb3UqKE6dAAAAwPsYuAMAAGRIVye4AwAAAMB+0831OAAAgMwxcAcAAMiQ8sKuqRMAAAAAIG8c4HocAABA5hi4AwAAZEj3ogNSJwAAAABAXigsLHQ9DgAAIIMM3AEAADKkZ1FZ6gQAAAAAyAu5XM4dFQEAADLIwB0AACBDyoq6pU4AAAAAgLzRo9iBEwAAAFlj4A4AAJAhBxYauAMAwP9n7/6j7a7re8+/P/vsnZyTfXJOcghJJCaIBwhqGhBCNdUQQlKqpIPcQWwVxWK9KLdW7VhLvdYWZ6zWcVqnulz+uL1Tx0p7q7VWW+lcB0hRK7QaUQso+WFrcrGBgfDDRIgnOZ/5Q2wrBSTh5Lz3d+/H4y/WYmWt57/ns1/r/QUAmC3e4wAAAHqPgTsAAEAPmRhyMQoAAAAAZssx7QXZCQAAADyMgTsAAEAP6Q6NRGeonZ0BAAAAAANhrDUvOwEAAICHMXAHAADoMRNlLDsBAAAAAAbCgqHR7AQAAAAexsAdAACgx/hRDQAAAABmx7zW3OwEAAAAHsbAHQAAoMf4LDIAAAAAzI6JIV9TBAAA6DUG7gAAAD1mYXt+dgIAAAAADIRlnUXZCQAAADyMgTsAAECPeeqcZdkJAAAAAND3OkPtWNRekJ0xO2o9kJ0AAADweBm4AwAAzTEgP8IsHhqQH9UAAAAAINFxLdfbAQAAepGBOwAAQI85rnNMdgIAAAAA9L3Fg3K9PSIi6vezCwAAAB4vA3cAAKBBBuNHmCd3FmcnAAAAAEDfe5JDEwAAAD3JwB0AAKDHLO1MRKvlzzUAAAAAOJqO6xybnTB7agzE8RAAAKA/WEwAAADNMSA/wnRKO45tDdLnkQEAAABg9q3wJUUAAICeZOAOAAA0R6s1lZ0wW/y4BgAAAABH19L2RHbC7Cllf3YCAADA42XgDgAANEet92QnzJYndY7JTgAAAACAvra4vTA7YTYZuAMAAI1h4A4AADRCjVoi4sHsjtlyXOfY7AQAAAAA6FutViuWdgbogvsAva0CAADNZ+AOAAA0QolSo9QHsjtmy4rO4uwEAAAAAOhby4cWR6e0szNmzwC9rQIAAM1n4A4AADTHdGtgfoSZnLssOwEAAAAA+tbK4eXZCbNrgN5WAQCA5jNwBwAAmqPU72UnzJbJOcdFZ2iALkgBAAAAwCx66pwBOzAxQG+rAABA8xm4AwAADVIfzC6YLZ3Sjqe2j8vOAAAAAIC+dMrcAbvgXuK+7AQAAIDHy8AdAABojtq6JzthNq0ctB/ZAAAAAGCWnDjnydkJs6uUvTVqyc4AAAB4PAzcAQCA5ih1oAbuT53jgjsAAAAAzLTOUDuWz1mcnTG7pusDJUrNzgAAAHg8DNwBAIDmqNN7sxNm0ylzV2QnAAAAAEDfeWp7AA9LDNjbKgAA0GwG7gAAQHOUzr3ZCbPppLkD9plkAAAAAJgFK+cuz06YfQP2tgoAADSbgTsAANAc5eD92QmzaVF7QYwPjWZnAAAAAEBfeeqcAbzgfqC1p0Yt2RkAAACPh4E7AADQCDVqifnjd2Z3zLaT57jiDgAAAAAz6ZS5K7ITZt+xI/tKlJqdAQAA8HgYuAMAAI1QotSydc1U1NiX3TKbnjb8lOwEAAAAAOgrJ80dsKMSNfaWrWumsjMAAAAeLwN3AACgae7IDphNp4+clJ0AAAAAAH3j+M7SWNRekJ0x2/ZkBwAAABwOA3cAAKBZSvlOdsJs+onhp2YnAAAAAEDfOHVkMjth9pVyd3YCAADA4TBwBwAAmmagrg0tai+I4ztLszMAAAAAoC+cNjyQX0wcqDdVAACg+QzcAQCAZqn1n7MTZttAXpUCAAAAgKPgtJETsxNm3wC+qQIAAM1m4A4AADRLLXuzE2bbgF6VAgAAAIAZ1W0Nx+TcZdkZs28A31QBAIBmM3AHAACapcS3sxNm20BelQIAAACAGXb6yMnZCVl2ZgcAAAAcDgN3AACgWVrTu7ITZtvk3GUxPjSanQEAAAAAjfaM4admJ+QYmv5OdgIAAMDhMHAHAACaZbr9z9kJGVYP6o9vAAAAADBDfnLklOyEHLX+U3YCAADA4TBwBwAAmmXO9O7shAxnjKzMTgAAAACAxmq1WnHK3BXZGTnmLxjIN1UAAKC5DNwBAIBGKbds2Bc19mZ3zLbVw5PZCQAAAADQWKvmnBDdoZHsjAx7ytY1U9kRAAAAh8PAHQAAaKJ/yg6YbatHJqPbGs7OAAAAAIBG+qnuT2QnZPl2dgAAAMDhMnAHAACap5Sd2QmzrVPa8ZzB/REOAAAAAJ6Qn5r3jOyEHDV2ZCcAAAAcLgN3AACggaa/lV2Q4dkjA/ojHAAAAAA8AeNDo/H04adkZ+SoZXt2AgAAwOEycAcAAJqntAbyR5n1o6dmJwAAAABA4zxr3tOiU9rZGVkG7muYAABA8xm4AwAADTT9j9kFGRa1F8TKuSuyMwAAAACgUQb7y4iHDNwBAIDGMXAHAACap8Zt2QlZnjXv6dkJAAAAANAoA/1lxFbZlZ0AAABwuAzcAQCA5tl2zneixr7sjAxnd0/LTgAAAACAxlg5d0Usai/IzshRY1/ZtvH27AwAAIDDZeAOAAA0TolSI2JbdkeG1SOT0W0NZ2cAAAAAQCMM9BcRS9ySnQAAAHAkDNwBAICm+kZ2QIZOacdzuj+RnQEAAAAAjfBT856RnZCnxteyEwAAAI6EgTsAANBUA/vjzNndZ2YnAAAAAEDPGx8ajTXzTsnOyLQjOwAAAOBIGLgDAACNU6OWiLg1uyPL2d3TojPUzs4AAAAAgJ62vntqdMpAv6MN7BsqAADQbAbuAABA45QoNcr0N7I7snSHRuLZw0/PzgAAAACAnnbe/GdnJ+Qq9avZCQAAAEfCwB0AAGimbRv/MWrsy87I8vxB/3EOAAAAAB7D+NBorJl3SnZGnhr7Yts538nOAAAAOBIG7gAAQCP94Ip73JLdkeXs7mnRGRrozysDAAAAwKNa3z01OmWA389KualEqdkZAAAAR8LAHQAAaK4aX8tOyNIdGokN856ZnQEAAAAAPem8Qf8CYq03ZScAAAAcKQN3AACguUpszU7IdHbXwB0AAAAAHm58aDTWzDslOyNZMXAHAAAay8AdAABopBq1xPTQl7I7Mp07/8zotoazMwAAAACgp5w7uiY6pZ2dkau2BvbrlwAAQPMZuAMAAI1UotQY794cNaayW7J0Sjue0/2J7AwAAAAA6CkbR8/ITshVYyrGuzdnZwAAABwpA3cAAKCxytY1UxHxD9kdmc6b/+zsBAAAAADoGeNDo7Fm3inZGdn+4aG3UwAAgEYycAcAAJruy9kBmZ7bXR3jQ6PZGQAAAADQE14w9tzolHZ2RrYvZAcAAAA8EQbuAABAs9Xy+eyETJ3SjheMPTc7AwAAAAB6wgXeyiJag/1mCgAA7rJhiQAAIABJREFUNJ+BOwAA0GytQ1/MTsjmRzsAAAAAiFg9PBmTc5dlZ+Sr0zfUqCU7AwAA4EgZuAMAAI1Wtm36VtTYnd2RaXLuslg9PJmdAQAAAACpLhhbl52Qr8busm3j7SVKzU4BAAA4UgbuAABA85VyY3ZCtp9fsDE7AQAAAADSdFvD8bz5P5md0Qs+lx0AAADwRBm4AwAAzVenP5+dkO3c+WfG+NBodgYAAAAApDhv/rOjOzSSndED6t9lFwAAADxRBu4AAEDz1fYXshOydUo7zh1dk50BAAAAACkuGD8rO6E3eCsFAAD6gIE7AADQfOPdm6PGvuyMbC9esCk7AQAAAABm3cq5K2LV8AnZGflq7Ivx7s3ZGQAAAE+UgTsAANB4ZeuaqSjlpuyObJNzl8Xq4cnsDAAAAACYVS8Ye252Qq+4sWxdM5UdAQAA8EQZuAMAAH1i+ovZBb3g5xdszE4AAAAAgFnTbQ3HBQbuP1DLF7ITAAAAZoKBOwAA0B9q+Xx2Qi84d/6ZsaQ9kZ0BAAAAALPiwvGzozs0kp3RG4amvZECAAB9wcAdAADoD3PK9VFj4D+/2ynteLEr7gAAAAAMgFarFS8a35Cd0RtqTEW79ffZGQAAADPBwB0AAOgL5ZYN+6KUG7M7esGLxjdEtzWcnQEAAAAAR9Wm7hmxfM7i7IxecX25ZcO+7AgAAICZYOAOAAD0j1r/MjuhF3SHRuLC8bOzMwAAAADgqHrpgnOzE3rJZ7MDAAAAZoqBOwAA0D/q0DXZCb3iReMbotXyJx8AAAAA/Wn18GScOnJidkYPGfqr7AIAAICZYu0AAAD0jx1nfTVq7M7O6AXL5yyOTd0zsjMAAAAA4Kh4xcR52Qm9o8busn39N7IzAAAAZoqBOwAA0DdKlBoRf53d0StevvD52QkAAAAAMOOWtCdiw+jp2Rm9xJsoAADQVwzcAQCAvlGjlmiV/ze7o1esGj4hzhw5JTsDAAAAAGbUyxc+Lzuht3gTBQAA+oyBOwAA0DdKlBoPtK+NGlPZLb3iFyc2ZycAAAAAwIwZHxqNC8aem53RO2pMxQPta7MzAAAAZpKBOwAA0FfKrnX3RCk3Znf0irXdVbF6eDI7AwAAAABmxKsmzo/u0Eh2Ru8o5caya9092RkAAAAzycAdAADoP9PhYtG/8Z+OuSA7AQAAAACesCXtiXjRgg3ZGb2l1r/MTgAAAJhpBu4AAEAfan06u6CXrO2uijNHTsnOAAAAAIAn5OULnxed0s7O6C116JrsBAAAgJlm4A4AAPSfHWd9NSL2ZGf0kl9edGF2AgAAAAAcMdfbH0GN3Q+9hQIAAPQVA3cAAKDvlCg1anwsu6OXnDpyoivuAAAAADTWqybOd7393/tkiVKzIwAAAGaagTsAANCfWvVT2Qm95vXHvig7AQAAAAAO25L2RJw//pzsjN5Tp/9bdgIAAMDRYOAOAAD0p9vO2RI1dmdn9JJVwyfEuu7q7AwAAAAAOCyutz+CGrtjx8YbszMAAACOBgN3AACgLz30ad5PZnf0ml9Z9KJotfwpCAAAAEAzuN7+KEr94+wEAACAo8WqAQAA6F8+0fvvTM5dFpu6Z2RnAAAAAMDj8rpFL3S9/ZFM1089dOQDAACg7xi4AwAA/WvHxhujxu7sjF5zxbEviW5rODsDAAAAAB7T6uHJ2Dy2Njuj99TYGTs23pidAQAAcLQYuAMAAH3roQtGn8zu6DWL2gviZQufl50BAAAAAI/pisUXZyf0plL/zPV2AACgnxm4AwAA/a1O/7fshF70yonNsaQ9kZ0BAAAAAI/o/LHnxKrhE7IzetN0+0+zEwAAAI4mA3cAAKC/7dh4Y9TYmZ3RazqlHa9b9MLsDAAAAAD4d7qtYW9Xj6bGzrJj/U3ZGQAAAEeTgTsAANDXSpQapf5Zdkcv2jy2NlYPT2ZnAAAAAMCPeNnC58Wi9oLsjN7krRMAABgABu4AAEBfq1GLT/Y+ujcvuSRaLX8aAgAAANAblrQn4pUTm7Mzepe3TgAAYABYMQAAAH2tRKllx/qbosZXslt60SlzV8TPjq7NzgAAAACAiIh43aIXRqe0szN6U42vlB3rb8rOAAAAONoM3AEAgL5Xo5aI+uHsjl71ukUvjG5rODsDAAAAgAG3engyNo85xvDovHECAACDwcAdAADoeyVKjQNzPho19mW39KJF7QXxS8f8z9kZAAAAAAywVqsVb15ySXZG76qxLw7M+Wh2BgAAwGwwcAcAAAZC2bXunoj4VHZHr7p44U/H6uHJ7AwAAAAABtRlC8+PU+auyM7oZZ966I0TAACg7xm4AwAAg6NV/6/shF525ZJLozPUzs4AAAAAYMAc31kalyw4Nzujt9Xp92UnAAAAzBYDdwAAYHDcds6WqLEzO6NXTc5dFr+44GezMwAAAAAYMG9afHF0h0ayM3pXjVtjx8YbszMAAABmi4E7AAAwMEqUGhEfzO7oZa+c2BzHd5ZmZwAAAAAwIM4fe06s7a7Kzuh1H37obRMAAGAgGLgDAACDpdQ/jhpT2Rm9qlPa8b8t/cVotfy5CAAAAMDRNT40Gr9+7MXZGb2txlQc6PxBdgYAAMBsslgAAAAGStm28fao9TPZHb3s1JET48L5Z2VnAAAAANDnrjj2JdEdGsnO6G2l/EXZte6e7AwAAIDZZOAOAAAMnlJcPPoxfmXRi2JJeyI7AwAAAIA+ta67OjaPrc3O6H1l+gPZCQAAALPNwB0AABg82zdcHTV2Z2f0su7QSLx1yaXZGQAAAAD0ofGh0bjS29OPV2Nn3HbOluwMAACA2WbgDgAADJwSpUbEe7M7et3a7qq4aPzs7AwAAAAA+swVx74kFrUXZGc0QP39h94yAQAABoqBOwAAMJjmlPdHjb3ZGb3uisUXx8q5K7IzAAAAAOgT5489JzaPrc3O6H019sWBOR/NzgAAAMhg4A4AAAycGrXELWfvj1L/S3ZLr+uUdrxj6WXRGWpnpwAAAADQcEvaE/Hrx16cndEMpb6v7Fp3T3YGAABABgN3AABg4JQo9aFP+743akxl9/S6ybnL4pcW/ofsDAAAAAAarNVqxbuedHl0h0ayU3rfD94s31ujluwUAACADAbuAADAwCrbNt4eER/L7miCSyfOi3Xd1dkZAAAAADTUZQvPj1NHTszOaIqPlW0bb3/oSAcAAMDAMXAHAAAGWx363eyEprhyyaUxPjSanQEAAABAw6wenoxXTmzOzmgOb5YAAMCAM3AHAAAG246zvho1rsnOaIJF7QXx1iWXZmcAAAAA0CDd1nC8fell0Snt7JRmqHFN2bH+puwMAACATAbuAADAQHvoM7//Z3ZHU2wYPT0uGj87OwMAAACAhnjz4kti+ZzF2RlN4q0SAAAYeAbuAAAA2zdcHTVuzc5oiisWXxyrhyezMwAAAADocReNnx2bx9ZmZzRHjVtj+4arszMAAACyGbgDAAADr0Sp0Sq/l93RFJ3Sjncf95pY0p7ITgEAAACgR60enowrFl+cndEw5V0PfXESAABgoBm4AwAAA69GLTE6/yMRsSe7pSkWtRfEO5ZeFq2WPysBAAAA+FHjQ6Px7uNeE53Szk5pjhq7Y2z+VdkZAAAAvcASAQAAGHglSo2tZxyMWt+e3dIkZ8xbGa+duDA7AwAAAIAe0mq14p1LXxWL2guyUxqmvqtsXTOVXQEAANALDNwBAAB+aGz8A1Fjd3ZGk1w6cV6cO//M7AwAAAAAesRrJy6Mtd1V2RnNUmN3jI1/IDsDAACgVxi4AwAAxL+54l7ibdktTXPl4ktj5dwV2RkAAAAAJFvXXR2XTpyXndE8rfJW19sBAAD+lYE7AADAvzV/7A+jxs7sjCbpDo3E7z7pl6LbGs5OAQAAACDJ8Z2l8c6lr87OaJ4aO2N0/keyMwAAAHqJgTsAAMBDSpRatq6ZilZ5R3ZL0yyfszh+e+l/jFbLn5kAAAAAg2Z8aDTet+xXojs0kp3SPLVcGVvPOJidAQAA0EssDwAAAB5udP5Hosat2RlNs2H09PiNRZdkZwAAAAAwizpD7Xjn0lfF8jmLs1Oap8bOGJ//pyVKzU4BAADoJQbuAAAAD1O2rpmK6or7kbhwwfq4ZOHzsjMAAAAAmCVvPfYVsba7KjujmWq5smxdM5WdAQAA0GsM3AEAAB7J+Pw/dcX9yLx20YVx7vwzszMAAAAAOMpefcwFsXlsbXZGM9W4NXacfVV2BgAAQC8ycAcAAHgEZeuaqWiV38ruaKJOacfbl14Wq4cns1MAAAAAOErOnX9mXH7MC7IzmqtVfqtEqdkZAAAAvahkBwAAAPSiGvUHfy+dtOXLUeL05JxGuuvgvfGK3e+Mb0/tyU4BAAAAYAadOXJKvP/Jb4hOaWenNFONr8T2DWsM3AEAAB6ZC+4AAACPoESpJUqNVn1jdktTLWoviHcf95oYHxrNTgEAAABghhzfWRq/f9xrjdufCG+OAAAAj8nAHQAA4DGU2zZeF7Vend3RVJNzl8W7n/Sa6Az5wRMAAACg6caHRuN9y34lukMj2SnNNV3/Im47Z4vr7QAAAI/OwB0AAODHav9q1JjKrmiqM+atjHctudzIHQAAAKDBuq3h+NCT3xjL5yzOTmmuGlNR2v/ZuB0AAOCxGbgDAAD8GGX7+m9ExPuzO5psw+jp8a4ll0er5c9QAAAAgKbptobjvce9Pk6ZuyI7pdlK/b2H3hoBAAB4DJYFAAAAj8eBzpVRY292RpNtGD093rb4ldkZAAAAAByGzlA7fvdJvxRnzFuZndJ0e+LBOe/MjgAAAGgCA3cAAIDHoexad0+UeFN2R9NtHlsbv3bsS7IzAAAAAHgcOkPteNeSy2Ntd1V2SvOV8htl17p7sjMAAACawMAdAADg8Zo/9odR4yvZGU138cKfjlcfc0F2BgAAAACPodVqxVuPfUVsGD09O6X5anwlRud/JDsDAACgKQzcAQAAHqeydc1UtOobszv6weXHvCAuWfi87AwAAAAAHsVvLLokNo+tzc7oD636xrJ1zVR2BgAAQFMYuAMAAByGctvG62K6/kV2Rz94w7E/FxeNnx2tlj9NAQAAAHrJrx37krhwwfrsjD5RPl5u23hddgUAAECTWBEAAAAcrlZ9Q9RwcWkG/MaSl8dLx8/NzgAAAADgIb927Evi4oU/nZ3RH2rsizj069kZAAAATWPgDgAAcJjKtk3filJ/L7ujX7zh2J+L1y+6KDsDAAAAYKC1Wq34zcW/YNw+k2r5P8q2Td/KzgAAAGgaA3cAAIAjMX/8LVHj1uyMfnHpxHlG7gAAAABJWq1WvG3xK+PCBeuzU/pHjVtjfP7bszMAAACaqGQHAAAANFVdee05Ucu12R395BP3Xh9vu+sjMT09nZ0CAAAAMBA6Q+1415LLY8Po6dkp/WV6+qdix8YbS5SanQIAANA0LrgDAAAcoXLbxuuixoeyO/rJhQvWx9sWvzJaLX+uAgAAABxt3dZwvHfp64zbZ1qN95Qdm24wbgcAADgyFgMAAABPxJzyhqixOzujn2weWxtvW/zK6Ay1s1MAAAAA+la3NRzvPe71sba7Kjulv9TYHXPKm7MzAAAAmszAHQAA4Im45ez9EXF5dka/2Ty2Nt615HIjdwAAAICjYHxoNN6/7A1xxryV2Sn96PJyy4Z92REAAABNVrIDAAAA+kE9ecvHIupF2R395msP7Ihf/s7vx32H/CYIAAAAMBOWtCfi/cv+l5icuyw7pf/UuCq2b3hZiVKzUwAAAJrMBXcAAIAZMf0rUWNvdkW/OXXkxLhq+Vvi+M7S7BQAAACAxls9PBl/vOItxu1HQ429UeoVxu0AAABPnIE7AADADCjbNt4eJd6U3dGPls9ZHH+y4jfjzJFTslMAAAAAGuvc+WfGB5a9IRa1F2Sn9KnyhrJt4+3ZFQAAAP2gZAcAAAD0k3ryls9F1HXZHf1oqh6M/7znQ/HZ734pOwUAAACgUS5Z+Lx4w7E/l53Rv2pcE9s3nOt6OwAAwMxwwR0AAGBGHfqFqLEvu6IfdUo73vWk/xSvPuaC7BQAAACAxnj9oouM24+mGnujTL/KuB0AAGDmuOAOAAAww+qJW14arfpH2R397BP3Xh/vuPujMXXoYHYKAAAAQE/qtobjzYsvic1ja7NT+tt0eVnZseGj2RkAAAD9xMAdAADgKKgnXffRKHFxdkc/u2H/zXHFng/GfYcczAcAAAD4t5a0J+L3jntNrBo+ITulv9W4qmw/56XZGQAAAP2mlR0AAADQlw50fjlq7MzO6Gdru6viquVvidXDk9kpAAAAAD3jzJFT4o9XvMW4/WirsTPmlFdnZwAAAPQjF9wBAACOknriNWujtK6PEp3sln42VQ/G/3rHh+PT9/9tdgoAAABAqovGz44rFl8cndLOTulvNaaiTq+PHRtvLFFqdg4AAEC/MXAHAAA4iurJ1/5ORLkiu2MQfOLe6+Mdd380pg4dzE4BAAAAmFXd1nC8efElsXlsbXbKYJguV5YdG96anQEAANCvDNwBAACOonrGlzvx3fs/HxHPym4ZBF97YEe88Z/fH3cc3JudAgAAADArju8sjXcf95qYnLssO2VQ/F3MH1tXtq6Zyg4BAADoVwbuAAAAR1k9+ZqnRm19LUqMZrcMgrsO3hu//s8fjC898M3sFAAAAICjal13dbxz6aujOzSSnTIYauyLMn1q2bbpW9kpAAAA/czAHQAAYBbUlVt+MWr9g+yOQTFVD8Z77vpEfOSe/yc7BQAAAGDGtVqteO3EhXHpxHnZKYNlurwsdpx9VYlSs1MAAAD6mYE7AADALKknb/lYRL0ou2OQ3LD/5vitO/4w7ji4NzsFAAAAYEYsaU/EO5ZeFmfMW5mdMlhqXFW2n/PS7AwAAIBB0MoOAAAAGBideEXUuDU7Y5Cs7a6KP17xlljXXZ2dAgAAAPCEnTv/zPjk8W8zbp9tNW6NOeXV2RkAAACDwgV3AACAWVRPuv5pEYe+ECUmslsGzWfuvyF++86PxP7pB7NTAAAAAA5LtzUcb158SWweW5udMnhq7I0yfWbZtulb2SkAAACDwsAdAABgltWTrtscJf4qu2MQ7Txwe7xpz4fitgO7slMAAAAAHpfVw5Px9qWXxfI5i7NTBlMpF5XbNvxZdgYAAMAgMXAHAABIUE++9nciyhXZHYNoqh6MP9j7mfjQPZ+O6enp7BwAAACAR9RqteKyhefH5ce8IDtlcE2XK8uODW/NzgAAABg0Bu4AAAAJatQSJ133V1HKedktg+qG/TfHO+68Kr49tSc7BQAAAOBHrJy7In5zyS/EquETslMGV41rYmzsvLJ1zVR2CgAAwKAxcAcAAEhQo5ZY8YUFMXfqS1FiMrtnUE3Vg/Geuz4RH73vs665AwAAAOk6Q+148dimeO2iC6NT2tk5g6vG7jjQObXsWndPdgoAAMAgMnAHAABIVE+8/plRDn0uSoxmtwyybx7YFb+557/GbQd2ZacAAAAAA2r18GRcueTSmJy7LDtlsNXYF3XorNhx1ldLlJqdAwAAMIgM3AEAAJLVE7e8NFr1j7I7Bt1UPRgfu3dLvO/uP4/90w9m5wAAAAADotsajv848T/FpRPnZacQEVHLpWX7hg9nZwAAAAwyA3cAAIAeUE+67oNR4rLsDiJ2f//OeOsdfxhfeuCb2SkAAABAn1vXXR1XLrk0FrUXZKcQEVHjPbF9w+tdbgcAAMhl4A4AANADatQSJ235bJTYlN3CD3zi3uvj9+/+s7jv0L7sFAAAAKDPLGlPxOsWvTA2j63NTuGHar06xsYvKFvXTGWnAAAADDoDdwAAgB5Rn7FlNL5fr48Sp2e38AP7Dz0Q777rY/EX+74QU4cOZucAAAAADdcZaseLxzbFqyfOj+7QSHYOP1Tj1jjQeW7Zte6e7BQAAAAM3AEAAHpKPfnaZVHLDVFieXYL/2r39++Md/5/V8Xn9389OwUAAABoqHXd1XHFsRfH8jmLs1P4UXsi6pqybePt2SEAAAD8gIE7AABAj6knXv/MKIc+FyVGs1v4UTfsvznecedV8e2pPdkpAAAAQEMc31kab1p8caztrspO4eFq7Is6dFbZsf6m7BQAAAD+lYE7AABAD6onXbc5Ij4ZJTrZLfyoqXowPnbvlnjf3X8e+6cfzM4BAAAAetT40Gi8auL8eNGCDdEp7ewcHq7GVET8h7L9nM9kpwAAAPCjDNwBAAB6VD35ussi4oPZHTyyuw7eGx+4+1Pxie9+Lqanp7NzAAAAgB7RGWrHi8c2xcsX/kwsai/IzuHR1Prasn3je7MzAAAA+PcM3AEAAHpUjVri5OveEVGuyG7h0e3+/p3xf9/z14buAAAAMOBarVb87OjauGzi/Fg+Z3F2Do+pvrNs2/jr2RUAAAA8MgN3AACAHlajljhpyx9FiYuzW3hsOw/cHh++56/jr/bdYOgOAAAAA6TVasWm7hnx2mNeaNjeCOXjse3snytRanYJAAAAj8zAHQAAoMfVZ2wZjam4OqKuy27hx9t54Pb4wN5PxWe/+6XsFAAAAOAoW9ddHa9ZdGGcMndFdgqPS/l8zJ+/sWxdM5VdAgAAwKMzcAcAAGiAH4zc6zUR8azsFh6fbx7YFf91718ZugMAAEAfOnPklPjVxS82bG+Wv4tO2RS3nL3f9XYAAIDeZuAOAADQEHXF5xfG3KlrosTp2S08fl97YEf8l71/GX/7wM0xPT2dnQMAAAAcoVarFZu6Z8TLFz4/Vg2fkJ3D4ahxaxzoPLfsWndPdgoAAAA/noE7AABAgzw0cv9ClHh6dguHZ/f374yP3bcl/uT+a2Lq0MHsHAAAAOBx6raG47z5z46XL3x+LJ+zODuHw1VjZ5S6vmzbeHt2CgAAAI+PgTsAAEBD1Kg/+Bvu5OuOi1qujxKTyUkcgbsO3ht/ef8X40/uvTbuOLg3OwcAAAB4FONDo/HiBZviovH1sai9IDuHI1Fjd5S61rgdAACgWQzcAQAAGqZGLXHytSdEtP42IpZm93BkpurB+Ox3vxQfvPvT8e2pPdk5AAAAwEOO7yyNn1twTrxowYbolHZ2Dkeqxu4o02eXbZu+lZ0CAADA4TFwBwAAaKh60vVPi3LoujByb7wt+74Sn7jv+vjbB26O6enp7BwAAAAYOK1WK54zsiouXvDTsba7KjuHJ25P1KFzyvb138gOAQAA4PAZuAMAADRYPfH6Z0Y5dE2UmMhu4Ym76+C98Zf3fzH+5N5r446De7NzAAAAoO8taU/Ez8z/yXjR+IZYPmdxdg4zocbeqEObYsdZXy1RanYOAAAAh8/AHQAAoOHqidesjdL6bJQYzW5h5tyw/+b48/s/F1u+d1NMHTqYnQMAAAB944fX2p8//9mxeWxtdg4zqca+qNPnxo6NNxq3AwAANJeBOwAAQB9wyb1//fCq+yfv+3x8e2pPdg4AAAA01g+vtb984c/EovaC7BxmWo29Uad/tuzYdEN2CgAAAE+MgTsAAECfqCde/8xoHbo6IpZmtzDzpurB+PoDO+Ovv3tjfHbfl+O+Q/uykwAAAKDnLWlPxFnd1fH8+c+OM+atzM7h6NkT00PnlR3rb8oOAQAA4IkzcAcAAOgj9aTrnxZx6L9HieXZLRxdW793W/zN/q/Gp+7/grE7AAAA/BvjQ6OxvntqnDN6ejy3uzo6pZ2dxNG1J+rQObH9rG+WKDU7BgAAgCfOwB0AAKDP1JOveWrU1mejxGR2C7PD2B0AAIBB120Nx8bRM4zaB02N3VGmz45tG//RuB0AAKB/GLgDAAD0oXrytcuils9GiadntzB7purB+ML+r8ff7v+H+Nz+r8cdB/dmJwEAAMBRs6Q9EWd1V8fG0TNizbxTjNoHTY1bo9Rzy7aNt2enAAAAMLMM3AEAAPpQjVpixRcWxNypa6LE6dk95Nj9/Tvj77/3jdiy/ytx44O3xtShg9lJAAAAcMRarVasmnNCnDN6epw572mxaviE7CSyGLcDAAD0NQN3AACAPvUvI/fhqb+OiGdl95Brqh6ML3/vm/HF790S//27f++6OwAAAI3wwyvtz+n+RPzkyNOiOzSSnUS2Gl+JA51NZde6e7JTAAAAODoM3AEAAPpYjVriGX/Tjam4OqKuy+6hd/zwuvtXH9weX3tgZ3x7ak92EgAAAMTxnaVx6shknDZ8UvzkvKfF8jmLs5PoKeXz0Ynzyi0b9mWXAAAAcPQYuAMAAAyAesaXO3H//X8YJS7ObqE33XXw3viHB78V3zywO764/x/iG1PfjqlDB7OzAAAA6GOtVitO6jw5njXv6XHK3BWxenjSoJ3HUD4enXiFcTsAAED/M3AHAAAYEDVqiRP/5jejVa/MbqH3TdWD8fUHdsbXH9wZtx74p7jtwd2x+9CdMT09nZ0GAABAA7VarVg+tDhWDi+Pp899SqwenozVI5PRKe3sNJqgxnti+4bXlyg1OwUAAICjz8AdAABgwNSVW34xpuv7o0Qnu4VmmaoHY9f374hdU3fENw/sjlse/FZsO/A/4o6De7PTAAAA6CHjQ6NxfGdJnDZyUjylszSeMmepMTtHpsZUlHhN2XbOh7JTAAAAmD0G7gAAAAOorrz2nJguH48SE9ktNN9dB++N7Qf+R3xn6u74p6k9sefg3bFnam98e+qOuO+Qr4YDAAD0ox+O2Jd2JmJp+5h4SmdpHNc5Jk6a++RY1F6QnUc/qLEvIn6+bD/nM9kpAAAAzC4DdwAAgAFUo5Y48XOnRTn0qSixPLuH/rX/0AOx5+De2DV1R3xn6u7Yc3Bv7Dl4dzwwfSDuPHhv3HtoX+yb/l7sn34wOxUAAICI6LaGY7Q1LxYMjcZYa148qXNMLBiaH0vbE3Fc55hY0VkSS9sT0R0ayU6ln9XYHXXoBWXH+puyUwDqTs+nAAAayklEQVQAAJh9Bu4AAAADrJ587bKo5dNR4vTsFgbb/kMPxAP1QNx16P645+D9sffQd+PB6e/H/dP7IyLiwToV35t+MOa1huPug/f+y7+776H/DwAAwI8ab3X/5b9HWsMxrzUcERHDpRMREWOtbgy35sTE0PxY2B6LRUNjMT40Gp3STumFf1HjK1Hq+WXbxtuzUwAAAMhh4A4AADDg6jO2jMb3p/80SjkvuwUAAACAAVbr1XFgzkvLrnX3ZKcAAACQp5UdAAAAQK5yy4Z9MTZ+QdR4T3YLAAAAAAOqxntibPwC43YAAABccAcAAOBf1BO3vDRKfX+UGM1uAQAAAGAA1NgXUX65bN/w4ewUAAAAeoOBOwAAAD+innj9M6Mc+niUmMxuAQAAAKCP1dgZdeiismP9TdkpAAAA9I5WdgAAAAC9pexYf1PMKafFdP2L7BYAAAAA+lStV8eBzpnG7QAAADycC+4AAAA8ohq1xElbfjVK/O/ZLQAAAAD0k/rO2HbOm0qUml0CAABA7zFwBwAA4DHVk67bHBEfiRIT2S0AAAAANFiNvRFxSdl+zmeyUwAAAOhdBu4AAAA8phq1xMnXHRe1fDpKnJ7dAwAAAEAD1fhKlOmLyrZN38pOAQAAoLe1sgMAAADobSVKLds23h5zyvqocVV2DwAAAAANU+NDMaesN24HAADg8XDBHQAAgMNSV255YUzXD0aJiewWAAAAAHpYjb1Ry+tix9lXlSg1OwcAAIBmMHAHAADgsNWTr10W0fqTiLouuwUAAACAnvR3EdMvcbUdAACAw2XgDgAAwGGrUX/w9+RJ170movxulOgkJwEAAADQC2pMRS2/HePz3162rpnKzgEAAKB5DNwBAAB4QuqJ1z8zyqGPR4nJ7BYAAAAAEtXYGXX6ZWXHphuyUwAAAGiuVnYAAAAAzVZ2rL8p5pTTosZ7slsAAAAASFLjqphTTjNuBwAA4IlywR0AAIAZU1dueWFM1w9GiYnsFgAAAABmQY29Ucvryo4NH81OAQAAoD8YuAMAADCj6snXLosaH4pSzstuAQAAAOAoqvXqKHFZ2bbx9uwUAAAA+oeBOwAAAEdFXbnlhVHreyNiaXYLAAAAADNqT0yXN7raDgAAwNFg4A4AAMBRU1d8fmHMnfqdKHFZdgsAAAAAM6F8PB5sv6rsWndPdgkAAAD9ycAdAACAo66uvPacmC4fihKT2S0AAAAAHIEaO6NVL/v/2bu7UL8LOo7jn+9/npl02tq6MYYj1nGmFrVN0MC1x5sKLIq6SKiIHqGICuym7LmoqCgIDIKIKMjqokC7ca45oYRtBTVtD67QKG+amUeynZ3/t4s5teXygbP9zsPrdfk7MN63v7PP+f5yaPvuJKlUD50EAADA4jQaOgAAAIDFrw7tuD0rVlye9JfTmRm6BwAAAIBnqDOTzreyvF6VQ9t3V6qN2wEAADiXXHAHAADgvOqpPRtSs99NZePQLQAAAAD8H50D6fEH6+jOXw+dAgAAwNLhgjsAAADnVR3d8tusWHFNOjekMz10DwAAAABn6Eync0NWrLjGuB0AAIDzzQV3AAAABtPrd61J142pvHfoFgAAAACSpH6SjD+Sw9v/WqkeugYAAIClx8AdAACAwfXUng0Zjb+Z9OahWwAAAACWqLsyHn/ExXYAAACGZuAOAADA4Dp96v30sl+9OeP+eiqXDJwEAAAAsDR07k/qxhzZ+n0X2wEAAJgPDNwBAACYV/rK3ZM50R9IcmMqk0P3AAAAACxKnelUfzsTo8/XwW3TQ+cAAADAaQbuAAAAzEu9fteadH05leuHbgEAAABYVLpvTfWH6vDOY0OnAAAAwJkM3AEAAJjXeuq2V2c0+kaSq4duAQAAAFjYam/Gsx+vozt/PXQJAAAAnI2BOwAAAAtCX7Zre7q+GEN3AAAAgGfrrnQ+lyPbbk2SSvXQQQAAAHA2Bu4AAAAsCJ0+9Q572e3bMq6vprJx4CQAAACA+a1zd0b1qRza+jOjdgAAABYKA3cAAAAWnE5XLt39uiSfNXQHAAAAOEPn7nR9KUe3/tCwHQAAgIXGwB0AAIAFqzftm8j0w2/IuD+TyhVD9wAAAAAMqnNvKl/JC1Z8r/ZfNTN0DgAAADwXBu4AAAAseL1p30T++fD1SX8ilZcO3QMAAABwXnXuTdens/IFPzZsBwAAYKEzcAcAAGDR6HTl0t2vS+WTSa4eugcAAADgnOocSNc3DNsBAABYTAzcAQAAWJR6as+G1OzHkrw1lYmhewAAAADmTPetGeVrdWjH7UOnAAAAwFwzcAcAAGBR6/W3rUuPPpzkXalMDt0DAAAA8Jx0ZpLcnCz7Qh3Zcs/QOQAAAHCuGLgDAACwJPTavaty4cy7U/lokouH7gEAAAB4hh7IuG7KiQu+VfdtfnDoGAAAADjXDNwBAABY9Dr9xPvvpv0XZPrht2fcH03ligGzAAAAAM6uc3cq38xE/SgHtz6SJJXqobMAAADgXDNwBwAAYEnpdJ3+z+Ce2rMhNfv+JG9LZXLgNAAAAGCp60yn6pep8U11aMftQ+cAAADAEAzcAQAAWPL6yt2T+XfemOp3pLJz6B4AAABgiekcSOU7p6+1u9QOAADAUmbgDgAAAE/Sl+65PHXyHel6Tyqrh+4BAAAAFqnO8SQ/TS+7qY5u+e2pR098eQ4AAACWKgN3AAAAeAq9ad9Eph9+Q8b9PlfdAQAAgDnzpGvtdXDb9NA5AAAAMN8YuAMAAMDT6PW71qTzplRdn+TqoXsAAACABaZzd7puzmj2Bzm840+utAMAAMDZGbgDAADA03jy58F7/W3r0vX61OgtSW8eug0AAACYp06P2mt0cx3Zcs+pR0/8jgEAAAB4agbuAAAA8Bw9PnZPvTOVjUP3AAAAAAN7ilE7AAAA8OwYuAMAAMAc6Kk9G5Lxdal+aypXDN0DAAAAnCdG7QAAADCnDNwBAABgjvX6XWsyHm3LKNele0cqq4duAgAAAOZIZzrJb5L+RapvqcM7j5163FWpHrgOAAAAFjwDdwAAADiHetO+iTz0yMsfu+5+XSobh24CAAAAnqXOvUluyah/nsmVe2v/VTNDJwEAAMBiZeAOAAAA51Gv3bsqF53ckXG/MclrXXcHAACAeagznfQdqfp50rfk8Pa/us4OAAAA54eBOwAAAJwnnX78PbxS/fh19zp5bWq0Od3XpHLJkI0AAACwJHXuT3JH0nelL7gzK5//B1faAQAAYBgG7gAAADCP9Ppda1KjV2fcm1O14bHR+8TQXQAAALBodGaSHElyZ7r2pkb7c+Q1f0xO/UH6sHEAAACAgTsAAADMY33l7smc6C3puirV1ybZmMrqobsAAABgwegcT3IgXXemel+W1546uG361I+6jNoBAABgfjFwBwAAgAWm19+2Lj26PF1XJeNXpeoVqbx06C4AAAAYXOfedP8+Gf0u1ftS43vq8M5jQ2cBAAAAz5yBOwAAACxAna7kiU+n99q9q7J8/JLU+JWp8cvSeUVSlyVZm8rEoLEAAAAwlzozSe5L+lAqv0+NjmR2dCAXjo/k4NZHXGQHAACAhc3AHQAAABaRMz+t3pv2TeSfj0wls+uSXpfUVNJTSb0kp8bvk0O1AgAAwFl1jid5IOk/J3U06aNJHUuWHcuK5x/N/k0nDdkBAABgcTJwBwAAgCWsr9w9mROjS5LZdamsybhenOrVqXpxkovT/aIkF6eyeuhWAAAAFoHTw/Wqvyd5IN1/S9fxLMtfMu4HkmXHsnx8fx3cNj10KgAAADAMA3cAAADgaXW6svbOF+Z5/16V8cTKLDu5KhmtzjiTqV6ezsokSfWL0nVRkuf91z9QtWqAbAAAAOZa94NnPHk01f9K19+TJJWH0nUio0wn4+OZveDBjGYeyqMXPpj7rv3HM7m6fubXyQAAAAAAAAAAnrVO/88f0ne6nuo5AAAAC8//e8fz7gcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8J/24JAAAAAAQND/174wAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwCjMBqX+BkvkCAAAAAElFTkSuQmCC","e":1},{"id":"image_1","w":587,"h":330,"u":"","p":"data:image/png;base64,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iKwPCksi8hfuXjj5crPhBy0K3ThnKJrE91D0O210DjwExsCGHS6FyEd+krTd+dk/DtbKLk5E1h+FJRFZ0M2PThyMMz+G+UmKHXaHgZ1snOW6J8A9w0YcBh2/4Va5evjd4S/LLkxE1j+FJRFZkrv/3rWjUWVfRHQU7CQhHHWz/QY7yq5tlhR44DBqzjUiu2JmtyIqn+37u8GJsosTkY1FYUlElu3q7493bs3DDirsI1h3iOgx5xhwgOJQzLU0CXxi7jfcrD9YGImz+N7EG9VHfX2D6RrXIiKbiMKSiKwId+z2n3pfi7JsVwh+CPy0wS+Bk6zeBYAf4Xxs5kMOg7FVRtN6/eHhfxp9skp/T0RakMKSiKyKzy+e6UjHH7+RVyt7gvtZs6gP9xMUjeLLPRBzEvjUsSsR4aKbD1Ui++pe/Pq3ut6aiKwWhSURWXUjH3S18RLbqrG9SW7dGKdw78PsAPDmjzw1Be45jGB22Tz0x5GPhrTxeP9vxp7okiIishYUlkRkTfl5ogfvntmSjU/+JK3EuzE/iXMaOAscBL4HhjD+l2D9xOGTaqXyVe3rtNb125FmudWLSCtSWBKRUvkH78f/99P+at7o3BmwQ040Wa2E2/XvfPzI+yOpZo9EREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREVsifAcw2mbDP3VuFAAAAAElFTkSuQmCC","e":1},{"id":"image_2","w":2300,"h":2000,"u":"","p":"data:image/png;base64,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","e":1},{"id":"image_3","w":625,"h":625,"u":"","p":"data:image/png;base64,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","e":1},{"id":"comp_0","layers":[{"ddd":0,"ind":1,"ty":4,"nm":"avatar","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[750,750,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"rc","d":1,"s":{"a":0,"k":[1190,961],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"r":{"a":0,"k":0,"ix":4},"nm":"Rectangle Path 1","mn":"ADBE Vector Shape - Rect","hd":false}],"ip":0,"op":3600,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":4,"nm":"circles","parent":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[45,20.5,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"rc","d":1,"s":{"a":0,"k":[996,920],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"r":{"a":0,"k":0,"ix":4},"nm":"Rectangle Path 1","mn":"ADBE Vector Shape - Rect","hd":false}],"ip":0,"op":3600,"st":0,"bm":0},{"ddd":0,"ind":3,"ty":4,"nm":"xd","parent":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[308.5,292.5,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"rc","d":1,"s":{"a":0,"k":[263,262],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"r":{"a":0,"k":0,"ix":4},"nm":"Rectangle Path 1","mn":"ADBE Vector Shape - Rect","hd":false}],"ip":0,"op":3600,"st":0,"bm":0},{"ddd":0,"ind":4,"ty":0,"nm":"Adobe_XD-Logo.wine","cl":"wine","parent":3,"refId":"comp_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2},"a":{"a":0,"k":[131.5,131,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":263,"h":262,"ip":0,"op":3600,"st":0,"bm":0},{"ddd":0,"ind":5,"ty":4,"nm":"Ellipse 7","parent":3,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[263,262],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"op","nm":"Offset Paths 1","a":{"a":0,"k":-0.5,"ix":1},"lj":1,"ml":{"a":0,"k":4,"ix":3},"ix":3,"mn":"ADBE Vector Filter - Offset","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 7 Stroke","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[263,262],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"fl","c":{"a":0,"k":[0.278431372549,0.329411764706,0.403921568627,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 7 Fill","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":3600,"st":0,"bm":0},{"ddd":0,"ind":6,"ty":4,"nm":"javascript","parent":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[440,-326,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"rc","d":1,"s":{"a":0,"k":[310,309],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"r":{"a":0,"k":0,"ix":4},"nm":"Rectangle Path 1","mn":"ADBE Vector Shape - Rect","hd":false}],"ip":0,"op":3600,"st":0,"bm":0},{"ddd":0,"ind":7,"ty":0,"nm":"javascript-logo","parent":6,"refId":"comp_2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2},"a":{"a":0,"k":[155,154.5,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":310,"h":309,"ip":0,"op":3600,"st":0,"bm":0},{"ddd":0,"ind":8,"ty":4,"nm":"Ellipse 1","parent":6,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[310,309],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"op","nm":"Offset Paths 1","a":{"a":0,"k":-0.5,"ix":1},"lj":1,"ml":{"a":0,"k":4,"ix":3},"ix":3,"mn":"ADBE Vector Filter - Offset","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1 Stroke","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[310,309],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"fl","c":{"a":0,"k":[0.278431372549,0.329411764706,0.403921568627,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1 Fill","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":3600,"st":0,"bm":0},{"ddd":0,"ind":9,"ty":4,"nm":"react","parent":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[-390.5,257,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"rc","d":1,"s":{"a":0,"k":[409,409],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"r":{"a":0,"k":0,"ix":4},"nm":"Rectangle Path 1","mn":"ADBE Vector Shape - Rect","hd":false}],"ip":0,"op":3600,"st":0,"bm":0},{"ddd":0,"ind":10,"ty":0,"nm":"React-icon.svg","cl":"svg","parent":9,"refId":"comp_3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2},"a":{"a":0,"k":[204.5,204.5,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":409,"h":409,"ip":0,"op":3600,"st":0,"bm":0},{"ddd":0,"ind":11,"ty":4,"nm":"Ellipse 5","parent":9,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,0,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[409,409],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"op","nm":"Offset Paths 1","a":{"a":0,"k":-0.5,"ix":1},"lj":1,"ml":{"a":0,"k":4,"ix":3},"ix":3,"mn":"ADBE Vector Filter - Offset","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 5 Stroke","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[409,409],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"fl","c":{"a":0,"k":[0.278431372549,0.329411764706,0.403921568627,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 5 Fill","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":3600,"st":0,"bm":0},{"ddd":0,"ind":12,"ty":2,"nm":"avatar_Casper","parent":1,"refId":"image_3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[-17.5,-56,0],"ix":2},"a":{"a":0,"k":[312.5,312.5,0],"ix":1},"s":{"a":0,"k":[135.84,135.84,100],"ix":6}},"ao":0,"hasMask":true,"masksProperties":[{"inv":false,"mode":"f","pt":{"a":0,"k":{"i":[[172.469,0],[0,-172.469],[-172.469,0],[0,172.469]],"o":[[-172.469,0],[0,172.469],[172.469,0],[0,-172.469]],"v":[[312.5,0],[0,312.5],[312.5,625],[625,312.5]],"c":true},"ix":1},"o":{"a":0,"k":100,"ix":3},"x":{"a":0,"k":0,"ix":4},"nm":"Mask 1"}],"ip":0,"op":3600,"st":0,"bm":0},{"ddd":0,"ind":13,"ty":4,"nm":"Ellipse 11","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0]},{"t":1000,"s":[360]}],"ix":10},"p":{"a":0,"k":[735,695.5,0],"ix":2},"a":{"a":0,"k":[-520,-46,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[76,76],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"op","nm":"Offset Paths 1","a":{"a":0,"k":-0.5,"ix":1},"lj":1,"ml":{"a":0,"k":4,"ix":3},"ix":3,"mn":"ADBE Vector Filter - Offset","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 10 Stroke","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[76,76],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"fl","c":{"a":0,"k":[0.278431372549,0.329411764706,0.403921568627,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 10 Fill","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":3600,"st":0,"bm":0},{"ddd":0,"ind":14,"ty":4,"nm":"Ellipse 9","parent":2,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0]},{"t":1000,"s":[1080]}],"ix":10},"p":{"a":0,"k":[-79.981,-113.461,0],"ix":2},"a":{"a":0,"k":[-195.481,-554.961,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[37,37],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"op","nm":"Offset Paths 1","a":{"a":0,"k":-0.5,"ix":1},"lj":1,"ml":{"a":0,"k":4,"ix":3},"ix":3,"mn":"ADBE Vector Filter - Offset","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 9 Stroke","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[37,37],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"fl","c":{"a":0,"k":[0.278431372549,0.329411764706,0.403921568627,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 9 Fill","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":3600,"st":0,"bm":0},{"ddd":0,"ind":15,"ty":4,"nm":"Ellipse 8","parent":2,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0]},{"t":1000,"s":[720]}],"ix":10},"p":{"a":0,"k":[-41.019,-42.032,0],"ix":2},"a":{"a":0,"k":[429.481,390.468,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[55,55],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"op","nm":"Offset Paths 1","a":{"a":0,"k":-0.5,"ix":1},"lj":1,"ml":{"a":0,"k":4,"ix":3},"ix":3,"mn":"ADBE Vector Filter - Offset","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 8 Stroke","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[55,55],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"fl","c":{"a":0,"k":[0.278431372549,0.329411764706,0.403921568627,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 8 Fill","np":2,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":3600,"st":0,"bm":0}]},{"id":"comp_1","layers":[{"ddd":0,"ind":1,"ty":4,"nm":"Adobe_XD-Logo.wine","cl":"wine","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[131.5,131,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[263,262],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"op","nm":"Offset Paths 1","a":{"a":0,"k":-0.5,"ix":1},"lj":1,"ml":{"a":0,"k":4,"ix":3},"ix":3,"mn":"ADBE Vector Filter - Offset","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Adobe_XD-Logo.wine Stroke","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false,"cl":"wine"}],"ip":0,"op":3600,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":2,"nm":"Adobe_XD-Logo.wine","cl":"wine","refId":"image_0","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[131.5,131,0],"ix":2},"a":{"a":0,"k":[1500,1000,0],"ix":1},"s":{"a":0,"k":[11.99,11.99,100],"ix":6}},"ao":0,"hasMask":true,"masksProperties":[{"inv":false,"mode":"f","pt":{"a":0,"k":{"i":[[605.717,0],[0,-603.414],[-605.717,0],[0,603.414]],"o":[[-605.717,0],[0,603.414],[605.717,0],[0,-603.414]],"v":[[1500,-92.548],[403.282,1000],[1500,2092.548],[2596.718,1000]],"c":true},"ix":1},"o":{"a":0,"k":100,"ix":3},"x":{"a":0,"k":0,"ix":4},"nm":"Mask 1"}],"ip":0,"op":3600,"st":0,"bm":0}]},{"id":"comp_2","layers":[{"ddd":0,"ind":1,"ty":4,"nm":"javascript-logo","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[155,154.5,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[310,309],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"op","nm":"Offset Paths 1","a":{"a":0,"k":-0.5,"ix":1},"lj":1,"ml":{"a":0,"k":4,"ix":3},"ix":3,"mn":"ADBE Vector Filter - Offset","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"javascript-logo Stroke","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":3600,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":2,"nm":"javascript-logo","refId":"image_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[155,154.5,0],"ix":2},"a":{"a":0,"k":[293.5,165,0],"ix":1},"s":{"a":0,"k":[67.494,67.494,100],"ix":6}},"ao":0,"hasMask":true,"masksProperties":[{"inv":false,"mode":"f","pt":{"a":0,"k":{"i":[[126.836,0],[0,-126.427],[-126.836,0],[0,126.427]],"o":[[-126.836,0],[0,126.427],[126.836,0],[0,-126.427]],"v":[[293.5,-63.91],[63.849,165],[293.5,393.91],[523.151,165]],"c":true},"ix":1},"o":{"a":0,"k":100,"ix":3},"x":{"a":0,"k":0,"ix":4},"nm":"Mask 1"}],"ip":0,"op":3600,"st":0,"bm":0}]},{"id":"comp_3","layers":[{"ddd":0,"ind":1,"ty":4,"nm":"React-icon.svg","cl":"svg","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[204.5,204.5,0],"ix":2},"a":{"a":0,"k":[0,0,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[409,409],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"op","nm":"Offset Paths 1","a":{"a":0,"k":-0.5,"ix":1},"lj":1,"ml":{"a":0,"k":4,"ix":3},"ix":3,"mn":"ADBE Vector Filter - Offset","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"React-icon.svg Stroke","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false,"cl":"svg"}],"ip":0,"op":3600,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":2,"nm":"React-icon.svg","cl":"svg","refId":"image_2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[204.5,204.5,0],"ix":2},"a":{"a":0,"k":[1150,1000,0],"ix":1},"s":{"a":0,"k":[15.285,15.285,100],"ix":6}},"ao":0,"hasMask":true,"masksProperties":[{"inv":false,"mode":"f","pt":{"a":0,"k":{"i":[[738.409,0],[0,-738.409],[-738.409,0],[0,738.409]],"o":[[-738.409,0],[0,738.409],[738.409,0],[0,-738.409]],"v":[[1150,-337.94],[-187.94,1000],[1150,2337.94],[2487.94,1000]],"c":true},"ix":1},"o":{"a":0,"k":100,"ix":3},"x":{"a":0,"k":0,"ix":4},"nm":"Mask 1"}],"ip":0,"op":3600,"st":0,"bm":0}]}],"layers":[{"ddd":0,"ind":1,"ty":0,"nm":"Comp 1","refId":"comp_0","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[750,750,0],"ix":2},"a":{"a":0,"k":[750,750,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"w":1500,"h":1500,"ip":0,"op":3600,"st":0,"bm":0}],"markers":[]}');

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CCasper%5Cportfoliocaspervandamme%5Csrc%5Capp%5Ccontactme%5Cpage.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);